{
  "uid": "a*-algorithm",
  "testStrategy": "JSON",
  "name": "A* Algorithm",
  "version": 0,
  "releaseDate": "2020-11-16T00:00:00Z",
  "category": "Famous Algorithms",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 2060,
    "failureCount": 838
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "479373313",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 2327
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given a two-dimensional array containing <span>0</span>s and\n  <span>1</span>s, where each <span>0</span> represents a free space and each\n  <span>1</span> represents an obstacle (a space that cannot be passed through).\n  You can think of this array as a grid-shaped graph. You're also given four\n  integers <span>startRow</span>, <span>startCol</span>, <span>endRow</span>,\n  and <span>endCol</span>, representing the positions of a start node and an end\n  node in the graph.\n</p>\n<p>\n  Write a function that finds the shortest path between the start node and the\n  end node using the A* search algorithm and returns it.\n</p>\n<p>\n  The shortest path should be returned as an array of node positions, where each\n  node position is an array of two elements: the <span>[row, col]</span> of the\n  respective node in the graph. The output array should contain the start node's\n  position, the end node's position, and all of the positions of the remaining\n  nodes in the shortest path, and these node positions should be ordered from\n  start node to end node.\n</p>\n<p>\n  If there is no path from the start node to the end node, your function should\n  return an empty array.\n</p>\n<p>Note that:</p>\n<ul>\n  <li>\n    From each node in the graph, you can only travel in four directions: up,\n    left, down and right; you can't travel diagonally.\n  </li>\n  <li>\n    The distance between all neighboring nodes in the graph is the same; you\n    can treat it as a distance of 1.\n  </li>\n  <li>\n    The start node and end node are guaranteed to be located in empty spaces\n    (cells containing <span>0</span>).\n  </li>\n  <li>\n    The start node and end node will never be out of bounds and will never\n    overlap.\n  </li>\n  <li>\n    There will be at most one shortest path from the start node to the end\n    node.\n  </li>\n</ul>\n<p>\n  If you're unfamiliar with A*, we recommend watching the Conceptual Overview\n  section of this question's video explanation before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">startRow</span> = 0\n<span class=\"CodeEditor-promptParameter\">startCol</span> = 1\n<span class=\"CodeEditor-promptParameter\">endRow</span> = 4\n<span class=\"CodeEditor-promptParameter\">endCol</span> = 3\n<span class=\"CodeEditor-promptParameter\">graph</span> = [\n  [0, 0, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 0, 0],\n  [1, 0, 1, 1, 1],\n  [0, 0, 0, 0, 0],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[[0, 1], [0, 0], [1, 0], [2, 0], [2, 1], [3, 1], [4, 1], [4, 2], [4, 3]]\n\n<span class=\"CodeEditor-promptComment\">// The shortest path can be clearly seen here:</span>\n<span class=\"CodeEditor-promptComment\">// [</span>\n<span class=\"CodeEditor-promptComment\">//   [., ., 0, 0, 0],</span>\n<span class=\"CodeEditor-promptComment\">//   [., 1, 1, 1, 0],</span>\n<span class=\"CodeEditor-promptComment\">//   [., ., 0, 0, 0],</span>\n<span class=\"CodeEditor-promptComment\">//   [1, ., 1, 1, 1],</span>\n<span class=\"CodeEditor-promptComment\">//   [0, ., ., ., 0],</span>\n<span class=\"CodeEditor-promptComment\">// ]</span>\n</pre>\n</div>",
  "hints": [
    "<p>\nA* works by visiting nodes in the graph, one by one, all the while keeping track of their shortest estimated distance to the end node and continuously updating these distances. More specifically, the algorithm keeps track of unvisited nodes and visits the unvisited node with the shortest estimated distance to the end node at any point in time, naturally starting with the start node. Whenever the algorithm visits an unvisited node, it looks at all of its neighboring nodes and tries to update their shortest estimated distance to the end node, using the current shortest distance to the current node as a base and using a special heuristic to estimate the remaining distance to the end node. In a grid-shaped graph, the heuristic used is often the Manhattan Distance (i.e., the number of naive vertical and horizontal steps between the current node and the end node). Once the algorithm has reached the end node, it is guaranteed to have found the shortest path to it. How can you implement this algorithm?\n</p>\n",
    "\n<p>\nThe most challenging part of A* is determining how to efficiently find the node with the current shortest estimated distance to the end. Can you think of a data structure that could be used to keep track of the distances and to efficiently retrieve the node with the current shortest estimated distance to the end at each step?\n</p>\n",
    "\n<p>\nCreate a min-heap that will hold all of the unvisited nodes and their current shortest estimated distance to the end node. Initialize all nodes except for the start node as having a shortest estimated distance to the end node of infinity and also a shortest distance from the start node to themselves of infinity; the start node will have a distance to itself of 0 and an estimated distance to the end node of its Manhattan Distance to the end node. Next, write a while loop that will run until the min-heap is empty or until the end node is reached. At every iteration in the loop, remove the node from the top of the heap (the node with the shortest estimated distance to the end node), loop through all of its neighboring nodes, and for each neighbor, update its two distances if reaching the neighbor from the current node yields a shorter distance than whatever's already stored on the neighbor. Once you reach the end node, you'll have found the shortest path to it from the start node. Note that you'll have to keep track of which node each node came from whenever you update node distances; this is so that you can reconstruct the shortest path once you reach the end node.\n</p>"
  ],
  "spaceTime": "O(w * h * log(w * h)) time | O(w * h) space - where w is the width of the graph and h is the height",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> aStarAlgorithm(\n  int startRow, int startCol, int endRow, int endCol, vector<vector<int>> graph\n) {\n  // Write your code here.\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <cmath>\n#include <limits>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Node {\n public:\n  string id;\n  int row;\n  int col;\n  int value;\n  int distanceFromStart;\n  int estimatedDistanceToEnd;\n  Node* cameFrom;\n\n  Node(int row, int col, int value) {\n    this->id = to_string(row) + '-' + to_string(col);\n    this->row = row;\n    this->col = col;\n    this->value = value;\n    this->distanceFromStart = numeric_limits<int>::max();\n    this->estimatedDistanceToEnd = numeric_limits<int>::max();\n    this->cameFrom = nullptr;\n  }\n};\n\nclass MinHeap {\n public:\n  vector<Node*> heap;\n  unordered_map<string, int> nodePositionsInHeap;\n\n  MinHeap(vector<Node*> array) {\n    for (int i = 0; i < array.size(); i++) {\n      auto node = array[i];\n      nodePositionsInHeap[node->id] = i;\n    }\n    heap = buildHeap(array);\n  }\n\n  // O(n) time | O(1) space\n  vector<Node*> buildHeap(vector<Node*>& array) {\n    int firstParentIdx = (array.size() - 2) / 2;\n    for (int currentIdx = firstParentIdx + 1; currentIdx >= 0; currentIdx--) {\n      siftDown(currentIdx, array.size() - 1, array);\n    }\n    return array;\n  }\n\n  bool isEmpty() { return heap.size() == 0; }\n\n  // O(log(n)) time | O(1) space\n  void siftDown(int currentIdx, int endIdx, vector<Node*>& array) {\n    int childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      int childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      int idxToSwap;\n      if (childTwoIdx != -1 && array[childTwoIdx]->estimatedDistanceToEnd <\n                                   heap[childOneIdx]->estimatedDistanceToEnd) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (array[idxToSwap]->estimatedDistanceToEnd < array[currentIdx]->estimatedDistanceToEnd) {\n        swap(currentIdx, idxToSwap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  void siftUp(int currentIdx) {\n    int parentIdx = (currentIdx - 1) / 2;\n    while (currentIdx > 0 && heap[currentIdx]->estimatedDistanceToEnd <\n                               heap[parentIdx]->estimatedDistanceToEnd) {\n      swap(currentIdx, parentIdx);\n      currentIdx = parentIdx;\n      parentIdx = (currentIdx - 1) / 2;\n    }\n  }\n\n  Node* remove() {\n    if (isEmpty()) {\n      return nullptr;\n    }\n\n    swap(0, heap.size() - 1);\n    auto node = heap.back();\n    heap.pop_back();\n    nodePositionsInHeap.erase(node->id);\n    siftDown(0, heap.size() - 1, heap);\n    return node;\n  }\n\n  void insert(Node* node) {\n    heap.push_back(node);\n    nodePositionsInHeap[node->id] = heap.size() - 1;\n    siftUp(heap.size() - 1);\n  }\n\n  void swap(int i, int j) {\n    nodePositionsInHeap[heap[i]->id] = j;\n    nodePositionsInHeap[heap[j]->id] = i;\n    auto temp = heap[i];\n    heap[i] = heap[j];\n    heap[j] = temp;\n  }\n\n  bool containsNode(Node* node) {\n    return nodePositionsInHeap.find(node->id) != nodePositionsInHeap.end();\n  }\n\n  void update(Node* node) { siftUp(nodePositionsInHeap[node->id]); }\n};\n\nvector<vector<int>> reconstructPath(Node* endNode);\nvector<Node*> getNeightboringNodes(Node* node, vector<vector<Node*>>& nodes);\nint calculateManhattanDistance(Node* currentNode, Node* endNode);\nvector<vector<Node*>> initializeNodes(vector<vector<int>> graph);\n\n// O(w * h * log(w * h)) time | O(w * h) space - where\n// w is the width of the graph and h is the height\nvector<vector<int>> aStarAlgorithm(\n  int startRow, int startCol, int endRow, int endCol, vector<vector<int>> graph\n) {\n  auto nodes = initializeNodes(graph);\n  auto startNode = nodes[startRow][startCol];\n  auto endNode = nodes[endRow][endCol];\n\n  startNode->distanceFromStart = 0;\n  startNode->estimatedDistanceToEnd =\n    calculateManhattanDistance(startNode, endNode);\n\n  MinHeap nodesToVisit(vector<Node*>{startNode});\n\n  while (!nodesToVisit.isEmpty()) {\n    auto currentMinDistanceNode = nodesToVisit.remove();\n\n    if (currentMinDistanceNode == endNode) {\n      break;\n    }\n\n    auto neighbors = getNeightboringNodes(currentMinDistanceNode, nodes);\n\n    for (auto neighbor : neighbors) {\n      if (neighbor->value == 1) {\n        continue;\n      }\n\n      int tentativeDistanceToNeighbor =\n        currentMinDistanceNode->distanceFromStart + 1;\n\n      if (tentativeDistanceToNeighbor >= neighbor->distanceFromStart) {\n        continue;\n      }\n\n      neighbor->cameFrom = currentMinDistanceNode;\n      neighbor->distanceFromStart = tentativeDistanceToNeighbor;\n      neighbor->estimatedDistanceToEnd =\n        tentativeDistanceToNeighbor +\n        calculateManhattanDistance(neighbor, endNode);\n\n      if (!nodesToVisit.containsNode(neighbor)) {\n        nodesToVisit.insert(neighbor);\n      } else {\n        nodesToVisit.update(neighbor);\n      }\n    }\n  }\n\n  return reconstructPath(endNode);\n}\n\nvector<vector<Node*>> initializeNodes(vector<vector<int>> graph) {\n  vector<vector<Node*>> nodes;\n\n  for (int i = 0; i < graph.size(); i++) {\n    nodes.push_back(vector<Node*>{});\n    for (int j = 0; j < graph[i].size(); j++) {\n      nodes[i].push_back(new Node(i, j, graph[i][j]));\n    }\n  }\n\n  return nodes;\n}\n\nint calculateManhattanDistance(Node* currentNode, Node* endNode) {\n  int currentRow = currentNode->row;\n  int currentCol = currentNode->col;\n  int endRow = endNode->row;\n  int endCol = endNode->col;\n\n  return abs(currentRow - endRow) + abs(currentCol - endCol);\n}\n\nvector<Node*> getNeightboringNodes(Node* node, vector<vector<Node*>>& nodes) {\n  vector<Node*> neighbors;\n\n  int numRows = nodes.size();\n  int numCols = nodes[0].size();\n\n  int row = node->row;\n  int col = node->col;\n\n  if (row < numRows - 1) {  // DOWN\n    neighbors.push_back(nodes[row + 1][col]);\n  }\n\n  if (row > 0) {  // UP\n    neighbors.push_back(nodes[row - 1][col]);\n  }\n\n  if (col < numCols - 1) {  // RIGHT\n    neighbors.push_back(nodes[row][col + 1]);\n  }\n\n  if (col > 0) {  // LEFT\n    neighbors.push_back(nodes[row][col - 1]);\n  }\n\n  return neighbors;\n}\n\nvector<vector<int>> reconstructPath(Node* endNode) {\n  if (endNode->cameFrom == nullptr) {\n    return vector<vector<int>>{};\n  }\n\n  Node* currentNode = endNode;\n  vector<vector<int>> path;\n\n  while (currentNode != nullptr) {\n    path.push_back(vector<int>{currentNode->row, currentNode->col});\n    currentNode = currentNode->cameFrom;\n  }\n\n  reverse(path.begin(), path.end());\n  return path;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto startRow = 0;\n      auto startCol = 1;\n      auto endRow = 4;\n      auto endCol = 3;\n      vector<vector<int>> graph = {\n        {0, 0, 0, 0, 0},\n        {0, 1, 1, 1, 0},\n        {0, 0, 0, 0, 0},\n        {1, 0, 1, 1, 1},\n        {0, 0, 0, 0, 0},\n      };\n      vector<vector<int>> expected = {\n        {0, 1}, {0, 0}, {1, 0}, {2, 0}, {2, 1}, {3, 1}, {4, 1}, {4, 2}, {4, 3}};\n      auto actual = aStarAlgorithm(startRow, startCol, endRow, endCol, graph);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto startRow = 0;\n      auto startCol = 1;\n      auto endRow = 4;\n      auto endCol = 3;\n      vector<vector<int>> graph = {\n        {0, 0, 0, 0, 0},\n        {0, 1, 1, 1, 0},\n        {0, 0, 0, 0, 0},\n        {1, 0, 1, 1, 1},\n        {0, 0, 0, 0, 0},\n      };\n      vector<vector<int>> expected = {\n        {0, 1}, {0, 0}, {1, 0}, {2, 0}, {2, 1}, {3, 1}, {4, 1}, {4, 2}, {4, 3}};\n      auto actual = aStarAlgorithm(startRow, startCol, endRow, endCol, graph);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public int[][] AStarAlgorithm(\n    int startRow, int startCol, int endRow, int endCol, int[][] graph\n  ) {\n    // Write your code here.\n    return new int[][] {};\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // O(w * h * log(w * h)) time | O(w * h) space - where\n  // w is the width of the graph and h is the height\n  public int[][] AStarAlgorithm(\n    int startRow, int startCol, int endRow, int endCol, int[][] graph\n  ) {\n    List<List<Node> > nodes = initializeNodes(graph);\n    Node startNode = nodes[startRow][startCol];\n    Node endNode = nodes[endRow][endCol];\n\n    startNode.distanceFromStart = 0;\n    startNode.estimatedDistanceToEnd =\n      calculateManhattanDistance(startNode, endNode);\n\n    List<Node> nodesToVisitList = new List<Node>();\n    nodesToVisitList.Add(startNode);\n    MinHeap nodesToVisit = new MinHeap(nodesToVisitList);\n\n    while (!nodesToVisit.isEmpty()) {\n      Node currentMinDistanceNode = nodesToVisit.Remove();\n      if (currentMinDistanceNode == endNode) {\n        break;\n      }\n\n      List<Node> neighbors =\n        getNeightboringNodes(currentMinDistanceNode, nodes);\n      foreach (var neighbor in neighbors) {\n        if (neighbor.value == 1) {\n          continue;\n        }\n\n        int tentativeDistanceToNeighbor =\n          currentMinDistanceNode.distanceFromStart + 1;\n        if (tentativeDistanceToNeighbor >= neighbor.distanceFromStart) {\n          continue;\n        }\n\n        neighbor.cameFrom = currentMinDistanceNode;\n        neighbor.distanceFromStart = tentativeDistanceToNeighbor;\n        neighbor.estimatedDistanceToEnd =\n          tentativeDistanceToNeighbor +\n          calculateManhattanDistance(neighbor, endNode);\n\n        if (!nodesToVisit.ContainsNode(neighbor)) {\n          nodesToVisit.Insert(neighbor);\n        } else {\n          nodesToVisit.Update(neighbor);\n        }\n      }\n    }\n\n    return reconstructPath(endNode);\n  }\n\n  List<List<Node> > initializeNodes(int[][] graph) {\n    List<List<Node> > nodes = new List<List<Node> >();\n\n    for (int i = 0; i < graph.Length; i++) {\n      List<Node> nodeList = new List<Node>();\n      nodes.Add(nodeList);\n      for (int j = 0; j < graph[i].Length; j++) {\n        nodes[i].Add(new Node(i, j, graph[i][j]));\n      }\n    }\n\n    return nodes;\n  }\n\n  int calculateManhattanDistance(Node currentNode, Node endNode) {\n    int currentRow = currentNode.row;\n    int currentCol = currentNode.col;\n    int endRow = endNode.row;\n    int endCol = endNode.col;\n\n    return Math.Abs(currentRow - endRow) + Math.Abs(currentCol - endCol);\n  }\n\n  List<Node> getNeightboringNodes(Node node, List<List<Node> > nodes) {\n    List<Node> neighbors = new List<Node>();\n\n    int numRows = nodes.Count;\n    int numCols = nodes[0].Count;\n\n    int row = node.row;\n    int col = node.col;\n\n    if (row < numRows - 1) {  // DOWN\n      neighbors.Add(nodes[row + 1][col]);\n    }\n\n    if (row > 0) {  // UP\n      neighbors.Add(nodes[row - 1][col]);\n    }\n\n    if (col < numCols - 1) {  // RIGHT\n      neighbors.Add(nodes[row][col + 1]);\n    }\n\n    if (col > 0) {  // LEFT\n      neighbors.Add(nodes[row][col - 1]);\n    }\n\n    return neighbors;\n  }\n\n  int[][] reconstructPath(Node endNode) {\n    if (endNode.cameFrom == null) {\n      return new int[][] {};\n    }\n\n    Node currentNode = endNode;\n    List<List<int> > path = new List<List<int> >();\n\n    while (currentNode != null) {\n      List<int> nodeData = new List<int>();\n      nodeData.Add(currentNode.row);\n      nodeData.Add(currentNode.col);\n      path.Add(nodeData);\n      currentNode = currentNode.cameFrom;\n    }\n\n    // convert path to return type int[][] and reverse\n    int[][] res = new int [path.Count][];\n    for (int i = 0; i < res.Length; i++) {\n      res[i] = path[res.Length - 1 - i].ToArray();\n    }\n\n    return res;\n  }\n\n  public class Node {\n    public string id;\n    public int row;\n    public int col;\n    public int value;\n    public int distanceFromStart;\n    public int estimatedDistanceToEnd;\n    public Node cameFrom;\n\n    public Node(int row, int col, int value) {\n      this.id = row.ToString() + '-' + col.ToString();\n      this.row = row;\n      this.col = col;\n      this.value = value;\n      this.distanceFromStart = Int32.MaxValue;\n      this.estimatedDistanceToEnd = Int32.MaxValue;\n      this.cameFrom = null;\n    }\n  };\n\n  public class MinHeap {\n    List<Node> heap = new List<Node>();\n    Dictionary<string, int> nodePositionsInHeap = new Dictionary<string, int>();\n\n    public MinHeap(List<Node> array) {\n      for (int i = 0; i < array.Count; i++) {\n        Node node = array[i];\n        nodePositionsInHeap[node.id] = i;\n      }\n      heap = buildHeap(array);\n    }\n\n    // O(n) time | O(1) space\n    List<Node> buildHeap(List<Node> array) {\n      int firstParentIdx = (array.Count - 2) / 2;\n      for (int currentIdx = firstParentIdx + 1; currentIdx >= 0; currentIdx--) {\n        siftDown(currentIdx, array.Count - 1, array);\n      }\n      return array;\n    }\n\n    public bool isEmpty() {\n      return heap.Count == 0;\n    }\n\n    // O(log(n)) time | O(1) space\n    void siftDown(int currentIdx, int endIdx, List<Node> array) {\n      int childOneIdx = currentIdx * 2 + 1;\n      while (childOneIdx <= endIdx) {\n        int childTwoIdx =\n          currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n        int idxToSwap;\n        if (childTwoIdx != -1 && array[childTwoIdx].estimatedDistanceToEnd <\n                                     heap[childOneIdx].estimatedDistanceToEnd) {\n          idxToSwap = childTwoIdx;\n        } else {\n          idxToSwap = childOneIdx;\n        }\n        if (array[idxToSwap].estimatedDistanceToEnd < array[currentIdx].estimatedDistanceToEnd) {\n          swap(currentIdx, idxToSwap);\n          currentIdx = idxToSwap;\n          childOneIdx = currentIdx * 2 + 1;\n        } else {\n          return;\n        }\n      }\n    }\n\n    // O(log(n)) time | O(1) space\n    void siftUp(int currentIdx) {\n      int parentIdx = (currentIdx - 1) / 2;\n      while (currentIdx > 0 && heap[currentIdx].estimatedDistanceToEnd <\n                                 heap[parentIdx].estimatedDistanceToEnd) {\n        swap(currentIdx, parentIdx);\n        currentIdx = parentIdx;\n        parentIdx = (currentIdx - 1) / 2;\n      }\n    }\n\n    public Node Remove() {\n      if (isEmpty()) {\n        return null;\n      }\n\n      swap(0, heap.Count - 1);\n      Node node = heap[heap.Count - 1];\n      heap.RemoveAt(heap.Count - 1);\n      nodePositionsInHeap.Remove(node.id);\n      siftDown(0, heap.Count - 1, heap);\n      return node;\n    }\n\n    public void Insert(Node node) {\n      heap.Add(node);\n      nodePositionsInHeap[node.id] = heap.Count - 1;\n      siftUp(heap.Count - 1);\n    }\n\n    public void Update(Node node) {\n      siftUp(nodePositionsInHeap[node.id]);\n    }\n\n    public bool ContainsNode(Node node) {\n      return nodePositionsInHeap.ContainsKey(node.id);\n    }\n\n    void swap(int i, int j) {\n      nodePositionsInHeap[heap[i].id] = j;\n      nodePositionsInHeap[heap[j].id] = i;\n      Node temp = heap[i];\n      heap[i] = heap[j];\n      heap[j] = temp;\n    }\n  };\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int startRow = 0;\n    int startCol = 1;\n    int endRow = 4;\n    int endCol = 3;\n    int[][] graph = new int[][] {\n      new int[] { 0, 0, 0, 0, 0 },\n      new int[] { 0, 1, 1, 1, 0 },\n      new int[] { 0, 0, 0, 0, 0 },\n      new int[] { 1, 0, 1, 1, 1 },\n      new int[] { 0, 0, 0, 0, 0 },\n    };\n    int[][] expected = new int[][] {\n      new int[] { 0, 1 },\n      new int[] { 0, 0 },\n      new int[] { 1, 0 },\n      new int[] { 2, 0 },\n      new int[] { 2, 1 },\n      new int[] { 3, 1 },\n      new int[] { 4, 1 },\n      new int[] { 4, 2 },\n      new int[] { 4, 3 }\n    };\n    var actual =\n      new Program().AStarAlgorithm(startRow, startCol, endRow, endCol, graph);\n    Utils.AssertTrue(expected.Length == actual.Length);\n    for (int i = 0; i < expected.Length; i++) {\n      for (int j = 0; j < expected[i].Length; j++) {\n        Utils.AssertTrue(expected[i][j] == actual[i][j]);\n      }\n    }\n  }\n}",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int startRow = 0;\n    int startCol = 1;\n    int endRow = 4;\n    int endCol = 3;\n    int[][] graph = new int[][] {\n      new int[] { 0, 0, 0, 0, 0 },\n      new int[] { 0, 1, 1, 1, 0 },\n      new int[] { 0, 0, 0, 0, 0 },\n      new int[] { 1, 0, 1, 1, 1 },\n      new int[] { 0, 0, 0, 0, 0 },\n    };\n    int[][] expected = new int[][] {\n      new int[] { 0, 1 },\n      new int[] { 0, 0 },\n      new int[] { 1, 0 },\n      new int[] { 2, 0 },\n      new int[] { 2, 1 },\n      new int[] { 3, 1 },\n      new int[] { 4, 1 },\n      new int[] { 4, 2 },\n      new int[] { 4, 3 }\n    };\n    var actual =\n      new Program().AStarAlgorithm(startRow, startCol, endRow, endCol, graph);\n    Utils.AssertTrue(expected.Length == actual.Length);\n    for (int i = 0; i < expected.Length; i++) {\n      for (int j = 0; j < expected[i].Length; j++) {\n        Utils.AssertTrue(expected[i][j] == actual[i][j]);\n      }\n    }\n  }\n}"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc AStarAlgorithm(startRow int, startCol int, endRow int, endCol int, graph [][]int) [][]int {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// O(w * h * log(w * h)) time | O(w * h) space - where\n// w is the width of the graph and h is the height\nfunc AStarAlgorithm(startRow int, startCol int, endRow int, endCol int, graph [][]int) [][]int {\n\tnodes := initializeNodes(graph)\n\n\tstartNode := nodes[startRow][startCol]\n\tendNode := nodes[endRow][endCol]\n\n\tstartNode.distanceFromStart = 0\n\tstartNode.estimatedDistanceToEnd = calculateManhattanDistance(startNode, endNode)\n\n\tnodesToVisit := newMinHeap([]*Node{startNode})\n\n\tfor !nodesToVisit.IsEmpty() {\n\t\tcurrentMinDistanceNode := nodesToVisit.Remove()\n\t\tif currentMinDistanceNode == endNode {\n\t\t\tbreak\n\t\t}\n\n\t\tneighbors := getNeighboringNodes(currentMinDistanceNode, nodes)\n\t\tfor _, neighbor := range neighbors {\n\t\t\tif neighbor.value == 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttentativeDistanceToNeighbor := currentMinDistanceNode.distanceFromStart + 1\n\t\t\tif tentativeDistanceToNeighbor >= neighbor.distanceFromStart {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tneighbor.cameFrom = currentMinDistanceNode\n\t\t\tneighbor.distanceFromStart = tentativeDistanceToNeighbor\n\t\t\tneighbor.estimatedDistanceToEnd = tentativeDistanceToNeighbor +\n\t\t\t\tcalculateManhattanDistance(neighbor, endNode)\n\n\t\t\tif !nodesToVisit.containsNode(neighbor) {\n\t\t\t\tnodesToVisit.Insert(neighbor)\n\t\t\t} else {\n\t\t\t\tnodesToVisit.Update(neighbor)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn reconstructPath(endNode)\n}\n\ntype Node struct {\n\tid                     string\n\trow                    int\n\tcol                    int\n\tvalue                  int\n\tdistanceFromStart      int\n\testimatedDistanceToEnd int\n\tcameFrom               *Node\n}\n\nfunc newNode(row, col, value int) *Node {\n\treturn &Node{\n\t\tid:                     fmt.Sprintf(\"%d-%d\", row, col),\n\t\trow:                    row,\n\t\tcol:                    col,\n\t\tvalue:                  value,\n\t\tdistanceFromStart:      math.MaxInt32,\n\t\testimatedDistanceToEnd: math.MaxInt32,\n\t\tcameFrom:               nil,\n\t}\n}\n\nfunc initializeNodes(graph [][]int) [][]*Node {\n\tnodes := make([][]*Node, 0)\n\tfor row := range graph {\n\t\tnewRow := make([]*Node, 0)\n\t\tfor col := range graph[0] {\n\t\t\tvalue := graph[row][col]\n\t\t\tnewRow = append(newRow, newNode(row, col, value))\n\t\t}\n\t\tnodes = append(nodes, newRow)\n\t}\n\treturn nodes\n}\n\nfunc calculateManhattanDistance(currentNode *Node, endNode *Node) int {\n\treturn abs(currentNode.col-endNode.col) + abs(currentNode.row-endNode.row)\n}\n\nfunc getNeighboringNodes(node *Node, nodes [][]*Node) []*Node {\n\tneighbors := make([]*Node, 0)\n\tnumRows := len(nodes)\n\tnumCols := len(nodes[0])\n\n\trow := node.row\n\tcol := node.col\n\n\tif row < numRows-1 {\n\t\tneighbors = append(neighbors, nodes[row+1][col])\n\t} // DOWN\n\tif row > 0 {\n\t\tneighbors = append(neighbors, nodes[row-1][col])\n\t} // UP\n\tif col < numCols-1 {\n\t\tneighbors = append(neighbors, nodes[row][col+1])\n\t} // RIGHT\n\tif col > 0 {\n\t\tneighbors = append(neighbors, nodes[row][col-1])\n\t} // LEFT\n\n\treturn neighbors\n}\n\nfunc reconstructPath(endNode *Node) [][]int {\n\tif endNode.cameFrom == nil {\n\t\treturn [][]int{}\n\t}\n\n\tcurrentNode := endNode\n\tpath := make([][]int, 0)\n\tfor currentNode != nil {\n\t\tpath = append(path, []int{currentNode.row, currentNode.col})\n\t\tcurrentNode = currentNode.cameFrom\n\t}\n\treturn reversePath(path)\n}\n\nfunc reversePath(path [][]int) [][]int {\n\tnewPath := make([][]int, len(path))\n\tfor i := range path {\n\t\tj := len(path) - i - 1\n\t\tnewPath[i] = path[j]\n\t}\n\treturn newPath\n}\n\nfunc abs(a int) int {\n\tif a > 0 {\n\t\treturn a\n\t}\n\treturn -a\n}\n\ntype MinHeap struct {\n\tarray               []*Node\n\tnodePositionsInHeap map[string]int\n}\n\nfunc newMinHeap(array []*Node) *MinHeap {\n\tnodePositionsInHeap := map[string]int{}\n\tfor i, node := range array {\n\t\tnodePositionsInHeap[node.id] = i\n\t}\n\theap := &MinHeap{array: array, nodePositionsInHeap: nodePositionsInHeap}\n\theap.buildHeap()\n\treturn heap\n}\n\nfunc (h *MinHeap) IsEmpty() bool { return len(h.array) == 0 }\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) Remove() *Node {\n\tif h.IsEmpty() {\n\t\treturn nil\n\t}\n\n\th.swap(0, len(h.array)-1)\n\n\tpeeked := h.array[len(h.array)-1]\n\th.array = h.array[0 : len(h.array)-1]\n\n\tdelete(h.nodePositionsInHeap, peeked.id)\n\th.siftDown(0, len(h.array)-1)\n\treturn peeked\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) Update(node *Node) {\n\th.siftUp(h.nodePositionsInHeap[node.id])\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) Insert(node *Node) {\n\th.array = append(h.array, node)\n\th.nodePositionsInHeap[node.id] = len(h.array) - 1\n\th.siftUp(len(h.array) - 1)\n}\n\nfunc (h *MinHeap) containsNode(node *Node) bool {\n\t_, found := h.nodePositionsInHeap[node.id]\n\treturn found\n}\n\nfunc (h MinHeap) swap(i, j int) {\n\th.nodePositionsInHeap[h.array[i].id] = j\n\th.nodePositionsInHeap[h.array[j].id] = i\n\th.array[i], h.array[j] = h.array[j], h.array[i]\n}\n\n// O(n) time | O(1) space\nfunc (h *MinHeap) buildHeap() {\n\tfirst := (len(h.array) - 2) / 2\n\tfor currentIdx := first + 1; currentIdx >= 0; currentIdx-- {\n\t\th.siftDown(currentIdx, len(h.array)-1)\n\t}\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) siftDown(currentIdx, endIdx int) {\n\tchildOneIdx := currentIdx*2 + 1\n\tfor childOneIdx <= endIdx {\n\t\tchildTwoIdx := -1\n\t\tif currentIdx*2+2 <= endIdx {\n\t\t\tchildTwoIdx = currentIdx*2 + 2\n\t\t}\n\t\tindexToSwap := childOneIdx\n\t\tc1Distance := h.array[childOneIdx].estimatedDistanceToEnd\n\t\tif childTwoIdx > -1 && h.array[childTwoIdx].estimatedDistanceToEnd < c1Distance {\n\t\t\tindexToSwap = childTwoIdx\n\t\t}\n\n\t\tif h.array[indexToSwap].estimatedDistanceToEnd < h.array[currentIdx].estimatedDistanceToEnd {\n\t\t\th.swap(currentIdx, indexToSwap)\n\t\t\tcurrentIdx = indexToSwap\n\t\t\tchildOneIdx = currentIdx*2 + 1\n\t\t} else {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) siftUp(currentIdx int) {\n\tparentIdx := (currentIdx - 1) / 2\n\tfor currentIdx > 0 && h.array[currentIdx].estimatedDistanceToEnd < h.array[parentIdx].estimatedDistanceToEnd {\n\t\th.swap(currentIdx, parentIdx)\n\t\tcurrentIdx = parentIdx\n\t\tparentIdx = (currentIdx - 1) / 2\n\t}\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tstartRow := 0\n\tstartCol := 1\n\tendRow := 4\n\tendCol := 3\n\tgraph := [][]int{\n\t\t{0, 0, 0, 0, 0},\n\t\t{0, 1, 1, 1, 0},\n\t\t{0, 0, 0, 0, 0},\n\t\t{1, 0, 1, 1, 1},\n\t\t{0, 0, 0, 0, 0},\n\t}\n\texpected := [][]int{{0, 1}, {0, 0}, {1, 0}, {2, 0}, {2, 1}, {3, 1}, {4, 1}, {4, 2}, {4, 3}}\n\tactual := AStarAlgorithm(startRow, startCol, endRow, endCol, graph)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tstartRow := 0\n\tstartCol := 1\n\tendRow := 4\n\tendCol := 3\n\tgraph := [][]int{\n\t\t{0, 0, 0, 0, 0},\n\t\t{0, 1, 1, 1, 0},\n\t\t{0, 0, 0, 0, 0},\n\t\t{1, 0, 1, 1, 1},\n\t\t{0, 0, 0, 0, 0},\n\t}\n\texpected := [][]int{{0, 1}, {0, 0}, {1, 0}, {2, 0}, {2, 1}, {3, 1}, {4, 1}, {4, 2}, {4, 3}}\n\tactual := AStarAlgorithm(startRow, startCol, endRow, endCol, graph)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public int[][] aStarAlgorithm(\n    int startRow, int startCol, int endRow, int endCol, int[][] graph\n  ) {\n    // Write your code here.\n    return new int[][] {};\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  class Node {\n    String id;\n    int row;\n    int col;\n    int value;\n    int distanceFromStart;\n    int estimatedDistanceToEnd;\n    Node cameFrom;\n\n    Node(int row, int col, int value) {\n      this.id = String.valueOf(row) + '-' + String.valueOf(col);\n      this.row = row;\n      this.col = col;\n      this.value = value;\n      this.distanceFromStart = Integer.MAX_VALUE;\n      this.estimatedDistanceToEnd = Integer.MAX_VALUE;\n      this.cameFrom = null;\n    }\n  };\n\n  class MinHeap {\n    List<Node> heap = new ArrayList<Node>();\n    Map<String, Integer> nodePositionsInHeap = new HashMap<String, Integer>();\n\n    public MinHeap(List<Node> array) {\n      for (int i = 0; i < array.size(); i++) {\n        Node node = array.get(i);\n        nodePositionsInHeap.put(node.id, i);\n      }\n      heap = buildHeap(array);\n    }\n\n    // O(n) time | O(1) space\n    List<Node> buildHeap(List<Node> array) {\n      int firstParentIdx = (array.size() - 2) / 2;\n      for (int currentIdx = firstParentIdx + 1; currentIdx >= 0; currentIdx--) {\n        siftDown(currentIdx, array.size() - 1, array);\n      }\n      return array;\n    }\n\n    boolean isEmpty() {\n      return heap.size() == 0;\n    }\n\n    // O(log(n)) time | O(1) space\n    void siftDown(int currentIdx, int endIdx, List<Node> array) {\n      int childOneIdx = currentIdx * 2 + 1;\n      while (childOneIdx <= endIdx) {\n        int childTwoIdx =\n          currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n        int idxToSwap;\n        if (childTwoIdx != -1\n            && array.get(childTwoIdx).estimatedDistanceToEnd\n                < heap.get(childOneIdx).estimatedDistanceToEnd) {\n          idxToSwap = childTwoIdx;\n        } else {\n          idxToSwap = childOneIdx;\n        }\n        if (array.get(idxToSwap).estimatedDistanceToEnd < array.get(currentIdx).estimatedDistanceToEnd) {\n          swap(currentIdx, idxToSwap);\n          currentIdx = idxToSwap;\n          childOneIdx = currentIdx * 2 + 1;\n        } else {\n          return;\n        }\n      }\n    }\n\n    // O(log(n)) time | O(1) space\n    void siftUp(int currentIdx) {\n      int parentIdx = (currentIdx - 1) / 2;\n      while (currentIdx > 0\n             && heap.get(currentIdx).estimatedDistanceToEnd\n               < heap.get(parentIdx).estimatedDistanceToEnd) {\n        swap(currentIdx, parentIdx);\n        currentIdx = parentIdx;\n        parentIdx = (currentIdx - 1) / 2;\n      }\n    }\n\n    Node remove() {\n      if (isEmpty()) {\n        return null;\n      }\n\n      swap(0, heap.size() - 1);\n      Node node = heap.get(heap.size() - 1);\n      heap.remove(heap.size() - 1);\n      nodePositionsInHeap.remove(node.id);\n      siftDown(0, heap.size() - 1, heap);\n      return node;\n    }\n\n    void insert(Node node) {\n      heap.add(node);\n      nodePositionsInHeap.put(node.id, heap.size() - 1);\n      siftUp(heap.size() - 1);\n    }\n\n    void swap(int i, int j) {\n      nodePositionsInHeap.put(heap.get(i).id, j);\n      nodePositionsInHeap.put(heap.get(j).id, i);\n      Node temp = heap.get(i);\n      heap.set(i, heap.get(j));\n      heap.set(j, temp);\n    }\n\n    boolean containsNode(Node node) {\n      return nodePositionsInHeap.containsKey(node.id);\n    }\n\n    void update(Node node) {\n      siftUp(nodePositionsInHeap.get(node.id));\n    }\n  };\n\n  // O(w * h * log(w * h)) time | O(w * h) space - where\n  // w is the width of the graph and h is the height\n  public int[][] aStarAlgorithm(\n    int startRow, int startCol, int endRow, int endCol, int[][] graph\n  ) {\n    List<List<Node>> nodes = initializeNodes(graph);\n    Node startNode = nodes.get(startRow).get(startCol);\n    Node endNode = nodes.get(endRow).get(endCol);\n\n    startNode.distanceFromStart = 0;\n    startNode.estimatedDistanceToEnd =\n      calculateManhattanDistance(startNode, endNode);\n\n    List<Node> nodesToVisitList = new ArrayList<Node>();\n    nodesToVisitList.add(startNode);\n    MinHeap nodesToVisit = new MinHeap(nodesToVisitList);\n\n    while (!nodesToVisit.isEmpty()) {\n      Node currentMinDistanceNode = nodesToVisit.remove();\n\n      if (currentMinDistanceNode == endNode) {\n        break;\n      }\n\n      List<Node> neighbors =\n        getNeightboringNodes(currentMinDistanceNode, nodes);\n\n      for (Node neighbor : neighbors) {\n        if (neighbor.value == 1) {\n          continue;\n        }\n\n        int tentativeDistanceToNeighbor =\n          currentMinDistanceNode.distanceFromStart + 1;\n\n        if (tentativeDistanceToNeighbor >= neighbor.distanceFromStart) {\n          continue;\n        }\n\n        neighbor.cameFrom = currentMinDistanceNode;\n        neighbor.distanceFromStart = tentativeDistanceToNeighbor;\n        neighbor.estimatedDistanceToEnd = tentativeDistanceToNeighbor\n          + calculateManhattanDistance(neighbor, endNode);\n\n        if (!nodesToVisit.containsNode(neighbor)) {\n          nodesToVisit.insert(neighbor);\n        } else {\n          nodesToVisit.update(neighbor);\n        }\n      }\n    }\n\n    return reconstructPath(endNode);\n  }\n\n  List<List<Node>> initializeNodes(int[][] graph) {\n    List<List<Node>> nodes = new ArrayList<List<Node>>();\n\n    for (int i = 0; i < graph.length; i++) {\n      List<Node> nodeList = new ArrayList<Node>();\n      nodes.add(nodeList);\n      for (int j = 0; j < graph[i].length; j++) {\n        nodes.get(i).add(new Node(i, j, graph[i][j]));\n      }\n    }\n\n    return nodes;\n  }\n\n  int calculateManhattanDistance(Node currentNode, Node endNode) {\n    int currentRow = currentNode.row;\n    int currentCol = currentNode.col;\n    int endRow = endNode.row;\n    int endCol = endNode.col;\n\n    return Math.abs(currentRow - endRow) + Math.abs(currentCol - endCol);\n  }\n\n  List<Node> getNeightboringNodes(Node node, List<List<Node>> nodes) {\n    List<Node> neighbors = new ArrayList<Node>();\n\n    int numRows = nodes.size();\n    int numCols = nodes.get(0).size();\n\n    int row = node.row;\n    int col = node.col;\n\n    if (row < numRows - 1) { // DOWN\n      neighbors.add(nodes.get(row + 1).get(col));\n    }\n\n    if (row > 0) { // UP\n      neighbors.add(nodes.get(row - 1).get(col));\n    }\n\n    if (col < numCols - 1) { // RIGHT\n      neighbors.add(nodes.get(row).get(col + 1));\n    }\n\n    if (col > 0) { // LEFT\n      neighbors.add(nodes.get(row).get(col - 1));\n    }\n\n    return neighbors;\n  }\n\n  int[][] reconstructPath(Node endNode) {\n    if (endNode.cameFrom == null) {\n      return new int[][] {};\n    }\n\n    Node currentNode = endNode;\n    List<List<Integer>> path = new ArrayList<List<Integer>>();\n\n    while (currentNode != null) {\n      List<Integer> nodeData = new ArrayList<Integer>();\n      nodeData.add(currentNode.row);\n      nodeData.add(currentNode.col);\n      path.add(nodeData);\n      currentNode = currentNode.cameFrom;\n    }\n\n    // convert path to return type int[][] and reverse\n    int[][] res = new int[path.size()][2];\n    for (int i = 0; i < res.length; i++) {\n      res[i][0] = path.get(res.length - 1 - i).get(0);\n      res[i][1] = path.get(res.length - 1 - i).get(1);\n    }\n\n    return res;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int startRow = 0;\n    int startCol = 1;\n    int endRow = 4;\n    int endCol = 3;\n    int[][] graph = new int[][] {\n      {0, 0, 0, 0, 0},\n      {0, 1, 1, 1, 0},\n      {0, 0, 0, 0, 0},\n      {1, 0, 1, 1, 1},\n      {0, 0, 0, 0, 0},\n    };\n    int[][] expected = new int[][] {\n      {0, 1}, {0, 0}, {1, 0}, {2, 0}, {2, 1}, {3, 1}, {4, 1}, {4, 2}, {4, 3}};\n    var actual =\n      new Program().aStarAlgorithm(startRow, startCol, endRow, endCol, graph);\n    Utils.assertTrue(expected.length == actual.length);\n    for (int i = 0; i < expected.length; i++) {\n      for (int j = 0; j < expected[i].length; j++) {\n        Utils.assertTrue(expected[i][j] == actual[i][j]);\n      }\n    }\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int startRow = 0;\n    int startCol = 1;\n    int endRow = 4;\n    int endCol = 3;\n    int[][] graph = new int[][] {\n      {0, 0, 0, 0, 0},\n      {0, 1, 1, 1, 0},\n      {0, 0, 0, 0, 0},\n      {1, 0, 1, 1, 1},\n      {0, 0, 0, 0, 0},\n    };\n    int[][] expected = new int[][] {\n      {0, 1}, {0, 0}, {1, 0}, {2, 0}, {2, 1}, {3, 1}, {4, 1}, {4, 2}, {4, 3}};\n    var actual =\n      new Program().aStarAlgorithm(startRow, startCol, endRow, endCol, graph);\n    Utils.assertTrue(expected.length == actual.length);\n    for (int i = 0; i < expected.length; i++) {\n      for (int j = 0; j < expected[i].length; j++) {\n        Utils.assertTrue(expected[i][j] == actual[i][j]);\n      }\n    }\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function aStarAlgorithm(startRow, startCol, endRow, endCol, graph) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.aStarAlgorithm = aStarAlgorithm;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Node {\n  constructor(row, col, value) {\n    this.id = row.toString() + '-' + col.toString();\n    this.row = row;\n    this.col = col;\n    this.value = value;\n    this.distanceFromStart = Infinity;\n    this.estimatedDistanceToEnd = Infinity;\n    this.cameFrom = null;\n  }\n}\n\n// O(w * h * log(w * h)) time | O(w * h) space - where\n// w is the width of the graph and h is the height\nfunction aStarAlgorithm(startRow, startCol, endRow, endCol, graph) {\n  const nodes = initializeNodes(graph);\n\n  const startNode = nodes[startRow][startCol];\n  const endNode = nodes[endRow][endCol];\n\n  startNode.distanceFromStart = 0;\n  startNode.estimatedDistanceToEnd = calculateManhattanDistance(startNode, endNode);\n\n  const nodesToVisit = new MinHeap([startNode]);\n\n  while (!nodesToVisit.isEmpty()) {\n    const currentMinDistanceNode = nodesToVisit.remove();\n\n    if (currentMinDistanceNode === endNode) break;\n\n    const neighbors = getNeighboringNodes(currentMinDistanceNode, nodes);\n    for (const neighbor of neighbors) {\n      if (neighbor.value === 1) continue;\n\n      const tentativeDistanceToNeighbor = currentMinDistanceNode.distanceFromStart + 1;\n\n      if (tentativeDistanceToNeighbor >= neighbor.distanceFromStart) continue;\n\n      neighbor.cameFrom = currentMinDistanceNode;\n      neighbor.distanceFromStart = tentativeDistanceToNeighbor;\n      neighbor.estimatedDistanceToEnd =\n        tentativeDistanceToNeighbor + calculateManhattanDistance(neighbor, endNode);\n\n      if (!nodesToVisit.containsNode(neighbor)) {\n        nodesToVisit.insert(neighbor);\n      } else {\n        nodesToVisit.update(neighbor);\n      }\n    }\n  }\n\n  return reconstructPath(endNode);\n}\n\nfunction initializeNodes(graph) {\n  const nodes = [];\n\n  for (const [i, row] of graph.entries()) {\n    nodes.push([]);\n    for (const [j, value] of row.entries()) {\n      const node = new Node(i, j, value);\n      nodes[i].push(node);\n    }\n  }\n\n  return nodes;\n}\n\nfunction calculateManhattanDistance(currentNode, endNode) {\n  const currentRow = currentNode.row;\n  const currentCol = currentNode.col;\n  const endRow = endNode.row;\n  const endCol = endNode.col;\n\n  return Math.abs(currentRow - endRow) + Math.abs(currentCol - endCol);\n}\n\nfunction getNeighboringNodes(node, nodes) {\n  const neighbors = [];\n\n  const numRows = nodes.length;\n  const numCols = nodes[0].length;\n\n  const row = node.row;\n  const col = node.col;\n\n  if (row < numRows - 1) {\n    // DOWN\n    neighbors.push(nodes[row + 1][col]);\n  }\n\n  if (row > 0) {\n    // UP\n    neighbors.push(nodes[row - 1][col]);\n  }\n\n  if (col < numCols - 1) {\n    // RIGHT\n    neighbors.push(nodes[row][col + 1]);\n  }\n\n  if (col > 0) {\n    // LEFT\n    neighbors.push(nodes[row][col - 1]);\n  }\n\n  return neighbors;\n}\n\nfunction reconstructPath(endNode) {\n  if (endNode.cameFrom === null) {\n    return [];\n  }\n\n  let currentNode = endNode;\n  const path = [];\n\n  while (currentNode !== null) {\n    path.push([currentNode.row, currentNode.col]);\n    currentNode = currentNode.cameFrom;\n  }\n\n  path.reverse(); // reverse path so it goes from start to end\n\n  return path;\n}\n\nclass MinHeap {\n  constructor(array) {\n    // Holds the position in the heap that each node is at\n    this.nodePositionsInHeap = array.reduce((obj, node, i) => {\n      obj[node.id] = i;\n      return obj;\n    }, {});\n    this.heap = this.buildHeap(array);\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  // O(n) time | O(1) space\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  // O(log(n)) time | O(1) space\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (\n        childTwoIdx !== -1 &&\n        heap[childTwoIdx].estimatedDistanceToEnd < heap[childOneIdx].estimatedDistanceToEnd\n      ) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap].estimatedDistanceToEnd < heap[currentIdx].estimatedDistanceToEnd) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (\n      currentIdx > 0 &&\n      heap[currentIdx].estimatedDistanceToEnd < heap[parentIdx].estimatedDistanceToEnd\n    ) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  remove() {\n    if (this.isEmpty()) return;\n\n    this.swap(0, this.heap.length - 1, this.heap);\n    const node = this.heap.pop();\n    delete this.nodePositionsInHeap[node.id];\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return node;\n  }\n\n  // O(log(n)) time | O(1) space\n  insert(node) {\n    this.heap.push(node);\n    this.nodePositionsInHeap[node.id] = this.heap.length - 1;\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i, j, heap) {\n    this.nodePositionsInHeap[this.heap[i].id] = j;\n    this.nodePositionsInHeap[this.heap[j].id] = i;\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n\n  containsNode(node) {\n    return node.id in this.nodePositionsInHeap;\n  }\n\n  update(node) {\n    this.siftUp(this.nodePositionsInHeap[node.id], this.heap);\n  }\n}\n\n// Do not edit the line below.\nexports.aStarAlgorithm = aStarAlgorithm;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const startRow = 0;\n  const startCol = 1;\n  const endRow = 4;\n  const endCol = 3;\n  const graph = [\n    [0, 0, 0, 0, 0],\n    [0, 1, 1, 1, 0],\n    [0, 0, 0, 0, 0],\n    [1, 0, 1, 1, 1],\n    [0, 0, 0, 0, 0],\n  ];\n  const expected = [\n    [0, 1],\n    [0, 0],\n    [1, 0],\n    [2, 0],\n    [2, 1],\n    [3, 1],\n    [4, 1],\n    [4, 2],\n    [4, 3],\n  ];\n  const actual = program.aStarAlgorithm(startRow, startCol, endRow, endCol, graph);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const startRow = 0;\n  const startCol = 1;\n  const endRow = 4;\n  const endCol = 3;\n  const graph = [\n    [0, 0, 0, 0, 0],\n    [0, 1, 1, 1, 0],\n    [0, 0, 0, 0, 0],\n    [1, 0, 1, 1, 1],\n    [0, 0, 0, 0, 0],\n  ];\n  const expected = [\n    [0, 1],\n    [0, 0],\n    [1, 0],\n    [2, 0],\n    [2, 1],\n    [3, 1],\n    [4, 1],\n    [4, 2],\n    [4, 3],\n  ];\n  const actual = program.aStarAlgorithm(startRow, startCol, endRow, endCol, graph);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun aStarAlgorithm(startRow: Int, startCol: Int, endRow: Int, endCol: Int, graph: List<List<Int>>): List<List<Int>> {\n    // Write your code here.\n    return listOf()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.abs\n\nclass Node(row: Int, col: Int, value: Int) {\n    val id = row.toString() + \"-\" + col.toString()\n    val row = row\n    val col = col\n    val value = value\n    var distanceFromStart = Int.MAX_VALUE\n    var estimatedDistanceToEnd = Int.MAX_VALUE\n    var cameFrom: Node? = null\n}\n\n// O(w * h * log(w * h)) time | O(w * h) space - where\n// w is the width of the graph and h is the height\nfun aStarAlgorithm(\n    startRow: Int,\n    startCol: Int,\n    endRow: Int,\n    endCol: Int,\n    graph: List<List<Int>>,\n): List<List<Int>> {\n    val nodes = initializeNodes(graph)\n\n    val startNode = nodes[startRow][startCol]\n    val endNode = nodes[endRow][endCol]\n\n    startNode.distanceFromStart = 0\n    startNode.estimatedDistanceToEnd = calculateManhattanDistance(startNode, endNode)\n\n    val nodesToVisit = MinHeap(mutableListOf(startNode))\n\n    while (!nodesToVisit.isEmpty()) {\n        val currentMinDistanceNode = nodesToVisit.remove()!!\n\n        if (currentMinDistanceNode == endNode) break\n\n        val neighbors = getNeighboringNodes(currentMinDistanceNode, nodes)\n        for (neighbor in neighbors) {\n            if (neighbor.value == 1) continue\n\n            val tentativeDistanceToNeighbor = currentMinDistanceNode.distanceFromStart + 1\n\n            if (tentativeDistanceToNeighbor >= neighbor.distanceFromStart) continue\n\n            neighbor.cameFrom = currentMinDistanceNode\n            neighbor.distanceFromStart = tentativeDistanceToNeighbor\n            neighbor.estimatedDistanceToEnd = tentativeDistanceToNeighbor + calculateManhattanDistance(neighbor, endNode)\n\n            if (!nodesToVisit.containsNode(neighbor)) {\n                nodesToVisit.insert(neighbor)\n            } else {\n                nodesToVisit.update(neighbor)\n            }\n        }\n    }\n\n    return reconstructPath(endNode)\n}\n\nfun initializeNodes(graph: List<List<Int>>): List<List<Node>> {\n    val nodes = mutableListOf<MutableList<Node>>()\n    for (row in 0 until graph.size) {\n        val newRow = mutableListOf<Node>()\n        for (col in 0 until graph[0].size) {\n            val value = graph[row][col]\n            newRow.add(Node(row, col, value))\n        }\n        nodes.add(newRow)\n    }\n    return nodes\n}\n\nfun calculateManhattanDistance(currentNode: Node, endNode: Node): Int {\n    val currentRow = currentNode.row\n    val currentCol = currentNode.col\n    val endRow = endNode.row\n    val endCol = endNode.col\n\n    return abs(currentCol - endCol) + abs(currentRow - endRow)\n}\n\nfun getNeighboringNodes(node: Node, nodes: List<List<Node>>): List<Node> {\n    val neighbors = mutableListOf<Node>()\n\n    val numRows = nodes.size\n    val numCols = nodes[0].size\n\n    val row = node.row\n    val col = node.col\n\n    if (row < numRows - 1) neighbors.add(nodes[row + 1][col]) // DOWN\n    if (row > 0) neighbors.add(nodes[row - 1][col]) // UP\n    if (col < numCols - 1) neighbors.add(nodes[row][col + 1]) // RIGHT\n    if (col > 0) neighbors.add(nodes[row][col - 1]) // LEFT\n\n    return neighbors\n}\n\nfun reconstructPath(endNode: Node): List<List<Int>> {\n    if (endNode.cameFrom == null) return listOf()\n\n    var currentNode: Node? = endNode\n    val path = mutableListOf<List<Int>>()\n\n    while (currentNode != null) {\n        path.add(listOf(currentNode.row, currentNode.col))\n        currentNode = currentNode.cameFrom\n    }\n\n    path.reverse()\n    return path\n}\n\nopen class MinHeap(array: MutableList<Node>) {\n    // Holds the position in the heap that each node is at\n    val nodePositionsInHeap = array.mapIndexed() { i, node -> Pair(i, node) }.associate({\n        it.second.id to it.first\n    }).toMutableMap()\n    val heap = this.buildHeap(array)\n\n    // O(n) time | O(1) space\n    fun buildHeap(array: MutableList<Node>): MutableList<Node> {\n        val firstParentIdx = (array.size - 2) / 2\n        for (currentIdx in firstParentIdx downTo 0) {\n            this.siftDown(currentIdx, array.size - 1, array)\n        }\n        return array\n    }\n\n    fun isEmpty(): Boolean {\n        return this.heap.size == 0\n    }\n\n    // O(log(n)) time | O(1) space\n    fun siftDown(currentIdx: Int, endIdx: Int, heap: MutableList<Node>) {\n        var newCurrentIdx = currentIdx\n        var childOneIdx = currentIdx * 2 + 1\n        while (childOneIdx <= endIdx) {\n            var childTwoIdx = if (newCurrentIdx * 2 + 2 <= endIdx) newCurrentIdx * 2 + 2 else -1\n            var idxToSwap: Int\n            if (childTwoIdx != -1 && heap[childTwoIdx].estimatedDistanceToEnd < heap[childOneIdx].estimatedDistanceToEnd) {\n                idxToSwap = childTwoIdx\n            } else {\n                idxToSwap = childOneIdx\n            }\n            if (heap[idxToSwap].estimatedDistanceToEnd < heap[newCurrentIdx].estimatedDistanceToEnd) {\n                this.swap(newCurrentIdx, idxToSwap, heap)\n                newCurrentIdx = idxToSwap\n                childOneIdx = newCurrentIdx * 2 + 1\n            } else {\n                return\n            }\n        }\n    }\n\n    // O(log(n)) time | O(1) space\n    fun siftUp(currentIdx: Int, heap: MutableList<Node>) {\n        var newCurrentIdx = currentIdx\n        var parentIdx = (currentIdx - 1) / 2\n        while (newCurrentIdx > 0 && heap[newCurrentIdx].estimatedDistanceToEnd < heap[parentIdx].estimatedDistanceToEnd) {\n            this.swap(newCurrentIdx, parentIdx, heap)\n            newCurrentIdx = parentIdx\n            parentIdx = (newCurrentIdx - 1) / 2\n        }\n    }\n\n    // O(log(n)) time | O(1) space\n    fun remove(): Node? {\n        if (this.isEmpty()) return null\n\n        this.swap(0, this.heap.size - 1, this.heap)\n        val node = this.heap.removeAt(this.heap.size - 1)\n        this.nodePositionsInHeap.remove(node.id)\n        this.siftDown(0, this.heap.size - 1, this.heap)\n        return node\n    }\n\n    // O(log(n)) time | O(1) space\n    fun insert(node: Node) {\n        this.heap.add(node)\n        this.nodePositionsInHeap[node.id] = this.heap.size - 1\n        this.siftUp(this.heap.size - 1, this.heap)\n    }\n\n    fun swap(i: Int, j: Int, heap: MutableList<Node>) {\n        this.nodePositionsInHeap[heap[i].id] = j\n        this.nodePositionsInHeap[heap[j].id] = i\n        val temp = heap[j]\n        heap[j] = heap[i]\n        heap[i] = temp\n    }\n\n    fun containsNode(node: Node): Boolean {\n        return node.id in this.nodePositionsInHeap\n    }\n\n    fun update(node: Node) {\n        this.siftUp(this.nodePositionsInHeap[node.id]!!, this.heap)\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.aStarAlgorithm\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val startRow = 0\n        val startCol = 1\n        val endRow = 4\n        val endCol = 3\n        val graph = listOf(\n            listOf(0, 0, 0, 0, 0),\n            listOf(0, 1, 1, 1, 0),\n            listOf(0, 0, 0, 0, 0),\n            listOf(1, 0, 1, 1, 1),\n            listOf(0, 0, 0, 0, 0),\n        )\n        val expected = listOf(\n            listOf(0, 1),\n            listOf(0, 0),\n            listOf(1, 0),\n            listOf(2, 0),\n            listOf(2, 1),\n            listOf(3, 1),\n            listOf(4, 1),\n            listOf(4, 2),\n            listOf(4, 3),\n        )\n        val output = aStarAlgorithm(startRow, startCol, endRow, endCol, graph)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.aStarAlgorithm\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val startRow = 0\n        val startCol = 1\n        val endRow = 4\n        val endCol = 3\n        val graph = listOf(\n            listOf(0, 0, 0, 0, 0),\n            listOf(0, 1, 1, 1, 0),\n            listOf(0, 0, 0, 0, 0),\n            listOf(1, 0, 1, 1, 1),\n            listOf(0, 0, 0, 0, 0),\n        )\n        val expected = listOf(\n            listOf(0, 1),\n            listOf(0, 0),\n            listOf(1, 0),\n            listOf(2, 0),\n            listOf(2, 1),\n            listOf(3, 1),\n            listOf(4, 1),\n            listOf(4, 2),\n            listOf(4, 3),\n        )\n        val output = aStarAlgorithm(startRow, startCol, endRow, endCol, graph)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def aStarAlgorithm(startRow, startCol, endRow, endCol, graph):\n    # Write your code here.\n    return []\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Node:\n    def __init__(self, row, col, value):\n        self.id = str(row) + \"-\" + str(col)\n        self.row = row\n        self.col = col\n        self.value = value\n        self.distanceFromStart = float(\"inf\")\n        self.estimatedDistanceToEnd = float(\"inf\")\n        self.cameFrom = None\n\n\n# O(w * h * log(w * h)) time | O(w * h) space - where\n# w is the width of the graph and h is the height\ndef aStarAlgorithm(startRow, startCol, endRow, endCol, graph):\n    nodes = initializeNodes(graph)\n\n    startNode = nodes[startRow][startCol]\n    endNode = nodes[endRow][endCol]\n\n    startNode.distanceFromStart = 0\n    startNode.estimatedDistanceToEnd = calculateManhattanDistance(startNode, endNode)\n\n    nodesToVisit = MinHeap([startNode])\n\n    while not nodesToVisit.isEmpty():\n        currentMinDistanceNode = nodesToVisit.remove()\n\n        if currentMinDistanceNode == endNode:\n            break\n\n        neighbors = getNeighboringNodes(currentMinDistanceNode, nodes)\n        for neighbor in neighbors:\n            if neighbor.value == 1:\n                continue\n\n            tentativeDistanceToNeighbor = currentMinDistanceNode.distanceFromStart + 1\n\n            if tentativeDistanceToNeighbor >= neighbor.distanceFromStart:\n                continue\n\n            neighbor.cameFrom = currentMinDistanceNode\n            neighbor.distanceFromStart = tentativeDistanceToNeighbor\n            neighbor.estimatedDistanceToEnd = (\n                tentativeDistanceToNeighbor + calculateManhattanDistance(neighbor, endNode)\n            )\n\n            if not nodesToVisit.containsNode(neighbor):\n                nodesToVisit.insert(neighbor)\n            else:\n                nodesToVisit.update(neighbor)\n\n    return reconstructPath(endNode)\n\n\ndef initializeNodes(graph):\n    nodes = []\n\n    for i, row in enumerate(graph):\n        nodes.append([])\n        for j, value in enumerate(row):\n            nodes[i].append(Node(i, j, value))\n\n    return nodes\n\n\ndef calculateManhattanDistance(currentNode, endNode):\n    currentRow = currentNode.row\n    currentCol = currentNode.col\n    endRow = endNode.row\n    endCol = endNode.col\n\n    return abs(currentRow - endRow) + abs(currentCol - endCol)\n\n\ndef getNeighboringNodes(node, nodes):\n    neighbors = []\n\n    numRows = len(nodes)\n    numCols = len(nodes[0])\n\n    row = node.row\n    col = node.col\n\n    if row < numRows - 1:  # DOWN\n        neighbors.append(nodes[row + 1][col])\n\n    if row > 0:  # UP\n        neighbors.append(nodes[row - 1][col])\n\n    if col < numCols - 1:  # RIGHT\n        neighbors.append(nodes[row][col + 1])\n\n    if col > 0:  # LEFT\n        neighbors.append(nodes[row][col - 1])\n\n    return neighbors\n\n\ndef reconstructPath(endNode):\n    if not endNode.cameFrom:\n        return []\n\n    currentNode = endNode\n    path = []\n\n    while currentNode is not None:\n        path.append([currentNode.row, currentNode.col])\n        currentNode = currentNode.cameFrom\n\n    return path[::-1]  # reverse path so it goes from start to end\n\n\nclass MinHeap:\n    def __init__(self, array):\n        # Holds the position in the heap that each node is at\n        self.nodePositionsInHeap = {node.id: idx for idx, node in enumerate(array)}\n        self.heap = self.buildHeap(array)\n\n    def isEmpty(self):\n        return len(self.heap) == 0\n\n    # O(n) time | O(1) space\n    def buildHeap(self, array):\n        firstParentIdx = (len(array) - 2) // 2\n        for currentIdx in reversed(range(firstParentIdx + 1)):\n            self.siftDown(currentIdx, len(array) - 1, array)\n        return array\n\n    # O(log(n)) time | O(1) space\n    def siftDown(self, currentIdx, endIdx, heap):\n        childOneIdx = currentIdx * 2 + 1\n        while childOneIdx <= endIdx:\n            childTwoIdx = currentIdx * 2 + 2 if currentIdx * 2 + 2 <= endIdx else -1\n            if (\n                childTwoIdx != -1\n                and heap[childTwoIdx].estimatedDistanceToEnd\n                < heap[childOneIdx].estimatedDistanceToEnd\n            ):\n                idxToSwap = childTwoIdx\n            else:\n                idxToSwap = childOneIdx\n            if heap[idxToSwap].estimatedDistanceToEnd < heap[currentIdx].estimatedDistanceToEnd:\n                self.swap(currentIdx, idxToSwap, heap)\n                currentIdx = idxToSwap\n                childOneIdx = currentIdx * 2 + 1\n            else:\n                return\n\n    # O(log(n)) time | O(1) space\n    def siftUp(self, currentIdx, heap):\n        parentIdx = (currentIdx - 1) // 2\n        while (\n            currentIdx > 0\n            and heap[currentIdx].estimatedDistanceToEnd < heap[parentIdx].estimatedDistanceToEnd\n        ):\n            self.swap(currentIdx, parentIdx, heap)\n            currentIdx = parentIdx\n            parentIdx = (currentIdx - 1) // 2\n\n    # O(log(n)) time | O(1) space\n    def remove(self):\n        if self.isEmpty():\n            return\n\n        self.swap(0, len(self.heap) - 1, self.heap)\n        node = self.heap.pop()\n        del self.nodePositionsInHeap[node.id]\n        self.siftDown(0, len(self.heap) - 1, self.heap)\n        return node\n\n    # O(log(n)) time | O(1) space\n    def insert(self, node):\n        self.heap.append(node)\n        self.nodePositionsInHeap[node.id] = len(self.heap) - 1\n        self.siftUp(len(self.heap) - 1, self.heap)\n\n    def swap(self, i, j, heap):\n        self.nodePositionsInHeap[heap[i].id] = j\n        self.nodePositionsInHeap[heap[j].id] = i\n        heap[i], heap[j] = heap[j], heap[i]\n\n    def containsNode(self, node):\n        return node.id in self.nodePositionsInHeap\n\n    def update(self, node):\n        self.siftUp(self.nodePositionsInHeap[node.id], self.heap)\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        startRow = 0\n        startCol = 1\n        endRow = 4\n        endCol = 3\n        graph = [\n            [0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0],\n            [1, 0, 1, 1, 1],\n            [0, 0, 0, 0, 0],\n        ]\n        expected = [[0, 1], [0, 0], [1, 0], [2, 0], [2, 1], [3, 1], [4, 1], [4, 2], [4, 3]]\n        actual = program.aStarAlgorithm(startRow, startCol, endRow, endCol, graph)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        startRow = 0\n        startCol = 1\n        endRow = 4\n        endCol = 3\n        graph = [\n            [0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0],\n            [1, 0, 1, 1, 1],\n            [0, 0, 0, 0, 0],\n        ]\n        expected = [[0, 1], [0, 0], [1, 0], [2, 0], [2, 1], [3, 1], [4, 1], [4, 2], [4, 3]]\n        actual = program.aStarAlgorithm(startRow, startCol, endRow, endCol, graph)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def aStarAlgorithm(startRow, startCol, endRow, endCol, graph)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def aStarAlgorithm(startRow, startCol, endRow, endCol, graph)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.aStarAlgorithm\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.aStarAlgorithm\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "\nclass Program {\n  func aStarAlgorithm(_ startRow: Int, _ startCol: Int, _ endRow: Int, _ endCol: Int, _ graph: [[Int]]) -> [[Int]] {\n    // Write your code here.\n    return [[Int]]()\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(w * h * log(w * h)) time | O(w * h) space - where\n  // w is the width of the graph and h is the height\n  func aStarAlgorithm(_ startRow: Int, _ startCol: Int, _ endRow: Int, _ endCol: Int, _ graph: [[Int]]) -> [[Int]] {\n    var nodes = initializeNodes(graph)\n\n    let startNode = nodes[startRow][startCol]\n    let endNode = nodes[endRow][endCol]\n\n    startNode.distanceFromStart = 0\n    startNode.estimatedDistanceToEnd = calculateManhattanDistance(startNode, endNode)\n\n    var startNodes = [startNode]\n    let nodesToVisit = MinHeap(&startNodes)\n\n    while !nodesToVisit.isEmpty() {\n      let currentMinDistanceNode = nodesToVisit.remove()!\n      if currentMinDistanceNode == endNode {\n        break\n      }\n\n      let neighbors = getNeighboringNodes(currentMinDistanceNode, nodes)\n      for neighbor in neighbors {\n        if neighbor.value == 1 {\n          continue\n        }\n\n        let tentativeDistanceToNeighbor = currentMinDistanceNode.distanceFromStart + 1\n        if tentativeDistanceToNeighbor >= neighbor.distanceFromStart {\n          continue\n        }\n\n        neighbor.cameFrom = currentMinDistanceNode\n        neighbor.distanceFromStart = tentativeDistanceToNeighbor\n        neighbor.estimatedDistanceToEnd = tentativeDistanceToNeighbor +\n          calculateManhattanDistance(neighbor, endNode)\n\n        if !nodesToVisit.containsNode(neighbor) {\n          nodesToVisit.insert(neighbor)\n        } else {\n          nodesToVisit.update(neighbor)\n        }\n      }\n    }\n    return reconstructPath(endNode)\n  }\n\n  class Node {\n    let id: String\n    let row: Int\n    let col: Int\n    let value: Int\n    var distanceFromStart: Int\n    var estimatedDistanceToEnd: Int\n    var cameFrom: Node?\n\n    init(_ row: Int, _ col: Int, _ value: Int) {\n      id = String(row) + \"-\" + String(col)\n      self.row = row\n      self.col = col\n      self.value = value\n      distanceFromStart = Int.max\n      estimatedDistanceToEnd = Int.max\n      cameFrom = nil\n    }\n\n    static func == (lhs: Node, rhs: Node) -> Bool {\n      return lhs.id == rhs.id\n    }\n  }\n\n  func initializeNodes(_ graph: [[Int]]) -> [[Node]] {\n    var nodes = [[Node]]()\n    for row in 0 ..< graph.count {\n      var newRow = [Node]()\n      for col in 0 ..< graph[0].count {\n        let value = graph[row][col]\n        newRow.append(Node(row, col, value))\n      }\n      nodes.append(newRow)\n    }\n    return nodes\n  }\n\n  func calculateManhattanDistance(_ currentNode: Node, _ endNode: Node) -> Int {\n    return abs(currentNode.col - endNode.col) + abs(currentNode.row - endNode.row)\n  }\n\n  func getNeighboringNodes(_ node: Node, _ nodes: [[Node]]) -> [Node] {\n    var neighbors = [Node]()\n    let numRows = nodes.count\n    let numCols = nodes[0].count\n\n    let row = node.row\n    let col = node.col\n\n    if row < numRows - 1 {\n      neighbors.append(nodes[row + 1][col])\n    } // DOWN\n    if row > 0 {\n      neighbors.append(nodes[row - 1][col])\n    } // UP\n    if col < numCols - 1 {\n      neighbors.append(nodes[row][col + 1])\n    } // RIGHT\n    if col > 0 {\n      neighbors.append(nodes[row][col - 1])\n    } // LEFT\n\n    return neighbors\n  }\n\n  func reconstructPath(_ endNode: Node) -> [[Int]] {\n    if endNode.cameFrom == nil {\n      return [[Int]]()\n    }\n\n    var currentNode: Node? = endNode\n    var path = [[Int]]()\n    while currentNode != nil {\n      path.append([currentNode!.row, currentNode!.col])\n      currentNode = currentNode!.cameFrom\n    }\n    return reversePath(path)\n  }\n\n  func reversePath(_ path: [[Int]]) -> [[Int]] {\n    var newPath = [[Int]]()\n    for i in 0 ..< path.count {\n      let j = path.count - i - 1\n      newPath.append(path[j])\n    }\n    return newPath\n  }\n\n  class MinHeap {\n    var heap = [Node]()\n    var nodePositionsInHeap = [String: Int]()\n\n    init(_ array: inout [Node]) {\n      for (i, node) in array.enumerated() {\n        nodePositionsInHeap[node.id] = i\n      }\n      heap = array\n      buildHeap(array: &array)\n    }\n\n    // O(n) time | O(1) space\n    func buildHeap(array: inout [Node]) {\n      var firstParentIndex = Double((array.count - 2) / 2)\n      firstParentIndex = firstParentIndex.rounded(.down)\n\n      for currentIndex in stride(from: Int(firstParentIndex), through: 0, by: -1) {\n        let endIndex = array.count - 1\n        siftDown(currentIndex, endIndex)\n      }\n    }\n\n    // O(log(n)) time | O(1) space\n    func siftDown(_ currentIndex: Int, _ endIndex: Int) {\n      var childOneIndex = currentIndex * 2 + 1\n      var current = currentIndex\n      while childOneIndex <= endIndex {\n        var childTwoIndex = -1\n        if current * 2 + 2 <= endIndex {\n          childTwoIndex = current * 2 + 2\n        }\n        var indexToSwap = childOneIndex\n        if childTwoIndex > -1, heap[childTwoIndex].estimatedDistanceToEnd < heap[childOneIndex].estimatedDistanceToEnd {\n          indexToSwap = childTwoIndex\n        }\n\n        if heap[indexToSwap].estimatedDistanceToEnd < heap[current].estimatedDistanceToEnd {\n          swap(current, indexToSwap)\n          current = indexToSwap\n          childOneIndex = current * 2 + 1\n        } else {\n          return\n        }\n      }\n    }\n\n    // O(log(n)) time | O(1) space\n    func siftUp(_ currentIndex: Int) {\n      var currentIndex = currentIndex\n      var parentIndex = (currentIndex - 1) / 2\n\n      while currentIndex > 0, heap[currentIndex].estimatedDistanceToEnd < heap[parentIndex].estimatedDistanceToEnd {\n        swap(currentIndex, parentIndex)\n        currentIndex = parentIndex\n        parentIndex = (currentIndex - 1) / 2\n      }\n    }\n\n    // O(log(n)) time | O(1) space\n    func remove() -> Node? {\n      if isEmpty() {\n        return nil\n      }\n\n      let l = heap.count\n      swap(0, l - 1)\n      let peeked = heap[l - 1]\n      heap.removeLast()\n      nodePositionsInHeap.removeValue(forKey: peeked.id)\n      siftDown(0, l - 2)\n      return peeked\n    }\n\n    // O(log(n)) time | O(1) space\n    func update(_ node: Node) {\n      siftUp(nodePositionsInHeap[node.id]!)\n    }\n\n    // O(log(n)) time | O(1) space\n    func insert(_ node: Node) {\n      heap.append(node)\n      nodePositionsInHeap[node.id] = heap.count - 1\n      siftUp(heap.count - 1)\n    }\n\n    func swap(_ i: Int, _ j: Int) {\n      nodePositionsInHeap[heap[i].id] = j\n      nodePositionsInHeap[heap[j].id] = i\n\n      let temp = heap[i]\n      heap[i] = heap[j]\n      heap[j] = temp\n    }\n\n    func isEmpty() -> Bool {\n      return heap.count == 0\n    }\n\n    func containsNode(_ node: Node) -> Bool {\n      return nodePositionsInHeap[node.id] != nil\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let startRow = 0\n      let startCol = 1\n      let endRow = 4\n      let endCol = 3\n      let graph = [\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0],\n        [1, 0, 1, 1, 1],\n        [0, 0, 0, 0, 0],\n      ]\n      let expected = [[0, 1], [0, 0], [1, 0], [2, 0], [2, 1], [3, 1], [4, 1], [4, 2], [4, 3]]\n      let actual = Program().aStarAlgorithm(startRow, startCol, endRow, endCol, graph)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let startRow = 0\n      let startCol = 1\n      let endRow = 4\n      let endCol = 3\n      let graph = [\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0],\n        [1, 0, 1, 1, 1],\n        [0, 0, 0, 0, 0],\n      ]\n      let expected = [[0, 1], [0, 0], [1, 0], [2, 0], [2, 1], [3, 1], [4, 1], [4, 2], [4, 3]]\n      let actual = Program().aStarAlgorithm(startRow, startCol, endRow, endCol, graph)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function aStarAlgorithm(\n  startRow: number,\n  startCol: number,\n  endRow: number,\n  endCol: number,\n  graph: number[][],\n) {\n  // Write your code here.\n  return [];\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Node {\n  id: string;\n  row: number;\n  col: number;\n  value: number;\n  distanceFromStart: number;\n  estimatedDistanceToEnd: number;\n  cameFrom: Node | null;\n\n  constructor(row: number, col: number, value: number) {\n    this.id = row.toString() + '-' + col.toString();\n    this.row = row;\n    this.col = col;\n    this.value = value;\n    this.distanceFromStart = Infinity;\n    this.estimatedDistanceToEnd = Infinity;\n    this.cameFrom = null;\n  }\n}\n\n// O(w * h * log(w * h)) time | O(w * h) space - where\n// w is the width of the graph and h is the height\nexport function aStarAlgorithm(\n  startRow: number,\n  startCol: number,\n  endRow: number,\n  endCol: number,\n  graph: number[][],\n) {\n  const nodes = initializeNodes(graph);\n\n  const startNode = nodes[startRow][startCol];\n  const endNode = nodes[endRow][endCol];\n\n  startNode.distanceFromStart = 0;\n  startNode.estimatedDistanceToEnd = calculateManhattanDistance(startNode, endNode);\n\n  const nodesToVisit = new MinHeap([startNode]);\n\n  while (!nodesToVisit.isEmpty()) {\n    const currentMinDistanceNode = nodesToVisit.remove()!;\n\n    if (currentMinDistanceNode === endNode) break;\n\n    const neighbors = getNeighboringNodes(currentMinDistanceNode, nodes);\n    for (const neighbor of neighbors) {\n      if (neighbor.value === 1) continue;\n\n      const tentativeDistanceToNeighbor = currentMinDistanceNode.distanceFromStart + 1;\n\n      if (tentativeDistanceToNeighbor >= neighbor.distanceFromStart) continue;\n\n      neighbor.cameFrom = currentMinDistanceNode;\n      neighbor.distanceFromStart = tentativeDistanceToNeighbor;\n      neighbor.estimatedDistanceToEnd =\n        tentativeDistanceToNeighbor + calculateManhattanDistance(neighbor, endNode);\n\n      if (!nodesToVisit.containsNode(neighbor)) {\n        nodesToVisit.insert(neighbor);\n      } else {\n        nodesToVisit.update(neighbor);\n      }\n    }\n  }\n\n  return reconstructPath(endNode);\n}\n\nfunction initializeNodes(graph: number[][]) {\n  const nodes: Node[][] = [];\n\n  for (const [i, row] of graph.entries()) {\n    nodes.push([]);\n    for (const [j, value] of row.entries()) {\n      const node = new Node(i, j, value);\n      nodes[i].push(node);\n    }\n  }\n\n  return nodes;\n}\n\nfunction calculateManhattanDistance(currentNode: Node, endNode: Node) {\n  const currentRow = currentNode.row;\n  const currentCol = currentNode.col;\n  const endRow = endNode.row;\n  const endCol = endNode.col;\n\n  return Math.abs(currentRow - endRow) + Math.abs(currentCol - endCol);\n}\n\nfunction getNeighboringNodes(node: Node, nodes: Node[][]) {\n  const neighbors: Node[] = [];\n\n  const numRows = nodes.length;\n  const numCols = nodes[0].length;\n\n  const row = node.row;\n  const col = node.col;\n\n  if (row < numRows - 1) {\n    // DOWN\n    neighbors.push(nodes[row + 1][col]);\n  }\n\n  if (row > 0) {\n    // UP\n    neighbors.push(nodes[row - 1][col]);\n  }\n\n  if (col < numCols - 1) {\n    // RIGHT\n    neighbors.push(nodes[row][col + 1]);\n  }\n\n  if (col > 0) {\n    // LEFT\n    neighbors.push(nodes[row][col - 1]);\n  }\n\n  return neighbors;\n}\n\nfunction reconstructPath(endNode: Node) {\n  if (endNode.cameFrom === null) {\n    return [];\n  }\n\n  let currentNode: Node | null = endNode;\n  const path: number[][] = [];\n\n  while (currentNode !== null) {\n    path.push([currentNode.row, currentNode.col]);\n    currentNode = currentNode.cameFrom;\n  }\n\n  path.reverse(); // reverse path so it goes from start to end\n\n  return path;\n}\n\nclass MinHeap {\n  nodePositionsInHeap: {[id: string]: number};\n  heap: Node[];\n\n  constructor(array: Node[]) {\n    // Holds the position in the heap that each node is at\n    this.nodePositionsInHeap = array.reduce((obj, node, i) => {\n      obj[node.id] = i;\n      return obj;\n    }, {} as {[id: string]: number});\n    this.heap = this.buildHeap(array);\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  // O(n) time | O(1) space\n  buildHeap(array: Node[]) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  // O(log(n)) time | O(1) space\n  siftDown(currentIdx: number, endIdx: number, heap: Node[]) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (\n        childTwoIdx !== -1 &&\n        heap[childTwoIdx].estimatedDistanceToEnd < heap[childOneIdx].estimatedDistanceToEnd\n      ) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap].estimatedDistanceToEnd < heap[currentIdx].estimatedDistanceToEnd) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  siftUp(currentIdx: number, heap: Node[]) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (\n      currentIdx > 0 &&\n      heap[currentIdx].estimatedDistanceToEnd < heap[parentIdx].estimatedDistanceToEnd\n    ) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  remove() {\n    if (this.isEmpty()) return;\n\n    this.swap(0, this.heap.length - 1, this.heap);\n    const node = this.heap.pop()!;\n    delete this.nodePositionsInHeap[node.id];\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return node;\n  }\n\n  // O(log(n)) time | O(1) space\n  insert(node: Node) {\n    this.heap.push(node);\n    this.nodePositionsInHeap[node.id] = this.heap.length - 1;\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i: number, j: number, heap: Node[]) {\n    this.nodePositionsInHeap[this.heap[i].id] = j;\n    this.nodePositionsInHeap[this.heap[j].id] = i;\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n\n  containsNode(node: Node) {\n    return node.id in this.nodePositionsInHeap;\n  }\n\n  update(node: Node) {\n    this.siftUp(this.nodePositionsInHeap[node.id], this.heap);\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const startRow = 0;\n  const startCol = 1;\n  const endRow = 4;\n  const endCol = 3;\n  const graph = [\n    [0, 0, 0, 0, 0],\n    [0, 1, 1, 1, 0],\n    [0, 0, 0, 0, 0],\n    [1, 0, 1, 1, 1],\n    [0, 0, 0, 0, 0],\n  ];\n  const expected = [\n    [0, 1],\n    [0, 0],\n    [1, 0],\n    [2, 0],\n    [2, 1],\n    [3, 1],\n    [4, 1],\n    [4, 2],\n    [4, 3],\n  ];\n  const actual = program.aStarAlgorithm(startRow, startCol, endRow, endCol, graph);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const startRow = 0;\n  const startCol = 1;\n  const endRow = 4;\n  const endCol = 3;\n  const graph = [\n    [0, 0, 0, 0, 0],\n    [0, 1, 1, 1, 0],\n    [0, 0, 0, 0, 0],\n    [1, 0, 1, 1, 1],\n    [0, 0, 0, 0, 0],\n  ];\n  const expected = [\n    [0, 1],\n    [0, 0],\n    [1, 0],\n    [2, 0],\n    [2, 1],\n    [3, 1],\n    [4, 1],\n    [4, 2],\n    [4, 3],\n  ];\n  const actual = program.aStarAlgorithm(startRow, startCol, endRow, endCol, graph);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "startRow",
      "example": 0,
      "schema": {
        "type": "integer"
      }
    },
    {
      "name": "startCol",
      "example": 1,
      "schema": {
        "type": "integer"
      }
    },
    {
      "name": "endRow",
      "example": 4,
      "schema": {
        "type": "integer"
      }
    },
    {
      "name": "endCol",
      "example": 3,
      "schema": {
        "type": "integer"
      }
    },
    {
      "name": "graph",
      "example": [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          1,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          1,
          1,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "schema": {
        "items": {
          "items": {
            "type": "integer"
          },
          "type": "array"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "endCol": 3,
      "endRow": 4,
      "graph": [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          1,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          1,
          1,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "startCol": 1,
      "startRow": 0
    },
    {
      "endCol": 8,
      "endRow": 8,
      "graph": [
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1
        ],
        [
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          0,
          1
        ],
        [
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          1
        ],
        [
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          1
        ],
        [
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          1
        ],
        [
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          1
        ],
        [
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          0,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ]
      ],
      "startCol": 1,
      "startRow": 1
    },
    {
      "endCol": 4,
      "endRow": 7,
      "graph": [
        [
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          1,
          1,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          1,
          1,
          0,
          1,
          1,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "startCol": 1,
      "startRow": 1
    },
    {
      "endCol": 1,
      "endRow": 8,
      "graph": [
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          1,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "startCol": 8,
      "startRow": 1
    },
    {
      "endCol": 19,
      "endRow": 0,
      "graph": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          1,
          0,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "startCol": 0,
      "startRow": 0
    },
    {
      "endCol": 17,
      "endRow": 18,
      "graph": [
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          0,
          0,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          1,
          1,
          1,
          0,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          1,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          1,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          1,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          1,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          1,
          0,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1
        ],
        [
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          1,
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          0,
          0,
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ]
      ],
      "startCol": 1,
      "startRow": 1
    },
    {
      "endCol": 2,
      "endRow": 1,
      "graph": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          1,
          1,
          0,
          1,
          1,
          1,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          1,
          1,
          0,
          1,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "startCol": 1,
      "startRow": 1
    },
    {
      "endCol": 4,
      "endRow": 22,
      "graph": [
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "startCol": 11,
      "startRow": 1
    }
  ],
  "jsonTests": [
    {
      "endCol": 3,
      "endRow": 4,
      "graph": [
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          1,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          1,
          1,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "startCol": 1,
      "startRow": 0
    },
    {
      "endCol": 8,
      "endRow": 8,
      "graph": [
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1
        ],
        [
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          0,
          1
        ],
        [
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          1
        ],
        [
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          1
        ],
        [
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          1
        ],
        [
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          1
        ],
        [
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          0,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ]
      ],
      "startCol": 1,
      "startRow": 1
    },
    {
      "endCol": 4,
      "endRow": 7,
      "graph": [
        [
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          1,
          1,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          1,
          1,
          0,
          1,
          1,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "startCol": 1,
      "startRow": 1
    },
    {
      "endCol": 1,
      "endRow": 8,
      "graph": [
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          1,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "startCol": 8,
      "startRow": 1
    },
    {
      "endCol": 19,
      "endRow": 0,
      "graph": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          1,
          0,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "startCol": 0,
      "startRow": 0
    },
    {
      "endCol": 17,
      "endRow": 18,
      "graph": [
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          0,
          0,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          1,
          1,
          1,
          0,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          1,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          1,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          1,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          1,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          1,
          0,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1
        ],
        [
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          1,
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          0,
          0,
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ]
      ],
      "startCol": 1,
      "startRow": 1
    },
    {
      "endCol": 2,
      "endRow": 1,
      "graph": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          1,
          1,
          0,
          1,
          1,
          1,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          1,
          1,
          0,
          1,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "startCol": 1,
      "startRow": 1
    },
    {
      "endCol": 4,
      "endRow": 22,
      "graph": [
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          0,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "startCol": 11,
      "startRow": 1
    }
  ],
  "changelog": []
}