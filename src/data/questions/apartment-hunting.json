{
  "uid": "apartment-hunting",
  "testStrategy": "JSON",
  "name": "Apartment Hunting",
  "version": 0,
  "releaseDate": "2019-09-01T00:00:00Z",
  "category": "Arrays",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 10081,
    "failureCount": 3760
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "354828587",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1568
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're looking to move into a new apartment on specific street, and you're\n  given a list of contiguous blocks on that street where each block contains an\n  apartment that you could move into.\n</p>\n<p>\n  You also have a list of requirements: a list of buildings that are important\n  to you. For instance, you might value having a school and a gym near your\n  apartment. The list of blocks that you have contains information at every\n  block about all of the buildings that are present and absent at the block in\n  question. For instance, for every block, you might know whether a school, a\n  pool, an office, and a gym are present.\n</p>\n<p>\n  In order to optimize your life, you want to pick an apartment block such that\n  you minimize the farthest distance you'd have to walk from your apartment to\n  reach any of your required buildings.\n</p>\n<p>\n  Write a function that takes in a list of contiguous blocks on a specific\n  street and a list of your required buildings and that returns the location\n  (the index) of the block that's most optimal for you.\n</p>\n<p>\n  If there are multiple most optimal blocks, your function can return the index\n  of any one of them.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">blocks</span> = [\n  {\n    \"gym\": false,\n    \"school\": true,\n    \"store\": false,\n  },\n  {\n    \"gym\": true,\n    \"school\": false,\n    \"store\": false,\n  },\n  {\n    \"gym\": true,\n    \"school\": true,\n    \"store\": false,\n  },\n  {\n    \"gym\": false,\n    \"school\": true,\n    \"store\": false,\n  },\n  {\n    \"gym\": false,\n    \"school\": true,\n    \"store\": true,\n  },\n]\n<span class=\"CodeEditor-promptParameter\">reqs</span> = [\"gym\", \"school\", \"store\"]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3 <span class=\"CodeEditor-promptComment\">// at index 3, the farthest you'd have to walk to reach a gym, a school, or a store is 1 block; at any other index, you'd have to walk farther</span>\n</pre>\n</div>",
  "hints": [
    "<p>\nFor every block, you want to go through every requirement, and for every requirement, you want to find the closest other block with that requirement (or rather, the smallest distance to another block with that requirement). Once you've done that for every requirement and for every block, you want to pick, for every block, the distance of the farthest requirement. You can do this with three nested \"for\" loops.\n</p>\n",
    "\n<p>\nIs there a way to optimize on the solution mentioned in Hint #1 (that uses three nested \"for\" loops) by precomputing the smallest distances of every requirement from every block?\n</p>\n",
    "\n<p>\nFor every requirement, you should be able to precompute its smallest distances from every block by doing two simple passes though the array of blocks: one pass from left to right and one pass from right to left. Once you have these precomputed values, you can iterate through all of the blocks and pick the biggest of all the precomputed distances at that block.\n</p>"
  ],
  "spaceTime": "O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nint apartmentHunting(\n  vector<unordered_map<string, bool>> blocks, vector<string> reqs\n) {\n  // Write your code here;\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nint getIdxAtMinValue(vector<int> array);\nint distanceBetween(int a, int b);\n\n// O(b^2*r) time | O(b) space - where b is the number of blocks and r is the\n// number of requirements\nint apartmentHunting(\n  vector<unordered_map<string, bool>> blocks, vector<string> reqs\n) {\n  vector<int> maxDistancesAtBlocks(blocks.size(), INT_MIN);\n  for (int i = 0; i < blocks.size(); i++) {\n    for (string req : reqs) {\n      int closestReqDistance = INT_MAX;\n      for (int j = 0; j < blocks.size(); j++) {\n        if (blocks[j][req]) {\n          closestReqDistance = min(closestReqDistance, distanceBetween(i, j));\n        }\n      }\n      maxDistancesAtBlocks[i] =\n        max(maxDistancesAtBlocks[i], closestReqDistance);\n    }\n  }\n  return getIdxAtMinValue(maxDistancesAtBlocks);\n}\n\nint getIdxAtMinValue(vector<int> array) {\n  int idxAtMinValue = 0;\n  int minValue = INT_MAX;\n  for (int i = 0; i < array.size(); i++) {\n    int currentValue = array[i];\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      idxAtMinValue = i;\n    }\n  }\n  return idxAtMinValue;\n}\n\nint distanceBetween(int a, int b) { return abs(a - b); }\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n\n#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nvector<int> getMinDistances(\n  vector<unordered_map<string, bool>> blocks, string req\n);\nvector<int> getMaxDistancesAtBlocks(\n  vector<unordered_map<string, bool>> blocks,\n  vector<vector<int>> minDistancesFromBlocks\n);\nint getIdxAtMinValue(vector<int> array);\nint distanceBetween(int a, int b);\n\n// O(br) time | O(br) space - where b is the number of blocks and r is the\n// number of requirements\nint apartmentHunting(\n  vector<unordered_map<string, bool>> blocks, vector<string> reqs\n) {\n  vector<vector<int>> minDistancesFromBlocks;\n  for (string req : reqs) {\n    minDistancesFromBlocks.push_back(getMinDistances(blocks, req));\n  }\n  vector<int> maxDistancesAtBlocks =\n    getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks);\n  return getIdxAtMinValue(maxDistancesAtBlocks);\n}\n\nvector<int> getMinDistances(\n  vector<unordered_map<string, bool>> blocks, string req\n) {\n  vector<int> minDistances(blocks.size());\n  int closestReqIdx = INT_MAX;\n  for (int i = 0; i < blocks.size(); i++) {\n    if (blocks[i][req]) closestReqIdx = i;\n    minDistances[i] = distanceBetween(i, closestReqIdx);\n  }\n  for (int i = blocks.size() - 1; i >= 0; i--) {\n    if (blocks[i][req]) closestReqIdx = i;\n    minDistances[i] = min(minDistances[i], distanceBetween(i, closestReqIdx));\n  }\n  return minDistances;\n}\n\nvector<int> getMaxDistancesAtBlocks(\n  vector<unordered_map<string, bool>> blocks,\n  vector<vector<int>> minDistancesFromBlocks\n) {\n  vector<int> maxDistancesAtBlocks(blocks.size());\n  for (int i = 0; i < blocks.size(); i++) {\n    vector<int> minDistancesAtBlock;\n    for (vector<int> distances : minDistancesFromBlocks) {\n      minDistancesAtBlock.push_back(distances[i]);\n    }\n    maxDistancesAtBlocks[i] =\n      *max_element(minDistancesAtBlock.begin(), minDistancesAtBlock.end());\n  }\n  return maxDistancesAtBlocks;\n}\n\nint getIdxAtMinValue(vector<int> array) {\n  int idxAtMinValue = 0;\n  int minValue = INT_MAX;\n  for (int i = 0; i < array.size(); i++) {\n    int currentValue = array[i];\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      idxAtMinValue = i;\n    }\n  }\n  return idxAtMinValue;\n}\n\nint distanceBetween(int a, int b) { return abs(a - b); }\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include <algorithm>\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<unordered_map<string, bool>> blocks(5);\n\n      blocks[0].insert({\"gym\", false});\n      blocks[0].insert({\"school\", true});\n      blocks[0].insert({\"store\", false});\n\n      blocks[1].insert({\"gym\", true});\n      blocks[1].insert({\"school\", false});\n      blocks[1].insert({\"store\", false});\n\n      blocks[2].insert({\"gym\", true});\n      blocks[2].insert({\"school\", true});\n      blocks[2].insert({\"store\", false});\n\n      blocks[3].insert({\"gym\", false});\n      blocks[3].insert({\"school\", true});\n      blocks[3].insert({\"store\", false});\n\n      blocks[4].insert({\"gym\", false});\n      blocks[4].insert({\"school\", true});\n      blocks[4].insert({\"store\", true});\n\n      vector<string> reqs = {\"gym\", \"school\", \"store\"};\n      assert(apartmentHunting(blocks, reqs) == 3);\n    });\n  }\n};\n",
      "unitTests": "#include <algorithm>\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<unordered_map<string, bool>> blocks(5);\n\n      blocks[0].insert({\"gym\", false});\n      blocks[0].insert({\"school\", true});\n      blocks[0].insert({\"store\", false});\n\n      blocks[1].insert({\"gym\", true});\n      blocks[1].insert({\"school\", false});\n      blocks[1].insert({\"store\", false});\n\n      blocks[2].insert({\"gym\", true});\n      blocks[2].insert({\"school\", true});\n      blocks[2].insert({\"store\", false});\n\n      blocks[3].insert({\"gym\", false});\n      blocks[3].insert({\"school\", true});\n      blocks[3].insert({\"store\", false});\n\n      blocks[4].insert({\"gym\", false});\n      blocks[4].insert({\"school\", true});\n      blocks[4].insert({\"store\", true});\n\n      vector<string> reqs = {\"gym\", \"school\", \"store\"};\n      assert(apartmentHunting(blocks, reqs) == 3);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n  public static int ApartmentHunting(\n    List<Dictionary<string, bool> > blocks, string[] reqs\n  ) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(b^2*r) time | O(b) space - where b is the number of blocks and r is the\n  // number of requirements\n  public static int ApartmentHunting(\n    List<Dictionary<string, bool> > blocks, string[] reqs\n  ) {\n    int[] maxDistancesAtBlocks = new int[blocks.Count];\n    Array.Fill(maxDistancesAtBlocks, Int32.MinValue);\n\n    for (int i = 0; i < blocks.Count; i++) {\n      foreach (string req in reqs) {\n        int closestReqDistance = Int32.MaxValue;\n        for (int j = 0; j < blocks.Count; j++) {\n          if (blocks[j][req]) {\n            closestReqDistance =\n              Math.Min(closestReqDistance, distanceBetween(i, j));\n          }\n        }\n        maxDistancesAtBlocks[i] =\n          Math.Max(maxDistancesAtBlocks[i], closestReqDistance);\n      }\n    }\n    return getIdxAtMinValue(maxDistancesAtBlocks);\n  }\n\n  public static int getIdxAtMinValue(int[] array) {\n    int idxAtMinValue = 0;\n    int minValue = Int32.MaxValue;\n    for (int i = 0; i < array.Length; i++) {\n      int currentValue = array[i];\n      if (currentValue < minValue) {\n        minValue = currentValue;\n        idxAtMinValue = i;\n      }\n    }\n    return idxAtMinValue;\n  }\n\n  public static int distanceBetween(int a, int b) {\n    return Math.Abs(a - b);\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(br) time | O(br) space - where b is the number of blocks and r is the\n  // number of requirements\n  public static int ApartmentHunting(\n    List<Dictionary<string, bool> > blocks, string[] reqs\n  ) {\n    int[][] minDistancesFromBlocks = new int [reqs.Length][];\n    for (int i = 0; i < reqs.Length; i++) {\n      minDistancesFromBlocks[i] = getMinDistances(blocks, reqs[i]);\n    }\n    int[] maxDistancesAtBlocks =\n      getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks);\n    return getIdxAtMinValue(maxDistancesAtBlocks);\n  }\n\n  public static int[] getMinDistances(\n    List<Dictionary<string, bool> > blocks, string req\n  ) {\n    int[] minDistances = new int[blocks.Count];\n    int closestReqIdx = Int32.MaxValue;\n    for (int i = 0; i < blocks.Count; i++) {\n      if (blocks[i][req]) closestReqIdx = i;\n      minDistances[i] = distanceBetween(i, closestReqIdx);\n    }\n    for (int i = blocks.Count - 1; i >= 0; i--) {\n      if (blocks[i][req]) closestReqIdx = i;\n      minDistances[i] =\n        Math.Min(minDistances[i], distanceBetween(i, closestReqIdx));\n    }\n    return minDistances;\n  }\n\n  public static int[] getMaxDistancesAtBlocks(\n    List<Dictionary<string, bool> > blocks, int[][] minDistancesFromBlocks\n  ) {\n    int[] maxDistancesAtBlocks = new int[blocks.Count];\n    for (int i = 0; i < blocks.Count; i++) {\n      int[] minDistancesAtBlock = new int[minDistancesFromBlocks.Length];\n      for (int j = 0; j < minDistancesFromBlocks.Length; j++) {\n        minDistancesAtBlock[j] = minDistancesFromBlocks[j][i];\n      }\n      maxDistancesAtBlocks[i] = arrayMax(minDistancesAtBlock);\n    }\n    return maxDistancesAtBlocks;\n  }\n\n  public static int getIdxAtMinValue(int[] array) {\n    int idxAtMinValue = 0;\n    int minValue = Int32.MaxValue;\n    for (int i = 0; i < array.Length; i++) {\n      int currentValue = array[i];\n      if (currentValue < minValue) {\n        minValue = currentValue;\n        idxAtMinValue = i;\n      }\n    }\n    return idxAtMinValue;\n  }\n\n  public static int distanceBetween(int a, int b) {\n    return Math.Abs(a - b);\n  }\n\n  public static int arrayMax(int[] array) {\n    int max = array[0];\n    foreach (int a in array) {\n      if (a > max) {\n        max = a;\n      }\n    }\n    return max;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    List<Dictionary<string, bool> > blocks =\n      new List<Dictionary<string, bool> >();\n\n    blocks.Insert(0, new Dictionary<string, bool>());\n    blocks[0][\"gym\"] = false;\n    blocks[0][\"school\"] = true;\n    blocks[0][\"store\"] = false;\n\n    blocks.Insert(1, new Dictionary<string, bool>());\n    blocks[1][\"gym\"] = true;\n    blocks[1][\"school\"] = false;\n    blocks[1][\"store\"] = false;\n\n    blocks.Insert(2, new Dictionary<string, bool>());\n    blocks[2][\"gym\"] = true;\n    blocks[2][\"school\"] = true;\n    blocks[2][\"store\"] = false;\n\n    blocks.Insert(3, new Dictionary<string, bool>());\n    blocks[3][\"gym\"] = false;\n    blocks[3][\"school\"] = true;\n    blocks[3][\"store\"] = false;\n\n    blocks.Insert(4, new Dictionary<string, bool>());\n    blocks[4][\"gym\"] = false;\n    blocks[4][\"school\"] = true;\n    blocks[4][\"store\"] = true;\n\n    string[] reqs = new string[] { \"gym\", \"school\", \"store\" };\n    Utils.AssertTrue(Program.ApartmentHunting(blocks, reqs) == 3);\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    List<Dictionary<string, bool> > blocks =\n      new List<Dictionary<string, bool> >();\n\n    blocks.Insert(0, new Dictionary<string, bool>());\n    blocks[0][\"gym\"] = false;\n    blocks[0][\"school\"] = true;\n    blocks[0][\"store\"] = false;\n\n    blocks.Insert(1, new Dictionary<string, bool>());\n    blocks[1][\"gym\"] = true;\n    blocks[1][\"school\"] = false;\n    blocks[1][\"store\"] = false;\n\n    blocks.Insert(2, new Dictionary<string, bool>());\n    blocks[2][\"gym\"] = true;\n    blocks[2][\"school\"] = true;\n    blocks[2][\"store\"] = false;\n\n    blocks.Insert(3, new Dictionary<string, bool>());\n    blocks[3][\"gym\"] = false;\n    blocks[3][\"school\"] = true;\n    blocks[3][\"store\"] = false;\n\n    blocks.Insert(4, new Dictionary<string, bool>());\n    blocks[4][\"gym\"] = false;\n    blocks[4][\"school\"] = true;\n    blocks[4][\"store\"] = true;\n\n    string[] reqs = new string[] { \"gym\", \"school\", \"store\" };\n    Utils.AssertTrue(Program.ApartmentHunting(blocks, reqs) == 3);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\ntype Block map[string]bool\n\nfunc ApartmentHunting(blocks []Block, reqs []string) int {\n\t// Write your code here.\n\treturn -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport \"math\"\n\ntype Block map[string]bool\n\n// O(b^2*r) time | O(b) space - where b is the number of blocks\n// and r is the number of requirements.\nfunc ApartmentHunting(blocks []Block, reqs []string) int {\n\tmaxDistancesAtBlocks := make([]int, len(blocks))\n\tfor i := range blocks {\n\t\tmaxDistancesAtBlocks[i] = -1\n\t\tfor _, req := range reqs {\n\t\t\tclosestReqDistance := math.MaxInt32\n\t\t\tfor j := range blocks {\n\t\t\t\tif blocks[j][req] {\n\t\t\t\t\tclosestReqDistance = min(closestReqDistance, distanceBetween(i, j))\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxDistancesAtBlocks[i] = max(maxDistancesAtBlocks[i], closestReqDistance)\n\t\t}\n\t}\n\n\tvar optimalBlockIdx int\n\tsmallestMaxDistance := math.MaxInt32\n\tfor i, currentDistance := range maxDistancesAtBlocks {\n\t\tif currentDistance < smallestMaxDistance {\n\t\t\tsmallestMaxDistance = currentDistance\n\t\t\toptimalBlockIdx = i\n\t\t}\n\t}\n\treturn optimalBlockIdx\n}\n\nfunc distanceBetween(a, b int) int {\n\tif a > b {\n\t\treturn a - b\n\t}\n\treturn b - a\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport \"math\"\n\ntype Block map[string]bool\n\n// O(br) time | O(br) space - where b is the number of blocks\n// and r is the number of requirements.\nfunc ApartmentHunting(blocks []Block, reqs []string) int {\n\tminDistancesFromBlocks := [][]int{}\n\tfor _, req := range reqs {\n\t\tminDistancesFromBlocks = append(minDistancesFromBlocks,\n\t\t\tgetMinDistances(blocks, req))\n\t}\n\tmaxDistancesAtBlocks := getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks)\n\n\tvar optimalBlockIdx int\n\tsmallestMaxDistance := math.MaxInt32\n\tfor i, currentDistance := range maxDistancesAtBlocks {\n\t\tif currentDistance < smallestMaxDistance {\n\t\t\tsmallestMaxDistance = currentDistance\n\t\t\toptimalBlockIdx = i\n\t\t}\n\t}\n\treturn optimalBlockIdx\n}\n\nfunc getMinDistances(blocks []Block, req string) []int {\n\tminDistances := make([]int, len(blocks))\n\tclosestReq := math.MaxInt32\n\tfor i := range blocks {\n\t\tif val, found := blocks[i][req]; found && val {\n\t\t\tclosestReq = i\n\t\t}\n\t\tminDistances[i] = distanceBetween(i, closestReq)\n\t}\n\n\tfor i := len(blocks) - 1; i >= 0; i-- {\n\t\tif val, found := blocks[i][req]; found && val {\n\t\t\tclosestReq = i\n\t\t}\n\t\tminDistances[i] = min(minDistances[i], distanceBetween(i, closestReq))\n\t}\n\treturn minDistances\n}\n\nfunc getMaxDistancesAtBlocks(blocks []Block, minDistancesFromBlocks [][]int) []int {\n\tmaxDistancesAtBlocks := make([]int, len(blocks))\n\tfor i := range blocks {\n\t\tminDistancesAtBlock := []int{}\n\t\tfor _, distances := range minDistancesFromBlocks {\n\t\t\tminDistancesAtBlock = append(minDistancesAtBlock, distances[i])\n\t\t}\n\t\tmaxDistancesAtBlocks[i] = max(minDistancesAtBlock)\n\t}\n\treturn maxDistancesAtBlocks\n}\n\nfunc distanceBetween(a, b int) int {\n\tif a > b {\n\t\treturn a - b\n\t}\n\treturn b - a\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(array []int) int {\n\tif len(array) == 0 {\n\t\treturn 0\n\t}\n\n\tmax := array[0]\n\tfor i := 1; i < len(array); i++ {\n\t\tif array[i] > max {\n\t\t\tmax = array[i]\n\t\t}\n\t}\n\treturn max\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tblocks := []Block{\n\t\t{\n\t\t\t\"gym\":    false,\n\t\t\t\"school\": true,\n\t\t\t\"store\":  false,\n\t\t},\n\t\t{\n\t\t\t\"gym\":    true,\n\t\t\t\"school\": false,\n\t\t\t\"store\":  false,\n\t\t},\n\t\t{\n\t\t\t\"gym\":    true,\n\t\t\t\"school\": true,\n\t\t\t\"store\":  false,\n\t\t},\n\t\t{\n\t\t\t\"gym\":    false,\n\t\t\t\"school\": true,\n\t\t\t\"store\":  false,\n\t\t},\n\t\t{\n\t\t\t\"gym\":    false,\n\t\t\t\"school\": true,\n\t\t\t\"store\":  true,\n\t\t},\n\t}\n\treqs := []string{\"gym\", \"school\", \"store\"}\n\toutput := ApartmentHunting(blocks, reqs)\n\trequire.Equal(t, output, 3)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tblocks := []Block{\n\t\t{\n\t\t\t\"gym\":    false,\n\t\t\t\"school\": true,\n\t\t\t\"store\":  false,\n\t\t},\n\t\t{\n\t\t\t\"gym\":    true,\n\t\t\t\"school\": false,\n\t\t\t\"store\":  false,\n\t\t},\n\t\t{\n\t\t\t\"gym\":    true,\n\t\t\t\"school\": true,\n\t\t\t\"store\":  false,\n\t\t},\n\t\t{\n\t\t\t\"gym\":    false,\n\t\t\t\"school\": true,\n\t\t\t\"store\":  false,\n\t\t},\n\t\t{\n\t\t\t\"gym\":    false,\n\t\t\t\"school\": true,\n\t\t\t\"store\":  true,\n\t\t},\n\t}\n\treqs := []string{\"gym\", \"school\", \"store\"}\n\toutput := ApartmentHunting(blocks, reqs)\n\trequire.Equal(t, output, 3)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static int apartmentHunting(\n    List<Map<String, Boolean>> blocks, String[] reqs\n  ) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(b^2*r) time | O(b) space - where b is the number of blocks and r is the\n  // number of requirements\n  public static int apartmentHunting(\n    List<Map<String, Boolean>> blocks, String[] reqs\n  ) {\n    int[] maxDistancesAtBlocks = new int[blocks.size()];\n    Arrays.fill(maxDistancesAtBlocks, Integer.MIN_VALUE);\n\n    for (int i = 0; i < blocks.size(); i++) {\n      for (String req : reqs) {\n        int closestReqDistance = Integer.MAX_VALUE;\n        for (int j = 0; j < blocks.size(); j++) {\n          if (blocks.get(j).get(req)) {\n            closestReqDistance =\n              Math.min(closestReqDistance, distanceBetween(i, j));\n          }\n        }\n        maxDistancesAtBlocks[i] =\n          Math.max(maxDistancesAtBlocks[i], closestReqDistance);\n      }\n    }\n    return getIdxAtMinValue(maxDistancesAtBlocks);\n  }\n\n  public static int getIdxAtMinValue(int[] array) {\n    int idxAtMinValue = 0;\n    int minValue = Integer.MAX_VALUE;\n    for (int i = 0; i < array.length; i++) {\n      int currentValue = array[i];\n      if (currentValue < minValue) {\n        minValue = currentValue;\n        idxAtMinValue = i;\n      }\n    }\n    return idxAtMinValue;\n  }\n\n  public static int distanceBetween(int a, int b) {\n    return Math.abs(a - b);\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(br) time | O(br) space - where b is the number of blocks and r is the\n  // number of requirements\n  public static int apartmentHunting(\n    List<Map<String, Boolean>> blocks, String[] reqs\n  ) {\n    int[][] minDistancesFromBlocks = new int[reqs.length][];\n    for (int i = 0; i < reqs.length; i++) {\n      minDistancesFromBlocks[i] = getMinDistances(blocks, reqs[i]);\n    }\n    int[] maxDistancesAtBlocks =\n      getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks);\n    return getIdxAtMinValue(maxDistancesAtBlocks);\n  }\n\n  public static int[] getMinDistances(\n    List<Map<String, Boolean>> blocks, String req\n  ) {\n    int[] minDistances = new int[blocks.size()];\n    int closestReqIdx = Integer.MAX_VALUE;\n    for (int i = 0; i < blocks.size(); i++) {\n      if (blocks.get(i).get(req)) closestReqIdx = i;\n      minDistances[i] = distanceBetween(i, closestReqIdx);\n    }\n    for (int i = blocks.size() - 1; i >= 0; i--) {\n      if (blocks.get(i).get(req)) closestReqIdx = i;\n      minDistances[i] =\n        Math.min(minDistances[i], distanceBetween(i, closestReqIdx));\n    }\n    return minDistances;\n  }\n\n  public static int[] getMaxDistancesAtBlocks(\n    List<Map<String, Boolean>> blocks, int[][] minDistancesFromBlocks\n  ) {\n    int[] maxDistancesAtBlocks = new int[blocks.size()];\n    for (int i = 0; i < blocks.size(); i++) {\n      int[] minDistancesAtBlock = new int[minDistancesFromBlocks.length];\n      for (int j = 0; j < minDistancesFromBlocks.length; j++) {\n        minDistancesAtBlock[j] = minDistancesFromBlocks[j][i];\n      }\n      maxDistancesAtBlocks[i] = arrayMax(minDistancesAtBlock);\n    }\n    return maxDistancesAtBlocks;\n  }\n\n  public static int getIdxAtMinValue(int[] array) {\n    int idxAtMinValue = 0;\n    int minValue = Integer.MAX_VALUE;\n    for (int i = 0; i < array.length; i++) {\n      int currentValue = array[i];\n      if (currentValue < minValue) {\n        minValue = currentValue;\n        idxAtMinValue = i;\n      }\n    }\n    return idxAtMinValue;\n  }\n\n  public static int distanceBetween(int a, int b) {\n    return Math.abs(a - b);\n  }\n\n  public static int arrayMax(int[] array) {\n    int max = array[0];\n    for (int a : array) {\n      if (a > max) {\n        max = a;\n      }\n    }\n    return max;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<Map<String, Boolean>> blocks = new ArrayList<Map<String, Boolean>>();\n\n    blocks.add(0, new HashMap<String, Boolean>());\n    blocks.get(0).put(\"gym\", false);\n    blocks.get(0).put(\"school\", true);\n    blocks.get(0).put(\"store\", false);\n\n    blocks.add(1, new HashMap<String, Boolean>());\n    blocks.get(1).put(\"gym\", true);\n    blocks.get(1).put(\"school\", false);\n    blocks.get(1).put(\"store\", false);\n\n    blocks.add(2, new HashMap<String, Boolean>());\n    blocks.get(2).put(\"gym\", true);\n    blocks.get(2).put(\"school\", true);\n    blocks.get(2).put(\"store\", false);\n\n    blocks.add(3, new HashMap<String, Boolean>());\n    blocks.get(3).put(\"gym\", false);\n    blocks.get(3).put(\"school\", true);\n    blocks.get(3).put(\"store\", false);\n\n    blocks.add(4, new HashMap<String, Boolean>());\n    blocks.get(4).put(\"gym\", false);\n    blocks.get(4).put(\"school\", true);\n    blocks.get(4).put(\"store\", true);\n\n    String[] reqs = new String[] {\"gym\", \"school\", \"store\"};\n    Utils.assertTrue(Program.apartmentHunting(blocks, reqs) == 3);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<Map<String, Boolean>> blocks = new ArrayList<Map<String, Boolean>>();\n\n    blocks.add(0, new HashMap<String, Boolean>());\n    blocks.get(0).put(\"gym\", false);\n    blocks.get(0).put(\"school\", true);\n    blocks.get(0).put(\"store\", false);\n\n    blocks.add(1, new HashMap<String, Boolean>());\n    blocks.get(1).put(\"gym\", true);\n    blocks.get(1).put(\"school\", false);\n    blocks.get(1).put(\"store\", false);\n\n    blocks.add(2, new HashMap<String, Boolean>());\n    blocks.get(2).put(\"gym\", true);\n    blocks.get(2).put(\"school\", true);\n    blocks.get(2).put(\"store\", false);\n\n    blocks.add(3, new HashMap<String, Boolean>());\n    blocks.get(3).put(\"gym\", false);\n    blocks.get(3).put(\"school\", true);\n    blocks.get(3).put(\"store\", false);\n\n    blocks.add(4, new HashMap<String, Boolean>());\n    blocks.get(4).put(\"gym\", false);\n    blocks.get(4).put(\"school\", true);\n    blocks.get(4).put(\"store\", true);\n\n    String[] reqs = new String[] {\"gym\", \"school\", \"store\"};\n    Utils.assertTrue(Program.apartmentHunting(blocks, reqs) == 3);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function apartmentHunting(blocks, reqs) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.apartmentHunting = apartmentHunting;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(b^2*r) time | O(b) space - where b is the number of blocks and r is the number of requirements\nfunction apartmentHunting(blocks, reqs) {\n  const maxDistancesAtBlocks = new Array(blocks.length).fill(-Infinity);\n  for (let i = 0; i < blocks.length; i++) {\n    for (const req of reqs) {\n      let closestReqDistance = Infinity;\n      for (let j = 0; j < blocks.length; j++) {\n        if (blocks[j][req]) {\n          closestReqDistance = Math.min(closestReqDistance, distanceBetween(i, j));\n        }\n      }\n      maxDistancesAtBlocks[i] = Math.max(maxDistancesAtBlocks[i], closestReqDistance);\n    }\n  }\n  return getIdxAtMinValue(maxDistancesAtBlocks);\n}\n\nfunction getIdxAtMinValue(array) {\n  let idxAtMinValue = 0;\n  let minValue = Infinity;\n  for (let i = 0; i < array.length; i++) {\n    const currentValue = array[i];\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      idxAtMinValue = i;\n    }\n  }\n  return idxAtMinValue;\n}\n\nfunction distanceBetween(a, b) {\n  return Math.abs(a - b);\n}\n\nexports.apartmentHunting = apartmentHunting;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements\nfunction apartmentHunting(blocks, reqs) {\n  const minDistancesFromBlocks = reqs.map(req => getMinDistances(blocks, req));\n  const maxDistancesAtBlocks = getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks);\n  return getIdxAtMinValue(maxDistancesAtBlocks);\n}\n\nfunction getMinDistances(blocks, req) {\n  const minDistances = new Array(blocks.length);\n  let closestReqIdx = Infinity;\n  for (let i = 0; i < blocks.length; i++) {\n    if (blocks[i][req]) closestReqIdx = i;\n    minDistances[i] = distanceBetween(i, closestReqIdx);\n  }\n  for (let i = blocks.length - 1; i >= 0; i--) {\n    if (blocks[i][req]) closestReqIdx = i;\n    minDistances[i] = Math.min(minDistances[i], distanceBetween(i, closestReqIdx));\n  }\n  return minDistances;\n}\n\nfunction getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks) {\n  const maxDistancesAtBlocks = new Array(blocks.length);\n  for (let i = 0; i < blocks.length; i++) {\n    const minDistancesAtBlock = minDistancesFromBlocks.map(distances => distances[i]);\n    maxDistancesAtBlocks[i] = Math.max(...minDistancesAtBlock);\n  }\n  return maxDistancesAtBlocks;\n}\n\nfunction getIdxAtMinValue(array) {\n  let idxAtMinValue = 0;\n  let minValue = Infinity;\n  for (let i = 0; i < array.length; i++) {\n    const currentValue = array[i];\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      idxAtMinValue = i;\n    }\n  }\n  return idxAtMinValue;\n}\n\nfunction distanceBetween(a, b) {\n  return Math.abs(a - b);\n}\n\nexports.apartmentHunting = apartmentHunting;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const blocks = [\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: true,\n      school: false,\n      store: false,\n    },\n    {\n      gym: true,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: true,\n    },\n  ];\n  const reqs = ['gym', 'school', 'store'];\n  chai.expect(program.apartmentHunting(blocks, reqs)).to.deep.equal(3);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const blocks = [\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: true,\n      school: false,\n      store: false,\n    },\n    {\n      gym: true,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: true,\n    },\n  ];\n  const reqs = ['gym', 'school', 'store'];\n  chai.expect(program.apartmentHunting(blocks, reqs)).to.deep.equal(3);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun apartmentHunting(blocks: List<Map<String, Boolean>>, reqs: List<String>): Int {\n    // Write your code here.\n    return -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.min\n\n// O(b^2*r) time | O(b) space - where b is the number of blocks and r is the number of requirements\nfun apartmentHunting(blocks: List<Map<String, Boolean>>, reqs: List<String>): Int {\n    val maxDistancesAtBlocks = MutableList(blocks.size) { Int.MIN_VALUE }\n    for (i in 0 until blocks.size) {\n        for (req in reqs) {\n            var closestReqDistance = Int.MAX_VALUE\n            for (j in 0 until blocks.size) {\n                if (blocks[j].containsKey(req) && blocks[j][req]!!) {\n                    closestReqDistance = min(closestReqDistance, distanceBetween(i, j))\n                }\n            }\n            maxDistancesAtBlocks[i] = max(maxDistancesAtBlocks[i], closestReqDistance)\n        }\n    }\n    return getIdxAtMinValue(maxDistancesAtBlocks)\n}\n\nfun getIdxAtMinValue(array: MutableList<Int>): Int {\n    var idxAtMinValue = 0\n    var minValue = Int.MAX_VALUE\n    for (i in 0 until array.size) {\n        val currentValue = array[i]\n        if (currentValue < minValue) {\n            minValue = currentValue\n            idxAtMinValue = i\n        }\n    }\n    return idxAtMinValue\n}\n\nfun distanceBetween(a: Int, b: Int): Int {\n    return abs(a - b)\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.abs\nimport kotlin.math.min\n\n// O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements\nfun apartmentHunting(blocks: List<Map<String, Boolean>>, reqs: List<String>): Int {\n    val minDistancesFromBlocks = reqs.map { req -> getMinDistances(blocks, req) }\n    val maxDistancesAtBlocks = getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks)\n    return getIdxAtMinValue(maxDistancesAtBlocks)\n}\n\nfun getMinDistances(blocks: List<Map<String, Boolean>>, req: String): List<Int> {\n    val minDistances = MutableList<Int>(blocks.size) { 0 }\n    var closestReqIdx = Int.MAX_VALUE\n    for (i in 0 until blocks.size) {\n        if (blocks[i].containsKey(req) && blocks[i][req]!!) closestReqIdx = i\n        minDistances[i] = distanceBetween(i, closestReqIdx)\n    }\n    for (i in blocks.size - 1 downTo 0) {\n        if (blocks[i].containsKey(req) && blocks[i][req]!!) closestReqIdx = i\n        minDistances[i] = min(minDistances[i], distanceBetween(i, closestReqIdx))\n    }\n    return minDistances\n}\n\nfun getMaxDistancesAtBlocks(blocks: List<Map<String, Boolean>>, minDistancesFromBlocks: List<List<Int>>): List<Int> {\n    val maxDistancesAtBlocks = MutableList<Int>(blocks.size) { 0 }\n    for (i in 0 until blocks.size) {\n        val minDistancesAtBlock = minDistancesFromBlocks.map { distances -> distances[i] }\n        maxDistancesAtBlocks[i] = minDistancesAtBlock.max()!!\n    }\n    return maxDistancesAtBlocks\n}\n\nfun getIdxAtMinValue(array: List<Int>): Int {\n    var idxAtMinValue = 0\n    var minValue = Int.MAX_VALUE\n    for (i in 0 until array.size) {\n        val currentValue = array[i]\n        if (currentValue < minValue) {\n            minValue = currentValue\n            idxAtMinValue = i\n        }\n    }\n    return idxAtMinValue\n}\n\nfun distanceBetween(a: Int, b: Int): Int {\n    return abs(a - b)\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.apartmentHunting as apartmentHunting\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val blocks = listOf<Map<String, Boolean>>(\n            mapOf(\"gym\" to false, \"school\" to true, \"store\" to false),\n            mapOf(\"gym\" to true, \"school\" to false, \"store\" to false),\n            mapOf(\"gym\" to true, \"school\" to true, \"store\" to false),\n            mapOf(\"gym\" to false, \"school\" to true, \"store\" to false),\n            mapOf(\"gym\" to false, \"school\" to true, \"store\" to true),\n        )\n        val reqs = listOf(\"gym\", \"school\", \"store\")\n        println(apartmentHunting(blocks, reqs))\n        assert(apartmentHunting(blocks, reqs) == 3)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.apartmentHunting as apartmentHunting\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val blocks = listOf<Map<String, Boolean>>(\n            mapOf(\"gym\" to false, \"school\" to true, \"store\" to false),\n            mapOf(\"gym\" to true, \"school\" to false, \"store\" to false),\n            mapOf(\"gym\" to true, \"school\" to true, \"store\" to false),\n            mapOf(\"gym\" to false, \"school\" to true, \"store\" to false),\n            mapOf(\"gym\" to false, \"school\" to true, \"store\" to true),\n        )\n        val reqs = listOf(\"gym\", \"school\", \"store\")\n        println(apartmentHunting(blocks, reqs))\n        assert(apartmentHunting(blocks, reqs) == 3)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def apartmentHunting(blocks, reqs):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(b^2*r) time | O(b) space - where b is the number of blocks and r is the number of requirements\ndef apartmentHunting(blocks, reqs):\n    maxDistancesAtBlocks = [float(\"-inf\") for block in blocks]\n    for i in range(len(blocks)):\n        for req in reqs:\n            closestReqDistance = float(\"inf\")\n            for j in range(len(blocks)):\n                if blocks[j][req]:\n                    closestReqDistance = min(closestReqDistance, distanceBetween(i, j))\n            maxDistancesAtBlocks[i] = max(maxDistancesAtBlocks[i], closestReqDistance)\n    return getIdxAtMinValue(maxDistancesAtBlocks)\n\n\ndef getIdxAtMinValue(array):\n    idxAtMinValue = 0\n    minValue = float(\"inf\")\n    for i in range(len(array)):\n        currentValue = array[i]\n        if currentValue < minValue:\n            minValue = currentValue\n            idxAtMinValue = i\n    return idxAtMinValue\n\n\ndef distanceBetween(a, b):\n    return abs(a - b)\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements\ndef apartmentHunting(blocks, reqs):\n    minDistancesFromBlocks = list(map(lambda req: getMinDistances(blocks, req), reqs))\n    maxDistancesAtBlocks = getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks)\n    return getIdxAtMinValue(maxDistancesAtBlocks)\n\n\ndef getMinDistances(blocks, req):\n    minDistances = [0 for block in blocks]\n    closestReqIdx = float(\"inf\")\n    for i in range(len(blocks)):\n        if blocks[i][req]:\n            closestReqIdx = i\n        minDistances[i] = distanceBetween(i, closestReqIdx)\n    for i in reversed(range(len(blocks))):\n        if blocks[i][req]:\n            closestReqIdx = i\n        minDistances[i] = min(minDistances[i], distanceBetween(i, closestReqIdx))\n    return minDistances\n\n\ndef getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks):\n    maxDistancesAtBlocks = [0 for block in blocks]\n    for i in range(len(blocks)):\n        minDistancesAtBlock = list(map(lambda distances: distances[i], minDistancesFromBlocks))\n        maxDistancesAtBlocks[i] = max(minDistancesAtBlock)\n    return maxDistancesAtBlocks\n\n\ndef getIdxAtMinValue(array):\n    idxAtMinValue = 0\n    minValue = float(\"inf\")\n    for i in range(len(array)):\n        currentValue = array[i]\n        if currentValue < minValue:\n            minValue = currentValue\n            idxAtMinValue = i\n    return idxAtMinValue\n\n\ndef distanceBetween(a, b):\n    return abs(a - b)\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        blocks = [\n            {\"gym\": False, \"school\": True, \"store\": False},\n            {\"gym\": True, \"school\": False, \"store\": False},\n            {\"gym\": True, \"school\": True, \"store\": False},\n            {\"gym\": False, \"school\": True, \"store\": False},\n            {\"gym\": False, \"school\": True, \"store\": True},\n        ]\n        reqs = [\"gym\", \"school\", \"store\"]\n        self.assertEqual(program.apartmentHunting(blocks, reqs), 3)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        blocks = [\n            {\"gym\": False, \"school\": True, \"store\": False},\n            {\"gym\": True, \"school\": False, \"store\": False},\n            {\"gym\": True, \"school\": True, \"store\": False},\n            {\"gym\": False, \"school\": True, \"store\": False},\n            {\"gym\": False, \"school\": True, \"store\": True},\n        ]\n        reqs = [\"gym\", \"school\", \"store\"]\n        self.assertEqual(program.apartmentHunting(blocks, reqs), 3)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func apartmentHunting(_ blocks: [[String: Bool]], _ requirements: [String]) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(b^2 * r) time | O(b) space\n  func apartmentHunting(_ blocks: [[String: Bool]], _ requirements: [String]) -> Int {\n    var maxDistancesAtBlocks = Array(repeating: -Int.max, count: blocks.count)\n    for i in 0 ..< blocks.count {\n      for requirement in requirements {\n        var closestReqDistance = Int.max\n\n        for j in 0 ..< blocks.count {\n          if let requirementAvailable = blocks[j][requirement], requirementAvailable {\n            closestReqDistance = min(closestReqDistance, distanceBetween(i, j))\n          }\n        }\n\n        maxDistancesAtBlocks[i] = max(maxDistancesAtBlocks[i], closestReqDistance)\n      }\n    }\n\n    return getIndexAtMinValue(maxDistancesAtBlocks)\n  }\n\n  func getIndexAtMinValue(_ array: [Int]) -> Int {\n    var indexAtMinValue = 0\n    var minValue = Int.max\n\n    for i in 0 ..< array.count {\n      let currentValue = array[i]\n\n      if currentValue < minValue {\n        minValue = currentValue\n        indexAtMinValue = i\n      }\n    }\n\n    return indexAtMinValue\n  }\n\n  func distanceBetween(_ a: Int, _ b: Int) -> Int {\n    return abs(a - b)\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements\n  func apartmentHunting(_ blocks: [[String: Bool]], _ requirements: [String]) -> Int {\n    let minDistancesFromBlocks = requirements.map { getMinDistances(blocks, $0) }\n    let maxDistancesAtBlocks = getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks)\n\n    return getIndexAtMinValue(maxDistancesAtBlocks)\n  }\n\n  func getMinDistances(_ blocks: [[String: Bool]], _ requirement: String) -> [Int] {\n    var minDistances = Array(repeating: -1, count: blocks.count)\n    var closestRequirementIndex = Int.max\n\n    for i in 0 ..< blocks.count {\n      if let requirementAvailable = blocks[i][requirement], requirementAvailable {\n        closestRequirementIndex = i\n      }\n\n      minDistances[i] = distanceBetween(i, closestRequirementIndex)\n    }\n\n    for i in (0 ..< blocks.count).reversed() {\n      if let requirementAvailable = blocks[i][requirement], requirementAvailable {\n        closestRequirementIndex = i\n      }\n\n      minDistances[i] = min(minDistances[i], distanceBetween(i, closestRequirementIndex))\n    }\n\n    return minDistances\n  }\n\n  func getMaxDistancesAtBlocks(_ blocks: [[String: Bool]], _ minDistancesFromBlocks: [[Int]]) -> [Int] {\n    var maxDistancesAtBlocks = Array(repeating: -1, count: blocks.count)\n\n    for i in 0 ..< blocks.count {\n      let minDistancesAtBlock = minDistancesFromBlocks.map { $0[i] }\n\n      if let max = minDistancesAtBlock.max() {\n        maxDistancesAtBlocks[i] = max\n      }\n    }\n\n    return maxDistancesAtBlocks\n  }\n\n  func getIndexAtMinValue(_ array: [Int]) -> Int {\n    var indexAtMinValue = 0\n    var minValue = Int.max\n\n    for i in 0 ..< array.count {\n      let currentValue = array[i]\n\n      if currentValue < minValue {\n        minValue = currentValue\n        indexAtMinValue = i\n      }\n    }\n\n    return indexAtMinValue\n  }\n\n  func distanceBetween(_ a: Int, _ b: Int) -> Int {\n    return abs(a - b)\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws in\n      let requirements = [\"gym\", \"school\", \"store\"]\n      let blocks = [\n        [\n          \"gym\": false,\n          \"school\": true,\n          \"store\": false,\n        ],\n        [\n          \"gym\": true,\n          \"school\": false,\n          \"store\": false,\n        ],\n        [\n          \"gym\": true,\n          \"school\": true,\n          \"store\": false,\n        ],\n        [\n          \"gym\": false,\n          \"school\": true,\n          \"store\": false,\n        ],\n        [\n          \"gym\": false,\n          \"school\": true,\n          \"store\": true,\n        ],\n      ]\n\n      try assertEqual(3, program.apartmentHunting(blocks, requirements))\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws in\n      let requirements = [\"gym\", \"school\", \"store\"]\n      let blocks = [\n        [\n          \"gym\": false,\n          \"school\": true,\n          \"store\": false,\n        ],\n        [\n          \"gym\": true,\n          \"school\": false,\n          \"store\": false,\n        ],\n        [\n          \"gym\": true,\n          \"school\": true,\n          \"store\": false,\n        ],\n        [\n          \"gym\": false,\n          \"school\": true,\n          \"store\": false,\n        ],\n        [\n          \"gym\": false,\n          \"school\": true,\n          \"store\": true,\n        ],\n      ]\n\n      try assertEqual(3, program.apartmentHunting(blocks, requirements))\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "interface Block {\n  [key: string]: boolean;\n}\n\nexport function apartmentHunting(blocks: Block[], reqs: string[]) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\ninterface Block {\n  [key: string]: boolean;\n}\n\n// O(b^2*r) time | O(b) space - where b is the number of blocks and r is the number of requirements\nexport function apartmentHunting(blocks: Block[], reqs: string[]) {\n  const maxDistancesAtBlocks = new Array(blocks.length).fill(-Infinity);\n  for (let i = 0; i < blocks.length; i++) {\n    for (const req of reqs) {\n      let closestReqDistance = Infinity;\n      for (let j = 0; j < blocks.length; j++) {\n        if (blocks[j][req]) {\n          closestReqDistance = Math.min(closestReqDistance, distanceBetween(i, j));\n        }\n      }\n      maxDistancesAtBlocks[i] = Math.max(maxDistancesAtBlocks[i], closestReqDistance);\n    }\n  }\n  return getIdxAtMinValue(maxDistancesAtBlocks);\n}\n\nfunction getIdxAtMinValue(array: number[]) {\n  let idxAtMinValue = 0;\n  let minValue = Infinity;\n  for (let i = 0; i < array.length; i++) {\n    const currentValue = array[i];\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      idxAtMinValue = i;\n    }\n  }\n  return idxAtMinValue;\n}\n\nfunction distanceBetween(a: number, b: number) {\n  return Math.abs(a - b);\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\ninterface Block {\n  [key: string]: boolean;\n}\n\n// O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements\nexport function apartmentHunting(blocks: Block[], reqs: string[]) {\n  const minDistancesFromBlocks = reqs.map(req => getMinDistances(blocks, req));\n  const maxDistancesAtBlocks = getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks);\n  return getIdxAtMinValue(maxDistancesAtBlocks);\n}\n\nfunction getMinDistances(blocks: Block[], req: string) {\n  const minDistances: number[] = new Array(blocks.length);\n  let closestReqIdx = Infinity;\n  for (let i = 0; i < blocks.length; i++) {\n    if (blocks[i][req]) closestReqIdx = i;\n    minDistances[i] = distanceBetween(i, closestReqIdx);\n  }\n  for (let i = blocks.length - 1; i >= 0; i--) {\n    if (blocks[i][req]) closestReqIdx = i;\n    minDistances[i] = Math.min(minDistances[i], distanceBetween(i, closestReqIdx));\n  }\n  return minDistances;\n}\n\nfunction getMaxDistancesAtBlocks(blocks: Block[], minDistancesFromBlocks: number[][]) {\n  const maxDistancesAtBlocks: number[] = new Array(blocks.length);\n  for (let i = 0; i < blocks.length; i++) {\n    const minDistancesAtBlock = minDistancesFromBlocks.map(distances => distances[i]);\n    maxDistancesAtBlocks[i] = Math.max(...minDistancesAtBlock);\n  }\n  return maxDistancesAtBlocks;\n}\n\nfunction getIdxAtMinValue(array: number[]) {\n  let idxAtMinValue = 0;\n  let minValue = Infinity;\n  for (let i = 0; i < array.length; i++) {\n    const currentValue = array[i];\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      idxAtMinValue = i;\n    }\n  }\n  return idxAtMinValue;\n}\n\nfunction distanceBetween(a: number, b: number) {\n  return Math.abs(a - b);\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const blocks = [\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: true,\n      school: false,\n      store: false,\n    },\n    {\n      gym: true,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: true,\n    },\n  ];\n  const reqs = ['gym', 'school', 'store'];\n  chai.expect(program.apartmentHunting(blocks, reqs)).to.deep.equal(3);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const blocks = [\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: true,\n      school: false,\n      store: false,\n    },\n    {\n      gym: true,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: true,\n    },\n  ];\n  const reqs = ['gym', 'school', 'store'];\n  chai.expect(program.apartmentHunting(blocks, reqs)).to.deep.equal(3);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "blocks",
      "example": [
        {
          "gym": false,
          "school": true,
          "store": false
        },
        {
          "gym": true,
          "school": false,
          "store": false
        },
        {
          "gym": true,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "school": true,
          "store": true
        }
      ],
      "schema": {
        "items": {
          "additionalProperties": {
            "type": "boolean"
          },
          "type": "object"
        },
        "type": "array"
      }
    },
    {
      "name": "reqs",
      "example": [
        "gym",
        "school",
        "store"
      ],
      "schema": {
        "items": {
          "type": "string"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "blocks": [
        {
          "gym": false,
          "school": true,
          "store": false
        },
        {
          "gym": true,
          "school": false,
          "store": false
        },
        {
          "gym": true,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "school": true,
          "store": true
        }
      ],
      "reqs": [
        "gym",
        "school",
        "store"
      ]
    },
    {
      "blocks": [
        {
          "gym": false,
          "office": true,
          "school": true,
          "store": false
        },
        {
          "gym": true,
          "office": false,
          "school": false,
          "store": false
        },
        {
          "gym": true,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "school": true,
          "store": true
        }
      ],
      "reqs": [
        "gym",
        "office",
        "school",
        "store"
      ]
    },
    {
      "blocks": [
        {
          "gym": false,
          "office": true,
          "school": true,
          "store": false
        },
        {
          "gym": true,
          "office": false,
          "school": false,
          "store": false
        },
        {
          "gym": true,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "school": true,
          "store": true
        }
      ],
      "reqs": [
        "gym",
        "office",
        "school",
        "store"
      ]
    },
    {
      "blocks": [
        {
          "foo": true,
          "gym": false,
          "kappa": false,
          "office": true,
          "school": true,
          "store": false
        },
        {
          "foo": true,
          "gym": true,
          "kappa": false,
          "office": false,
          "school": false,
          "store": false
        },
        {
          "foo": true,
          "gym": true,
          "kappa": false,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "foo": true,
          "gym": false,
          "kappa": false,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "foo": true,
          "gym": true,
          "kappa": false,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "foo": true,
          "gym": false,
          "kappa": false,
          "office": false,
          "school": true,
          "store": true
        }
      ],
      "reqs": [
        "gym",
        "school",
        "store"
      ]
    },
    {
      "blocks": [
        {
          "gym": true,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "school": false,
          "store": true
        },
        {
          "gym": true,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "school": true,
          "store": false
        }
      ],
      "reqs": [
        "gym",
        "school",
        "store"
      ]
    },
    {
      "blocks": [
        {
          "gym": true,
          "pool": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": false,
          "store": true
        },
        {
          "gym": true,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "pool": true,
          "school": false,
          "store": false
        }
      ],
      "reqs": [
        "gym",
        "pool",
        "school",
        "store"
      ]
    },
    {
      "blocks": [
        {
          "gym": true,
          "office": false,
          "pool": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "office": true,
          "pool": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": true,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "pool": false,
          "school": false,
          "store": true
        },
        {
          "gym": true,
          "office": true,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "pool": true,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "pool": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "pool": true,
          "school": false,
          "store": false
        }
      ],
      "reqs": [
        "gym",
        "pool",
        "school",
        "store"
      ]
    }
  ],
  "jsonTests": [
    {
      "blocks": [
        {
          "gym": false,
          "school": true,
          "store": false
        },
        {
          "gym": true,
          "school": false,
          "store": false
        },
        {
          "gym": true,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "school": true,
          "store": true
        }
      ],
      "reqs": [
        "gym",
        "school",
        "store"
      ]
    },
    {
      "blocks": [
        {
          "gym": false,
          "office": true,
          "school": true,
          "store": false
        },
        {
          "gym": true,
          "office": false,
          "school": false,
          "store": false
        },
        {
          "gym": true,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "school": true,
          "store": true
        }
      ],
      "reqs": [
        "gym",
        "office",
        "school",
        "store"
      ]
    },
    {
      "blocks": [
        {
          "gym": false,
          "office": true,
          "school": true,
          "store": false
        },
        {
          "gym": true,
          "office": false,
          "school": false,
          "store": false
        },
        {
          "gym": true,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "school": true,
          "store": true
        }
      ],
      "reqs": [
        "gym",
        "office",
        "school",
        "store"
      ]
    },
    {
      "blocks": [
        {
          "foo": true,
          "gym": false,
          "kappa": false,
          "office": true,
          "school": true,
          "store": false
        },
        {
          "foo": true,
          "gym": true,
          "kappa": false,
          "office": false,
          "school": false,
          "store": false
        },
        {
          "foo": true,
          "gym": true,
          "kappa": false,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "foo": true,
          "gym": false,
          "kappa": false,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "foo": true,
          "gym": true,
          "kappa": false,
          "office": false,
          "school": true,
          "store": false
        },
        {
          "foo": true,
          "gym": false,
          "kappa": false,
          "office": false,
          "school": true,
          "store": true
        }
      ],
      "reqs": [
        "gym",
        "school",
        "store"
      ]
    },
    {
      "blocks": [
        {
          "gym": true,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "school": false,
          "store": true
        },
        {
          "gym": true,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "school": true,
          "store": false
        }
      ],
      "reqs": [
        "gym",
        "school",
        "store"
      ]
    },
    {
      "blocks": [
        {
          "gym": true,
          "pool": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": false,
          "store": true
        },
        {
          "gym": true,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "pool": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "pool": true,
          "school": false,
          "store": false
        }
      ],
      "reqs": [
        "gym",
        "pool",
        "school",
        "store"
      ]
    },
    {
      "blocks": [
        {
          "gym": true,
          "office": false,
          "pool": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "office": true,
          "pool": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": true,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "pool": false,
          "school": false,
          "store": true
        },
        {
          "gym": true,
          "office": true,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "pool": true,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "pool": false,
          "school": false,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "pool": false,
          "school": true,
          "store": false
        },
        {
          "gym": false,
          "office": false,
          "pool": true,
          "school": false,
          "store": false
        }
      ],
      "reqs": [
        "gym",
        "pool",
        "school",
        "store"
      ]
    }
  ],
  "changelog": []
}