{
  "uid": "bst-construction",
  "testStrategy": "JSON",
  "name": "BST Construction",
  "version": 0,
  "releaseDate": "2000-05-04T00:00:00Z",
  "category": "Binary Search Trees",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 28911,
    "failureCount": 24596
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "228491674",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1707
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a <span>BST</span> class for a Binary Search Tree. The class should\n  support:\n</p>\n<ul>\n  <li>Inserting values with the <span>insert</span> method.</li>\n  <li>\n    Removing values with the <span>remove</span> method; this method should\n    only remove the first instance of a given value.\n  </li>\n  <li>Searching for values with the <span>contains</span> method.</li>\n</ul>\n<p>\n  Note that you can't remove values from a single-node tree. In other words,\n  calling the <span>remove</span> method on a single-node tree should simply not\n  do anything.\n</p>\n<p>\n  Each <span>BST</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. A node is\n  said to be a valid <span>BST</span> node if and only if it satisfies the BST\n  property: its <span>value</span> is strictly greater than the values of every\n  node to its left; its <span>value</span> is less than or equal to the values\n  of every node to its right; and its children nodes are either valid\n  <span>BST</span> nodes themselves or <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Usage</h3>\n<pre>\n<span class=\"CodeEditor-promptComment\">// Assume the following BST has already been created:</span>\n         10\n       /     \\\n      5      15\n    /   \\   /   \\\n   2     5 13   22\n /           \\\n1            14\n\n<span class=\"CodeEditor-promptComment\">// All operations below are performed sequentially.</span>\n<span class=\"CodeEditor-promptParameter\">insert</span>(12):   10\n            /     \\\n           5      15\n         /   \\   /   \\\n        2     5 13   22\n      /        /  \\\n     1        12  14\n\n<span class=\"CodeEditor-promptParameter\">remove</span>(10):   12\n            /     \\\n           5      15\n         /   \\   /   \\\n        2     5 13   22\n      /           \\\n     1            14\n\n<span class=\"CodeEditor-promptParameter\">contains</span>(15): true\n</pre>\n</div>",
  "hints": [
    "<p>\nAs you try to insert, find, or a remove a value into, in, or from a BST, you will have to traverse the tree's nodes. The BST property allows you to eliminate half of the remaining tree at each node that you traverse: if the target value is strictly smaller than a node's value, then it must be (or can only be) located to the left of the node, otherwise it must be (or can only be) to the right of that node.\n</p>\n",
    "\n<p>\nTraverse the BST all the while applying the logic described in Hint #1. For insertion, add the target value to the BST once you reach a leaf (None / null) node. For searching, if you reach a leaf node without having found the target value that means the value isn't in the BST. For removal, consider the various cases that you might encounter: the node you need to remove might have two children nodes, one, or none; it might also be the root node; make sure to account for all of these cases.\n</p>\n",
    "\n<p>\nWhat are the advantages and disadvantages of implementing these methods iteratively as opposed to recursively?\n</p>"
  ],
  "spaceTime": "Average (all 3 methods): O(log(n)) time | O(1) space - where n is the number of nodes in the BST\nWorst (all 3 methods): O(n) time | O(1) space - where n is the number of nodes in the BST",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": true,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\n// Do not edit the class below except for\n// the insert, contains, and remove methods.\n// Feel free to add new properties and methods\n// to the class.\nclass BST {\n public:\n  int value;\n  BST* left;\n  BST* right;\n\n  BST(int val) {\n    value = val;\n    left = nullptr;\n    right = nullptr;\n  }\n\n  BST& insert(int val) {\n    // Write your code here.\n    // Do not edit the return statement of this method.\n    return *this;\n  }\n\n  bool contains(int val) {\n    // Write your code here.\n    return false;\n  }\n\n  BST& remove(int val) {\n    // Write your code here.\n    // Do not edit the return statement of this method.\n    return *this;\n  }\n};\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nclass BST {\n public:\n  int value;\n  BST* left;\n  BST* right;\n\n  BST(int val) {\n    value = val;\n    left = nullptr;\n    right = nullptr;\n  }\n\n  // Average: O(log(n)) time | O(log(n)) space\n  // Worst: O(n) time | O(n) space\n  BST& insert(int val) {\n    if (val < value) {\n      if (left == nullptr) {\n        BST* newBST = new BST(val);\n        left = newBST;\n      } else {\n        left->insert(val);\n      }\n    } else {\n      if (right == nullptr) {\n        BST* newBST = new BST(val);\n        right = newBST;\n      } else {\n        right->insert(val);\n      }\n    }\n    return *this;\n  }\n\n  // Average: O(log(n)) time | O(log(n)) space\n  // Worst: O(n) time | O(n) space\n  bool contains(int val) {\n    if (val < value) {\n      if (left == nullptr) {\n        return false;\n      } else {\n        return left->contains(val);\n      }\n    } else if (val > value) {\n      if (right == nullptr) {\n        return false;\n      } else {\n        return right->contains(val);\n      }\n    } else {\n      return true;\n    }\n  }\n\n  // Average: O(log(n)) time | O(log(n)) space\n  // Worst: O(n) time | O(n) space\n  BST& remove(int val, BST* parent = nullptr) {\n    if (val < value) {\n      if (left != nullptr) {\n        left->remove(val, this);\n      }\n    } else if (val > value) {\n      if (right != nullptr) {\n        right->remove(val, this);\n      }\n    } else {\n      if (left != nullptr && right != nullptr) {\n        value = right->getMinValue();\n        right->remove(value, this);\n      } else if (parent == nullptr) {\n        if (left != nullptr) {\n          value = left->value;\n          right = left->right;\n          left = left->left;\n        } else if (right != nullptr) {\n          value = right->value;\n          left = right->left;\n          right = right->right;\n        } else {\n          // This is a single-node tree; do nothing.\n        }\n      } else if (parent->left == this) {\n        parent->left = left != nullptr ? left : right;\n      } else if (parent->right == this) {\n        parent->right = left != nullptr ? left : right;\n      }\n    }\n    return *this;\n  }\n\n  int getMinValue() {\n    if (left == nullptr) {\n      return value;\n    } else {\n      return left->getMinValue();\n    }\n  }\n};\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nclass BST {\n public:\n  int value;\n  BST* left;\n  BST* right;\n\n  BST(int val) {\n    value = val;\n    left = nullptr;\n    right = nullptr;\n  }\n\n  // Average: O(log(n)) time | O(1) space\n  // Worst: O(n) time | O(1) space\n  BST& insert(int val) {\n    BST* currentNode = this;\n    while (true) {\n      if (val < currentNode->value) {\n        if (currentNode->left == nullptr) {\n          BST* newNode = new BST(val);\n          currentNode->left = newNode;\n          break;\n        } else {\n          currentNode = currentNode->left;\n        }\n      } else {\n        if (currentNode->right == nullptr) {\n          BST* newNode = new BST(val);\n          currentNode->right = newNode;\n          break;\n        } else {\n          currentNode = currentNode->right;\n        }\n      }\n    }\n    return *this;\n  }\n\n  // Average: O(log(n)) time | O(1) space\n  // Worst: O(n) time | O(1) space\n  bool contains(int val) {\n    BST* currentNode = this;\n    while (currentNode != nullptr) {\n      if (val < currentNode->value) {\n        currentNode = currentNode->left;\n      } else if (val > currentNode->value) {\n        currentNode = currentNode->right;\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Average: O(log(n)) time | O(1) space\n  // Worst: O(n) time | O(1) space\n  BST& remove(int val, BST* parentNode = nullptr) {\n    BST* currentNode = this;\n    while (currentNode != nullptr) {\n      if (val < currentNode->value) {\n        parentNode = currentNode;\n        currentNode = currentNode->left;\n      } else if (val > currentNode->value) {\n        parentNode = currentNode;\n        currentNode = currentNode->right;\n      } else {\n        if (currentNode->left != nullptr && currentNode->right != nullptr) {\n          currentNode->value = currentNode->right->getMinValue();\n          currentNode->right->remove(currentNode->value, currentNode);\n        } else if (parentNode == nullptr) {\n          if (currentNode->left != nullptr) {\n            currentNode->value = currentNode->left->value;\n            currentNode->right = currentNode->left->right;\n            currentNode->left = currentNode->left->left;\n          } else if (currentNode->right != nullptr) {\n            currentNode->value = currentNode->right->value;\n            currentNode->left = currentNode->right->left;\n            currentNode->right = currentNode->right->right;\n          } else {\n            // This is a single-node tree; do nothing.\n          }\n        } else if (parentNode->left == currentNode) {\n          parentNode->left = currentNode->left != nullptr ? currentNode->left\n                                                          : currentNode->right;\n        } else if (parentNode->right == currentNode) {\n          parentNode->right = currentNode->left != nullptr ? currentNode->left\n                                                           : currentNode->right;\n        }\n        break;\n      }\n    }\n    return *this;\n  }\n\n  int getMinValue() {\n    if (left == nullptr) {\n      return value;\n    } else {\n      return left->getMinValue();\n    }\n  }\n};\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BST* root = new BST(10);\n      root->left = new BST(5);\n      root->left->left = new BST(2);\n      root->left->left->left = new BST(1);\n      root->left->right = new BST(5);\n      root->right = new BST(15);\n      root->right->left = new BST(13);\n      root->right->left->right = new BST(14);\n      root->right->right = new BST(22);\n\n      root->insert(12);\n      assert(root->right->left->left->value == 12);\n\n      root->remove(10);\n      assert(root->contains(10) == false);\n      assert(root->value == 12);\n\n      assert(root->contains(15));\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BST* root = new BST(10);\n      root->left = new BST(5);\n      root->left->left = new BST(2);\n      root->left->left->left = new BST(1);\n      root->left->right = new BST(5);\n      root->right = new BST(15);\n      root->right->left = new BST(13);\n      root->right->left->right = new BST(14);\n      root->right->right = new BST(22);\n\n      root->insert(12);\n      assert(root->right->left->left->value == 12);\n\n      root->remove(10);\n      assert(root->contains(10) == false);\n      assert(root->value == 12);\n\n      assert(root->contains(15));\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public class BST {\n    public int value;\n    public BST left;\n    public BST right;\n\n    public BST(int value) {\n      this.value = value;\n    }\n\n    public BST Insert(int value) {\n      // Write your code here.\n      // Do not edit the return statement of this method.\n      return this;\n    }\n\n    public bool Contains(int value) {\n      // Write your code here.\n      return false;\n    }\n\n    public BST Remove(int value) {\n      // Write your code here.\n      // Do not edit the return statement of this method.\n      return this;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n  public class BST {\n    public int value;\n    public BST left;\n    public BST right;\n\n    public BST(int value) {\n      this.value = value;\n    }\n\n    // Average: O(log(n)) time | O(log(n)) space\n    // Worst: O(n) time | O(n) space\n    public BST Insert(int value) {\n      if (value < this.value) {\n        if (left == null) {\n          BST newBST = new BST(value);\n          left = newBST;\n        } else {\n          left.Insert(value);\n        }\n      } else {\n        if (right == null) {\n          BST newBST = new BST(value);\n          right = newBST;\n        } else {\n          right.Insert(value);\n        }\n      }\n      return this;\n    }\n\n    // Average: O(log(n)) time | O(log(n)) space\n    // Worst: O(n) time | O(n) space\n    public bool Contains(int value) {\n      if (value < this.value) {\n        if (left == null) {\n          return false;\n        } else {\n          return left.Contains(value);\n        }\n      } else if (value > this.value) {\n        if (right == null) {\n          return false;\n        } else {\n          return right.Contains(value);\n        }\n      } else {\n        return true;\n      }\n    }\n\n    // Average: O(log(n)) time | O(log(n)) space\n    // Worst: O(n) time | O(n) space\n    public BST Remove(int value) {\n      Remove(value, null);\n      return this;\n    }\n\n    public void Remove(int value, BST parent) {\n      if (value < this.value) {\n        if (left != null) {\n          left.Remove(value, this);\n        }\n      } else if (value > this.value) {\n        if (right != null) {\n          right.Remove(value, this);\n        }\n      } else {\n        if (left != null && right != null) {\n          this.value = right.getMinValue();\n          right.Remove(this.value, this);\n        } else if (parent == null) {\n          if (left != null) {\n            this.value = left.value;\n            right = left.right;\n            left = left.left;\n          } else if (right != null) {\n            this.value = right.value;\n            left = right.left;\n            right = right.right;\n          } else {\n            // This is a single-node tree; do nothing.\n          }\n        } else if (parent.left == this) {\n          parent.left = left != null ? left : right;\n        } else if (parent.right == this) {\n          parent.right = left != null ? left : right;\n        }\n      }\n    }\n\n    public int getMinValue() {\n      if (left == null) {\n        return this.value;\n      } else {\n        return left.getMinValue();\n      }\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n  public class BST {\n    public int value;\n    public BST left;\n    public BST right;\n\n    public BST(int value) {\n      this.value = value;\n    }\n\n    // Average: O(log(n)) time | O(1) space\n    // Worst: O(n) time | O(1) space\n    public BST Insert(int value) {\n      BST currentNode = this;\n      while (true) {\n        if (value < currentNode.value) {\n          if (currentNode.left == null) {\n            BST newNode = new BST(value);\n            currentNode.left = newNode;\n            break;\n          } else {\n            currentNode = currentNode.left;\n          }\n        } else {\n          if (currentNode.right == null) {\n            BST newNode = new BST(value);\n            currentNode.right = newNode;\n            break;\n          } else {\n            currentNode = currentNode.right;\n          }\n        }\n      }\n      return this;\n    }\n\n    // Average: O(log(n)) time | O(1) space\n    // Worst: O(n) time | O(1) space\n    public bool Contains(int value) {\n      BST currentNode = this;\n      while (currentNode != null) {\n        if (value < currentNode.value) {\n          currentNode = currentNode.left;\n        } else if (value > currentNode.value) {\n          currentNode = currentNode.right;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    // Average: O(log(n)) time | O(1) space\n    // Worst: O(n) time | O(1) space\n    public BST Remove(int value) {\n      Remove(value, null);\n      return this;\n    }\n\n    public void Remove(int value, BST parentNode) {\n      BST currentNode = this;\n      while (currentNode != null) {\n        if (value < currentNode.value) {\n          parentNode = currentNode;\n          currentNode = currentNode.left;\n        } else if (value > currentNode.value) {\n          parentNode = currentNode;\n          currentNode = currentNode.right;\n        } else {\n          if (currentNode.left != null && currentNode.right != null) {\n            currentNode.value = currentNode.right.getMinValue();\n            currentNode.right.Remove(currentNode.value, currentNode);\n          } else if (parentNode == null) {\n            if (currentNode.left != null) {\n              currentNode.value = currentNode.left.value;\n              currentNode.right = currentNode.left.right;\n              currentNode.left = currentNode.left.left;\n            } else if (currentNode.right != null) {\n              currentNode.value = currentNode.right.value;\n              currentNode.left = currentNode.right.left;\n              currentNode.right = currentNode.right.right;\n            } else {\n              // This is a single-node tree; do nothing.\n            }\n          } else if (parentNode.left == currentNode) {\n            parentNode.left =\n              currentNode.left != null ? currentNode.left : currentNode.right;\n          } else if (parentNode.right == currentNode) {\n            parentNode.right =\n              currentNode.left != null ? currentNode.left : currentNode.right;\n          }\n          break;\n        }\n      }\n    }\n\n    public int getMinValue() {\n      if (left == null) {\n        return value;\n      } else {\n        return left.getMinValue();\n      }\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var root = new Program.BST(10);\n    root.left = new Program.BST(5);\n    root.left.left = new Program.BST(2);\n    root.left.left.left = new Program.BST(1);\n    root.left.right = new Program.BST(5);\n    root.right = new Program.BST(15);\n    root.right.left = new Program.BST(13);\n    root.right.left.right = new Program.BST(14);\n    root.right.right = new Program.BST(22);\n\n    root.Insert(12);\n    Utils.AssertTrue(root.right.left.left.value == 12);\n\n    root.Remove(10);\n    Utils.AssertTrue(root.Contains(10) == false);\n    Utils.AssertTrue(root.value == 12);\n\n    Utils.AssertTrue(root.Contains(15));\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var root = new Program.BST(10);\n    root.left = new Program.BST(5);\n    root.left.left = new Program.BST(2);\n    root.left.left.left = new Program.BST(1);\n    root.left.right = new Program.BST(5);\n    root.right = new Program.BST(15);\n    root.right.left = new Program.BST(13);\n    root.right.left.right = new Program.BST(14);\n    root.right.right = new Program.BST(22);\n\n    root.Insert(12);\n    Utils.AssertTrue(root.right.left.left.value == 12);\n\n    root.Remove(10);\n    Utils.AssertTrue(root.Contains(10) == false);\n    Utils.AssertTrue(root.value == 12);\n\n    Utils.AssertTrue(root.Contains(15));\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// Do not edit the class below except for\n// the insert, contains, and remove methods.\n// Feel free to add new properties and methods\n// to the class.\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\nfunc (tree *BST) Insert(value int) *BST {\n\t// Write your code here.\n\t// Do not edit the return statement of this method.\n\treturn tree\n}\n\nfunc (tree *BST) Contains(value int) bool {\n\t// Write your code here.\n\treturn false\n}\n\nfunc (tree *BST) Remove(value int) *BST {\n\t// Write your code here.\n\t// Do not edit the return statement of this method.\n\treturn tree\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\n// Average: O(log(n)) time | O(log(n)) space\n// Worst: O(n) time | O(n) space\nfunc (tree *BST) Insert(value int) *BST {\n\tif value < tree.Value {\n\t\tif tree.Left == nil {\n\t\t\ttree.Left = &BST{Value: value}\n\t\t} else {\n\t\t\ttree.Left.Insert(value)\n\t\t}\n\t} else {\n\t\tif tree.Right == nil {\n\t\t\ttree.Right = &BST{Value: value}\n\t\t} else {\n\t\t\ttree.Right.Insert(value)\n\t\t}\n\t}\n\treturn tree\n}\n\n// Average: O(log(n)) time | O(log(n)) space\n// Worst: O(n) time | O(n) space\nfunc (tree *BST) Contains(value int) bool {\n\tif value < tree.Value {\n\t\tif tree.Left == nil {\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn tree.Left.Contains(value)\n\t\t}\n\t} else if value > tree.Value {\n\t\tif tree.Right == nil {\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn tree.Right.Contains(value)\n\t\t}\n\t}\n\treturn true\n}\n\n// Average: O(log(n)) time | O(log(n)) space\n// Worst: O(n) time | O(n) space\nfunc (tree *BST) Remove(value int) *BST {\n\ttree.remove(value, nil)\n\treturn tree\n}\n\nfunc (tree *BST) remove(value int, parent *BST) {\n\tif value < tree.Value {\n\t\tif tree.Left != nil {\n\t\t\ttree.Left.remove(value, tree)\n\t\t}\n\t} else if value > tree.Value {\n\t\tif tree.Right != nil {\n\t\t\ttree.Right.remove(value, tree)\n\t\t}\n\t} else {\n\t\tif tree.Left != nil && tree.Right != nil {\n\t\t\ttree.Value = tree.Right.getMinValue()\n\t\t\ttree.Right.remove(tree.Value, tree)\n\t\t} else if parent == nil {\n\t\t\tif tree.Left != nil {\n\t\t\t\ttree.Value = tree.Left.Value\n\t\t\t\ttree.Right = tree.Left.Right\n\t\t\t\ttree.Left = tree.Left.Left\n\t\t\t} else if tree.Right != nil {\n\t\t\t\ttree.Value = tree.Right.Value\n\t\t\t\ttree.Left = tree.Right.Left\n\t\t\t\ttree.Right = tree.Right.Right\n\t\t\t} else {\n\t\t\t\t// This is a single-node tree; do nothing.\n\t\t\t}\n\t\t} else if parent.Left == tree {\n\t\t\tif tree.Left != nil {\n\t\t\t\tparent.Left = tree.Left\n\t\t\t} else {\n\t\t\t\tparent.Left = tree.Right\n\t\t\t}\n\t\t} else if parent.Right == tree {\n\t\t\tif tree.Left != nil {\n\t\t\t\tparent.Right = tree.Left\n\t\t\t} else {\n\t\t\t\tparent.Right = tree.Right\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (tree *BST) getMinValue() int {\n\tif tree.Left == nil {\n\t\treturn tree.Value\n\t}\n\treturn tree.Left.getMinValue()\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\n// Average: O(log(n)) time | O(1) space\n// Worst: O(n) time | O(1) space\nfunc (tree *BST) Insert(value int) *BST {\n\tcurrent := tree\n\tfor {\n\t\tif value < current.Value {\n\t\t\tif current.Left == nil {\n\t\t\t\tcurrent.Left = &BST{Value: value}\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tcurrent = current.Left\n\t\t\t}\n\t\t} else {\n\t\t\tif current.Right == nil {\n\t\t\t\tcurrent.Right = &BST{Value: value}\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tcurrent = current.Right\n\t\t\t}\n\t\t}\n\t}\n\treturn tree\n}\n\n// Average: O(log(n)) time | O(1) space\n// Worst: O(n) time | O(1) space\nfunc (tree *BST) Contains(value int) bool {\n\tcurrent := tree\n\tfor current != nil {\n\t\tif value < current.Value {\n\t\t\tcurrent = current.Left\n\t\t} else if value > current.Value {\n\t\t\tcurrent = current.Right\n\t\t} else {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Average: O(log(n)) time | O(1) space\n// Worst: O(n) time | O(1) space\nfunc (tree *BST) Remove(value int) *BST {\n\ttree.remove(value, nil)\n\treturn tree\n}\n\nfunc (tree *BST) remove(value int, parent *BST) {\n\tcurrent := tree\n\tfor current != nil {\n\t\tif value < current.Value {\n\t\t\tparent = current\n\t\t\tcurrent = current.Left\n\t\t} else if value > current.Value {\n\t\t\tparent = current\n\t\t\tcurrent = current.Right\n\t\t} else {\n\t\t\tif current.Left != nil && current.Right != nil {\n\t\t\t\tcurrent.Value = current.Right.getMinValue()\n\t\t\t\tcurrent.Right.remove(current.Value, current)\n\t\t\t} else if parent == nil {\n\t\t\t\tif current.Left != nil {\n\t\t\t\t\tcurrent.Value = current.Left.Value\n\t\t\t\t\tcurrent.Right = current.Left.Right\n\t\t\t\t\tcurrent.Left = current.Left.Left\n\t\t\t\t} else if current.Right != nil {\n\t\t\t\t\tcurrent.Value = current.Right.Value\n\t\t\t\t\tcurrent.Left = current.Right.Left\n\t\t\t\t\tcurrent.Right = current.Right.Right\n\t\t\t\t} else {\n\t\t\t\t\t// This is a single-node tree; do nothing.\n\t\t\t\t}\n\t\t\t} else if parent.Left == current {\n\t\t\t\tif current.Left != nil {\n\t\t\t\t\tparent.Left = current.Left\n\t\t\t\t} else {\n\t\t\t\t\tparent.Left = current.Right\n\t\t\t\t}\n\t\t\t} else if parent.Right == current {\n\t\t\t\tif current.Left != nil {\n\t\t\t\t\tparent.Right = current.Left\n\t\t\t\t} else {\n\t\t\t\t\tparent.Right = current.Right\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (tree *BST) getMinValue() int {\n\tif tree.Left == nil {\n\t\treturn tree.Value\n\t}\n\treturn tree.Left.getMinValue()\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc NewBST(value int) *BST {\n\treturn &BST{Value: value}\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\troot := NewBST(10)\n\troot.Left = NewBST(5)\n\troot.Left.Left = NewBST(2)\n\troot.Left.Left.Left = NewBST(1)\n\troot.Left.Right = NewBST(5)\n\troot.Right = NewBST(15)\n\troot.Right.Left = NewBST(13)\n\troot.Right.Left.Right = NewBST(14)\n\troot.Right.Right = NewBST(22)\n\n\troot.Insert(12)\n\trequire.True(t, root.Right.Left.Left.Value == 12)\n\n\troot.Remove(10)\n\trequire.True(t, root.Contains(10) == false)\n\trequire.True(t, root.Value == 12)\n\n\trequire.True(t, root.Contains(15))\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc NewBST(value int) *BST {\n\treturn &BST{Value: value}\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\troot := NewBST(10)\n\troot.Left = NewBST(5)\n\troot.Left.Left = NewBST(2)\n\troot.Left.Left.Left = NewBST(1)\n\troot.Left.Right = NewBST(5)\n\troot.Right = NewBST(15)\n\troot.Right.Left = NewBST(13)\n\troot.Right.Left.Right = NewBST(14)\n\troot.Right.Right = NewBST(22)\n\n\troot.Insert(12)\n\trequire.True(t, root.Right.Left.Left.Value == 12)\n\n\troot.Remove(10)\n\trequire.True(t, root.Contains(10) == false)\n\trequire.True(t, root.Value == 12)\n\n\trequire.True(t, root.Contains(15))\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  static class BST {\n    public int value;\n    public BST left;\n    public BST right;\n\n    public BST(int value) {\n      this.value = value;\n    }\n\n    public BST insert(int value) {\n      // Write your code here.\n      // Do not edit the return statement of this method.\n      return this;\n    }\n\n    public boolean contains(int value) {\n      // Write your code here.\n      return false;\n    }\n\n    public BST remove(int value) {\n      // Write your code here.\n      // Do not edit the return statement of this method.\n      return this;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  static class BST {\n    public int value;\n    public BST left;\n    public BST right;\n\n    public BST(int value) {\n      this.value = value;\n    }\n\n    // Average: O(log(n)) time | O(log(n)) space\n    // Worst: O(n) time | O(n) space\n    public BST insert(int value) {\n      if (value < this.value) {\n        if (left == null) {\n          BST newBST = new BST(value);\n          left = newBST;\n        } else {\n          left.insert(value);\n        }\n      } else {\n        if (right == null) {\n          BST newBST = new BST(value);\n          right = newBST;\n        } else {\n          right.insert(value);\n        }\n      }\n      return this;\n    }\n\n    // Average: O(log(n)) time | O(log(n)) space\n    // Worst: O(n) time | O(n) space\n    public boolean contains(int value) {\n      if (value < this.value) {\n        if (left == null) {\n          return false;\n        } else {\n          return left.contains(value);\n        }\n      } else if (value > this.value) {\n        if (right == null) {\n          return false;\n        } else {\n          return right.contains(value);\n        }\n      } else {\n        return true;\n      }\n    }\n\n    // Average: O(log(n)) time | O(log(n)) space\n    // Worst: O(n) time | O(n) space\n    public BST remove(int value) {\n      remove(value, null);\n      return this;\n    }\n\n    public void remove(int value, BST parent) {\n      if (value < this.value) {\n        if (left != null) {\n          left.remove(value, this);\n        }\n      } else if (value > this.value) {\n        if (right != null) {\n          right.remove(value, this);\n        }\n      } else {\n        if (left != null && right != null) {\n          this.value = right.getMinValue();\n          right.remove(this.value, this);\n        } else if (parent == null) {\n          if (left != null) {\n            this.value = left.value;\n            right = left.right;\n            left = left.left;\n          } else if (right != null) {\n            this.value = right.value;\n            left = right.left;\n            right = right.right;\n          } else {\n            // This is a single-node tree; do nothing.\n          }\n        } else if (parent.left == this) {\n          parent.left = left != null ? left : right;\n        } else if (parent.right == this) {\n          parent.right = left != null ? left : right;\n        }\n      }\n    }\n\n    public int getMinValue() {\n      if (left == null) {\n        return this.value;\n      } else {\n        return left.getMinValue();\n      }\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  static class BST {\n    public int value;\n    public BST left;\n    public BST right;\n\n    public BST(int value) {\n      this.value = value;\n    }\n\n    // Average: O(log(n)) time | O(1) space\n    // Worst: O(n) time | O(1) space\n    public BST insert(int value) {\n      BST currentNode = this;\n      while (true) {\n        if (value < currentNode.value) {\n          if (currentNode.left == null) {\n            BST newNode = new BST(value);\n            currentNode.left = newNode;\n            break;\n          } else {\n            currentNode = currentNode.left;\n          }\n        } else {\n          if (currentNode.right == null) {\n            BST newNode = new BST(value);\n            currentNode.right = newNode;\n            break;\n          } else {\n            currentNode = currentNode.right;\n          }\n        }\n      }\n      return this;\n    }\n\n    // Average: O(log(n)) time | O(1) space\n    // Worst: O(n) time | O(1) space\n    public boolean contains(int value) {\n      BST currentNode = this;\n      while (currentNode != null) {\n        if (value < currentNode.value) {\n          currentNode = currentNode.left;\n        } else if (value > currentNode.value) {\n          currentNode = currentNode.right;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    // Average: O(log(n)) time | O(1) space\n    // Worst: O(n) time | O(1) space\n    public BST remove(int value) {\n      remove(value, null);\n      return this;\n    }\n\n    public void remove(int value, BST parentNode) {\n      BST currentNode = this;\n      while (currentNode != null) {\n        if (value < currentNode.value) {\n          parentNode = currentNode;\n          currentNode = currentNode.left;\n        } else if (value > currentNode.value) {\n          parentNode = currentNode;\n          currentNode = currentNode.right;\n        } else {\n          if (currentNode.left != null && currentNode.right != null) {\n            currentNode.value = currentNode.right.getMinValue();\n            currentNode.right.remove(currentNode.value, currentNode);\n          } else if (parentNode == null) {\n            if (currentNode.left != null) {\n              currentNode.value = currentNode.left.value;\n              currentNode.right = currentNode.left.right;\n              currentNode.left = currentNode.left.left;\n            } else if (currentNode.right != null) {\n              currentNode.value = currentNode.right.value;\n              currentNode.left = currentNode.right.left;\n              currentNode.right = currentNode.right.right;\n            } else {\n              // This is a single-node tree; do nothing.\n            }\n          } else if (parentNode.left == currentNode) {\n            parentNode.left =\n              currentNode.left != null ? currentNode.left : currentNode.right;\n          } else if (parentNode.right == currentNode) {\n            parentNode.right =\n              currentNode.left != null ? currentNode.left : currentNode.right;\n          }\n          break;\n        }\n      }\n    }\n\n    public int getMinValue() {\n      if (left == null) {\n        return value;\n      } else {\n        return left.getMinValue();\n      }\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var root = new Program.BST(10);\n    root.left = new Program.BST(5);\n    root.left.left = new Program.BST(2);\n    root.left.left.left = new Program.BST(1);\n    root.left.right = new Program.BST(5);\n    root.right = new Program.BST(15);\n    root.right.left = new Program.BST(13);\n    root.right.left.right = new Program.BST(14);\n    root.right.right = new Program.BST(22);\n\n    root.insert(12);\n    Utils.assertTrue(root.right.left.left.value == 12);\n\n    root.remove(10);\n    Utils.assertTrue(root.contains(10) == false);\n    Utils.assertTrue(root.value == 12);\n\n    Utils.assertTrue(root.contains(15));\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var root = new Program.BST(10);\n    root.left = new Program.BST(5);\n    root.left.left = new Program.BST(2);\n    root.left.left.left = new Program.BST(1);\n    root.left.right = new Program.BST(5);\n    root.right = new Program.BST(15);\n    root.right.left = new Program.BST(13);\n    root.right.left.right = new Program.BST(14);\n    root.right.right = new Program.BST(22);\n\n    root.insert(12);\n    Utils.assertTrue(root.right.left.left.value == 12);\n\n    root.remove(10);\n    Utils.assertTrue(root.contains(10) == false);\n    Utils.assertTrue(root.value == 12);\n\n    Utils.assertTrue(root.contains(15));\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// Do not edit the class below except for\n// the insert, contains, and remove methods.\n// Feel free to add new properties and methods\n// to the class.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(value) {\n    // Write your code here.\n    // Do not edit the return statement of this method.\n    return this;\n  }\n\n  contains(value) {\n    // Write your code here.\n  }\n\n  remove(value) {\n    // Write your code here.\n    // Do not edit the return statement of this method.\n    return this;\n  }\n}\n\n// Do not edit the line below.\nexports.BST = BST;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  // Average: O(log(n)) time | O(log(n)) space\n  // Worst: O(n) time | O(n) space\n  insert(value) {\n    if (value < this.value) {\n      if (this.left === null) {\n        this.left = new BST(value);\n      } else {\n        this.left.insert(value);\n      }\n    } else {\n      if (this.right === null) {\n        this.right = new BST(value);\n      } else {\n        this.right.insert(value);\n      }\n    }\n    return this;\n  }\n\n  // Average: O(log(n)) time | O(log(n)) space\n  // Worst: O(n) time | O(n) space\n  contains(value) {\n    if (value < this.value) {\n      if (this.left === null) {\n        return false;\n      } else {\n        return this.left.contains(value);\n      }\n    } else if (value > this.value) {\n      if (this.right === null) {\n        return false;\n      } else {\n        return this.right.contains(value);\n      }\n    } else {\n      return true;\n    }\n  }\n\n  // Average: O(log(n)) time | O(log(n)) space\n  // Worst: O(n) time | O(n) space\n  remove(value, parent = null) {\n    if (value < this.value) {\n      if (this.left !== null) {\n        this.left.remove(value, this);\n      }\n    } else if (value > this.value) {\n      if (this.right !== null) {\n        this.right.remove(value, this);\n      }\n    } else {\n      if (this.left !== null && this.right !== null) {\n        this.value = this.right.getMinValue();\n        this.right.remove(this.value, this);\n      } else if (parent === null) {\n        if (this.left !== null) {\n          this.value = this.left.value;\n          this.right = this.left.right;\n          this.left = this.left.left;\n        } else if (this.right !== null) {\n          this.value = this.right.value;\n          this.left = this.right.left;\n          this.right = this.right.right;\n        } else {\n          // This is a single-node tree; do nothing.\n        }\n      } else if (parent.left === this) {\n        parent.left = this.left !== null ? this.left : this.right;\n      } else if (parent.right === this) {\n        parent.right = this.left !== null ? this.left : this.right;\n      }\n    }\n    return this;\n  }\n\n  getMinValue() {\n    if (this.left === null) {\n      return this.value;\n    } else {\n      return this.left.getMinValue();\n    }\n  }\n}\n\nexports.BST = BST;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  // Average: O(log(n)) time | O(1) space\n  // Worst: O(n) time | O(1) space\n  insert(value) {\n    let currentNode = this;\n    while (true) {\n      if (value < currentNode.value) {\n        if (currentNode.left === null) {\n          currentNode.left = new BST(value);\n          break;\n        } else {\n          currentNode = currentNode.left;\n        }\n      } else {\n        if (currentNode.right === null) {\n          currentNode.right = new BST(value);\n          break;\n        } else {\n          currentNode = currentNode.right;\n        }\n      }\n    }\n    return this;\n  }\n\n  // Average: O(log(n)) time | O(1) space\n  // Worst: O(n) time | O(1) space\n  contains(value) {\n    let currentNode = this;\n    while (currentNode !== null) {\n      if (value < currentNode.value) {\n        currentNode = currentNode.left;\n      } else if (value > currentNode.value) {\n        currentNode = currentNode.right;\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Average: O(log(n)) time | O(1) space\n  // Worst: O(n) time | O(1) space\n  remove(value, parentNode = null) {\n    let currentNode = this;\n    while (currentNode !== null) {\n      if (value < currentNode.value) {\n        parentNode = currentNode;\n        currentNode = currentNode.left;\n      } else if (value > currentNode.value) {\n        parentNode = currentNode;\n        currentNode = currentNode.right;\n      } else {\n        if (currentNode.left !== null && currentNode.right !== null) {\n          currentNode.value = currentNode.right.getMinValue();\n          currentNode.right.remove(currentNode.value, currentNode);\n        } else if (parentNode === null) {\n          if (currentNode.left !== null) {\n            currentNode.value = currentNode.left.value;\n            currentNode.right = currentNode.left.right;\n            currentNode.left = currentNode.left.left;\n          } else if (currentNode.right !== null) {\n            currentNode.value = currentNode.right.value;\n            currentNode.left = currentNode.right.left;\n            currentNode.right = currentNode.right.right;\n          } else {\n            // This is a single-node tree; do nothing.\n          }\n        } else if (parentNode.left === currentNode) {\n          parentNode.left = currentNode.left !== null ? currentNode.left : currentNode.right;\n        } else if (parentNode.right === currentNode) {\n          parentNode.right = currentNode.left !== null ? currentNode.left : currentNode.right;\n        }\n        break;\n      }\n    }\n    return this;\n  }\n\n  getMinValue() {\n    let currentNode = this;\n    while (currentNode.left !== null) {\n      currentNode = currentNode.left;\n    }\n    return currentNode.value;\n  }\n}\n\nexports.BST = BST;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nconst {BST} = program;\n\nit('Test Case #1', function () {\n  const root = new BST(10);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.right = new BST(5);\n  root.right = new BST(15);\n  root.right.left = new BST(13);\n  root.right.left.right = new BST(14);\n  root.right.right = new BST(22);\n\n  root.insert(12);\n  chai.expect(root.right.left.left.value).to.deep.equal(12);\n\n  root.remove(10);\n  chai.expect(root.contains(10)).to.deep.equal(false);\n  chai.expect(root.value).to.deep.equal(12);\n\n  chai.expect(root.contains(15)).to.deep.equal(true);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nconst {BST} = program;\n\nit('Test Case #1', function () {\n  const root = new BST(10);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.right = new BST(5);\n  root.right = new BST(15);\n  root.right.left = new BST(13);\n  root.right.left.right = new BST(14);\n  root.right.right = new BST(22);\n\n  root.insert(12);\n  chai.expect(root.right.left.left.value).to.deep.equal(12);\n\n  root.remove(10);\n  chai.expect(root.contains(10)).to.deep.equal(false);\n  chai.expect(root.value).to.deep.equal(12);\n\n  chai.expect(root.contains(15)).to.deep.equal(true);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// Do not edit the class below except for\n// the insert, contains, and remove methods.\n// Feel free to add new properties and methods\n// to the class.\nopen class BST(value: Int) {\n    var value = value\n    var left: BST? = null\n    var right: BST? = null\n\n    fun insert(value: Int): BST {\n        // Write your code here.\n        // Do not edit the return statement of this method.\n        return this\n    }\n\n    fun contains(value: Int): Boolean {\n        // Write your code here.\n        return false\n    }\n\n    fun remove(value: Int): BST {\n        // Write your code here.\n        // Do not edit the return statement of this method.\n        return this\n    }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class BST(value: Int) {\n    var value = value\n    var left: BST? = null\n    var right: BST? = null\n\n    // Average: O(log(n)) time | O(log(n)) space\n    // Worst: O(n) time | O(n) space\n    fun insert(value: Int): BST {\n        if (value < this.value) {\n            if (this.left == null) {\n                this.left = BST(value)\n            } else {\n                this.left!!.insert(value)\n            }\n        } else {\n            if (this.right == null) {\n                this.right = BST(value)\n            } else {\n                this.right!!.insert(value)\n            }\n        }\n        return this\n    }\n\n    // Average: O(log(n)) time | O(log(n)) space\n    // Worst: O(n) time | O(n) space\n    fun contains(value: Int): Boolean {\n        if (value < this.value) {\n            if (this.left == null) {\n                return false\n            } else {\n                return this.left!!.contains(value)\n            }\n        } else if (value > this.value) {\n            if (this.right == null) {\n                return false\n            } else {\n                return this.right!!.contains(value)\n            }\n        } else {\n            return true\n        }\n    }\n\n    // Average: O(log(n)) time | O(log(n)) space\n    // Worst: O(n) time | O(n) space\n    fun remove(value: Int, parent: BST? = null): BST {\n        if (value < this.value) {\n            if (this.left != null) {\n                this.left!!.remove(value, this)\n            }\n        } else if (value > this.value) {\n            if (this.right != null) {\n                this.right!!.remove(value, this)\n            }\n        } else {\n            if (this.left != null && this.right != null) {\n                this.value = this.right!!.getMinValue()\n                this.right!!.remove(this.value, this)\n            } else if (parent == null) {\n                if (this.left != null) {\n                    this.value = this.left!!.value\n                    this.right = this.left!!.right\n                    this.left = this.left!!.left\n                } else if (this.right != null) {\n                    this.value = this.right!!.value\n                    this.left = this.right!!.left\n                    this.right = this.right!!.right\n                } else {\n                    // This is a single-node tree; do nothing.\n                }\n            } else if (parent.left == this) {\n                parent.left = if (this.left != null) this.left else this.right\n            } else if (parent.right == this) {\n                parent.right = if (this.left != null) this.left else this.right\n            }\n        }\n        return this\n    }\n\n    fun getMinValue(): Int {\n        if (this.left == null) {\n            return this.value\n        } else {\n            return this.left!!.getMinValue()\n        }\n    }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class BST(value: Int) {\n    var value = value\n    var left: BST? = null\n    var right: BST? = null\n\n    // Average: O(log(n)) time | O(1) space\n    // Worst: O(n) time | O(1) space\n    fun insert(value: Int): BST {\n        var currentNode: BST? = this\n        while (true) {\n            if (value < currentNode!!.value) {\n                if (currentNode.left == null) {\n                    currentNode.left = BST(value)\n                    break\n                } else {\n                    currentNode = currentNode.left\n                }\n            } else {\n                if (currentNode.right == null) {\n                    currentNode.right = BST(value)\n                    break\n                } else {\n                    currentNode = currentNode.right\n                }\n            }\n        }\n        return this\n    }\n\n    // Average: O(log(n)) time | O(1) space\n    // Worst: O(n) time | O(1) space\n    fun contains(value: Int): Boolean {\n        var currentNode: BST? = this\n        while (currentNode !== null) {\n            if (value < currentNode.value) {\n                currentNode = currentNode.left\n            } else if (value > currentNode.value) {\n                currentNode = currentNode.right\n            } else {\n                return true\n            }\n        }\n        return false\n    }\n\n    // Average: O(log(n)) time | O(1) space\n    // Worst: O(n) time | O(1) space\n    fun remove(value: Int, parent: BST? = null): BST {\n        var parentNode = parent\n        var currentNode: BST? = this\n        while (currentNode !== null) {\n            if (value < currentNode.value) {\n                parentNode = currentNode\n                currentNode = currentNode.left\n            } else if (value > currentNode.value) {\n                parentNode = currentNode\n                currentNode = currentNode.right\n            } else {\n                if (currentNode.left !== null && currentNode.right !== null) {\n                    currentNode.value = currentNode.right!!.getMinValue()\n                    currentNode.right!!.remove(currentNode.value, currentNode)\n                } else if (parentNode == null) {\n                    if (currentNode.left !== null) {\n                        currentNode.value = currentNode.left!!.value\n                        currentNode.right = currentNode.left!!.right\n                        currentNode.left = currentNode.left!!.left\n                    } else if (currentNode.right !== null) {\n                        currentNode.value = currentNode.right!!.value\n                        currentNode.left = currentNode.right!!.left\n                        currentNode.right = currentNode.right!!.right\n                    } else {\n                        // This is a single-node tree; do nothing.\n                    }\n                } else if (parentNode.left == currentNode) {\n                    parentNode.left = if (currentNode.left !== null) currentNode.left else currentNode.right\n                } else if (parentNode.right == currentNode) {\n                    parentNode.right = if (currentNode.left !== null) currentNode.left else currentNode.right\n                }\n                break\n            }\n        }\n        return this\n    }\n\n    fun getMinValue(): Int {\n        if (this.left == null) {\n            return this.value\n        } else {\n            return this.left!!.getMinValue()\n        }\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.BST as BST\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val root = BST(10)\n        root.left = BST(5)\n        root.left!!.left = BST(2)\n        root.left!!.left!!.left = BST(1)\n        root.left!!.right = BST(5)\n        root.right = BST(15)\n        root.right!!.left = BST(13)\n        root.right!!.left!!.right = BST(14)\n        root.right!!.right = BST(22)\n\n        root.insert(12)\n        assert(root.right!!.left!!.left != null)\n        assert(root.right!!.left!!.left!!.value == 12)\n\n        root.remove(10)\n        assert(!root.contains(10))\n        assert(root.value == 12)\n\n        assert(root.contains(15))\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.BST as BST\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val root = BST(10)\n        root.left = BST(5)\n        root.left!!.left = BST(2)\n        root.left!!.left!!.left = BST(1)\n        root.left!!.right = BST(5)\n        root.right = BST(15)\n        root.right!!.left = BST(13)\n        root.right!!.left!!.right = BST(14)\n        root.right!!.right = BST(22)\n\n        root.insert(12)\n        assert(root.right!!.left!!.left != null)\n        assert(root.right!!.left!!.left!!.value == 12)\n\n        root.remove(10)\n        assert(!root.contains(10))\n        assert(root.value == 12)\n\n        assert(root.contains(15))\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# Do not edit the class below except for\n# the insert, contains, and remove methods.\n# Feel free to add new properties and methods\n# to the class.\nclass BST:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n    def insert(self, value):\n        # Write your code here.\n        # Do not edit the return statement of this method.\n        return self\n\n    def contains(self, value):\n        # Write your code here.\n        pass\n\n    def remove(self, value):\n        # Write your code here.\n        # Do not edit the return statement of this method.\n        return self\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass BST:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n    # Average: O(log(n)) time | O(log(n)) space\n    # Worst: O(n) time | O(n) space\n    def insert(self, value):\n        if value < self.value:\n            if self.left is None:\n                self.left = BST(value)\n            else:\n                self.left.insert(value)\n        else:\n            if self.right is None:\n                self.right = BST(value)\n            else:\n                self.right.insert(value)\n        return self\n\n    # Average: O(log(n)) time | O(log(n)) space\n    # Worst: O(n) time | O(n) space\n    def contains(self, value):\n        if value < self.value:\n            if self.left is None:\n                return False\n            else:\n                return self.left.contains(value)\n        elif value > self.value:\n            if self.right is None:\n                return False\n            else:\n                return self.right.contains(value)\n        else:\n            return True\n\n    # Average: O(log(n)) time | O(log(n)) space\n    # Worst: O(n) time | O(n) space\n    def remove(self, value, parent=None):\n        if value < self.value:\n            if self.left is not None:\n                self.left.remove(value, self)\n        elif value > self.value:\n            if self.right is not None:\n                self.right.remove(value, self)\n        else:\n            if self.left is not None and self.right is not None:\n                self.value = self.right.getMinValue()\n                self.right.remove(self.value, self)\n            elif parent is None:\n                if self.left is not None:\n                    self.value = self.left.value\n                    self.right = self.left.right\n                    self.left = self.left.left\n                elif self.right is not None:\n                    self.value = self.right.value\n                    self.left = self.right.left\n                    self.right = self.right.right\n                else:\n                    # This is a single-node tree; do nothing.\n                    pass\n            elif parent.left == self:\n                parent.left = self.left if self.left is not None else self.right\n            elif parent.right == self:\n                parent.right = self.left if self.left is not None else self.right\n        return self\n\n    def getMinValue(self):\n        if self.left is None:\n            return self.value\n        else:\n            return self.left.getMinValue()\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass BST:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n    # Average: O(log(n)) time | O(1) space\n    # Worst: O(n) time | O(1) space\n    def insert(self, value):\n        currentNode = self\n        while True:\n            if value < currentNode.value:\n                if currentNode.left is None:\n                    currentNode.left = BST(value)\n                    break\n                else:\n                    currentNode = currentNode.left\n            else:\n                if currentNode.right is None:\n                    currentNode.right = BST(value)\n                    break\n                else:\n                    currentNode = currentNode.right\n        return self\n\n    # Average: O(log(n)) time | O(1) space\n    # Worst: O(n) time | O(1) space\n    def contains(self, value):\n        currentNode = self\n        while currentNode is not None:\n            if value < currentNode.value:\n                currentNode = currentNode.left\n            elif value > currentNode.value:\n                currentNode = currentNode.right\n            else:\n                return True\n        return False\n\n    # Average: O(log(n)) time | O(1) space\n    # Worst: O(n) time | O(1) space\n    def remove(self, value, parentNode=None):\n        currentNode = self\n        while currentNode is not None:\n            if value < currentNode.value:\n                parentNode = currentNode\n                currentNode = currentNode.left\n            elif value > currentNode.value:\n                parentNode = currentNode\n                currentNode = currentNode.right\n            else:\n                if currentNode.left is not None and currentNode.right is not None:\n                    currentNode.value = currentNode.right.getMinValue()\n                    currentNode.right.remove(currentNode.value, currentNode)\n                elif parentNode is None:\n                    if currentNode.left is not None:\n                        currentNode.value = currentNode.left.value\n                        currentNode.right = currentNode.left.right\n                        currentNode.left = currentNode.left.left\n                    elif currentNode.right is not None:\n                        currentNode.value = currentNode.right.value\n                        currentNode.left = currentNode.right.left\n                        currentNode.right = currentNode.right.right\n                    else:\n                        # This is a single-node tree; do nothing.\n                        pass\n                elif parentNode.left == currentNode:\n                    parentNode.left = (\n                        currentNode.left if currentNode.left is not None else currentNode.right\n                    )\n                elif parentNode.right == currentNode:\n                    parentNode.right = (\n                        currentNode.left if currentNode.left is not None else currentNode.right\n                    )\n                break\n        return self\n\n    def getMinValue(self):\n        currentNode = self\n        while currentNode.left is not None:\n            currentNode = currentNode.left\n        return currentNode.value\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nBST = program.BST\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = BST(10)\n        root.left = BST(5)\n        root.left.left = BST(2)\n        root.left.left.left = BST(1)\n        root.left.right = BST(5)\n        root.right = BST(15)\n        root.right.left = BST(13)\n        root.right.left.right = BST(14)\n        root.right.right = BST(22)\n\n        root.insert(12)\n        self.assertTrue(root.right.left.left.value == 12)\n\n        root.remove(10)\n        self.assertTrue(not root.contains(10))\n        self.assertTrue(root.value == 12)\n\n        self.assertTrue(root.contains(15))\n",
      "unitTests": "import program\nimport unittest\n\n\nBST = program.BST\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = BST(10)\n        root.left = BST(5)\n        root.left.left = BST(2)\n        root.left.left.left = BST(1)\n        root.left.right = BST(5)\n        root.right = BST(15)\n        root.right.left = BST(13)\n        root.right.left.right = BST(14)\n        root.right.right = BST(22)\n\n        root.insert(12)\n        self.assertTrue(root.right.left.left.value == 12)\n\n        root.remove(10)\n        self.assertTrue(not root.contains(10))\n        self.assertTrue(root.value == 12)\n\n        self.assertTrue(root.contains(15))\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n\n    func insert(value: Int) -> BST {\n      // Write your code here.\n      return self\n    }\n\n    func contains(value: Int) -> Bool {\n      // Write your code here.\n      return false\n    }\n\n    func remove(value: Int?, parentNode: BST?) -> BST {\n      // Write your code here.\n      return self\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n\n    // Average: O(log(n)) time | O(log(n)) space\n    // Worst: O(n) time | O(n) space\n    func insert(value: Int) -> BST {\n      if value < self.value {\n        if let left = left {\n          left.insert(value: value)\n        } else {\n          left = BST(value: value)\n        }\n      } else {\n        if let right = right {\n          right.insert(value: value)\n        } else {\n          right = BST(value: value)\n        }\n      }\n\n      return self\n    }\n\n    // Average: O(log(n)) time | O(log(n)) space\n    // Worst: O(n) time | O(n) space\n    func contains(value: Int) -> Bool {\n      if value < self.value {\n        if let left = left {\n          return left.contains(value: value)\n        } else {\n          return false\n        }\n      } else if value > self.value {\n        if let right = right {\n          return right.contains(value: value)\n        } else {\n          return false\n        }\n      } else {\n        return true\n      }\n    }\n\n    // Average: O(log(n)) time | O(log(n)) space\n    // Worst: O(n) time | O(n) space\n    func remove(value: Int?, parentNode: BST?) -> BST {\n      if let valueToRemove = value, valueToRemove < self.value {\n        if let left = left {\n          left.remove(value: value, parentNode: self)\n        }\n      } else if let valueToRemove = value, valueToRemove > self.value {\n        if let right = right {\n          right.remove(value: value, parentNode: self)\n        }\n      } else {\n        if let _ = left, let right = right {\n          self.value = right.getMinValue()\n\n          right.remove(value: self.value, parentNode: self)\n        } else if parentNode === nil {\n          if let left = left {\n            self.value = left.value\n\n            right = left.right\n\n            self.left = left.left\n          } else if let right = right {\n            self.value = right.value\n\n            left = right.left\n\n            self.right = right.right\n          } else {\n            // This is a single-node tree; do nothing.\n          }\n        } else if let parent = parentNode, let parentLeft = parent.left, parentLeft === self {\n          if let left = left {\n            parent.left = left\n          } else {\n            parent.left = right\n          }\n        } else if let parent = parentNode, let parentRight = parentNode?.right, parentRight === self {\n          if let left = left {\n            parent.right = left\n          } else {\n            parent.right = right\n          }\n        }\n      }\n\n      return self\n    }\n\n    func getMinValue() -> Int {\n      if let left = left {\n        return left.getMinValue()\n      } else {\n        return value\n      }\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n\n    // Average: O(log(n)) time | O(1) space\n    // Worst: O(n) time | O(1) space\n    func insert(value: Int) -> BST {\n      var currentNode: BST? = self\n\n      while true {\n        if let node = currentNode, value < node.value {\n          if node.left === nil {\n            node.left = BST(value: value)\n            break\n          } else {\n            currentNode = node.left\n          }\n        } else if let node = currentNode {\n          if node.right === nil {\n            node.right = BST(value: value)\n            break\n          } else {\n            currentNode = node.right\n          }\n        }\n      }\n\n      return self\n    }\n\n    // Average: O(log(n)) time | O(1) space\n    // Worst: O(n) time | O(1) space\n    func contains(value: Int) -> Bool {\n      var currentNode: BST? = self\n\n      while currentNode !== nil {\n        if let node = currentNode, value < node.value {\n          currentNode = node.left\n        } else if let node = currentNode, value > node.value {\n          currentNode = node.right\n        } else {\n          return true\n        }\n      }\n\n      return false\n    }\n\n    // Average: O(log(n)) time | O(1) space\n    // Worst: O(n) time | O(1) space\n    func remove(value: Int, parentNode: BST?) -> BST {\n      var currentNode: BST? = self\n      var parentNode: BST? = parentNode\n      while let node = currentNode {\n        if value < node.value {\n          parentNode = node\n          currentNode = node.left\n        } else if value > node.value {\n          parentNode = node\n          currentNode = node.right\n        } else {\n          if let left = node.left, let right = node.right {\n            node.value = right.getMinValue()\n            right.remove(value: node.value, parentNode: node)\n          } else if parentNode === nil {\n            if let left = node.left {\n              node.value = left.value\n              node.right = left.right\n              node.left = left.left\n            } else if let right = node.right {\n              node.value = right.value\n              node.left = right.left\n              node.right = right.right\n            } else {\n              // This is a single-node tree; do nothing.\n            }\n          } else if let parent = parentNode {\n            if let parentLeft = parent.left, parentLeft === node {\n              if let left = node.left {\n                parent.left = left\n              } else {\n                parent.left = node.right\n              }\n            } else if let parentRight = parent.right, parentRight === node {\n              if let left = node.left {\n                parent.right = left\n              } else {\n                parent.right = node.right\n              }\n            }\n          }\n          break\n        }\n      }\n\n      return self\n    }\n\n    func getMinValue() -> Int {\n      var currentNode = self\n\n      while currentNode.left !== nil {\n        if let left = currentNode.left {\n          currentNode = left\n        }\n      }\n\n      return currentNode.value\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let root = Program.BST(value: 10)\n      root.left = Program.BST(value: 5)\n      root.left!.left = Program.BST(value: 2)\n      root.left!.left!.left = Program.BST(value: 1)\n      root.left!.right = Program.BST(value: 5)\n      root.right = Program.BST(value: 15)\n      root.right!.left = Program.BST(value: 13)\n      root.right!.left!.right = Program.BST(value: 14)\n      root.right!.right = Program.BST(value: 22)\n\n      root.insert(value: 12)\n      try assertEqual(12, root.right?.left?.left?.value)\n\n      root.remove(value: 10, parentNode: nil)\n      try assertEqual(false, root.contains(value: 10))\n      try assertEqual(12, root.value)\n\n      try assertEqual(true, root.contains(value: 15))\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let root = Program.BST(value: 10)\n      root.left = Program.BST(value: 5)\n      root.left!.left = Program.BST(value: 2)\n      root.left!.left!.left = Program.BST(value: 1)\n      root.left!.right = Program.BST(value: 5)\n      root.right = Program.BST(value: 15)\n      root.right!.left = Program.BST(value: 13)\n      root.right!.left!.right = Program.BST(value: 14)\n      root.right!.right = Program.BST(value: 22)\n\n      root.insert(value: 12)\n      try assertEqual(12, root.right?.left?.left?.value)\n\n      root.remove(value: 10, parentNode: nil)\n      try assertEqual(false, root.contains(value: 10))\n      try assertEqual(12, root.value)\n\n      try assertEqual(true, root.contains(value: 15))\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// Do not edit the class below except for\n// the insert, contains, and remove methods.\n// Feel free to add new properties and methods\n// to the class.\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(value: number): BST {\n    // Write your code here.\n    // Do not edit the return statement of this method.\n    return this;\n  }\n\n  contains(value: number) {\n    // Write your code here.\n    return false;\n  }\n\n  remove(value: number): BST {\n    // Write your code here.\n    // Do not edit the return statement of this method.\n    return this;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  // Average: O(log(n)) time | O(log(n)) space\n  // Worst: O(n) time | O(n) space\n  insert(value: number): BST {\n    if (value < this.value) {\n      if (this.left === null) {\n        this.left = new BST(value);\n      } else {\n        this.left.insert(value);\n      }\n    } else {\n      if (this.right === null) {\n        this.right = new BST(value);\n      } else {\n        this.right.insert(value);\n      }\n    }\n    return this;\n  }\n\n  // Average: O(log(n)) time | O(log(n)) space\n  // Worst: O(n) time | O(n) space\n  contains(value: number): boolean {\n    if (value < this.value) {\n      if (this.left === null) {\n        return false;\n      } else {\n        return this.left.contains(value);\n      }\n    } else if (value > this.value) {\n      if (this.right === null) {\n        return false;\n      } else {\n        return this.right.contains(value);\n      }\n    } else {\n      return true;\n    }\n  }\n\n  // Average: O(log(n)) time | O(log(n)) space\n  // Worst: O(n) time | O(n) space\n  remove(value: number, parent: BST | null = null) {\n    if (value < this.value) {\n      if (this.left !== null) {\n        this.left.remove(value, this);\n      }\n    } else if (value > this.value) {\n      if (this.right !== null) {\n        this.right.remove(value, this);\n      }\n    } else {\n      if (this.left !== null && this.right !== null) {\n        this.value = this.right.getMinValue();\n        this.right.remove(this.value, this);\n      } else if (parent === null) {\n        if (this.left !== null) {\n          this.value = this.left.value;\n          this.right = this.left.right;\n          this.left = this.left.left;\n        } else if (this.right !== null) {\n          this.value = this.right.value;\n          this.left = this.right.left;\n          this.right = this.right.right;\n        } else {\n          // This is a single-node tree; do nothing.\n        }\n      } else if (parent.left === this) {\n        parent.left = this.left !== null ? this.left : this.right;\n      } else if (parent.right === this) {\n        parent.right = this.left !== null ? this.left : this.right;\n      }\n    }\n    return this;\n  }\n\n  getMinValue(): number {\n    if (this.left === null) {\n      return this.value;\n    } else {\n      return this.left.getMinValue();\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  // Average: O(log(n)) time | O(1) space\n  // Worst: O(n) time | O(1) space\n  insert(value: number) {\n    let currentNode: BST = this;\n    while (true) {\n      if (value < currentNode.value) {\n        if (currentNode.left === null) {\n          currentNode.left = new BST(value);\n          break;\n        } else {\n          currentNode = currentNode.left;\n        }\n      } else {\n        if (currentNode.right === null) {\n          currentNode.right = new BST(value);\n          break;\n        } else {\n          currentNode = currentNode.right;\n        }\n      }\n    }\n    return this;\n  }\n\n  // Average: O(log(n)) time | O(1) space\n  // Worst: O(n) time | O(1) space\n  contains(value: number) {\n    let currentNode: BST | null = this;\n    while (currentNode !== null) {\n      if (value < currentNode.value) {\n        currentNode = currentNode.left;\n      } else if (value > currentNode.value) {\n        currentNode = currentNode.right;\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Average: O(log(n)) time | O(1) space\n  // Worst: O(n) time | O(1) space\n  remove(value: number, parentNode: BST | null = null) {\n    let currentNode: BST | null = this;\n    while (currentNode !== null) {\n      if (value < currentNode.value) {\n        parentNode = currentNode;\n        currentNode = currentNode.left;\n      } else if (value > currentNode.value) {\n        parentNode = currentNode;\n        currentNode = currentNode.right;\n      } else {\n        if (currentNode.left !== null && currentNode.right !== null) {\n          currentNode.value = currentNode.right.getMinValue();\n          currentNode.right.remove(currentNode.value, currentNode);\n        } else if (parentNode === null) {\n          if (currentNode.left !== null) {\n            currentNode.value = currentNode.left.value;\n            currentNode.right = currentNode.left.right;\n            currentNode.left = currentNode.left.left;\n          } else if (currentNode.right !== null) {\n            currentNode.value = currentNode.right.value;\n            currentNode.left = currentNode.right.left;\n            currentNode.right = currentNode.right.right;\n          } else {\n            // This is a single-node tree; do nothing.\n          }\n        } else if (parentNode.left === currentNode) {\n          parentNode.left = currentNode.left !== null ? currentNode.left : currentNode.right;\n        } else if (parentNode.right === currentNode) {\n          parentNode.right = currentNode.left !== null ? currentNode.left : currentNode.right;\n        }\n        break;\n      }\n    }\n    return this;\n  }\n\n  getMinValue(): number {\n    let currentNode: BST = this;\n    while (currentNode.left !== null) {\n      currentNode = currentNode.left;\n    }\n    return currentNode.value;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nconst {BST} = program;\n\nit('Test Case #1', function () {\n  const root = new BST(10);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.right = new BST(5);\n  root.right = new BST(15);\n  root.right.left = new BST(13);\n  root.right.left.right = new BST(14);\n  root.right.right = new BST(22);\n\n  root.insert(12);\n  chai.expect(root.right.left.left).to.not.be.null;\n  chai.expect(root.right.left.left!.value).to.deep.equal(12);\n\n  root.remove(10);\n  chai.expect(root.contains(10)).to.deep.equal(false);\n  chai.expect(root.value).to.deep.equal(12);\n\n  chai.expect(root.contains(15)).to.deep.equal(true);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nconst {BST} = program;\n\nit('Test Case #1', function () {\n  const root = new BST(10);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.right = new BST(5);\n  root.right = new BST(15);\n  root.right.left = new BST(13);\n  root.right.left.right = new BST(14);\n  root.right.right = new BST(22);\n\n  root.insert(12);\n  chai.expect(root.right.left.left).to.not.be.null;\n  chai.expect(root.right.left.left!.value).to.deep.equal(12);\n\n  root.remove(10);\n  chai.expect(root.contains(10)).to.deep.equal(false);\n  chai.expect(root.value).to.deep.equal(12);\n\n  chai.expect(root.contains(15)).to.deep.equal(true);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "rootValue",
      "example": 10,
      "schema": {
        "type": "integer"
      }
    },
    {
      "name": "classMethodsToCall",
      "example": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        },
        {
          "arguments": [
            2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            13
          ],
          "method": "insert"
        },
        {
          "arguments": [
            22
          ],
          "method": "insert"
        },
        {
          "arguments": [
            1
          ],
          "method": "insert"
        },
        {
          "arguments": [
            14
          ],
          "method": "insert"
        },
        {
          "arguments": [
            12
          ],
          "method": "insert"
        },
        {
          "arguments": [
            10
          ],
          "method": "remove"
        },
        {
          "arguments": [
            15
          ],
          "method": "contains"
        }
      ],
      "schema": {
        "description": "These methods will be called in the order that they appear in below\non a <span>BST</span> built from the <span>rootValue</span> and with their respective arguments.\n",
        "items": {
          "properties": {
            "arguments": {
              "items": {
                "type": "integer"
              },
              "maxItems": 1,
              "minItems": 1,
              "type": "array"
            },
            "method": {
              "enum": [
                "contains",
                "insert",
                "remove"
              ],
              "type": "string"
            }
          },
          "required": [
            "method",
            "arguments"
          ],
          "type": "object"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        },
        {
          "arguments": [
            2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            13
          ],
          "method": "insert"
        },
        {
          "arguments": [
            22
          ],
          "method": "insert"
        },
        {
          "arguments": [
            1
          ],
          "method": "insert"
        },
        {
          "arguments": [
            14
          ],
          "method": "insert"
        },
        {
          "arguments": [
            12
          ],
          "method": "insert"
        },
        {
          "arguments": [
            10
          ],
          "method": "remove"
        },
        {
          "arguments": [
            15
          ],
          "method": "contains"
        }
      ],
      "rootValue": 10
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        }
      ],
      "rootValue": 10
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        },
        {
          "arguments": [
            10
          ],
          "method": "contains"
        },
        {
          "arguments": [
            5
          ],
          "method": "contains"
        },
        {
          "arguments": [
            15
          ],
          "method": "contains"
        },
        {
          "arguments": [
            1
          ],
          "method": "contains"
        },
        {
          "arguments": [
            6
          ],
          "method": "contains"
        },
        {
          "arguments": [
            11
          ],
          "method": "contains"
        },
        {
          "arguments": [
            16
          ],
          "method": "contains"
        }
      ],
      "rootValue": 10
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        },
        {
          "arguments": [
            5
          ],
          "method": "remove"
        },
        {
          "arguments": [
            15
          ],
          "method": "remove"
        },
        {
          "arguments": [
            10
          ],
          "method": "remove"
        }
      ],
      "rootValue": 10
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        },
        {
          "arguments": [
            10
          ],
          "method": "contains"
        },
        {
          "arguments": [
            5
          ],
          "method": "contains"
        },
        {
          "arguments": [
            15
          ],
          "method": "contains"
        },
        {
          "arguments": [
            10
          ],
          "method": "remove"
        },
        {
          "arguments": [
            5
          ],
          "method": "remove"
        },
        {
          "arguments": [
            15
          ],
          "method": "remove"
        },
        {
          "arguments": [
            10
          ],
          "method": "contains"
        },
        {
          "arguments": [
            5
          ],
          "method": "contains"
        },
        {
          "arguments": [
            15
          ],
          "method": "contains"
        }
      ],
      "rootValue": 10
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            3
          ],
          "method": "insert"
        },
        {
          "arguments": [
            4
          ],
          "method": "insert"
        },
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            6
          ],
          "method": "insert"
        },
        {
          "arguments": [
            7
          ],
          "method": "insert"
        },
        {
          "arguments": [
            8
          ],
          "method": "insert"
        },
        {
          "arguments": [
            9
          ],
          "method": "insert"
        },
        {
          "arguments": [
            10
          ],
          "method": "insert"
        },
        {
          "arguments": [
            11
          ],
          "method": "insert"
        },
        {
          "arguments": [
            12
          ],
          "method": "insert"
        },
        {
          "arguments": [
            13
          ],
          "method": "insert"
        },
        {
          "arguments": [
            14
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        },
        {
          "arguments": [
            16
          ],
          "method": "insert"
        },
        {
          "arguments": [
            17
          ],
          "method": "insert"
        },
        {
          "arguments": [
            18
          ],
          "method": "insert"
        },
        {
          "arguments": [
            19
          ],
          "method": "insert"
        },
        {
          "arguments": [
            20
          ],
          "method": "insert"
        },
        {
          "arguments": [
            2
          ],
          "method": "remove"
        },
        {
          "arguments": [
            4
          ],
          "method": "remove"
        },
        {
          "arguments": [
            6
          ],
          "method": "remove"
        },
        {
          "arguments": [
            8
          ],
          "method": "remove"
        },
        {
          "arguments": [
            11
          ],
          "method": "remove"
        },
        {
          "arguments": [
            13
          ],
          "method": "remove"
        },
        {
          "arguments": [
            15
          ],
          "method": "remove"
        },
        {
          "arguments": [
            17
          ],
          "method": "remove"
        },
        {
          "arguments": [
            19
          ],
          "method": "remove"
        },
        {
          "arguments": [
            1
          ],
          "method": "insert"
        },
        {
          "arguments": [
            2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            3
          ],
          "method": "insert"
        },
        {
          "arguments": [
            4
          ],
          "method": "insert"
        },
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            6
          ],
          "method": "insert"
        },
        {
          "arguments": [
            7
          ],
          "method": "insert"
        },
        {
          "arguments": [
            8
          ],
          "method": "insert"
        },
        {
          "arguments": [
            9
          ],
          "method": "insert"
        },
        {
          "arguments": [
            10
          ],
          "method": "insert"
        },
        {
          "arguments": [
            9000
          ],
          "method": "contains"
        }
      ],
      "rootValue": 1
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            3
          ],
          "method": "insert"
        },
        {
          "arguments": [
            4
          ],
          "method": "insert"
        },
        {
          "arguments": [
            1
          ],
          "method": "remove"
        }
      ],
      "rootValue": 1
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            -2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            -3
          ],
          "method": "insert"
        },
        {
          "arguments": [
            -4
          ],
          "method": "insert"
        },
        {
          "arguments": [
            1
          ],
          "method": "remove"
        }
      ],
      "rootValue": 1
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            10
          ],
          "method": "remove"
        },
        {
          "arguments": [
            15
          ],
          "method": "contains"
        }
      ],
      "rootValue": 10
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        },
        {
          "arguments": [
            2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            13
          ],
          "method": "insert"
        },
        {
          "arguments": [
            22
          ],
          "method": "insert"
        },
        {
          "arguments": [
            1
          ],
          "method": "insert"
        },
        {
          "arguments": [
            14
          ],
          "method": "insert"
        },
        {
          "arguments": [
            12
          ],
          "method": "insert"
        },
        {
          "arguments": [
            5
          ],
          "method": "remove"
        },
        {
          "arguments": [
            5
          ],
          "method": "remove"
        },
        {
          "arguments": [
            12
          ],
          "method": "remove"
        },
        {
          "arguments": [
            13
          ],
          "method": "remove"
        },
        {
          "arguments": [
            14
          ],
          "method": "remove"
        },
        {
          "arguments": [
            22
          ],
          "method": "remove"
        },
        {
          "arguments": [
            2
          ],
          "method": "remove"
        },
        {
          "arguments": [
            1
          ],
          "method": "remove"
        },
        {
          "arguments": [
            15
          ],
          "method": "contains"
        }
      ],
      "rootValue": 10
    }
  ],
  "jsonTests": [
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        },
        {
          "arguments": [
            2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            13
          ],
          "method": "insert"
        },
        {
          "arguments": [
            22
          ],
          "method": "insert"
        },
        {
          "arguments": [
            1
          ],
          "method": "insert"
        },
        {
          "arguments": [
            14
          ],
          "method": "insert"
        },
        {
          "arguments": [
            12
          ],
          "method": "insert"
        },
        {
          "arguments": [
            10
          ],
          "method": "remove"
        },
        {
          "arguments": [
            15
          ],
          "method": "contains"
        }
      ],
      "rootValue": 10
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        }
      ],
      "rootValue": 10
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        },
        {
          "arguments": [
            10
          ],
          "method": "contains"
        },
        {
          "arguments": [
            5
          ],
          "method": "contains"
        },
        {
          "arguments": [
            15
          ],
          "method": "contains"
        },
        {
          "arguments": [
            1
          ],
          "method": "contains"
        },
        {
          "arguments": [
            6
          ],
          "method": "contains"
        },
        {
          "arguments": [
            11
          ],
          "method": "contains"
        },
        {
          "arguments": [
            16
          ],
          "method": "contains"
        }
      ],
      "rootValue": 10
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        },
        {
          "arguments": [
            5
          ],
          "method": "remove"
        },
        {
          "arguments": [
            15
          ],
          "method": "remove"
        },
        {
          "arguments": [
            10
          ],
          "method": "remove"
        }
      ],
      "rootValue": 10
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        },
        {
          "arguments": [
            10
          ],
          "method": "contains"
        },
        {
          "arguments": [
            5
          ],
          "method": "contains"
        },
        {
          "arguments": [
            15
          ],
          "method": "contains"
        },
        {
          "arguments": [
            10
          ],
          "method": "remove"
        },
        {
          "arguments": [
            5
          ],
          "method": "remove"
        },
        {
          "arguments": [
            15
          ],
          "method": "remove"
        },
        {
          "arguments": [
            10
          ],
          "method": "contains"
        },
        {
          "arguments": [
            5
          ],
          "method": "contains"
        },
        {
          "arguments": [
            15
          ],
          "method": "contains"
        }
      ],
      "rootValue": 10
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            3
          ],
          "method": "insert"
        },
        {
          "arguments": [
            4
          ],
          "method": "insert"
        },
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            6
          ],
          "method": "insert"
        },
        {
          "arguments": [
            7
          ],
          "method": "insert"
        },
        {
          "arguments": [
            8
          ],
          "method": "insert"
        },
        {
          "arguments": [
            9
          ],
          "method": "insert"
        },
        {
          "arguments": [
            10
          ],
          "method": "insert"
        },
        {
          "arguments": [
            11
          ],
          "method": "insert"
        },
        {
          "arguments": [
            12
          ],
          "method": "insert"
        },
        {
          "arguments": [
            13
          ],
          "method": "insert"
        },
        {
          "arguments": [
            14
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        },
        {
          "arguments": [
            16
          ],
          "method": "insert"
        },
        {
          "arguments": [
            17
          ],
          "method": "insert"
        },
        {
          "arguments": [
            18
          ],
          "method": "insert"
        },
        {
          "arguments": [
            19
          ],
          "method": "insert"
        },
        {
          "arguments": [
            20
          ],
          "method": "insert"
        },
        {
          "arguments": [
            2
          ],
          "method": "remove"
        },
        {
          "arguments": [
            4
          ],
          "method": "remove"
        },
        {
          "arguments": [
            6
          ],
          "method": "remove"
        },
        {
          "arguments": [
            8
          ],
          "method": "remove"
        },
        {
          "arguments": [
            11
          ],
          "method": "remove"
        },
        {
          "arguments": [
            13
          ],
          "method": "remove"
        },
        {
          "arguments": [
            15
          ],
          "method": "remove"
        },
        {
          "arguments": [
            17
          ],
          "method": "remove"
        },
        {
          "arguments": [
            19
          ],
          "method": "remove"
        },
        {
          "arguments": [
            1
          ],
          "method": "insert"
        },
        {
          "arguments": [
            2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            3
          ],
          "method": "insert"
        },
        {
          "arguments": [
            4
          ],
          "method": "insert"
        },
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            6
          ],
          "method": "insert"
        },
        {
          "arguments": [
            7
          ],
          "method": "insert"
        },
        {
          "arguments": [
            8
          ],
          "method": "insert"
        },
        {
          "arguments": [
            9
          ],
          "method": "insert"
        },
        {
          "arguments": [
            10
          ],
          "method": "insert"
        },
        {
          "arguments": [
            9000
          ],
          "method": "contains"
        }
      ],
      "rootValue": 1
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            3
          ],
          "method": "insert"
        },
        {
          "arguments": [
            4
          ],
          "method": "insert"
        },
        {
          "arguments": [
            1
          ],
          "method": "remove"
        }
      ],
      "rootValue": 1
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            -2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            -3
          ],
          "method": "insert"
        },
        {
          "arguments": [
            -4
          ],
          "method": "insert"
        },
        {
          "arguments": [
            1
          ],
          "method": "remove"
        }
      ],
      "rootValue": 1
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            10
          ],
          "method": "remove"
        },
        {
          "arguments": [
            15
          ],
          "method": "contains"
        }
      ],
      "rootValue": 10
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            15
          ],
          "method": "insert"
        },
        {
          "arguments": [
            2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            5
          ],
          "method": "insert"
        },
        {
          "arguments": [
            13
          ],
          "method": "insert"
        },
        {
          "arguments": [
            22
          ],
          "method": "insert"
        },
        {
          "arguments": [
            1
          ],
          "method": "insert"
        },
        {
          "arguments": [
            14
          ],
          "method": "insert"
        },
        {
          "arguments": [
            12
          ],
          "method": "insert"
        },
        {
          "arguments": [
            5
          ],
          "method": "remove"
        },
        {
          "arguments": [
            5
          ],
          "method": "remove"
        },
        {
          "arguments": [
            12
          ],
          "method": "remove"
        },
        {
          "arguments": [
            13
          ],
          "method": "remove"
        },
        {
          "arguments": [
            14
          ],
          "method": "remove"
        },
        {
          "arguments": [
            22
          ],
          "method": "remove"
        },
        {
          "arguments": [
            2
          ],
          "method": "remove"
        },
        {
          "arguments": [
            1
          ],
          "method": "remove"
        },
        {
          "arguments": [
            15
          ],
          "method": "contains"
        }
      ],
      "rootValue": 10
    }
  ],
  "changelog": []
}