{
  "uid": "count-squares",
  "testStrategy": "JSON",
  "name": "Count Squares",
  "version": 0,
  "releaseDate": "2023-04-08T00:00:00Z",
  "category": "Arrays",
  "difficulty": 3,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 869,
    "failureCount": 151
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "785446802",
    "duration": 0,
    "annotations": [],
    "instructor": "Conner Ardman",
    "overviewTime": 0,
    "codeWalkthroughTime": 964
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in a list of Cartesian coordinates (i.e., (x, y)\n  coordinates) and returns the number of squares that can be formed by these\n  coordinates.\n</p>\n<p>\n  A square must have its four corners amongst the coordinates in order to be\n  counted. A single coordinate can be used as a corner for multiple different\n  squares.\n</p>\n<p>\n  You can also assume that no coordinate will be farther than 100 units from the\n  origin.\n</p>\n\n<h3>Sample Input</h3>\n<pre><span class=\"CodeEditor-promptParameter\">points</span> = [\n  [1, 1],\n  [0, 0],\n  [-4, 2],\n  [-2, -1],\n  [0, 1],\n  [1, 0],\n  [-1, 4]\n]</pre>\n<h3>Sample Output</h3>\n<pre>2 <span class=\"CodeEditor-promptComment\"> // [1, 1], [0, 0], [0, 1], and [1, 0] makes a square,\n// as does [1, 1], [-4, 2], [-2, -1], and [-1, 4]</span></pre>",
  "hints": [
    "<p>\n  Given any two points, there are exactly three pairs of points that would make\n  a square.\n</p>\n",
    "\n<p>\n  If two points are assumed to be diagonally across from each other in a square,\n  there is only one pair of points that would complete the square.\n</p>\n",
    "\n<p>\n  All four points of a square will always be equidistant from the midpoint.\n</p>\n",
    "\n<p>\n  The slopes of the two diagonals of a square are always negative reciprocals of\n  each other.\n</p>"
  ],
  "spaceTime": "O(n^2) time | O(n) space - where n is the number of points",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\nint countSquares(vector<vector<int>> points) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <unordered_set>\n\nusing namespace std;\n\nstring pointToString(vector<int> const& point);\nstring dbPointToString(vector<double> const& point);\n\n// O(n^2) time | O(n) space - where n is the number of points\nint countSquares(vector<vector<int>>& points) {\n  unordered_set<string> pointsSet;\n  for (auto const& point : points) {\n    pointsSet.insert(pointToString(point));\n  }\n\n  int count = 0;\n  for (auto const& pointA : points) {\n    for (auto const& pointB : points) {\n      if (pointA == pointB) {\n        continue;\n      }\n\n      vector<double> midpoint = {\n        (pointA[0] + pointB[0]) / 2.0, (pointA[1] + pointB[1]) / 2.0};\n      double xDistanceFromMid = pointA[0] - midpoint[0];\n      double yDistanceFromMid = pointA[1] - midpoint[1];\n\n      vector<double> pointC = {\n        midpoint[0] + yDistanceFromMid, midpoint[1] - xDistanceFromMid};\n      vector<double> pointD = {\n        midpoint[0] - yDistanceFromMid, midpoint[1] + xDistanceFromMid};\n\n      if (pointsSet.count(dbPointToString(pointC)) && pointsSet.count(dbPointToString(pointD))) {\n        count++;\n      }\n    }\n  }\n  return count / 4;\n}\n\nstring pointToString(vector<int> const& point) {\n  return to_string(point[0]) + \",\" + to_string(point[1]);\n}\n\nstring dbPointToString(vector<double> const& point) {\n  if (fmod(point[0], 1) == 0 && fmod(point[1], 1) == 0) {\n    return to_string((int)point[0]) + \",\" + to_string((int)point[1]);\n  }\n  return to_string(point[0]) + \",\" + to_string(point[1]);\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> input = {{1, 1}, {0, 0}, {0, 1}, {1, 0}};\n      auto expected = 1;\n      auto actual = countSquares(input);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> input = {{1, 1}, {0, 0}, {0, 1}, {1, 0}};\n      auto expected = 1;\n      auto actual = countSquares(input);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public int CountSquares(int[][] points) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // O(n^2) time | O(n) space - where n is the number of points\n  public int CountSquares(int[][] points) {\n    HashSet<string> pointsSet = new HashSet<string>();\n    foreach (var point in points) {\n      pointsSet.Add(pointTostring(point));\n    }\n\n    int count = 0;\n    foreach (var pointA in points) {\n      foreach (var pointB in points) {\n        if (pointA == pointB) {\n          continue;\n        }\n\n        double[] midpoint = new double[] {\n          (pointA[0] + pointB[0]) / 2.0, (pointA[1] + pointB[1]) / 2.0\n        };\n        double xDistanceFromMid = pointA[0] - midpoint[0];\n        double yDistanceFromMid = pointA[1] - midpoint[1];\n\n        double[] pointC = new double[] {\n          midpoint[0] + yDistanceFromMid, midpoint[1] - xDistanceFromMid\n        };\n        double[] pointD = new double[] {\n          midpoint[0] - yDistanceFromMid, midpoint[1] + xDistanceFromMid\n        };\n\n        if (pointsSet.Contains(dbPointTostring(pointC)) && pointsSet.Contains(dbPointTostring(pointD))) {\n          count++;\n        }\n      }\n    }\n    return count / 4;\n  }\n\n  private string pointTostring(int[] point) {\n    return point[0] + \",\" + point[1];\n  }\n\n  private string dbPointTostring(double[] point) {\n    if (point[0] % 1 == 0 && point[1] % 1 == 0) {\n      return (int)point[0] + \",\" + (int)point[1];\n    }\n    return point[0] + \",\" + point[1];\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var input = new int[][] {\n      new int[] { 1, 1 },\n      new int[] { 0, 0 },\n      new int[] { 0, 1 },\n      new int[] { 1, 0 }\n    };\n    var expected = 1;\n    var actual = new Program().CountSquares(input);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var input = new int[][] {\n      new int[] { 1, 1 },\n      new int[] { 0, 0 },\n      new int[] { 0, 1 },\n      new int[] { 1, 0 }\n    };\n    var expected = 1;\n    var actual = new Program().CountSquares(input);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc CountSquares(points [][]int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// O(n^2) time | O(n) space - where n is the number of points\nfunc CountSquares(points [][]int) int {\n\tpointsSet := map[string]bool{}\n\tfor _, point := range points {\n\t\tpointsSet[pointToString(point)] = true\n\t}\n\n\tcount := 0\n\tfor i, pointA := range points {\n\t\tfor j, pointB := range points {\n\t\t\tif i == j {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmidpoint := []float64{float64(pointA[0]+pointB[0]) / 2.0, float64(pointA[1]+pointB[1]) / 2.0}\n\t\t\txDistanceFromMid := float64(pointA[0]) - midpoint[0]\n\t\t\tyDistanceFromMid := float64(pointA[1]) - midpoint[1]\n\n\t\t\tpointC := []float64{midpoint[0] + yDistanceFromMid, midpoint[1] - xDistanceFromMid}\n\t\t\tpointD := []float64{midpoint[0] - yDistanceFromMid, midpoint[1] + xDistanceFromMid}\n\n\t\t\tif pointsSet[floatPointToString(pointC)] && pointsSet[floatPointToString(pointD)] {\n\t\t\t\tcount += 1\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count / 4\n}\n\nfunc pointToString(point []int) string {\n\treturn fmt.Sprintf(\"%d,%d\", point[0], point[1])\n}\n\nfunc floatPointToString(point []float64) string {\n\tif point[0] == math.Trunc(point[0]) && point[1] == math.Trunc(point[1]) {\n\t\treturn fmt.Sprintf(\"%d,%d\", int(point[0]), int(point[1]))\n\t}\n\treturn fmt.Sprintf(\"%f,%f\", point[0], point[1])\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{{1, 1}, {0, 0}, {0, 1}, {1, 0}}\n\texpected := 1\n\tactual := CountSquares(input)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{{1, 1}, {0, 0}, {0, 1}, {1, 0}}\n\texpected := 1\n\tactual := CountSquares(input)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public int countSquares(int[][] points) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n^2) time | O(n) space - where n is the number of points\n  public int countSquares(int[][] points) {\n    HashSet<String> pointsSet = new HashSet<String>();\n    for (int[] point : points) {\n      pointsSet.add(pointToString(point));\n    }\n\n    int count = 0;\n    for (int[] pointA : points) {\n      for (int[] pointB : points) {\n        if (pointA == pointB) {\n          continue;\n        }\n\n        double[] midpoint = new double[] {\n          (pointA[0] + pointB[0]) / 2.0, (pointA[1] + pointB[1]) / 2.0};\n        double xDistanceFromMid = pointA[0] - midpoint[0];\n        double yDistanceFromMid = pointA[1] - midpoint[1];\n\n        double[] pointC = new double[] {\n          midpoint[0] + yDistanceFromMid, midpoint[1] - xDistanceFromMid};\n        double[] pointD = new double[] {\n          midpoint[0] - yDistanceFromMid, midpoint[1] + xDistanceFromMid};\n\n        if (pointsSet.contains(dbPointToString(pointC)) && pointsSet.contains(dbPointToString(pointD))) {\n          count++;\n        }\n      }\n    }\n    return count / 4;\n  }\n\n  private String pointToString(int[] point) {\n    return point[0] + \",\" + point[1];\n  }\n\n  private String dbPointToString(double[] point) {\n    if (point[0] % 1 == 0 && point[1] % 1 == 0) {\n      return (int) point[0] + \",\" + (int) point[1];\n    }\n    return point[0] + \",\" + point[1];\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var input = new int[][] {\n      new int[] {1, 1}, new int[] {0, 0}, new int[] {0, 1}, new int[] {1, 0}};\n    var expected = 1;\n    var actual = new Program().countSquares(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var input = new int[][] {\n      new int[] {1, 1}, new int[] {0, 0}, new int[] {0, 1}, new int[] {1, 0}};\n    var expected = 1;\n    var actual = new Program().countSquares(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function countSquares(points) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.countSquares = countSquares;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space - where n is the number of points\nfunction countSquares(points) {\n  const pointsSet = new Set();\n  for (const point of points) {\n    pointsSet.add(pointToString(point));\n  }\n\n  let count = 0;\n  for (const pointA of points) {\n    for (const pointB of points) {\n      if (pointA === pointB) continue;\n\n      const midpoint = [(pointA[0] + pointB[0]) / 2, (pointA[1] + pointB[1]) / 2];\n      const xDistanceFromMid = pointA[0] - midpoint[0];\n      const yDistanceFromMid = pointA[1] - midpoint[1];\n\n      const pointC = [midpoint[0] + yDistanceFromMid, midpoint[1] - xDistanceFromMid];\n      const pointD = [midpoint[0] - yDistanceFromMid, midpoint[1] + xDistanceFromMid];\n\n      if (pointsSet.has(pointToString(pointC)) && pointsSet.has(pointToString(pointD))) {\n        count++;\n      }\n    }\n  }\n\n  return count / 4;\n}\n\nfunction pointToString(point) {\n  return point.join(',');\n}\n\n// Do not edit the line below.\nexports.countSquares = countSquares;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 1],\n    [0, 0],\n    [0, 1],\n    [1, 0],\n  ];\n  const expected = 1;\n  const actual = program.countSquares(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 1],\n    [0, 0],\n    [0, 1],\n    [1, 0],\n  ];\n  const expected = 1;\n  const actual = program.countSquares(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun countSquares(points: MutableList<MutableList<Int>>): Int {\n    // Write your code here.\n    return -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n^2) time | O(n) space - where n is the number of points\nfun countSquares(points: MutableList<MutableList<Int>>): Int {\n    val pointsSet = mutableSetOf<String>()\n    for (point in points) {\n        pointsSet.add(pointToString(listOf(point[0].toDouble(), point[1].toDouble())))\n    }\n\n    var count = 0\n    for (pointA in points) {\n        for (pointB in points) {\n            if (pointA == pointB) continue\n\n            val midpoint =\n                listOf(\n                    (pointA[0] + pointB[0]).toDouble() / 2,\n                    (pointA[1] + pointB[1]).toDouble() / 2,\n                )\n            val xDistanceFromMid = pointA[0] - midpoint[0]\n            val yDistanceFromMid = pointA[1] - midpoint[1]\n\n            val pointC = listOf(midpoint[0] + yDistanceFromMid, midpoint[1] - xDistanceFromMid)\n            val pointD = listOf(midpoint[0] - yDistanceFromMid, midpoint[1] + xDistanceFromMid)\n\n            if (pointsSet.contains(pointToString(pointC)) && pointsSet.contains(pointToString(pointD))) {\n                count++\n            }\n        }\n    }\n\n    return count / 4\n}\n\nfun pointToString(point: List<Double>): String {\n    return point.joinToString(\",\")\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.countSquares\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = mutableListOf(\n            mutableListOf(1, 1),\n            mutableListOf(0, 0),\n            mutableListOf(0, 1),\n            mutableListOf(1, 0),\n        )\n        val expected = 1\n        val output = countSquares(input)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.countSquares\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = mutableListOf(\n            mutableListOf(1, 1),\n            mutableListOf(0, 0),\n            mutableListOf(0, 1),\n            mutableListOf(1, 0),\n        )\n        val expected = 1\n        val output = countSquares(input)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def countSquares(points):\n    # Write your code here.\n    return -1\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n^2) time | O(n) space - where n is the number of points\ndef countSquares(points):\n    pointsSet = set()\n    for point in points:\n        pointsSet.add(pointToString(point))\n\n    count = 0\n    for pointA in points:\n        for pointB in points:\n            if pointA == pointB:\n                continue\n\n            midpoint = [(pointA[0] + pointB[0]) / 2, (pointA[1] + pointB[1]) / 2]\n            xDistanceFromMid = pointA[0] - midpoint[0]\n            yDistanceFromMid = pointA[1] - midpoint[1]\n\n            pointC = [midpoint[0] + yDistanceFromMid, midpoint[1] - xDistanceFromMid]\n            pointD = [midpoint[0] - yDistanceFromMid, midpoint[1] + xDistanceFromMid]\n\n            if pointToString(pointC) in pointsSet and pointToString(pointD) in pointsSet:\n                count += 1\n\n    return count / 4\n\n\ndef pointToString(point):\n    if point[0] % 1 == 0 and point[1] % 1 == 0:\n        point = [int(coordinate) for coordinate in point]\n    return \",\".join([str(coordinate) for coordinate in point])\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [[1, 1], [0, 0], [0, 1], [1, 0]]\n        expected = 1\n        actual = program.countSquares(input)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [[1, 1], [0, 0], [0, 1], [1, 0]]\n        expected = 1\n        actual = program.countSquares(input)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "\nclass Program\n    def countSquares(points)\n        # Write your code here.\n        return -1\n    end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n\nclass Program\n    def countSquares(points)\n        # Write your code here.\n        return -1\n    end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire './program.rb'\n\nclass TestSuite\n    include Assertions\n    def test_1\n        # inputs = ...\n        # output = Program.new.countSquares\n        # expected = ...\n        # assertEqual(expected, output)\n    end\nend\n\n",
      "unitTests": "require './program.rb'\n\nclass TestSuite\n    include Assertions\n    def test_1\n        # inputs = ...\n        # output = Program.new.countSquares\n        # expected = ...\n        # assertEqual(expected, output)\n    end\nend\n\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func countSquares(_ points: [[Int]]) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport Foundation\n\nclass Program {\n  // O(n^2) time | O(n) space - where n is the number of points\n  func countSquares(_ points: [[Int]]) -> Int {\n    var pointsSet: Set<String> = Set()\n    for point in points {\n      pointsSet.insert(pointToString(point))\n    }\n\n    var count = 0\n    for (i, pointA) in points.enumerated() {\n      for (j, pointB) in points.enumerated() {\n        if pointA == pointB {\n          continue\n        }\n\n        let midpoint: [Float] = [Float(pointA[0] + pointB[0]) / 2.0, Float(pointA[1] + pointB[1]) / 2.0]\n        let xDistanceFromMid = Float(pointA[0]) - midpoint[0]\n        let yDistanceFromMid = Float(pointA[1]) - midpoint[1]\n\n        let pointC: [Float] = [midpoint[0] + yDistanceFromMid, midpoint[1] - xDistanceFromMid]\n        let pointD: [Float] = [midpoint[0] - yDistanceFromMid, midpoint[1] + xDistanceFromMid]\n\n        if pointsSet.contains(floatPointToString(pointC)) && pointsSet.contains(floatPointToString(pointD)) {\n          count += 1\n        }\n      }\n    }\n    return count / 4\n  }\n\n  func pointToString(_ point: [Int]) -> String {\n    return \"\\(point[0]),\\(point[1])\"\n  }\n\n  func floatPointToString(_ point: [Float]) -> String {\n    if point[0] == floor(point[0]) && point[1] == floor(point[1]) {\n      return \"\\(Int(point[0])),\\(Int(point[1]))\"\n    }\n    return \"\\(point[0]),\\(point[1])\"\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      let input = [[1, 1], [0, 0], [0, 1], [1, 0]]\n      let expected = 1\n      var actual = Program().countSquares(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      let input = [[1, 1], [0, 0], [0, 1], [1, 0]]\n      let expected = 1\n      var actual = Program().countSquares(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function countSquares(points: number[][]) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space - where n is the number of points\nexport function countSquares(points: number[][]) {\n  const pointsSet = new Set();\n  for (const point of points) {\n    pointsSet.add(pointToString(point));\n  }\n\n  let count = 0;\n  for (const pointA of points) {\n    for (const pointB of points) {\n      if (pointA === pointB) continue;\n\n      const midpoint = [(pointA[0] + pointB[0]) / 2, (pointA[1] + pointB[1]) / 2];\n      const xDistanceFromMid = pointA[0] - midpoint[0];\n      const yDistanceFromMid = pointA[1] - midpoint[1];\n\n      const pointC = [midpoint[0] + yDistanceFromMid, midpoint[1] - xDistanceFromMid];\n      const pointD = [midpoint[0] - yDistanceFromMid, midpoint[1] + xDistanceFromMid];\n\n      if (pointsSet.has(pointToString(pointC)) && pointsSet.has(pointToString(pointD))) {\n        count++;\n      }\n    }\n  }\n\n  return count / 4;\n}\n\nfunction pointToString(point: number[]) {\n  return point.join(',');\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 1],\n    [0, 0],\n    [0, 1],\n    [1, 0],\n  ];\n  const expected = 1;\n  const actual = program.countSquares(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 1],\n    [0, 0],\n    [0, 1],\n    [1, 0],\n  ];\n  const expected = 1;\n  const actual = program.countSquares(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "points",
      "example": [],
      "schema": {
        "items": {
          "items": {
            "type": "integer"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "points": []
    },
    {
      "points": [
        [
          1,
          0
        ]
      ]
    },
    {
      "points": [
        [
          0,
          1
        ],
        [
          1,
          0
        ]
      ]
    },
    {
      "points": [
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          1,
          0
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          1,
          0
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          0,
          0
        ],
        [
          -4,
          2
        ],
        [
          -2,
          -1
        ],
        [
          0,
          1
        ],
        [
          1,
          0
        ],
        [
          -1,
          4
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          3,
          -3
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          -1,
          3
        ],
        [
          6,
          2
        ],
        [
          0,
          -2
        ],
        [
          1,
          0
        ],
        [
          4,
          0
        ],
        [
          5,
          1
        ],
        [
          1,
          5
        ],
        [
          -2,
          0
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          2,
          0
        ]
      ]
    },
    {
      "points": [
        [
          -1,
          -1
        ],
        [
          1,
          1
        ],
        [
          -1,
          1
        ],
        [
          1,
          -1
        ]
      ]
    },
    {
      "points": [
        [
          -2,
          -2
        ],
        [
          2,
          2
        ],
        [
          0,
          0
        ],
        [
          -2,
          2
        ],
        [
          2,
          -2
        ]
      ]
    },
    {
      "points": [
        [
          0,
          0
        ],
        [
          1,
          1
        ],
        [
          1,
          0
        ],
        [
          2,
          1
        ],
        [
          2,
          0
        ]
      ]
    },
    {
      "points": [
        [
          1,
          -1
        ],
        [
          -1,
          3
        ],
        [
          3,
          5
        ],
        [
          5,
          1
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          1,
          0
        ],
        [
          2,
          2
        ],
        [
          1,
          2
        ],
        [
          2,
          1
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          1,
          0
        ],
        [
          -1,
          3
        ],
        [
          3,
          5
        ],
        [
          5,
          1
        ],
        [
          1,
          -1
        ]
      ]
    },
    {
      "points": [
        [
          3,
          1
        ],
        [
          1,
          1
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          3,
          7
        ],
        [
          1,
          0
        ],
        [
          -1,
          3
        ],
        [
          3,
          5
        ],
        [
          5,
          1
        ],
        [
          9,
          1
        ],
        [
          1,
          -1
        ],
        [
          9,
          7
        ]
      ]
    },
    {
      "points": [
        [
          3,
          1
        ],
        [
          1,
          1
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          3,
          7
        ],
        [
          1,
          0
        ],
        [
          -4,
          -2
        ],
        [
          27,
          -5
        ],
        [
          -1,
          3
        ],
        [
          3,
          5
        ],
        [
          5,
          1
        ],
        [
          10,
          -19
        ],
        [
          9,
          1
        ],
        [
          1,
          -1
        ],
        [
          9,
          7
        ],
        [
          13,
          12
        ]
      ]
    },
    {
      "points": [
        [
          3,
          1
        ],
        [
          1,
          1
        ],
        [
          21,
          19
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          3,
          7
        ],
        [
          1,
          0
        ],
        [
          12,
          -14
        ],
        [
          -4,
          -2
        ],
        [
          27,
          -5
        ],
        [
          -1,
          3
        ],
        [
          3,
          5
        ],
        [
          5,
          1
        ],
        [
          10,
          -19
        ],
        [
          9,
          1
        ],
        [
          1,
          -1
        ],
        [
          9,
          7
        ],
        [
          13,
          12
        ],
        [
          0,
          7
        ],
        [
          33,
          -2
        ]
      ]
    },
    {
      "points": [
        [
          21,
          1
        ],
        [
          3,
          1
        ],
        [
          1,
          1
        ],
        [
          21,
          19
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          2,
          3
        ],
        [
          22,
          2
        ],
        [
          3,
          7
        ],
        [
          1,
          0
        ],
        [
          12,
          -14
        ],
        [
          -4,
          -2
        ],
        [
          -22,
          22
        ],
        [
          27,
          -5
        ],
        [
          -1,
          3
        ],
        [
          3,
          5
        ],
        [
          5,
          1
        ],
        [
          10,
          -19
        ],
        [
          9,
          1
        ],
        [
          1,
          -1
        ],
        [
          9,
          7
        ],
        [
          13,
          12
        ],
        [
          0,
          7
        ],
        [
          3,
          19
        ],
        [
          33,
          -2
        ]
      ]
    }
  ],
  "jsonTests": [
    {
      "points": []
    },
    {
      "points": [
        [
          1,
          0
        ]
      ]
    },
    {
      "points": [
        [
          0,
          1
        ],
        [
          1,
          0
        ]
      ]
    },
    {
      "points": [
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          1,
          0
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          1,
          0
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          0,
          0
        ],
        [
          -4,
          2
        ],
        [
          -2,
          -1
        ],
        [
          0,
          1
        ],
        [
          1,
          0
        ],
        [
          -1,
          4
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          3,
          -3
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          -1,
          3
        ],
        [
          6,
          2
        ],
        [
          0,
          -2
        ],
        [
          1,
          0
        ],
        [
          4,
          0
        ],
        [
          5,
          1
        ],
        [
          1,
          5
        ],
        [
          -2,
          0
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          2,
          0
        ]
      ]
    },
    {
      "points": [
        [
          -1,
          -1
        ],
        [
          1,
          1
        ],
        [
          -1,
          1
        ],
        [
          1,
          -1
        ]
      ]
    },
    {
      "points": [
        [
          -2,
          -2
        ],
        [
          2,
          2
        ],
        [
          0,
          0
        ],
        [
          -2,
          2
        ],
        [
          2,
          -2
        ]
      ]
    },
    {
      "points": [
        [
          0,
          0
        ],
        [
          1,
          1
        ],
        [
          1,
          0
        ],
        [
          2,
          1
        ],
        [
          2,
          0
        ]
      ]
    },
    {
      "points": [
        [
          1,
          -1
        ],
        [
          -1,
          3
        ],
        [
          3,
          5
        ],
        [
          5,
          1
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          1,
          0
        ],
        [
          2,
          2
        ],
        [
          1,
          2
        ],
        [
          2,
          1
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          1,
          0
        ],
        [
          -1,
          3
        ],
        [
          3,
          5
        ],
        [
          5,
          1
        ],
        [
          1,
          -1
        ]
      ]
    },
    {
      "points": [
        [
          3,
          1
        ],
        [
          1,
          1
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          3,
          7
        ],
        [
          1,
          0
        ],
        [
          -1,
          3
        ],
        [
          3,
          5
        ],
        [
          5,
          1
        ],
        [
          9,
          1
        ],
        [
          1,
          -1
        ],
        [
          9,
          7
        ]
      ]
    },
    {
      "points": [
        [
          3,
          1
        ],
        [
          1,
          1
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          3,
          7
        ],
        [
          1,
          0
        ],
        [
          -4,
          -2
        ],
        [
          27,
          -5
        ],
        [
          -1,
          3
        ],
        [
          3,
          5
        ],
        [
          5,
          1
        ],
        [
          10,
          -19
        ],
        [
          9,
          1
        ],
        [
          1,
          -1
        ],
        [
          9,
          7
        ],
        [
          13,
          12
        ]
      ]
    },
    {
      "points": [
        [
          3,
          1
        ],
        [
          1,
          1
        ],
        [
          21,
          19
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          3,
          7
        ],
        [
          1,
          0
        ],
        [
          12,
          -14
        ],
        [
          -4,
          -2
        ],
        [
          27,
          -5
        ],
        [
          -1,
          3
        ],
        [
          3,
          5
        ],
        [
          5,
          1
        ],
        [
          10,
          -19
        ],
        [
          9,
          1
        ],
        [
          1,
          -1
        ],
        [
          9,
          7
        ],
        [
          13,
          12
        ],
        [
          0,
          7
        ],
        [
          33,
          -2
        ]
      ]
    },
    {
      "points": [
        [
          21,
          1
        ],
        [
          3,
          1
        ],
        [
          1,
          1
        ],
        [
          21,
          19
        ],
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          2,
          3
        ],
        [
          22,
          2
        ],
        [
          3,
          7
        ],
        [
          1,
          0
        ],
        [
          12,
          -14
        ],
        [
          -4,
          -2
        ],
        [
          -22,
          22
        ],
        [
          27,
          -5
        ],
        [
          -1,
          3
        ],
        [
          3,
          5
        ],
        [
          5,
          1
        ],
        [
          10,
          -19
        ],
        [
          9,
          1
        ],
        [
          1,
          -1
        ],
        [
          9,
          7
        ],
        [
          13,
          12
        ],
        [
          0,
          7
        ],
        [
          3,
          19
        ],
        [
          33,
          -2
        ]
      ]
    }
  ],
  "changelog": []
}