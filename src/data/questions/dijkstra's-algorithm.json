{
  "uid": "dijkstra's-algorithm",
  "testStrategy": "JSON",
  "name": "Dijkstra's Algorithm",
  "version": 0,
  "releaseDate": "2020-11-16T00:00:00Z",
  "category": "Famous Algorithms",
  "difficulty": 3,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 8911,
    "failureCount": 3009
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "472009180",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 2017
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given an integer <span>start</span> and a list <span>edges</span> of\n  pairs of integers.\n</p>\n<p>\n  The list is what's called an adjacency list, and it represents a graph. The\n  number of vertices in the graph is equal to the length of <span>edges</span>,\n  where each index <span>i</span> in <span>edges</span> contains vertex\n  <span>i</span>'s outbound edges, in no particular order. Each individual edge\n  is represented by an pair of two numbers,\n  <span>[destination, distance]</span>, where the destination is a positive\n  integer denoting the destination vertex and the distance is a positive integer\n  representing the length of the edge (the distance from vertex\n  <span>i</span> to vertex <span>destination</span>). Note that these edges are\n  directed, meaning that you can only travel from a particular vertex to its\n  destination—not the other way around (unless the destination vertex itself has\n  an outbound edge to the original vertex).\n</p>\n<p>\n  Write a function that computes the lengths of the shortest paths between\n  <span>start</span> and all of the other vertices in the graph using Dijkstra's\n  algorithm and returns them in an array. Each index <span>i</span> in the\n  output array should represent the length of the shortest path between\n  <span>start</span> and vertex <span>i</span>. If no path is found from\n  <span>start</span> to vertex <span>i</span>, then\n  <span>output[i]</span> should be <span>-1</span>.\n</p>\n<p>\n  Note that the graph represented by <span>edges</span> won't contain any\n  self-loops (vertices that have an outbound edge to themselves) and will only\n  have positively weighted edges (i.e., no negative distances).\n</p>\n<p>\n  If you're unfamiliar with Dijkstra's algorithm, we recommend watching the\n  Conceptual Overview section of this question's video explanation before\n  starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">start</span> = 0\n<span class=\"CodeEditor-promptParameter\">edges</span> = [\n  [[1, 7]],\n  [[2, 6], [3, 20], [4, 3]],\n  [[3, 14]],\n  [[4, 2]],\n  [],\n  [],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[0, 7, 13, 27, 10, -1]\n</pre>\n</div>",
  "hints": [
    "<p>\nDijkstra's algorithm works by visiting vertices in the graph, one by one, all the while keeping track of the current shortest distances from the start vertex to all other vertices and continuously updating these shortest distances. More specifically, the algorithm keeps track of unvisited vertices and visits the unvisited vertex with the shortest distance at any point in time, naturally starting with the start vertex. Whenever the algorithm visits an unvisited vertex, it looks at all of its outbound edges and tries to update the shortest distances from the start to the destinations in the edges, using the current shortest distance to the current vertex as a base. Once the algorithm has visited all of the vertices and considered all of their edges, it is guaranteed to have found the shortest path to each vertex. How can you implement this algorithm?\n</p>\n",
    "\n<p>\nThe most challenging part of Dijkstra's algorithm is determining how to efficiently find the vertex with the current shortest distance. Can you think of a data structure that could be used to keep track of the distances and to efficiently retrieve the vertex with the current shortest distance at each step?\n</p>\n",
    "\n<p>\nCreate an array that can store the final shortest distances between the start vertex and all other vertices, as well as a min-heap that will hold all of the unvisited vertices and their current shortest distances. For both the final distances array and the min-heap, initialize all vertices except for the start node as having a distance of infinity; the start node will have a distance 0. Next, write a while loop that will run until the min-heap is empty. At every iteration in the loop, remove the vertex from the top of the heap (the vertex with the shortest distance), loop through all of its edges, and for each edge, update the shortest distance of the destination vertex to be the minimum of the destination's current shortest distance and the currently visited vertex's distance plus the current edge's weight. Once the heap is empty, all of the vertices will have been visited, and you'll have the shortest distances to all vertices stored in your distances array.\n</p>"
  ],
  "spaceTime": "O((v + e) * log(v)) time | O(v) space - where v is the number of vertices and e is the number of edges in the input graph",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nvector<int> dijkstrasAlgorithm(int start, vector<vector<vector<int>>> edges) {\n  // Write your code here;\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <limits>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntuple<int, int> getVertexWithMinDistances(\n  vector<int> minDistances, set<int> distances\n);\n\n// O(v^2 + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the input graph\nvector<int> dijkstrasAlgorithm(int start, vector<vector<vector<int>>> edges) {\n  int numberOfVertices = edges.size();\n\n  vector<int> minDistances(edges.size(), numeric_limits<int>::max());\n  minDistances[start] = 0;\n\n  set<int> visited;\n\n  while (visited.size() != numberOfVertices) {\n    auto [vertex, currentMinDistance] =\n      getVertexWithMinDistances(minDistances, visited);\n    if (currentMinDistance == numeric_limits<int>::max()) {\n      break;\n    }\n\n    visited.insert(vertex);\n\n    for (auto edge : edges[vertex]) {\n      auto destination = edge[0];\n      auto distanceToDestination = edge[1];\n\n      if (visited.find(destination) != visited.end()) {\n        continue;\n      }\n\n      auto newPathDistance = currentMinDistance + distanceToDestination;\n      auto currentDestinationDistance = minDistances[destination];\n      if (newPathDistance < currentDestinationDistance) {\n        minDistances[destination] = newPathDistance;\n      }\n    }\n  }\n\n  vector<int> finalDistances;\n  for (auto distance : minDistances) {\n    if (distance == numeric_limits<int>::max()) {\n      finalDistances.push_back(-1);\n    } else {\n      finalDistances.push_back(distance);\n    }\n  }\n  return finalDistances;\n}\n\ntuple<int, int> getVertexWithMinDistances(\n  vector<int> distances, set<int> visited\n) {\n  int currentMinDistance = numeric_limits<int>::max();\n  int vertex = -1;\n\n  for (int vertexIdx = 0; vertexIdx < distances.size(); vertexIdx++) {\n    int distance = distances[vertexIdx];\n\n    if (visited.find(vertexIdx) != visited.end()) {\n      continue;\n    }\n\n    if (distance <= currentMinDistance) {\n      vertex = vertexIdx;\n      currentMinDistance = distance;\n    }\n  }\n\n  return {vertex, currentMinDistance};\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <limits>\n#include <vector>\nusing namespace std;\n\nstruct Item {\n  int vertex, distance;\n};\n\nclass MinHeap {\n public:\n  vector<Item> heap;\n  unordered_map<int, int> vertexMap;\n\n  MinHeap(vector<Item> array) {\n    for (auto item : array) {\n      vertexMap[item.vertex] = item.vertex;\n    }\n    heap = buildHeap(array);\n  }\n\n  // O(n) time | O(1) space\n  vector<Item> buildHeap(vector<Item>& array) {\n    int firstParentIdx = (array.size() - 2) / 2;\n    for (int currentIdx = firstParentIdx + 1; currentIdx >= 0; currentIdx--) {\n      siftDown(currentIdx, array.size() - 1, array);\n    }\n    return array;\n  }\n\n  bool isEmpty() { return heap.size() == 0; }\n\n  // O(log(n)) time | O(1) space\n  void siftDown(int currentIdx, int endIdx, vector<Item>& heap) {\n    int childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      int childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      int idxToSwap;\n      if (childTwoIdx != -1 && heap[childTwoIdx].distance < heap[childOneIdx].distance) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap].distance < heap[currentIdx].distance) {\n        swap(currentIdx, idxToSwap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  void siftUp(int currentIdx) {\n    int parentIdx = (currentIdx - 1) / 2;\n    while (currentIdx > 0 &&\n           heap[currentIdx].distance < heap[parentIdx].distance) {\n      swap(currentIdx, parentIdx);\n      currentIdx = parentIdx;\n      parentIdx = (currentIdx - 1) / 2;\n    }\n  }\n\n  Item remove() {\n    swap(0, heap.size() - 1);\n    auto [vertex, distance] = heap.back();\n    heap.pop_back();\n    vertexMap.erase(vertex);\n    siftDown(0, heap.size() - 1, heap);\n    return Item{vertex, distance};\n  }\n\n  void update(int vertex, int value) {\n    heap[vertexMap[vertex]] = Item{vertex, value};\n    siftUp(vertexMap[vertex]);\n  }\n\n  void swap(int i, int j) {\n    vertexMap[heap[i].vertex] = j;\n    vertexMap[heap[j].vertex] = i;\n    auto temp = heap[i];\n    heap[i] = heap[j];\n    heap[j] = temp;\n  }\n};\n\n// O((v + e) * log(v)) time | O(v) space - where v is the number\n// of vertices and e is the number of edges in the input graph\nvector<int> dijkstrasAlgorithm(int start, vector<vector<vector<int>>> edges) {\n  int numberOfVertices = edges.size();\n\n  vector<int> minDistances(edges.size(), numeric_limits<int>::max());\n  minDistances[start] = 0;\n\n  vector<Item> minDistancesPairs;\n  for (int i = 0; i < edges.size(); i++) {\n    minDistancesPairs.push_back(Item{i, numeric_limits<int>::max()});\n  }\n\n  MinHeap minDistancesHeap(minDistancesPairs);\n  minDistancesHeap.update(start, 0);\n\n  while (!minDistancesHeap.isEmpty()) {\n    auto [vertex, currentMinDistance] = minDistancesHeap.remove();\n\n    if (currentMinDistance == numeric_limits<int>::max()) {\n      break;\n    }\n\n    for (auto edge : edges[vertex]) {\n      auto destination = edge[0];\n      auto distanceToDestination = edge[1];\n      auto newPathDistance = currentMinDistance + distanceToDestination;\n      auto currentDestinationDistance = minDistances[destination];\n      if (newPathDistance < currentDestinationDistance) {\n        minDistances[destination] = newPathDistance;\n        minDistancesHeap.update(destination, newPathDistance);\n      }\n    }\n  }\n\n  vector<int> finalDistances;\n  for (auto distance : minDistances) {\n    if (distance == numeric_limits<int>::max()) {\n      finalDistances.push_back(-1);\n    } else {\n      finalDistances.push_back(distance);\n    }\n  }\n  return finalDistances;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto start = 0;\n      vector<vector<vector<int>>> edges = {\n        {{1, 7}}, {{2, 6}, {3, 20}, {4, 3}}, {{3, 14}}, {{4, 2}}, {}, {}};\n      vector<int> expected = {0, 7, 13, 27, 10, -1};\n      auto actual = dijkstrasAlgorithm(start, edges);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto start = 0;\n      vector<vector<vector<int>>> edges = {\n        {{1, 7}}, {{2, 6}, {3, 20}, {4, 3}}, {{3, 14}}, {{4, 2}}, {}, {}};\n      vector<int> expected = {0, 7, 13, 27, 10, -1};\n      auto actual = dijkstrasAlgorithm(start, edges);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public int[] DijkstrasAlgorithm(int start, int[][][] edges) {\n    // Write your code here.\n    return new int[] {};\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(v^2 + e) time | O(v) space - where v is the number of\n  // vertices and e is the number of edges in the input graph\n  public int[] DijkstrasAlgorithm(int start, int[][][] edges) {\n    int numberOfVertices = edges.Length;\n\n    int[] minDistances = new int[edges.Length];\n    Array.Fill(minDistances, Int32.MaxValue);\n    minDistances[start] = 0;\n\n    HashSet<int> visited = new HashSet<int>();\n\n    while (visited.Count != numberOfVertices) {\n      int[] getVertexData = getVertexWithMinDistances(minDistances, visited);\n      int vertex = getVertexData[0];\n      int currentMinDistance = getVertexData[1];\n\n      if (currentMinDistance == Int32.MaxValue) {\n        break;\n      }\n\n      visited.Add(vertex);\n\n      foreach (var edge in edges[vertex]) {\n        int destination = edge[0];\n        int distanceToDestination = edge[1];\n\n        if (visited.Contains(destination)) {\n          continue;\n        }\n\n        int newPathDistance = currentMinDistance + distanceToDestination;\n        int currentDestinationDistance = minDistances[destination];\n        if (newPathDistance < currentDestinationDistance) {\n          minDistances[destination] = newPathDistance;\n        }\n      }\n    }\n\n    int[] finalDistances = new int[minDistances.Length];\n    for (int i = 0; i < minDistances.Length; i++) {\n      int distance = minDistances[i];\n      if (distance == Int32.MaxValue) {\n        finalDistances[i] = -1;\n      } else {\n        finalDistances[i] = distance;\n      }\n    }\n\n    return finalDistances;\n  }\n\n  public int[] getVertexWithMinDistances(\n    int[] distances, HashSet<int> visited\n  ) {\n    int currentMinDistance = Int32.MaxValue;\n    int vertex = -1;\n\n    for (int vertexIdx = 0; vertexIdx < distances.Length; vertexIdx++) {\n      int distance = distances[vertexIdx];\n\n      if (visited.Contains(vertexIdx)) {\n        continue;\n      }\n\n      if (distance <= currentMinDistance) {\n        vertex = vertexIdx;\n        currentMinDistance = distance;\n      }\n    }\n\n    return new int[] { vertex, currentMinDistance };\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // O((v + e) * log(v)) time | O(v) space - where v is the number\n  // of vertices and e is the number of edges in the input graph\n  public int[] DijkstrasAlgorithm(int start, int[][][] edges) {\n    int numberOfVertices = edges.Length;\n\n    int[] minDistances = new int[numberOfVertices];\n    Array.Fill(minDistances, Int32.MaxValue);\n    minDistances[start] = 0;\n\n    List<Item> minDistancesPairs = new List<Item>();\n    for (int i = 0; i < numberOfVertices; i++) {\n      Item item = new Item(i, Int32.MaxValue);\n      minDistancesPairs.Add(item);\n    }\n\n    MinHeap minDistancesHeap = new MinHeap(minDistancesPairs);\n    minDistancesHeap.Update(start, 0);\n\n    while (!minDistancesHeap.isEmpty()) {\n      Item heapItem = minDistancesHeap.Remove();\n      int vertex = heapItem.vertex;\n      int currentMinDistance = heapItem.distance;\n\n      if (currentMinDistance == Int32.MaxValue) {\n        break;\n      }\n\n      foreach (var edge in edges[vertex]) {\n        int destination = edge[0];\n        int distanceToDestination = edge[1];\n        int newPathDistance = currentMinDistance + distanceToDestination;\n        int currentDestinationDistance = minDistances[destination];\n        if (newPathDistance < currentDestinationDistance) {\n          minDistances[destination] = newPathDistance;\n          minDistancesHeap.Update(destination, newPathDistance);\n        }\n      }\n    }\n\n    int[] finalDistances = new int[minDistances.Length];\n    for (int i = 0; i < minDistances.Length; i++) {\n      int distance = minDistances[i];\n      if (distance == Int32.MaxValue) {\n        finalDistances[i] = -1;\n      } else {\n        finalDistances[i] = distance;\n      }\n    }\n\n    return finalDistances;\n  }\n\n  public class Item {\n    public int vertex;\n    public int distance;\n\n    public Item(int vertex, int distance) {\n      this.vertex = vertex;\n      this.distance = distance;\n    }\n  };\n\n  public class MinHeap {\n    Dictionary<int, int> vertexDictionary = new Dictionary<int, int>();\n    List<Item> heap = new List<Item>();\n\n    public MinHeap(List<Item> array) {\n      for (int i = 0; i < array.Count; i++) {\n        Item item = array[i];\n        vertexDictionary[item.vertex] = item.vertex;\n      }\n      heap = buildHeap(array);\n    }\n\n    List<Item> buildHeap(List<Item> array) {\n      int firstParentIdx = (array.Count - 2) / 2;\n      for (int currentIdx = firstParentIdx + 1; currentIdx >= 0; currentIdx--) {\n        siftDown(currentIdx, array.Count - 1, array);\n      }\n      return array;\n    }\n\n    public bool isEmpty() {\n      return heap.Count == 0;\n    }\n\n    void siftDown(int currentIdx, int endIdx, List<Item> heap) {\n      int childOneIdx = currentIdx * 2 + 1;\n      while (childOneIdx <= endIdx) {\n        int childTwoIdx =\n          currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n        int idxToSwap;\n        if (childTwoIdx != -1 && heap[childTwoIdx].distance < heap[childOneIdx].distance) {\n          idxToSwap = childTwoIdx;\n        } else {\n          idxToSwap = childOneIdx;\n        }\n        if (heap[idxToSwap].distance < heap[currentIdx].distance) {\n          swap(currentIdx, idxToSwap);\n          currentIdx = idxToSwap;\n          childOneIdx = currentIdx * 2 + 1;\n        } else {\n          return;\n        }\n      }\n    }\n\n    void siftUp(int currentIdx) {\n      int parentIdx = (currentIdx - 1) / 2;\n      while (currentIdx > 0 &&\n             heap[currentIdx].distance < heap[parentIdx].distance) {\n        swap(currentIdx, parentIdx);\n        currentIdx = parentIdx;\n        parentIdx = (currentIdx - 1) / 2;\n      }\n    }\n\n    public Item Remove() {\n      swap(0, heap.Count - 1);\n      Item lastItem = heap[heap.Count - 1];\n      int vertex = lastItem.vertex;\n      int distance = lastItem.distance;\n      heap.RemoveAt(heap.Count - 1);\n      vertexDictionary.Remove(vertex);\n      siftDown(0, heap.Count - 1, heap);\n      return new Item(vertex, distance);\n    }\n\n    public void Update(int vertex, int value) {\n      heap[vertexDictionary[vertex]] = new Item(vertex, value);\n      siftUp(vertexDictionary[vertex]);\n    }\n\n    void swap(int i, int j) {\n      vertexDictionary[heap[i].vertex] = j;\n      vertexDictionary[heap[j].vertex] = i;\n      Item temp = heap[i];\n      heap[i] = heap[j];\n      heap[j] = temp;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int start = 0;\n    int[][][] edges = {\n      new int[][] { new int[] { 1, 7 } },\n      new int[][] {\n        new int[] { 2, 6 }, new int[] { 3, 20 }, new int[] { 4, 3 }\n      },\n      new int[][] { new int[] { 3, 14 } },\n      new int[][] { new int[] { 4, 2 } },\n      new int[][] {},\n      new int[][] {}\n    };\n    int[] expected = { 0, 7, 13, 27, 10, -1 };\n    int[] actual = new Program().DijkstrasAlgorithm(start, edges);\n    Utils.AssertTrue(expected.Length == actual.Length);\n    for (int i = 0; i < expected.Length; i++) {\n      Utils.AssertTrue(expected[i] == actual[i]);\n    }\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int start = 0;\n    int[][][] edges = {\n      new int[][] { new int[] { 1, 7 } },\n      new int[][] {\n        new int[] { 2, 6 }, new int[] { 3, 20 }, new int[] { 4, 3 }\n      },\n      new int[][] { new int[] { 3, 14 } },\n      new int[][] { new int[] { 4, 2 } },\n      new int[][] {},\n      new int[][] {}\n    };\n    int[] expected = { 0, 7, 13, 27, 10, -1 };\n    int[] actual = new Program().DijkstrasAlgorithm(start, edges);\n    Utils.AssertTrue(expected.Length == actual.Length);\n    for (int i = 0; i < expected.Length; i++) {\n      Utils.AssertTrue(expected[i] == actual[i]);\n    }\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc DijkstrasAlgorithm(start int, edges [][][]int) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t\"math\"\n)\n\n// O(v^2 + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the input graph\nfunc DijkstrasAlgorithm(start int, edges [][][]int) []int {\n\tnumberOfVertices := len(edges)\n\n\tminDistances := make([]int, 0, len(edges))\n\tfor range edges {\n\t\tminDistances = append(minDistances, math.MaxInt32)\n\t}\n\tminDistances[start] = 0\n\n\tvisited := map[int]bool{}\n\n\tfor len(visited) != numberOfVertices {\n\t\tvertex, currentMinDistance := getVertexWithMinDistance(minDistances, visited)\n\t\tif currentMinDistance == math.MaxInt32 {\n\t\t\tbreak\n\t\t}\n\n\t\tvisited[vertex] = true\n\n\t\tfor _, edge := range edges[vertex] {\n\t\t\tdestination, distanceToDestination := edge[0], edge[1]\n\n\t\t\tif visited[destination] {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tnewPathDistance := currentMinDistance + distanceToDestination\n\t\t\tcurrentDestinationDistance := minDistances[destination]\n\t\t\tif newPathDistance < currentDestinationDistance {\n\t\t\t\tminDistances[destination] = newPathDistance\n\t\t\t}\n\t\t}\n\t}\n\n\tfinalDistances := make([]int, 0, len(minDistances))\n\tfor _, distance := range minDistances {\n\t\tif distance == math.MaxInt32 {\n\t\t\tfinalDistances = append(finalDistances, -1)\n\t\t} else {\n\t\t\tfinalDistances = append(finalDistances, distance)\n\t\t}\n\t}\n\treturn finalDistances\n}\n\nfunc getVertexWithMinDistance(distances []int, visited map[int]bool) (int, int) {\n\tcurrentMinDistance := math.MaxInt32\n\tvertex := -1\n\n\tfor vertexIdx, distance := range distances {\n\t\tif visited[vertexIdx] {\n\t\t\tcontinue\n\t\t}\n\n\t\tif distance <= currentMinDistance {\n\t\t\tvertex = vertexIdx\n\t\t\tcurrentMinDistance = distance\n\t\t}\n\t}\n\n\treturn vertex, currentMinDistance\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t\"math\"\n)\n\n// O((v + e) * log(v)) time | O(v) space - where v is the number\n// of vertices and e is the number of edges in the input graph\nfunc DijkstrasAlgorithm(start int, edges [][][]int) []int {\n\tnumberOfVertices := len(edges)\n\n\tminDistances := make([]int, 0, numberOfVertices)\n\tfor range edges {\n\t\tminDistances = append(minDistances, math.MaxInt32)\n\t}\n\tminDistances[start] = 0\n\n\tminDistancesPairs := make([]Item, 0, len(edges))\n\tfor i := range edges {\n\t\tminDistancesPairs = append(minDistancesPairs, Item{i, math.MaxInt32})\n\t}\n\tminDistancesHeap := NewMinHeap(minDistancesPairs)\n\tminDistancesHeap.Update(start, 0)\n\n\tfor !minDistancesHeap.IsEmpty() {\n\t\tvertex, currentMinDistance := minDistancesHeap.Remove()\n\t\tif currentMinDistance == math.MaxInt32 {\n\t\t\tbreak\n\t\t}\n\n\t\tfor _, edge := range edges[vertex] {\n\t\t\tdestination, distanceToDestination := edge[0], edge[1]\n\n\t\t\tnewPathDistance := currentMinDistance + distanceToDestination\n\t\t\tcurrentDestinationDistance := minDistances[destination]\n\t\t\tif newPathDistance < currentDestinationDistance {\n\t\t\t\tminDistances[destination] = newPathDistance\n\t\t\t\tminDistancesHeap.Update(destination, newPathDistance)\n\t\t\t}\n\t\t}\n\t}\n\n\tfinalDistances := make([]int, 0, len(minDistances))\n\tfor _, distance := range minDistances {\n\t\tif distance == math.MaxInt32 {\n\t\t\tfinalDistances = append(finalDistances, -1)\n\t\t} else {\n\t\t\tfinalDistances = append(finalDistances, distance)\n\t\t}\n\t}\n\treturn finalDistances\n}\n\ntype Item struct {\n\tVertex   int\n\tDistance int\n}\n\ntype MinHeap struct {\n\tarray     []Item\n\tvertexMap map[int]int\n}\n\nfunc NewMinHeap(array []Item) *MinHeap {\n\tvertexMap := map[int]int{}\n\tfor _, item := range array {\n\t\tvertexMap[item.Vertex] = item.Vertex\n\t}\n\theap := &MinHeap{array: array, vertexMap: vertexMap}\n\theap.buildHeap()\n\treturn heap\n}\n\nfunc (h *MinHeap) IsEmpty() bool { return h.length() == 0 }\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) Remove() (int, int) {\n\tl := h.length()\n\th.swap(0, l-1)\n\tpeeked := h.array[l-1]\n\th.array = h.array[0 : l-1]\n\tdelete(h.vertexMap, peeked.Vertex)\n\th.siftDown(0, l-2)\n\treturn peeked.Vertex, peeked.Distance\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) Update(vertex int, value int) {\n\th.array[h.vertexMap[vertex]] = Item{vertex, value}\n\th.siftUp(h.vertexMap[vertex])\n}\n\nfunc (h MinHeap) swap(i, j int) {\n\th.vertexMap[h.array[i].Vertex] = j\n\th.vertexMap[h.array[j].Vertex] = i\n\th.array[i], h.array[j] = h.array[j], h.array[i]\n}\n\nfunc (h MinHeap) length() int { return len(h.array) }\n\n// O(n) time | O(1) space\nfunc (h *MinHeap) buildHeap() {\n\tfirst := (len(h.array) - 2) / 2\n\tfor currentIdx := first + 1; currentIdx >= 0; currentIdx-- {\n\t\th.siftDown(currentIdx, len(h.array)-1)\n\t}\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) siftDown(currentIdx, endIdx int) {\n\tchildOneIdx := currentIdx*2 + 1\n\tfor childOneIdx <= endIdx {\n\t\tchildTwoIdx := -1\n\t\tif currentIdx*2+2 <= endIdx {\n\t\t\tchildTwoIdx = currentIdx*2 + 2\n\t\t}\n\t\tindexToSwap := childOneIdx\n\t\tif childTwoIdx > -1 && h.array[childTwoIdx].Distance < h.array[childOneIdx].Distance {\n\t\t\tindexToSwap = childTwoIdx\n\t\t}\n\n\t\tif h.array[indexToSwap].Distance < h.array[currentIdx].Distance {\n\t\t\th.swap(currentIdx, indexToSwap)\n\t\t\tcurrentIdx = indexToSwap\n\t\t\tchildOneIdx = currentIdx*2 + 1\n\t\t} else {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) siftUp(currentIdx int) {\n\tparentIdx := (currentIdx - 1) / 2\n\tfor currentIdx > 0 && h.array[currentIdx].Distance < h.array[parentIdx].Distance {\n\t\th.swap(currentIdx, parentIdx)\n\t\tcurrentIdx = parentIdx\n\t\tparentIdx = (currentIdx - 1) / 2\n\t}\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tstart := 0\n\tedges := [][][]int{\n\t\t{{1, 7}},\n\t\t{{2, 6}, {3, 20}, {4, 3}},\n\t\t{{3, 14}},\n\t\t{{4, 2}},\n\t\t{},\n\t\t{},\n\t}\n\texpected := []int{0, 7, 13, 27, 10, -1}\n\tactual := DijkstrasAlgorithm(start, edges)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tstart := 0\n\tedges := [][][]int{\n\t\t{{1, 7}},\n\t\t{{2, 6}, {3, 20}, {4, 3}},\n\t\t{{3, 14}},\n\t\t{{4, 2}},\n\t\t{},\n\t\t{},\n\t}\n\texpected := []int{0, 7, 13, 27, 10, -1}\n\tactual := DijkstrasAlgorithm(start, edges)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public int[] dijkstrasAlgorithm(int start, int[][][] edges) {\n    // Write your code here.\n    return new int[] {};\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(v^2 + e) time | O(v) space - where v is the number of\n  // vertices and e is the number of edges in the input graph\n  public int[] dijkstrasAlgorithm(int start, int[][][] edges) {\n    int numberOfVertices = edges.length;\n\n    int[] minDistances = new int[edges.length];\n    Arrays.fill(minDistances, Integer.MAX_VALUE);\n    minDistances[start] = 0;\n\n    Set<Integer> visited = new HashSet<Integer>();\n\n    while (visited.size() != numberOfVertices) {\n      int[] getVertexData = getVertexWithMinDistances(minDistances, visited);\n      int vertex = getVertexData[0];\n      int currentMinDistance = getVertexData[1];\n\n      if (currentMinDistance == Integer.MAX_VALUE) {\n        break;\n      }\n\n      visited.add(vertex);\n\n      for (int[] edge : edges[vertex]) {\n        int destination = edge[0];\n        int distanceToDestination = edge[1];\n\n        if (visited.contains(destination)) {\n          continue;\n        }\n\n        int newPathDistance = currentMinDistance + distanceToDestination;\n        int currentDestinationDistance = minDistances[destination];\n        if (newPathDistance < currentDestinationDistance) {\n          minDistances[destination] = newPathDistance;\n        }\n      }\n    }\n\n    int[] finalDistances = new int[minDistances.length];\n    for (int i = 0; i < minDistances.length; i++) {\n      int distance = minDistances[i];\n      if (distance == Integer.MAX_VALUE) {\n        finalDistances[i] = -1;\n      } else {\n        finalDistances[i] = distance;\n      }\n    }\n\n    return finalDistances;\n  }\n\n  public int[] getVertexWithMinDistances(\n    int[] distances, Set<Integer> visited\n  ) {\n    int currentMinDistance = Integer.MAX_VALUE;\n    int vertex = -1;\n\n    for (int vertexIdx = 0; vertexIdx < distances.length; vertexIdx++) {\n      int distance = distances[vertexIdx];\n\n      if (visited.contains(vertexIdx)) {\n        continue;\n      }\n\n      if (distance <= currentMinDistance) {\n        vertex = vertexIdx;\n        currentMinDistance = distance;\n      }\n    }\n\n    return new int[] {vertex, currentMinDistance};\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O((v + e) * log(v)) time | O(v) space - where v is the number\n  // of vertices and e is the number of edges in the input graph\n  public int[] dijkstrasAlgorithm(int start, int[][][] edges) {\n    int numberOfVertices = edges.length;\n\n    int[] minDistances = new int[numberOfVertices];\n    Arrays.fill(minDistances, Integer.MAX_VALUE);\n    minDistances[start] = 0;\n\n    List<Item> minDistancesPairs = new ArrayList<Item>();\n    for (int i = 0; i < numberOfVertices; i++) {\n      Item item = new Item(i, Integer.MAX_VALUE);\n      minDistancesPairs.add(item);\n    }\n\n    MinHeap minDistancesHeap = new MinHeap(minDistancesPairs);\n    minDistancesHeap.update(start, 0);\n\n    while (!minDistancesHeap.isEmpty()) {\n      Item heapItem = minDistancesHeap.remove();\n      int vertex = heapItem.vertex;\n      int currentMinDistance = heapItem.distance;\n\n      if (currentMinDistance == Integer.MAX_VALUE) {\n        break;\n      }\n\n      for (int[] edge : edges[vertex]) {\n        int destination = edge[0];\n        int distanceToDestination = edge[1];\n        int newPathDistance = currentMinDistance + distanceToDestination;\n        int currentDestinationDistance = minDistances[destination];\n        if (newPathDistance < currentDestinationDistance) {\n          minDistances[destination] = newPathDistance;\n          minDistancesHeap.update(destination, newPathDistance);\n        }\n      }\n    }\n\n    int[] finalDistances = new int[minDistances.length];\n    for (int i = 0; i < minDistances.length; i++) {\n      int distance = minDistances[i];\n      if (distance == Integer.MAX_VALUE) {\n        finalDistances[i] = -1;\n      } else {\n        finalDistances[i] = distance;\n      }\n    }\n\n    return finalDistances;\n  }\n\n  static class Item {\n    int vertex;\n    int distance;\n\n    public Item(int vertex, int distance) {\n      this.vertex = vertex;\n      this.distance = distance;\n    }\n  };\n\n  static class MinHeap {\n    Map<Integer, Integer> vertexMap = new HashMap<Integer, Integer>();\n    List<Item> heap = new ArrayList<Item>();\n\n    public MinHeap(List<Item> array) {\n      for (int i = 0; i < array.size(); i++) {\n        Item item = array.get(i);\n        vertexMap.put(item.vertex, item.vertex);\n      }\n      heap = buildHeap(array);\n    }\n\n    List<Item> buildHeap(List<Item> array) {\n      int firstParentIdx = (array.size() - 2) / 2;\n      for (int currentIdx = firstParentIdx + 1; currentIdx >= 0; currentIdx--) {\n        siftDown(currentIdx, array.size() - 1, array);\n      }\n      return array;\n    }\n\n    boolean isEmpty() {\n      return heap.size() == 0;\n    }\n\n    void siftDown(int currentIdx, int endIdx, List<Item> heap) {\n      int childOneIdx = currentIdx * 2 + 1;\n      while (childOneIdx <= endIdx) {\n        int childTwoIdx =\n          currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n        int idxToSwap;\n        if (childTwoIdx != -1\n            && heap.get(childTwoIdx).distance\n                < heap.get(childOneIdx).distance) {\n          idxToSwap = childTwoIdx;\n        } else {\n          idxToSwap = childOneIdx;\n        }\n        if (heap.get(idxToSwap).distance < heap.get(currentIdx).distance) {\n          swap(currentIdx, idxToSwap);\n          currentIdx = idxToSwap;\n          childOneIdx = currentIdx * 2 + 1;\n        } else {\n          return;\n        }\n      }\n    }\n\n    void siftUp(int currentIdx) {\n      int parentIdx = (currentIdx - 1) / 2;\n      while (currentIdx > 0\n             && heap.get(currentIdx).distance < heap.get(parentIdx).distance) {\n        swap(currentIdx, parentIdx);\n        currentIdx = parentIdx;\n        parentIdx = (currentIdx - 1) / 2;\n      }\n    }\n\n    Item remove() {\n      if (isEmpty()) {\n        return null;\n      }\n\n      swap(0, heap.size() - 1);\n      Item lastItem = heap.get(heap.size() - 1);\n      int vertex = lastItem.vertex;\n      int distance = lastItem.distance;\n      heap.remove(heap.size() - 1);\n      vertexMap.remove(vertex);\n      siftDown(0, heap.size() - 1, heap);\n      return new Item(vertex, distance);\n    }\n\n    void update(int vertex, int value) {\n      heap.set(vertexMap.get(vertex), new Item(vertex, value));\n      siftUp(vertexMap.get(vertex));\n    }\n\n    void swap(int i, int j) {\n      vertexMap.put(heap.get(i).vertex, j);\n      vertexMap.put(heap.get(j).vertex, i);\n      Item temp = heap.get(i);\n      heap.set(i, heap.get(j));\n      heap.set(j, temp);\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int start = 0;\n    int[][][] edges = {\n      {{1, 7}}, {{2, 6}, {3, 20}, {4, 3}}, {{3, 14}}, {{4, 2}}, {}, {}};\n    int[] expected = {0, 7, 13, 27, 10, -1};\n    int[] actual = new Program().dijkstrasAlgorithm(start, edges);\n    Utils.assertTrue(expected.length == actual.length);\n    for (int i = 0; i < expected.length; i++) {\n      Utils.assertTrue(expected[i] == actual[i]);\n    }\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int start = 0;\n    int[][][] edges = {\n      {{1, 7}}, {{2, 6}, {3, 20}, {4, 3}}, {{3, 14}}, {{4, 2}}, {}, {}};\n    int[] expected = {0, 7, 13, 27, 10, -1};\n    int[] actual = new Program().dijkstrasAlgorithm(start, edges);\n    Utils.assertTrue(expected.length == actual.length);\n    for (int i = 0; i < expected.length; i++) {\n      Utils.assertTrue(expected[i] == actual[i]);\n    }\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function dijkstrasAlgorithm(start, edges) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.dijkstrasAlgorithm = dijkstrasAlgorithm;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(v^2 + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the input graph\nfunction dijkstrasAlgorithm(start, edges) {\n  const numberOfVertices = edges.length;\n\n  const minDistances = [];\n  for (let i = 0; i < numberOfVertices; i++) {\n    minDistances.push(Infinity);\n  }\n  minDistances[start] = 0;\n\n  const visited = new Set();\n\n  while (visited.size != numberOfVertices) {\n    const [vertex, currentMinDistance] = getVertexWithMinDistance(minDistances, visited);\n\n    if (currentMinDistance === Infinity) {\n      break;\n    }\n\n    visited.add(vertex);\n\n    for (const edge of edges[vertex]) {\n      const [destination, distanceToDestination] = edge;\n\n      if (visited.has(destination)) {\n        continue;\n      }\n\n      const newPathDistance = currentMinDistance + distanceToDestination;\n      const currentDestinationDistance = minDistances[destination];\n      if (newPathDistance < currentDestinationDistance) {\n        minDistances[destination] = newPathDistance;\n      }\n    }\n  }\n\n  return minDistances.map(x => x === Infinity ? -1 : x);\n}\n\nfunction getVertexWithMinDistance(distances, visited) {\n  let currentMinDistance = Infinity;\n  let vertex = -1;\n\n  for (const [vertexIdx, distance] of distances.entries()) {\n    if (visited.has(vertexIdx)) {\n      continue;\n    }\n    if (distance <= currentMinDistance) {\n      vertex = vertexIdx;\n      currentMinDistance = distance;\n    }\n  }\n\n  return [vertex, currentMinDistance];\n}\n\n// Do not edit the line below.\nexports.dijkstrasAlgorithm = dijkstrasAlgorithm;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O((v + e) * log(v)) time | O(v) space - where v is the number\n// of vertices and e is the number of edges in the input graph\nfunction dijkstrasAlgorithm(start, edges) {\n  const numberOfVertices = edges.length;\n\n  const minDistances = [];\n  const initialDistances = [];\n  for (let i = 0; i < numberOfVertices; i++) {\n    minDistances.push(Infinity);\n    initialDistances.push([i, Infinity]);\n  }\n  minDistances[start] = 0;\n\n  const minDistancesHeap = new MinHeap(initialDistances);\n  minDistancesHeap.update(start, 0);\n\n  while (!minDistancesHeap.isEmpty()) {\n    const [vertex, currentMinDistance] = minDistancesHeap.remove();\n\n    if (currentMinDistance === Infinity) {\n      break;\n    }\n\n    for (const edge of edges[vertex]) {\n      const [destination, distanceToDestination] = edge;\n\n      const newPathDistance = currentMinDistance + distanceToDestination;\n      const currentDestinationDistance = minDistances[destination];\n      if (newPathDistance < currentDestinationDistance) {\n        minDistances[destination] = newPathDistance;\n        minDistancesHeap.update(destination, newPathDistance);\n      }\n    }\n  }\n\n  return minDistances.map(x => x === Infinity ? -1 : x);\n}\n\nclass MinHeap {\n  constructor(array) {\n    // Holds the position in the heap that each vertex is at\n    this.vertexMap = array.reduce((obj, _, i) => {\n      obj[i] = i;\n      return obj;\n    }, {});\n    this.heap = this.buildHeap(array);\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  // O(n) time | O(1) space\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  // O(log(n)) time | O(1) space\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx][1] < heap[childOneIdx][1]) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap][1] < heap[currentIdx][1]) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx][1] < heap[parentIdx][1]) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  remove() {\n    if (this.isEmpty()) return;\n\n    this.swap(0, this.heap.length - 1, this.heap);\n    const [vertex, distance] = this.heap.pop();\n    delete this.vertexMap[vertex];\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return [vertex, distance];\n  }\n\n  swap(i, j, heap) {\n    this.vertexMap[heap[i][0]] = j;\n    this.vertexMap[heap[j][0]] = i;\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n\n  update(vertex, value) {\n    this.heap[this.vertexMap[vertex]] = [vertex, value];\n    this.siftUp(this.vertexMap[vertex], this.heap);\n  }\n}\n\n// Do not edit the line below.\nexports.dijkstrasAlgorithm = dijkstrasAlgorithm;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const start = 0;\n  const edges = [\n    [[1, 7]],\n    [\n      [2, 6],\n      [3, 20],\n      [4, 3],\n    ],\n    [[3, 14]],\n    [[4, 2]],\n    [],\n    [],\n  ];\n  const expected = [0, 7, 13, 27, 10, -1];\n  const actual = program.dijkstrasAlgorithm(start, edges);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const start = 0;\n  const edges = [\n    [[1, 7]],\n    [\n      [2, 6],\n      [3, 20],\n      [4, 3],\n    ],\n    [[3, 14]],\n    [[4, 2]],\n    [],\n    [],\n  ];\n  const expected = [0, 7, 13, 27, 10, -1];\n  const actual = program.dijkstrasAlgorithm(start, edges);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun dijkstrasAlgorithm(start: Int, edges: List<List<List<Int>>>): List<Int> {\n    // Write your code here.\n    return listOf()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(v^2 + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the input graph\nfun dijkstrasAlgorithm(start: Int, edges: List<List<List<Int>>>): List<Int> {\n    val numberOfVertices = edges.size\n\n    val minDistances = MutableList(edges.size) { Int.MAX_VALUE }\n    minDistances[start] = 0\n\n    val visited = mutableSetOf<Int>()\n\n    while (visited.size != numberOfVertices) {\n        val (vertex, currentMinDistance) = getVertexWithMinDistance(minDistances, visited)\n\n        if (currentMinDistance == Int.MAX_VALUE) break\n\n        visited.add(vertex)\n\n        for (edge in edges[vertex]) {\n            val (destination, distanceToDestination) = edge\n\n            if (destination in visited) continue\n\n            val newPathDistance = currentMinDistance + distanceToDestination\n            val currentDestinationDistance = minDistances[destination]\n            if (newPathDistance < currentDestinationDistance) {\n                minDistances[destination] = newPathDistance\n            }\n        }\n    }\n\n    return minDistances.map() { x -> if (x == Int.MAX_VALUE) -1 else x }\n}\n\nfun getVertexWithMinDistance(distances: List<Int>, visited: Set<Int>): Pair<Int, Int> {\n    var currentMinDistance = Int.MAX_VALUE\n    var vertex = -1\n\n    for (vertexIdx in 0 until distances.size) {\n        val distance = distances[vertexIdx]\n        if (vertexIdx in visited) continue\n        if (distance <= currentMinDistance) {\n            vertex = vertexIdx\n            currentMinDistance = distance\n        }\n    }\n\n    return Pair(vertex, currentMinDistance)\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O((v + e) * log(v)) time | O(v) space - where v is the number\n// of vertices and e is the number of edges in the input graph\nfun dijkstrasAlgorithm(start: Int, edges: List<List<List<Int>>>): List<Int> {\n    val numberOfVertices = edges.size\n\n    val minDistances = MutableList(edges.size) { Int.MAX_VALUE }\n    minDistances[start] = 0\n\n    val minDistancesPairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 0 until edges.size) {\n        minDistancesPairs.add(Pair(i, Int.MAX_VALUE))\n    }\n    val minDistancesHeap = MinHeap(minDistancesPairs)\n    minDistancesHeap.update(start, 0)\n\n    while (!minDistancesHeap.isEmpty()) {\n        val (vertex, currentMinDistance) = minDistancesHeap.remove()!!\n\n        if (currentMinDistance == Int.MAX_VALUE) break\n\n        for (edge in edges[vertex]) {\n            val (destination, distanceToDestination) = edge\n\n            val newPathDistance = currentMinDistance + distanceToDestination\n            val currentDestinationDistance = minDistances[destination]\n            if (newPathDistance < currentDestinationDistance) {\n                minDistances[destination] = newPathDistance\n                minDistancesHeap.update(destination, newPathDistance)\n            }\n        }\n    }\n\n    return minDistances.map() { x -> if (x == Int.MAX_VALUE) -1 else x }\n}\n\nopen class MinHeap(array: MutableList<Pair<Int, Int>>) {\n    // Holds the position in the heap that each vertex is at\n    val vertexMap = array.associate({ it.first to it.first }).toMutableMap()\n    val heap = this.buildHeap(array)\n\n    // O(n) time | O(1) space\n    fun buildHeap(array: MutableList<Pair<Int, Int>>): MutableList<Pair<Int, Int>> {\n        val firstParentIdx = (array.size - 2) / 2\n        for (currentIdx in firstParentIdx downTo 0) {\n            this.siftDown(currentIdx, array.size - 1, array)\n        }\n        return array\n    }\n\n    fun isEmpty(): Boolean {\n        return this.heap.size == 0\n    }\n\n    // O(log(n)) time | O(1) space\n    fun siftDown(currentIdx: Int, endIdx: Int, heap: MutableList<Pair<Int, Int>>) {\n        var newCurrentIdx = currentIdx\n        var childOneIdx = currentIdx * 2 + 1\n        while (childOneIdx <= endIdx) {\n            var childTwoIdx = if (newCurrentIdx * 2 + 2 <= endIdx) newCurrentIdx * 2 + 2 else -1\n            var idxToSwap: Int\n            if (childTwoIdx != -1 && heap[childTwoIdx].second < heap[childOneIdx].second) {\n                idxToSwap = childTwoIdx\n            } else {\n                idxToSwap = childOneIdx\n            }\n            if (heap[idxToSwap].second < heap[newCurrentIdx].second) {\n                this.swap(newCurrentIdx, idxToSwap, heap)\n                newCurrentIdx = idxToSwap\n                childOneIdx = newCurrentIdx * 2 + 1\n            } else {\n                return\n            }\n        }\n    }\n\n    // O(log(n)) time | O(1) space\n    fun siftUp(currentIdx: Int, heap: MutableList<Pair<Int, Int>>) {\n        var newCurrentIdx = currentIdx\n        var parentIdx = (currentIdx - 1) / 2\n        while (newCurrentIdx > 0 && heap[newCurrentIdx].second < heap[parentIdx].second) {\n            this.swap(newCurrentIdx, parentIdx, heap)\n            newCurrentIdx = parentIdx\n            parentIdx = (newCurrentIdx - 1) / 2\n        }\n    }\n\n    // O(log(n)) time | O(1) space\n    fun remove(): Pair<Int, Int>? {\n        if (this.isEmpty()) return null\n\n        this.swap(0, this.heap.size - 1, this.heap)\n        val (vertex, distance) = this.heap.removeAt(this.heap.size - 1)\n        this.vertexMap.remove(vertex)\n        this.siftDown(0, this.heap.size - 1, this.heap)\n        return Pair(vertex, distance)\n    }\n\n    fun swap(i: Int, j: Int, heap: MutableList<Pair<Int, Int>>) {\n        this.vertexMap[heap[i].first] = j\n        this.vertexMap[heap[j].first] = i\n        val temp = heap[j]\n        heap[j] = heap[i]\n        heap[i] = temp\n    }\n\n    fun update(vertex: Int, value: Int) {\n        this.heap[this.vertexMap[vertex]!!] = Pair(vertex, value)\n        this.siftUp(this.vertexMap[vertex]!!, this.heap)\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.dijkstrasAlgorithm\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val start = 0\n        val edges = listOf(\n            listOf(listOf(1, 7)),\n            listOf(listOf(2, 6), listOf(3, 20), listOf(4, 3)),\n            listOf(listOf(3, 14)),\n            listOf(listOf(4, 2)),\n            listOf(),\n            listOf(),\n        )\n        val expected = listOf(0, 7, 13, 27, 10, -1)\n        val output = dijkstrasAlgorithm(start, edges)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.dijkstrasAlgorithm\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val start = 0\n        val edges = listOf(\n            listOf(listOf(1, 7)),\n            listOf(listOf(2, 6), listOf(3, 20), listOf(4, 3)),\n            listOf(listOf(3, 14)),\n            listOf(listOf(4, 2)),\n            listOf(),\n            listOf(),\n        )\n        val expected = listOf(0, 7, 13, 27, 10, -1)\n        val output = dijkstrasAlgorithm(start, edges)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def dijkstrasAlgorithm(start, edges):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(v^2 + e) time | O(v) space - where v is the number of\n# vertices and e is the number of edges in the input graph\ndef dijkstrasAlgorithm(start, edges):\n    numberOfVertices = len(edges)\n\n    minDistances = [float(\"inf\") for _ in range(numberOfVertices)]\n    minDistances[start] = 0\n\n    visited = set()\n\n    while len(visited) != numberOfVertices:\n        vertex, currentMinDistance = getVertexWithMinDistance(minDistances, visited)\n\n        if currentMinDistance == float(\"inf\"):\n            break\n\n        visited.add(vertex)\n\n        for edge in edges[vertex]:\n            destination, distanceToDestination = edge\n\n            if destination in visited:\n                continue\n\n            newPathDistance = currentMinDistance + distanceToDestination\n            currentDestinationDistance = minDistances[destination]\n            if newPathDistance < currentDestinationDistance:\n                minDistances[destination] = newPathDistance\n\n    return list(map(lambda x: -1 if x == float(\"inf\") else x, minDistances))\n\n\ndef getVertexWithMinDistance(distances, visited):\n    currentMinDistance = float(\"inf\")\n    vertex = -1\n\n    for vertexIdx, distance in enumerate(distances):\n        if vertexIdx in visited:\n            continue\n        if distance <= currentMinDistance:\n            vertex = vertexIdx\n            currentMinDistance = distance\n\n    return vertex, currentMinDistance\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O((v + e) * log(v)) time | O(v) space - where v is the number\n# of vertices and e is the number of edges in the input graph\ndef dijkstrasAlgorithm(start, edges):\n    numberOfVertices = len(edges)\n\n    minDistances = [float(\"inf\") for _ in range(numberOfVertices)]\n    minDistances[start] = 0\n\n    minDistancesHeap = MinHeap([(idx, float(\"inf\")) for idx in range(numberOfVertices)])\n    minDistancesHeap.update(start, 0)\n\n    while not minDistancesHeap.isEmpty():\n        vertex, currentMinDistance = minDistancesHeap.remove()\n\n        if currentMinDistance == float(\"inf\"):\n            break\n\n        for edge in edges[vertex]:\n            destination, distanceToDestination = edge\n\n            newPathDistance = currentMinDistance + distanceToDestination\n            currentDestinationDistance = minDistances[destination]\n            if newPathDistance < currentDestinationDistance:\n                minDistances[destination] = newPathDistance\n                minDistancesHeap.update(destination, newPathDistance)\n\n    return list(map(lambda x: -1 if x == float(\"inf\") else x, minDistances))\n\n\nclass MinHeap:\n    def __init__(self, array):\n        # Holds the position in the heap that each vertex is at\n        self.vertexMap = {idx: idx for idx in range(len(array))}\n        self.heap = self.buildHeap(array)\n\n    def isEmpty(self):\n        return len(self.heap) == 0\n\n    # O(n) time | O(1) space\n    def buildHeap(self, array):\n        firstParentIdx = (len(array) - 2) // 2\n        for currentIdx in reversed(range(firstParentIdx + 1)):\n            self.siftDown(currentIdx, len(array) - 1, array)\n        return array\n\n    # O(log(n)) time | O(1) space\n    def siftDown(self, currentIdx, endIdx, heap):\n        childOneIdx = currentIdx * 2 + 1\n        while childOneIdx <= endIdx:\n            childTwoIdx = currentIdx * 2 + 2 if currentIdx * 2 + 2 <= endIdx else -1\n            if childTwoIdx != -1 and heap[childTwoIdx][1] < heap[childOneIdx][1]:\n                idxToSwap = childTwoIdx\n            else:\n                idxToSwap = childOneIdx\n            if heap[idxToSwap][1] < heap[currentIdx][1]:\n                self.swap(currentIdx, idxToSwap, heap)\n                currentIdx = idxToSwap\n                childOneIdx = currentIdx * 2 + 1\n            else:\n                return\n\n    # O(log(n)) time | O(1) space\n    def siftUp(self, currentIdx, heap):\n        parentIdx = (currentIdx - 1) // 2\n        while currentIdx > 0 and heap[currentIdx][1] < heap[parentIdx][1]:\n            self.swap(currentIdx, parentIdx, heap)\n            currentIdx = parentIdx\n            parentIdx = (currentIdx - 1) // 2\n\n    # O(log(n)) time | O(1) space\n    def remove(self):\n        if self.isEmpty():\n            return\n\n        self.swap(0, len(self.heap) - 1, self.heap)\n        vertex, distance = self.heap.pop()\n        self.vertexMap.pop(vertex)\n        self.siftDown(0, len(self.heap) - 1, self.heap)\n        return vertex, distance\n\n    def swap(self, i, j, heap):\n        self.vertexMap[heap[i][0]] = j\n        self.vertexMap[heap[j][0]] = i\n        heap[i], heap[j] = heap[j], heap[i]\n\n    def update(self, vertex, value):\n        self.heap[self.vertexMap[vertex]] = (vertex, value)\n        self.siftUp(self.vertexMap[vertex], self.heap)\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        start = 0\n        edges = [[[1, 7]], [[2, 6], [3, 20], [4, 3]], [[3, 14]], [[4, 2]], [], []]\n        expected = [0, 7, 13, 27, 10, -1]\n        actual = program.dijkstrasAlgorithm(start, edges)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        start = 0\n        edges = [[[1, 7]], [[2, 6], [3, 20], [4, 3]], [[3, 14]], [[4, 2]], [], []]\n        expected = [0, 7, 13, 27, 10, -1]\n        actual = program.dijkstrasAlgorithm(start, edges)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def dijkstrasAlgorithm(start, edges)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def dijkstrasAlgorithm(start, edges)\n    # Write your code here.\n    return []\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def dijkstrasAlgorithm(start, edges)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.dijkstrasAlgorithm\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.dijkstrasAlgorithm\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func dijkstrasAlgorithm(_ start: Int, _ edges: [[[Int]]]) -> [Int] {\n    // Write your code here.\n    return [Int]()\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(v^2 + e) time | O(v) space - where v is the number of\n  // vertices and e is the number of edges in the input graph\n  func dijkstrasAlgorithm(_ start: Int, _ edges: [[[Int]]]) -> [Int] {\n    let numOfVertices = edges.count\n\n    var minDistances = Array(repeating: Int.max, count: numOfVertices)\n    minDistances[start] = 0\n\n    var visited = Set<Int>()\n\n    while visited.count != numOfVertices {\n      let (vertex, currentMinDistance) = getVertexWithMinDistance(&minDistances, &visited)\n      if currentMinDistance == Int.max {\n        break\n      }\n\n      visited.insert(vertex)\n\n      for edge in edges[vertex] {\n        var (destination, distanceToDestination) = (edge[0], edge[1])\n\n        if visited.contains(destination) {\n          continue\n        }\n\n        let newPathDistance = currentMinDistance + distanceToDestination\n        let currentDestinationDistance = minDistances[destination]\n        if newPathDistance < currentDestinationDistance {\n          minDistances[destination] = newPathDistance\n        }\n      }\n    }\n    return minDistances.map {\n      if $0 == Int.max {\n        return -1\n      }\n      return $0\n    }\n  }\n\n  func getVertexWithMinDistance(_ distances: inout [Int], _ visited: inout Set<Int>) -> (Int, Int) {\n    var currentMinDistance = Int.max\n    var vertex = -1\n\n    for vertexIdx in 0 ..< distances.count {\n      let distance = distances[vertexIdx]\n      if visited.contains(vertexIdx) {\n        continue\n      }\n\n      if distance <= currentMinDistance {\n        vertex = vertexIdx\n        currentMinDistance = distance\n      }\n    }\n    return (vertex, currentMinDistance)\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O((v + e) * log(v)) time | O(v) space - where v is the number\n  // of vertices and e is the number of edges in the input graph\n  func dijkstrasAlgorithm(_ start: Int, _ edges: [[[Int]]]) -> [Int] {\n    let numOfVertices = edges.count\n\n    var minDistances = Array(repeating: Int.max, count: numOfVertices)\n    minDistances[start] = 0\n\n    var minDistancesPairs = [Item]()\n    for i in 0 ..< edges.count {\n      minDistancesPairs.append(Item(vertex: i, distance: Int.max))\n    }\n\n    let minDistancesHeap = MinHeap(&minDistancesPairs)\n    minDistancesHeap.update(start, 0)\n\n    while !minDistancesHeap.isEmpty() {\n      let (vertex, currentMinDistance) = minDistancesHeap.remove()!\n\n      if currentMinDistance == Int.max {\n        break\n      }\n\n      for edge in edges[vertex] {\n        let (destination, distanceToDestination) = (edge[0], edge[1])\n\n        let newPathDistance = currentMinDistance + distanceToDestination\n        let currentDestinationDistance = minDistances[destination]\n        if newPathDistance < currentDestinationDistance {\n          minDistances[destination] = newPathDistance\n          minDistancesHeap.update(destination, newPathDistance)\n        }\n      }\n    }\n\n    return minDistances.map {\n      if $0 == Int.max {\n        return -1\n      }\n      return $0\n    }\n  }\n\n  struct Item {\n    var vertex: Int\n    var distance: Int\n  }\n\n  class MinHeap {\n    var heap = [Item]()\n    var vertexMap = [Int: Int]()\n\n    init(_ array: inout [Item]) {\n      for item in array {\n        vertexMap[item.vertex] = item.vertex\n      }\n      heap = array\n      buildHeap(array: &array)\n    }\n\n    // O(n) time | O(1) space\n    func buildHeap(array: inout [Item]) {\n      var firstParentIndex = Double((array.count - 2) / 2)\n      firstParentIndex = firstParentIndex.rounded(.down)\n\n      for currentIndex in stride(from: Int(firstParentIndex), through: 0, by: -1) {\n        let endIndex = array.count - 1\n        siftDown(currentIndex, endIndex)\n      }\n    }\n\n    // O(log(n)) time | O(1) space\n    func siftDown(_ currentIndex: Int, _ endIndex: Int) {\n      var childOneIndex = currentIndex * 2 + 1\n      var current = currentIndex\n      while childOneIndex <= endIndex {\n        var childTwoIndex = -1\n        if current * 2 + 2 <= endIndex {\n          childTwoIndex = current * 2 + 2\n        }\n        var indexToSwap = childOneIndex\n        if childTwoIndex > -1, heap[childTwoIndex].distance < heap[childOneIndex].distance {\n          indexToSwap = childTwoIndex\n        }\n\n        if heap[indexToSwap].distance < heap[current].distance {\n          swap(current, indexToSwap)\n          current = indexToSwap\n          childOneIndex = current * 2 + 1\n        } else {\n          return\n        }\n      }\n    }\n\n    // O(log(n)) time | O(1) space\n    func siftUp(_ currentIndex: Int) {\n      var currentIndex = currentIndex\n      var parentIndex = (currentIndex - 1) / 2\n\n      while currentIndex > 0, heap[currentIndex].distance < heap[parentIndex].distance {\n        swap(currentIndex, parentIndex)\n        currentIndex = parentIndex\n        parentIndex = (currentIndex - 1) / 2\n      }\n    }\n\n    // O(log(n)) time | O(1) space\n    func remove() -> (Int, Int)? {\n      if isEmpty() {\n        return nil\n      }\n\n      let l = heap.count\n      swap(0, l - 1)\n      let peeked = heap[l - 1]\n      heap.removeLast()\n      vertexMap.removeValue(forKey: peeked.vertex)\n      siftDown(0, l - 2)\n      return (peeked.vertex, peeked.distance)\n    }\n\n    // O(log(n)) time | O(1) space\n    func update(_ vertex: Int, _ value: Int) {\n      heap[vertexMap[vertex]!] = Item(vertex: vertex, distance: value)\n      siftUp(vertexMap[vertex]!)\n    }\n\n    func swap(_ i: Int, _ j: Int) {\n      vertexMap[heap[i].vertex] = j\n      vertexMap[heap[j].vertex] = i\n\n      let temp = heap[i]\n      heap[i] = heap[j]\n      heap[j] = temp\n    }\n\n    func isEmpty() -> Bool {\n      return heap.count == 0\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var start = 0\n      var edges = [\n        [[1, 7]],\n        [[2, 6], [3, 20], [4, 3]],\n        [[3, 14]],\n        [[4, 2]],\n        [],\n        [],\n      ]\n      var expected = [0, 7, 13, 27, 10, -1]\n      var actual = Program().dijkstrasAlgorithm(start, edges)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var start = 0\n      var edges = [\n        [[1, 7]],\n        [[2, 6], [3, 20], [4, 3]],\n        [[3, 14]],\n        [[4, 2]],\n        [],\n        [],\n      ]\n      var expected = [0, 7, 13, 27, 10, -1]\n      var actual = Program().dijkstrasAlgorithm(start, edges)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function dijkstrasAlgorithm(start: number, edges: number[][][]) {\n  // Write your code here.\n  return edges.map(vertex => 0);\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(v^2 + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the input graph\nexport function dijkstrasAlgorithm(start: number, edges: number[][][]) {\n  const numberOfVertices = edges.length;\n\n  const minDistances: number[] = [];\n  for (let i = 0; i < numberOfVertices; i++) {\n    minDistances.push(Infinity);\n  }\n  minDistances[start] = 0;\n\n  const visited = new Set<number>();\n\n  while (visited.size != numberOfVertices) {\n    const [vertex, currentMinDistance] = getVertexWithMinDistance(minDistances, visited);\n\n    if (currentMinDistance === Infinity) {\n      break;\n    }\n\n    visited.add(vertex);\n\n    for (const edge of edges[vertex]) {\n      const [destination, distanceToDestination] = edge;\n\n      if (visited.has(destination)) {\n        continue;\n      }\n\n      const newPathDistance = currentMinDistance + distanceToDestination;\n      const currentDestinationDistance = minDistances[destination];\n      if (newPathDistance < currentDestinationDistance) {\n        minDistances[destination] = newPathDistance;\n      }\n    }\n  }\n\n  return minDistances.map(x => x === Infinity ? -1 : x);\n}\n\nfunction getVertexWithMinDistance(distances: number[], visited: Set<number>) {\n  let currentMinDistance = Infinity;\n  let vertex = -1;\n\n  for (const [vertexIdx, distance] of distances.entries()) {\n    if (visited.has(vertexIdx)) {\n      continue;\n    }\n    if (distance <= currentMinDistance) {\n      vertex = vertexIdx;\n      currentMinDistance = distance;\n    }\n  }\n\n  return [vertex, currentMinDistance];\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O((v + e) * log(v)) time | O(v) space - where v is the number\n// of vertices and e is the number of edges in the input graph\nexport function dijkstrasAlgorithm(start: number, edges: number[][][]) {\n  const numberOfVertices = edges.length;\n\n  const minDistances: number[] = [];\n  const initialDistances: [number, number][] = [];\n  for (let i = 0; i < numberOfVertices; i++) {\n    minDistances.push(Infinity);\n    initialDistances.push([i, Infinity]);\n  }\n  minDistances[start] = 0;\n\n  const minDistancesHeap = new MinHeap(initialDistances);\n  minDistancesHeap.update(start, 0);\n\n  while (!minDistancesHeap.isEmpty()) {\n    const [vertex, currentMinDistance] = minDistancesHeap.remove()!;\n\n    if (currentMinDistance === Infinity) {\n      break;\n    }\n\n    for (const edge of edges[vertex]) {\n      const [destination, distanceToDestination] = edge;\n\n      const newPathDistance = currentMinDistance + distanceToDestination;\n      const currentDestinationDistance = minDistances[destination];\n      if (newPathDistance < currentDestinationDistance) {\n        minDistances[destination] = newPathDistance;\n        minDistancesHeap.update(destination, newPathDistance);\n      }\n    }\n  }\n\n  return minDistances.map(x => x === Infinity ? -1 : x);\n}\n\nclass MinHeap {\n  vertexMap: {[vertex: number]: number};\n  heap: [number, number][];\n\n  constructor(array: [number, number][]) {\n    // Holds the position in the heap that each vertex is at\n    this.vertexMap = array.reduce((obj, _, i) => {\n      obj[i] = i;\n      return obj;\n    }, {} as {[vertex: number]: number});\n    this.heap = this.buildHeap(array);\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  // O(n) time | O(1) space\n  buildHeap(array: [number, number][]) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  // O(log(n)) time | O(1) space\n  siftDown(currentIdx: number, endIdx: number, heap: [number, number][]) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx][1] < heap[childOneIdx][1]) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap][1] < heap[currentIdx][1]) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  siftUp(currentIdx: number, heap: [number, number][]) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx][1] < heap[parentIdx][1]) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  remove() {\n    if (this.isEmpty()) return;\n\n    this.swap(0, this.heap.length - 1, this.heap);\n    const [vertex, distance] = this.heap.pop()!;\n    delete this.vertexMap[vertex];\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return [vertex, distance];\n  }\n\n  swap(i: number, j: number, heap: [number, number][]) {\n    this.vertexMap[heap[i][0]] = j;\n    this.vertexMap[heap[j][0]] = i;\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n\n  update(vertex: number, value: number) {\n    this.heap[this.vertexMap[vertex]] = [vertex, value];\n    this.siftUp(this.vertexMap[vertex], this.heap);\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const start = 0;\n  const edges = [\n    [[1, 7]],\n    [\n      [2, 6],\n      [3, 20],\n      [4, 3],\n    ],\n    [[3, 14]],\n    [[4, 2]],\n    [],\n    [],\n  ];\n  const expected = [0, 7, 13, 27, 10, -1];\n  const actual = program.dijkstrasAlgorithm(start, edges);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const start = 0;\n  const edges = [\n    [[1, 7]],\n    [\n      [2, 6],\n      [3, 20],\n      [4, 3],\n    ],\n    [[3, 14]],\n    [[4, 2]],\n    [],\n    [],\n  ];\n  const expected = [0, 7, 13, 27, 10, -1];\n  const actual = program.dijkstrasAlgorithm(start, edges);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "start",
      "example": 0,
      "schema": {
        "type": "integer"
      }
    },
    {
      "name": "edges",
      "example": [
        [
          [
            1,
            7
          ]
        ],
        [
          [
            2,
            6
          ],
          [
            3,
            20
          ],
          [
            4,
            3
          ]
        ],
        [
          [
            3,
            14
          ]
        ],
        [
          [
            4,
            2
          ]
        ],
        [],
        []
      ],
      "schema": {
        "items": {
          "items": {
            "items": {
              "items": {
                "maxItems": 2,
                "minItems": 2
              },
              "type": "integer"
            },
            "type": "array"
          },
          "type": "array"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "edges": [
        [
          [
            1,
            7
          ]
        ],
        [
          [
            2,
            6
          ],
          [
            3,
            20
          ],
          [
            4,
            3
          ]
        ],
        [
          [
            3,
            14
          ]
        ],
        [
          [
            4,
            2
          ]
        ],
        [],
        []
      ],
      "start": 0
    },
    {
      "edges": [
        [],
        [],
        [],
        []
      ],
      "start": 1
    },
    {
      "edges": [
        [
          [
            1,
            1
          ],
          [
            3,
            1
          ]
        ],
        [
          [
            2,
            1
          ]
        ],
        [
          [
            6,
            1
          ]
        ],
        [
          [
            1,
            3
          ],
          [
            2,
            4
          ],
          [
            4,
            2
          ],
          [
            5,
            3
          ],
          [
            6,
            5
          ]
        ],
        [
          [
            5,
            1
          ]
        ],
        [
          [
            4,
            1
          ]
        ],
        [
          [
            5,
            2
          ]
        ],
        [
          [
            0,
            7
          ]
        ]
      ],
      "start": 7
    },
    {
      "edges": [
        [
          [
            1,
            3
          ],
          [
            2,
            2
          ]
        ],
        [
          [
            3,
            7
          ]
        ],
        [
          [
            1,
            2
          ],
          [
            3,
            4
          ],
          [
            4,
            1
          ]
        ],
        [],
        [
          [
            0,
            2
          ],
          [
            1,
            8
          ],
          [
            3,
            1
          ]
        ]
      ],
      "start": 4
    },
    {
      "edges": [
        [
          [
            1,
            2
          ]
        ],
        [
          [
            0,
            1
          ]
        ],
        [
          [
            3,
            1
          ]
        ],
        [
          [
            2,
            2
          ]
        ]
      ],
      "start": 1
    },
    {
      "edges": [
        [
          [
            1,
            1
          ],
          [
            7,
            8
          ]
        ],
        [
          [
            2,
            1
          ]
        ],
        [
          [
            3,
            1
          ]
        ],
        [
          [
            4,
            1
          ]
        ],
        [
          [
            5,
            1
          ]
        ],
        [
          [
            6,
            1
          ]
        ],
        [
          [
            7,
            1
          ]
        ],
        []
      ],
      "start": 0
    },
    {
      "edges": [
        [
          [
            1,
            2
          ],
          [
            3,
            3
          ],
          [
            4,
            2
          ]
        ],
        [
          [
            0,
            1
          ],
          [
            6,
            3
          ]
        ],
        [
          [
            3,
            9
          ]
        ],
        [
          [
            0,
            3
          ],
          [
            1,
            4
          ],
          [
            4,
            4
          ],
          [
            8,
            7
          ]
        ],
        [
          [
            0,
            1
          ],
          [
            10,
            3
          ]
        ],
        [
          [
            7,
            1
          ],
          [
            8,
            4
          ]
        ],
        [
          [
            8,
            1
          ]
        ],
        [],
        [
          [
            7,
            1
          ]
        ],
        [
          [
            10,
            2
          ]
        ],
        []
      ],
      "start": 3
    },
    {
      "edges": [
        [
          [
            1,
            4
          ],
          [
            7,
            11
          ]
        ],
        [
          [
            0,
            4
          ],
          [
            2,
            11
          ],
          [
            7,
            14
          ]
        ],
        [
          [
            1,
            11
          ],
          [
            3,
            10
          ],
          [
            5,
            7
          ],
          [
            8,
            5
          ]
        ],
        [
          [
            2,
            10
          ],
          [
            4,
            12
          ],
          [
            5,
            17
          ]
        ],
        [
          [
            3,
            12
          ],
          [
            5,
            13
          ],
          [
            6,
            3
          ]
        ],
        [
          [
            2,
            7
          ],
          [
            3,
            17
          ],
          [
            4,
            13
          ],
          [
            6,
            5
          ]
        ],
        [
          [
            4,
            3
          ],
          [
            5,
            6
          ],
          [
            7,
            4
          ],
          [
            9,
            8
          ]
        ],
        [
          [
            0,
            11
          ],
          [
            1,
            14
          ],
          [
            6,
            4
          ],
          [
            8,
            10
          ]
        ],
        [
          [
            2,
            5
          ],
          [
            6,
            9
          ],
          [
            7,
            10
          ]
        ],
        []
      ],
      "start": 8
    },
    {
      "edges": [
        [
          [
            2,
            4
          ]
        ],
        [
          [
            0,
            2
          ]
        ],
        [
          [
            1,
            1
          ],
          [
            3,
            2
          ]
        ],
        [
          [
            0,
            3
          ]
        ]
      ],
      "start": 3
    }
  ],
  "jsonTests": [
    {
      "edges": [
        [
          [
            1,
            7
          ]
        ],
        [
          [
            2,
            6
          ],
          [
            3,
            20
          ],
          [
            4,
            3
          ]
        ],
        [
          [
            3,
            14
          ]
        ],
        [
          [
            4,
            2
          ]
        ],
        [],
        []
      ],
      "start": 0
    },
    {
      "edges": [
        [],
        [],
        [],
        []
      ],
      "start": 1
    },
    {
      "edges": [
        [
          [
            1,
            1
          ],
          [
            3,
            1
          ]
        ],
        [
          [
            2,
            1
          ]
        ],
        [
          [
            6,
            1
          ]
        ],
        [
          [
            1,
            3
          ],
          [
            2,
            4
          ],
          [
            4,
            2
          ],
          [
            5,
            3
          ],
          [
            6,
            5
          ]
        ],
        [
          [
            5,
            1
          ]
        ],
        [
          [
            4,
            1
          ]
        ],
        [
          [
            5,
            2
          ]
        ],
        [
          [
            0,
            7
          ]
        ]
      ],
      "start": 7
    },
    {
      "edges": [
        [
          [
            1,
            3
          ],
          [
            2,
            2
          ]
        ],
        [
          [
            3,
            7
          ]
        ],
        [
          [
            1,
            2
          ],
          [
            3,
            4
          ],
          [
            4,
            1
          ]
        ],
        [],
        [
          [
            0,
            2
          ],
          [
            1,
            8
          ],
          [
            3,
            1
          ]
        ]
      ],
      "start": 4
    },
    {
      "edges": [
        [
          [
            1,
            2
          ]
        ],
        [
          [
            0,
            1
          ]
        ],
        [
          [
            3,
            1
          ]
        ],
        [
          [
            2,
            2
          ]
        ]
      ],
      "start": 1
    },
    {
      "edges": [
        [
          [
            1,
            1
          ],
          [
            7,
            8
          ]
        ],
        [
          [
            2,
            1
          ]
        ],
        [
          [
            3,
            1
          ]
        ],
        [
          [
            4,
            1
          ]
        ],
        [
          [
            5,
            1
          ]
        ],
        [
          [
            6,
            1
          ]
        ],
        [
          [
            7,
            1
          ]
        ],
        []
      ],
      "start": 0
    },
    {
      "edges": [
        [
          [
            1,
            2
          ],
          [
            3,
            3
          ],
          [
            4,
            2
          ]
        ],
        [
          [
            0,
            1
          ],
          [
            6,
            3
          ]
        ],
        [
          [
            3,
            9
          ]
        ],
        [
          [
            0,
            3
          ],
          [
            1,
            4
          ],
          [
            4,
            4
          ],
          [
            8,
            7
          ]
        ],
        [
          [
            0,
            1
          ],
          [
            10,
            3
          ]
        ],
        [
          [
            7,
            1
          ],
          [
            8,
            4
          ]
        ],
        [
          [
            8,
            1
          ]
        ],
        [],
        [
          [
            7,
            1
          ]
        ],
        [
          [
            10,
            2
          ]
        ],
        []
      ],
      "start": 3
    },
    {
      "edges": [
        [
          [
            1,
            4
          ],
          [
            7,
            11
          ]
        ],
        [
          [
            0,
            4
          ],
          [
            2,
            11
          ],
          [
            7,
            14
          ]
        ],
        [
          [
            1,
            11
          ],
          [
            3,
            10
          ],
          [
            5,
            7
          ],
          [
            8,
            5
          ]
        ],
        [
          [
            2,
            10
          ],
          [
            4,
            12
          ],
          [
            5,
            17
          ]
        ],
        [
          [
            3,
            12
          ],
          [
            5,
            13
          ],
          [
            6,
            3
          ]
        ],
        [
          [
            2,
            7
          ],
          [
            3,
            17
          ],
          [
            4,
            13
          ],
          [
            6,
            5
          ]
        ],
        [
          [
            4,
            3
          ],
          [
            5,
            6
          ],
          [
            7,
            4
          ],
          [
            9,
            8
          ]
        ],
        [
          [
            0,
            11
          ],
          [
            1,
            14
          ],
          [
            6,
            4
          ],
          [
            8,
            10
          ]
        ],
        [
          [
            2,
            5
          ],
          [
            6,
            9
          ],
          [
            7,
            10
          ]
        ],
        []
      ],
      "start": 8
    },
    {
      "edges": [
        [
          [
            2,
            4
          ]
        ],
        [
          [
            0,
            2
          ]
        ],
        [
          [
            1,
            1
          ],
          [
            3,
            2
          ]
        ],
        [
          [
            0,
            3
          ]
        ]
      ],
      "start": 3
    }
  ],
  "changelog": []
}