{
  "uid": "group-anagrams",
  "testStrategy": "JSON",
  "name": "Group Anagrams",
  "version": 0,
  "releaseDate": "2019-11-21T00:00:00Z",
  "category": "Strings",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 31269,
    "failureCount": 7825
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "373243741",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1227
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in an array of strings and groups anagrams together.\n</p>\n<p>\n  Anagrams are strings made up of exactly the same letters, where order doesn't\n  matter. For example, <span>\"cinema\"</span> and <span>\"iceman\"</span> are\n  anagrams; similarly, <span>\"foo\"</span> and <span>\"ofo\"</span> are anagrams.\n</p>\n<p>\n  Your function should return a list of anagram groups in no particular order.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">words</span> = [\"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\"]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[[\"yo\", \"oy\"], [\"flop\", \"olfp\"], [\"act\", \"tac\", \"cat\"], [\"foo\"]]\n</pre>\n</div>",
  "hints": [
    "<p>\nTry rearranging every input string such that each string's letters are ordered in alphabetical order. What can you do with the resulting strings?\n</p>\n",
    "\n<p>\nFor any two of the resulting strings mentioned in Hint #1 that are equal to each other, their original strings (with their letters in normal order) must be anagrams. Realizing this, you could bucket all of these resulting strings together, all the while keeping track of their original strings, to find the groups of anagrams.\n</p>\n",
    "\n<p>\nCan you simply store the resulting strings mentioned in Hint #1 in a hash table and find the groups of anagrams using this hash table?\n</p>"
  ],
  "spaceTime": "O(w * n * log(n)) time | O(wn) space - where w is the number of words and n is the length of the longest word",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\n\nusing namespace std;\n\nvector<vector<string>> groupAnagrams(vector<string> words) {\n  // Write your code here.\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <numeric>\n#include <vector>\n\nusing namespace std;\n\n// O(w * n * log(n) + n * w * log(w)) time | O(wn) space - where w is the number\n// of words and n is the length of the longest word\nvector<vector<string>> groupAnagrams(vector<string> words) {\n  if (words.size() == 0) return {};\n\n  vector<string> sortedWords = {};\n  for (auto word : words) {\n    sort(word.begin(), word.end());\n    sortedWords.push_back(word);\n  }\n\n  vector<int> indices(words.size());\n  iota(indices.begin(), indices.end(), 0);\n  sort(indices.begin(), indices.end(), [sortedWords](int a, int b) -> bool {\n    return sortedWords[a] < sortedWords[b];\n  });\n\n  vector<vector<string>> result = {};\n  vector<string> currentAnagramGroup = {};\n  string currentAnagram = sortedWords[indices[0]];\n  for (auto index : indices) {\n    string word = words[index];\n    string sortedWord = sortedWords[index];\n\n    if (sortedWord == currentAnagram) {\n      currentAnagramGroup.push_back(word);\n      continue;\n    }\n\n    result.push_back(currentAnagramGroup);\n    currentAnagramGroup = vector<string>{word};\n    currentAnagram = sortedWord;\n  }\n\n  result.push_back(currentAnagramGroup);\n\n  return result;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\n// O(w * n * log(n)) time | O(wn) space - where w is the number of words and n\n// is the length of the longest word\nvector<vector<string>> groupAnagrams(vector<string> words) {\n  unordered_map<string, vector<string>> anagrams;\n\n  for (auto word : words) {\n    string sortedWord = word;\n    sort(sortedWord.begin(), sortedWord.end());\n\n    if (anagrams.find(sortedWord) != anagrams.end()) {\n      anagrams[sortedWord].push_back(word);\n    } else {\n      anagrams[sortedWord] = vector<string>{word};\n    }\n  }\n\n  vector<vector<string>> output = {};\n  for (auto it : anagrams) {\n    output.push_back(it.second);\n  }\n  return output;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nbool compare(vector<vector<string>> expected, vector<vector<string>> output);\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<string> words = {\n        \"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\"};\n      vector<vector<string>> expected = {\n        {\"yo\", \"oy\"}, {\"flop\", \"olfp\"}, {\"act\", \"tac\", \"cat\"}, {\"foo\"}};\n      vector<vector<string>> output = groupAnagrams(words);\n      for (auto& el : output) {\n        sort(el.begin(), el.end());\n      }\n      assert(compare(expected, output));\n    });\n  }\n};\n\nbool compare(vector<vector<string>> expected, vector<vector<string>> output) {\n  if (expected.size() != output.size()) {\n    return false;\n  }\n\n  for (auto group : expected) {\n    sort(group.begin(), group.end());\n    if (find(output.begin(), output.end(), group) == output.end()) {\n      return false;\n    }\n  }\n  return true;\n}\n",
      "unitTests": "bool compare(vector<vector<string>> expected, vector<vector<string>> output);\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<string> words = {\n        \"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\"};\n      vector<vector<string>> expected = {\n        {\"yo\", \"oy\"}, {\"flop\", \"olfp\"}, {\"act\", \"tac\", \"cat\"}, {\"foo\"}};\n      vector<vector<string>> output = groupAnagrams(words);\n      for (auto& el : output) {\n        sort(el.begin(), el.end());\n      }\n      assert(compare(expected, output));\n    });\n  }\n};\n\nbool compare(vector<vector<string>> expected, vector<vector<string>> output) {\n  if (expected.size() != output.size()) {\n    return false;\n  }\n\n  for (auto group : expected) {\n    sort(group.begin(), group.end());\n    if (find(output.begin(), output.end(), group) == output.end()) {\n      return false;\n    }\n  }\n  return true;\n}\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nclass Program {\n  public static List<List<string> > groupAnagrams(List<string> words) {\n    // Write your code here.\n    return new List<List<string> >();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(w * n * log(n) + n * w * log(w)) time | O(wn) space - where w is the\n  // number of words and n is the length of the longest word\n  public static List<List<string> > groupAnagrams(List<string> words) {\n    if (words.Count == 0) return new List<List<string> >();\n\n    List<string> sortedWords = new List<string>();\n    foreach (string word in words) {\n      char[] charArray = word.ToCharArray();\n      Array.Sort(charArray);\n      string sortedWord = new String(charArray);\n      sortedWords.Add(sortedWord);\n    }\n\n    List<int> indices = Enumerable.Range(0, words.Count).ToList();\n    indices.Sort((a, b) => sortedWords[a].CompareTo(sortedWords[b]));\n\n    List<List<string> > result = new List<List<string> >();\n    List<string> currentAnagramGroup = new List<string>();\n    string currentAnagram = sortedWords[indices[0]];\n    foreach (int index in indices) {\n      string word = words[index];\n      string sortedWord = sortedWords[index];\n\n      if (sortedWord.Equals(currentAnagram)) {\n        currentAnagramGroup.Add(word);\n        continue;\n      }\n\n      result.Add(currentAnagramGroup);\n      currentAnagramGroup = new List<string>() { word };\n      currentAnagram = sortedWord;\n    }\n\n    result.Add(currentAnagramGroup);\n\n    return result;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(w * n * log(n)) time | O(wn) space - where w is the number of words and n\n  // is the length of the longest word\n  public static List<List<string> > groupAnagrams(List<string> words) {\n    Dictionary<string, List<string> > anagrams =\n      new Dictionary<string, List<string> >();\n\n    foreach (string word in words) {\n      char[] charArray = word.ToCharArray();\n      Array.Sort(charArray);\n      string sortedWord = new String(charArray);\n\n      if (anagrams.ContainsKey(sortedWord)) {\n        anagrams[sortedWord].Add(word);\n      } else {\n        anagrams[sortedWord] = new List<string>() { word };\n      }\n    }\n    return anagrams.Values.ToList();\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    List<string> words = new List<string>(\n    ) { \"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\" };\n    List<List<string> > expected = new List<List<string> >();\n    expected.Add(new List<string>() { \"yo\", \"oy\" });\n    expected.Add(new List<string>() { \"flop\", \"olfp\" });\n    expected.Add(new List<string>() { \"act\", \"tac\", \"cat\" });\n    expected.Add(new List<string>() { \"foo\" });\n    List<List<string> > output = Program.groupAnagrams(words);\n    foreach (List<string> innerList in output) {\n      innerList.Sort();\n    }\n    Utils.AssertTrue(compare(expected, output));\n  }\n\n  public bool compare(\n    List<List<string> > expected, List<List<string> > output\n  ) {\n    if (expected.Count != output.Count) return false;\n    foreach (List<string> e in expected) {\n      e.Sort();\n      var found = false;\n      foreach (List<string> o in output) {\n        if (e.SequenceEqual(o)) {\n          found = true;\n        }\n      }\n\n      if (!found) return false;\n    }\n\n    return true;\n  }\n}\n",
      "unitTests": "using System;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    List<string> words = new List<string>(\n    ) { \"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\" };\n    List<List<string> > expected = new List<List<string> >();\n    expected.Add(new List<string>() { \"yo\", \"oy\" });\n    expected.Add(new List<string>() { \"flop\", \"olfp\" });\n    expected.Add(new List<string>() { \"act\", \"tac\", \"cat\" });\n    expected.Add(new List<string>() { \"foo\" });\n    List<List<string> > output = Program.groupAnagrams(words);\n    foreach (List<string> innerList in output) {\n      innerList.Sort();\n    }\n    Utils.AssertTrue(compare(expected, output));\n  }\n\n  public bool compare(\n    List<List<string> > expected, List<List<string> > output\n  ) {\n    if (expected.Count != output.Count) return false;\n    foreach (List<string> e in expected) {\n      e.Sort();\n      var found = false;\n      foreach (List<string> o in output) {\n        if (e.SequenceEqual(o)) {\n          found = true;\n        }\n      }\n\n      if (!found) return false;\n    }\n\n    return true;\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc GroupAnagrams(words []string) [][]string {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t\"sort\"\n)\n\n// O(w * n * log(n) + n * w * log(w)) time | O(wn) space - where w is the number of words and\n// n is the length of the longest word\nfunc GroupAnagrams(words []string) [][]string {\n\tif len(words) == 0 {\n\t\treturn [][]string{}\n\t}\n\n\tsortedWords := []string{}\n\tindices := []int{}\n\tfor i, word := range words {\n\t\tsortedWords = append(sortedWords, sortWord(word))\n\t\tindices = append(indices, i)\n\t}\n\tsort.Slice(indices, func(i, j int) bool {\n\t\treturn sortedWords[indices[i]] < sortedWords[indices[j]]\n\t})\n\n\tresult := [][]string{}\n\tcurrentAnagramGroup := []string{}\n\tcurrentAnagram := sortedWords[indices[0]]\n\tfor _, index := range indices {\n\t\tword := words[index]\n\t\tsortedWord := sortedWords[index]\n\t\tif len(currentAnagramGroup) == 0 {\n\t\t\tcurrentAnagramGroup = append(currentAnagramGroup, word)\n\t\t\tcurrentAnagram = sortedWord\n\t\t\tcontinue\n\t\t}\n\n\t\tif sortedWord == currentAnagram {\n\t\t\tcurrentAnagramGroup = append(currentAnagramGroup, word)\n\t\t\tcontinue\n\t\t}\n\n\t\tresult = append(result, currentAnagramGroup)\n\t\tcurrentAnagramGroup = []string{word}\n\t\tcurrentAnagram = sortedWord\n\t}\n\n\tresult = append(result, currentAnagramGroup)\n\n\treturn result\n}\n\nfunc sortWord(word string) string {\n\twordBytes := []byte(word)\n\tsort.Slice(wordBytes, func(i, j int) bool {\n\t\treturn wordBytes[i] < wordBytes[j]\n\t})\n\treturn string(wordBytes)\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport \"sort\"\n\n// O(w * n * log(n)) time | O(wn) space - where w is the number of words and\n// n is the length of the longest word\nfunc GroupAnagrams(words []string) [][]string {\n\tanagrams := map[string][]string{}\n\n\tfor _, word := range words {\n\t\tsortedWord := sortWord(word)\n\t\tanagrams[sortedWord] = append(anagrams[sortedWord], word)\n\t}\n\n\tresult := [][]string{}\n\tfor _, group := range anagrams {\n\t\tresult = append(result, group)\n\t}\n\treturn result\n}\n\nfunc sortWord(word string) string {\n\twordBytes := []byte(word)\n\tsort.Slice(wordBytes, func(i, j int) bool {\n\t\treturn wordBytes[i] < wordBytes[j]\n\t})\n\treturn string(wordBytes)\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"sort\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\twords := []string{\"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\"}\n\texpected := [][]string{{\"yo\", \"oy\"}, {\"flop\", \"olfp\"}, {\"act\", \"tac\", \"cat\"}, {\"foo\"}}\n\toutput := GroupAnagrams(words)\n\tcompare(t, expected, output)\n}\n\nfunc compare(t *TestCase, expected, output [][]string) {\n\tt.Helper()\n\tfor _, group := range output {\n\t\tsort.Strings(group)\n\t}\n\n\tfor _, group := range expected {\n\t\tsort.Strings(group)\n\t}\n\trequire.ElementsMatch(t, expected, output)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"sort\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\twords := []string{\"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\"}\n\texpected := [][]string{{\"yo\", \"oy\"}, {\"flop\", \"olfp\"}, {\"act\", \"tac\", \"cat\"}, {\"foo\"}}\n\toutput := GroupAnagrams(words)\n\tcompare(t, expected, output)\n}\n\nfunc compare(t *TestCase, expected, output [][]string) {\n\tt.Helper()\n\tfor _, group := range output {\n\t\tsort.Strings(group)\n\t}\n\n\tfor _, group := range expected {\n\t\tsort.Strings(group)\n\t}\n\trequire.ElementsMatch(t, expected, output)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static List<List<String>> groupAnagrams(List<String> words) {\n    // Write your code here.\n    return new ArrayList();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\nimport java.util.stream.*;\n\nclass Program {\n  // O(w * n * log(n) + n * w * log(w)) time | O(wn) space - where w is the\n  // number of words and n is the length of the longest word\n  public static List<List<String>> groupAnagrams(List<String> words) {\n    if (words.size() == 0) return new ArrayList<List<String>>();\n\n    List<String> sortedWords = new ArrayList<String>();\n    for (String word : words) {\n      char[] charArray = word.toCharArray();\n      Arrays.sort(charArray);\n      String sortedWord = new String(charArray);\n      sortedWords.add(sortedWord);\n    }\n\n    List<Integer> indices =\n      IntStream.range(0, words.size()).boxed().collect(Collectors.toList());\n    indices.sort((a, b) -> sortedWords.get(a).compareTo(sortedWords.get(b)));\n\n    List<List<String>> result = new ArrayList<List<String>>();\n    List<String> currentAnagramGroup = new ArrayList<String>();\n    String currentAnagram = sortedWords.get(indices.get(0));\n    for (Integer index : indices) {\n      String word = words.get(index);\n      String sortedWord = sortedWords.get(index);\n\n      if (sortedWord.equals(currentAnagram)) {\n        currentAnagramGroup.add(word);\n        continue;\n      }\n\n      result.add(currentAnagramGroup);\n      currentAnagramGroup = new ArrayList<String>(Arrays.asList(word));\n      currentAnagram = sortedWord;\n    }\n\n    result.add(currentAnagramGroup);\n\n    return result;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\nimport java.util.stream.*;\n\nclass Program {\n  // O(w * n * log(n)) time | O(wn) space - where w is the number of words and n\n  // is the length of the longest word\n  public static List<List<String>> groupAnagrams(List<String> words) {\n    Map<String, List<String>> anagrams = new HashMap<String, List<String>>();\n\n    for (String word : words) {\n      char[] charArray = word.toCharArray();\n      Arrays.sort(charArray);\n      String sortedWord = new String(charArray);\n\n      if (anagrams.containsKey(sortedWord)) {\n        anagrams.get(sortedWord).add(word);\n      } else {\n        anagrams.put(sortedWord, new ArrayList<String>(Arrays.asList(word)));\n      }\n    }\n    return new ArrayList<>(anagrams.values());\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<String> words = new ArrayList<String>(\n      Arrays.asList(\"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\")\n    );\n    List<List<String>> expected = new ArrayList<List<String>>();\n    expected.add(new ArrayList<String>(Arrays.asList(\"yo\", \"oy\")));\n    expected.add(new ArrayList<String>(Arrays.asList(\"flop\", \"olfp\")));\n    expected.add(new ArrayList<String>(Arrays.asList(\"act\", \"tac\", \"cat\")));\n    expected.add(new ArrayList<String>(Arrays.asList(\"foo\")));\n    List<List<String>> output = Program.groupAnagrams(words);\n    for (List<String> innerList : output) {\n      Collections.sort(innerList);\n    }\n    Utils.assertTrue(compare(expected, output));\n  }\n\n  public boolean compare(\n    List<List<String>> expected, List<List<String>> output\n  ) {\n    if (expected.size() != output.size()) return false;\n\n    for (List<String> group : expected) {\n      Collections.sort(group);\n      if (!output.contains(group)) return false;\n    }\n\n    return true;\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<String> words = new ArrayList<String>(\n      Arrays.asList(\"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\")\n    );\n    List<List<String>> expected = new ArrayList<List<String>>();\n    expected.add(new ArrayList<String>(Arrays.asList(\"yo\", \"oy\")));\n    expected.add(new ArrayList<String>(Arrays.asList(\"flop\", \"olfp\")));\n    expected.add(new ArrayList<String>(Arrays.asList(\"act\", \"tac\", \"cat\")));\n    expected.add(new ArrayList<String>(Arrays.asList(\"foo\")));\n    List<List<String>> output = Program.groupAnagrams(words);\n    for (List<String> innerList : output) {\n      Collections.sort(innerList);\n    }\n    Utils.assertTrue(compare(expected, output));\n  }\n\n  public boolean compare(\n    List<List<String>> expected, List<List<String>> output\n  ) {\n    if (expected.size() != output.size()) return false;\n\n    for (List<String> group : expected) {\n      Collections.sort(group);\n      if (!output.contains(group)) return false;\n    }\n\n    return true;\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function groupAnagrams(words) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.groupAnagrams = groupAnagrams;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(w * n * log(n) + n * w * log(w)) time | O(wn) space - where w is the number of words and\n// n is the length of the longest word\nfunction groupAnagrams(words) {\n  if (words.length === 0) return [];\n\n  const sortedWords = words.map(word => word.split('').sort().join(''));\n  const indices = [...Array(words.length).keys()];\n  indices.sort((a, b) => {\n    if (sortedWords[a] < sortedWords[b]) return -1;\n    if (sortedWords[a] > sortedWords[b]) return 1;\n    return 0;\n  });\n\n  const result = [];\n  let currentAnagramGroup = [];\n  let currentAnagram = sortedWords[indices[0]];\n  for (const index of indices) {\n    const word = words[index];\n    const sortedWord = sortedWords[index];\n\n    if (sortedWord === currentAnagram) {\n      currentAnagramGroup.push(word);\n      continue;\n    }\n\n    result.push(currentAnagramGroup);\n    currentAnagramGroup = [word];\n    currentAnagram = sortedWord;\n  }\n\n  result.push(currentAnagramGroup);\n\n  return result;\n}\n\nexports.groupAnagrams = groupAnagrams;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(w * n * log(n)) time | O(wn) space - where w is the number of words and n is the length of the longest word\nfunction groupAnagrams(words) {\n  const anagrams = {};\n  for (const word of words) {\n    const sortedWord = word.split('').sort().join('');\n    if (sortedWord in anagrams) {\n      anagrams[sortedWord].push(word);\n    } else {\n      anagrams[sortedWord] = [word];\n    }\n  }\n  return Object.values(anagrams);\n}\n\nexports.groupAnagrams = groupAnagrams;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const words = ['yo', 'act', 'flop', 'tac', 'foo', 'cat', 'oy', 'olfp'];\n  const expected = [['yo', 'oy'], ['flop', 'olfp'], ['act', 'tac', 'cat'], ['foo']];\n  const output = program.groupAnagrams(words).map(anagramGroup => anagramGroup.sort());\n\n  compare(expected, output);\n});\n\nfunction compare(expected, output) {\n  chai.expect(output.length).to.deep.equal(expected.length);\n  for (const group of expected) {\n    chai.expect(output).to.deep.include(group.sort());\n  }\n}\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const words = ['yo', 'act', 'flop', 'tac', 'foo', 'cat', 'oy', 'olfp'];\n  const expected = [['yo', 'oy'], ['flop', 'olfp'], ['act', 'tac', 'cat'], ['foo']];\n  const output = program.groupAnagrams(words).map(anagramGroup => anagramGroup.sort());\n\n  compare(expected, output);\n});\n\nfunction compare(expected, output) {\n  chai.expect(output.length).to.deep.equal(expected.length);\n  for (const group of expected) {\n    chai.expect(output).to.deep.include(group.sort());\n  }\n}\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun groupAnagrams(words: List<String>): List<List<String>> {\n    // Write your code here.\n    return listOf()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(w * n * log(n) + n * w * log(w)) time | O(wn) space - where w is the number of words and\n// n is the length of the longest word\nfun groupAnagrams(words: List<String>): List<List<String>> {\n    if (words.size == 0) return listOf()\n\n    var sortedWords = mutableListOf<String>()\n    for (word in words) {\n        sortedWords.add(word.split(\"\").sorted().joinToString(\"\"))\n    }\n    var indices = List(words.size) { it }\n    indices = indices.sortedWith(\n        Comparator { a: Int, b: Int ->\n            when {\n                (sortedWords[a] > sortedWords[b]) -> 1\n                (sortedWords[a] < sortedWords[b]) -> -1\n                else -> 0\n            }\n        },\n    )\n\n    val result = mutableListOf<List<String>>()\n    var currentAnagramGroup = mutableListOf<String>()\n    var currentAnagram = sortedWords[indices[0]]\n    for (index in indices) {\n        val word = words[index]\n        val sortedWord = sortedWords[index]\n\n        if (sortedWord == currentAnagram) {\n            currentAnagramGroup.add(word)\n            continue\n        }\n\n        result.add(currentAnagramGroup)\n        currentAnagramGroup = mutableListOf(word)\n        currentAnagram = sortedWord\n    }\n\n    result.add(currentAnagramGroup)\n\n    return result\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(w * n * log(n)) time | O(wn) space - where w is the number of words and n is the length of the longest word\nfun groupAnagrams(words: List<String>): List<List<String>> {\n    val anagrams = mutableMapOf<String, MutableList<String>>()\n    for (word in words) {\n        val wordChars = word.toCharArray()\n        wordChars.sort()\n        val sortedWord = wordChars.joinToString(\"\")\n        if (sortedWord in anagrams) {\n            anagrams[sortedWord]!!.add(word)\n        } else {\n            anagrams[sortedWord] = mutableListOf(word)\n        }\n    }\n    return anagrams.values.toList()\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.groupAnagrams as groupAnagrams\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val words = listOf(\"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\")\n        val expected = listOf(\n            listOf(\"yo\", \"oy\"),\n            listOf(\"flop\", \"olfp\"),\n            listOf(\"act\", \"tac\", \"cat\"),\n            listOf(\"foo\"),\n        )\n        val output = groupAnagrams(words)\n        assert(compare(expected, output))\n    }\n}\n\nfun compare(expected: List<List<String>>, output: List<List<String>>): Boolean {\n    if (expected.size != output.size) return false\n    for (eGroup in expected) {\n        eGroup.toMutableList().sort()\n        var found = false\n        for (oGroup in output) {\n            oGroup.toMutableList().sort()\n            if (oGroup.equals(eGroup)) {\n                found = true\n                break\n            }\n        }\n        if (!found) return false\n    }\n    return true\n}\n",
      "unitTests": "import com.algoexpert.program.groupAnagrams as groupAnagrams\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val words = listOf(\"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\")\n        val expected = listOf(\n            listOf(\"yo\", \"oy\"),\n            listOf(\"flop\", \"olfp\"),\n            listOf(\"act\", \"tac\", \"cat\"),\n            listOf(\"foo\"),\n        )\n        val output = groupAnagrams(words)\n        assert(compare(expected, output))\n    }\n}\n\nfun compare(expected: List<List<String>>, output: List<List<String>>): Boolean {\n    if (expected.size != output.size) return false\n    for (eGroup in expected) {\n        eGroup.toMutableList().sort()\n        var found = false\n        for (oGroup in output) {\n            oGroup.toMutableList().sort()\n            if (oGroup.equals(eGroup)) {\n                found = true\n                break\n            }\n        }\n        if (!found) return false\n    }\n    return true\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def groupAnagrams(words):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(w * n * log(n) + n * w * log(w)) time | O(wn) space - where w is the number of words and\n# n is the length of the longest word\ndef groupAnagrams(words):\n    if len(words) == 0:\n        return []\n\n    sortedWords = [\"\".join(sorted(w)) for w in words]\n    indices = [i for i in range(len(words))]\n    indices.sort(key=lambda x: sortedWords[x])\n\n    result = []\n    currentAnagramGroup = []\n    currentAnagram = sortedWords[indices[0]]\n    for index in indices:\n        word = words[index]\n        sortedWord = sortedWords[index]\n\n        if sortedWord == currentAnagram:\n            currentAnagramGroup.append(word)\n            continue\n\n        result.append(currentAnagramGroup)\n        currentAnagramGroup = [word]\n        currentAnagram = sortedWord\n\n    result.append(currentAnagramGroup)\n\n    return result\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(w * n * log(n)) time | O(wn) space - where w is the number of words and\n# n is the length of the longest word\ndef groupAnagrams(words):\n    anagrams = {}\n    for word in words:\n        sortedWord = \"\".join(sorted(word))\n        if sortedWord in anagrams:\n            anagrams[sortedWord].append(word)\n        else:\n            anagrams[sortedWord] = [word]\n    return list(anagrams.values())\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        words = [\"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\"]\n        expected = [[\"yo\", \"oy\"], [\"flop\", \"olfp\"], [\"act\", \"tac\", \"cat\"], [\"foo\"]]\n        output = list(map(lambda x: sorted(x), program.groupAnagrams(words)))\n\n        self.compare(expected, output)\n\n    def compare(self, expected, output):\n        if len(expected) == 0:\n            self.assertEqual(output, expected)\n            return\n        self.assertEqual(len(expected), len(output))\n        for group in expected:\n            self.assertTrue(sorted(group) in output)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        words = [\"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\"]\n        expected = [[\"yo\", \"oy\"], [\"flop\", \"olfp\"], [\"act\", \"tac\", \"cat\"], [\"foo\"]]\n        output = list(map(lambda x: sorted(x), program.groupAnagrams(words)))\n\n        self.compare(expected, output)\n\n    def compare(self, expected, output):\n        if len(expected) == 0:\n            self.assertEqual(output, expected)\n            return\n        self.assertEqual(len(expected), len(output))\n        for group in expected:\n            self.assertTrue(sorted(group) in output)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def groupAnagrams(words)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def groupAnagrams(words)\n    # Write your code here.\n    return []\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def groupAnagrams(words)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.groupAnagrams\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.groupAnagrams\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func groupAnagrams(_ words: [String]) -> [[String]] {\n    // Write your code here.\n    return []\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(w * n * log(n) + n * w * log(w)) time | O(wn) space - where w is the number of words and\n  // n is the length of the longest word\n  func groupAnagrams(_ words: [String]) -> [[String]] {\n    if words.count == 0 {\n      return [[String]]()\n    }\n\n    var sortedWords = [String]()\n    var indices = [Int]()\n    for i in 0 ..< words.count {\n      sortedWords.append(sortWord(words[i]))\n      indices.append(i)\n    }\n    indices = indices.sorted {\n      return sortedWords[$0] < sortedWords[$1]\n    }\n\n    var result = [[String]]()\n    var currentAnagramGroup = [String]()\n    var currentAnagram = sortedWords[indices[0]]\n    for index in indices {\n      let word = words[index]\n      let sortedWord = sortedWords[index]\n      if currentAnagramGroup.count == 0 {\n        currentAnagramGroup.append(word)\n        currentAnagram = sortedWord\n        continue\n      }\n\n      if sortedWord == currentAnagram {\n        currentAnagramGroup.append(word)\n        continue\n      }\n\n      result.append(currentAnagramGroup)\n      currentAnagramGroup = [word]\n      currentAnagram = sortedWord\n    }\n\n    result.append(currentAnagramGroup)\n    return result\n  }\n\n  func sortWord(_ word: String) -> String {\n    return String(word.sorted())\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(w * n * log(n)) time | O(wn) space - where w is the number of words and\n  // n is the length of the longest word\n  func groupAnagrams(_ words: [String]) -> [[String]] {\n    var anagrams = [String: [String]]()\n\n    for word in words {\n      let sortedWord = String(word.sorted())\n      if var arr = anagrams[sortedWord] {\n        arr.append(word)\n        anagrams[sortedWord] = arr\n        continue\n      }\n      anagrams[sortedWord] = [word]\n    }\n\n    var result = [[String]]()\n    for group in anagrams {\n      result.append(group.value)\n    }\n    return result\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let words = [\"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\"]\n      let expected = [[\"yo\", \"oy\"], [\"flop\", \"olfp\"], [\"act\", \"tac\", \"cat\"], [\"foo\"]]\n      var output = program.groupAnagrams(words)\n      try compare(expected, output)\n    }\n  }\n\n  func compare(_ expected: [[String]], _ output: [[String]]) throws {\n    try assertEqual(output.count, expected.count)\n\n    var outputs = [String: Bool]()\n    for group in output {\n      outputs[group.sorted().joined(separator: \",\")] = true\n    }\n\n    for group in expected {\n      try assert(outputs[group.sorted().joined(separator: \",\")] != nil)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let words = [\"yo\", \"act\", \"flop\", \"tac\", \"foo\", \"cat\", \"oy\", \"olfp\"]\n      let expected = [[\"yo\", \"oy\"], [\"flop\", \"olfp\"], [\"act\", \"tac\", \"cat\"], [\"foo\"]]\n      var output = program.groupAnagrams(words)\n      try compare(expected, output)\n    }\n  }\n\n  func compare(_ expected: [[String]], _ output: [[String]]) throws {\n    try assertEqual(output.count, expected.count)\n\n    var outputs = [String: Bool]()\n    for group in output {\n      outputs[group.sorted().joined(separator: \",\")] = true\n    }\n\n    for group in expected {\n      try assert(outputs[group.sorted().joined(separator: \",\")] != nil)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function groupAnagrams(words: string[]) {\n  // Write your code here.\n  return [['', '']];\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(w * n * log(n) + n * w * log(w)) time | O(wn) space - where w is the number of words and\n// n is the length of the longest word\nexport function groupAnagrams(words: string[]) {\n  if (words.length === 0) return [];\n\n  const sortedWords = words.map(word => word.split('').sort().join(''));\n  const indices = [...Array(words.length).keys()];\n  indices.sort((a, b) => {\n    if (sortedWords[a] < sortedWords[b]) return -1;\n    if (sortedWords[a] > sortedWords[b]) return 1;\n    return 0;\n  });\n\n  const result: string[][] = [];\n  let currentAnagramGroup: string[] = [];\n  let currentAnagram = sortedWords[indices[0]];\n  for (const index of indices) {\n    const word = words[index];\n    const sortedWord = sortedWords[index];\n\n    if (sortedWord === currentAnagram) {\n      currentAnagramGroup.push(word);\n      continue;\n    }\n\n    result.push(currentAnagramGroup);\n    currentAnagramGroup = [word];\n    currentAnagram = sortedWord;\n  }\n\n  result.push(currentAnagramGroup);\n\n  return result;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(w * n * log(n)) time | O(wn) space - where w is the number of words and n is the length of the longest word\nexport function groupAnagrams(words: string[]) {\n  const anagrams: {[key: string]: string[]} = {};\n  for (const word of words) {\n    const sortedWord = word.split('').sort().join('');\n    if (sortedWord in anagrams) {\n      anagrams[sortedWord].push(word);\n    } else {\n      anagrams[sortedWord] = [word];\n    }\n  }\n  return Object.values(anagrams);\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const words = ['yo', 'act', 'flop', 'tac', 'foo', 'cat', 'oy', 'olfp'];\n  const expected = [['yo', 'oy'], ['flop', 'olfp'], ['act', 'tac', 'cat'], ['foo']];\n  const output = program.groupAnagrams(words).map(anagramGroup => anagramGroup.sort());\n\n  compare(expected, output);\n});\n\nfunction compare(expected: string[][], output: string[][]) {\n  chai.expect(output.length).to.deep.equal(expected.length);\n  for (const group of expected) {\n    chai.expect(output).to.deep.include(group.sort());\n  }\n}\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const words = ['yo', 'act', 'flop', 'tac', 'foo', 'cat', 'oy', 'olfp'];\n  const expected = [['yo', 'oy'], ['flop', 'olfp'], ['act', 'tac', 'cat'], ['foo']];\n  const output = program.groupAnagrams(words).map(anagramGroup => anagramGroup.sort());\n\n  compare(expected, output);\n});\n\nfunction compare(expected: string[][], output: string[][]) {\n  chai.expect(output.length).to.deep.equal(expected.length);\n  for (const group of expected) {\n    chai.expect(output).to.deep.include(group.sort());\n  }\n}\n"
    }
  },
  "customInputVars": [
    {
      "name": "words",
      "example": [
        "yo",
        "act",
        "flop",
        "tac",
        "foo",
        "cat",
        "oy",
        "olfp"
      ],
      "schema": {
        "items": {
          "type": "string"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "words": [
        "yo",
        "act",
        "flop",
        "tac",
        "foo",
        "cat",
        "oy",
        "olfp"
      ]
    },
    {
      "words": []
    },
    {
      "words": [
        "test"
      ]
    },
    {
      "words": [
        "abc",
        "dabd",
        "bca",
        "cab",
        "ddba"
      ]
    },
    {
      "words": [
        "abc",
        "cba",
        "bca"
      ]
    },
    {
      "words": [
        "zxc",
        "asd",
        "weq",
        "sda",
        "qwe",
        "xcz"
      ]
    },
    {
      "words": [
        "cinema",
        "a",
        "flop",
        "iceman",
        "meacyne",
        "lofp",
        "olfp"
      ]
    },
    {
      "words": [
        "abc",
        "abe",
        "abf",
        "abg"
      ]
    },
    {
      "words": [
        "aaa",
        "a"
      ]
    },
    {
      "words": [
        "bob",
        "boo"
      ]
    },
    {
      "words": [
        "ill",
        "duh"
      ]
    },
    {
      "words": [
        "yo",
        "oy",
        "zn"
      ]
    },
    {
      "words": [
        "yyo",
        "yo"
      ]
    },
    {
      "words": [
        "aca",
        "bba"
      ]
    }
  ],
  "jsonTests": [
    {
      "words": [
        "yo",
        "act",
        "flop",
        "tac",
        "foo",
        "cat",
        "oy",
        "olfp"
      ]
    },
    {
      "words": []
    },
    {
      "words": [
        "test"
      ]
    },
    {
      "words": [
        "abc",
        "dabd",
        "bca",
        "cab",
        "ddba"
      ]
    },
    {
      "words": [
        "abc",
        "cba",
        "bca"
      ]
    },
    {
      "words": [
        "zxc",
        "asd",
        "weq",
        "sda",
        "qwe",
        "xcz"
      ]
    },
    {
      "words": [
        "cinema",
        "a",
        "flop",
        "iceman",
        "meacyne",
        "lofp",
        "olfp"
      ]
    },
    {
      "words": [
        "abc",
        "abe",
        "abf",
        "abg"
      ]
    },
    {
      "words": [
        "aaa",
        "a"
      ]
    },
    {
      "words": [
        "bob",
        "boo"
      ]
    },
    {
      "words": [
        "ill",
        "duh"
      ]
    },
    {
      "words": [
        "yo",
        "oy",
        "zn"
      ]
    },
    {
      "words": [
        "yyo",
        "yo"
      ]
    },
    {
      "words": [
        "aca",
        "bba"
      ]
    }
  ],
  "changelog": []
}