{
  "uid": "kruskals-algorithm",
  "testStrategy": "JSON",
  "name": "Kruskal's Algorithm",
  "version": 0,
  "releaseDate": "2022-12-15T00:00:00Z",
  "category": "Famous Algorithms",
  "difficulty": 3,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 655,
    "failureCount": 77
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "775587125",
    "duration": 0,
    "annotations": [],
    "instructor": "Conner Ardman",
    "overviewTime": 0,
    "codeWalkthroughTime": 615
  },
  "prompt": "<div class=\"html\">\n  <p>\n    You're given a list of <span>edges</span> representing a weighted,\n    undirected graph with at least one node.\n  </p>\n\n  <p>\n    The given list is what's called an adjacency list, and it represents a graph.\n    The number of vertices in the graph is equal to the length of\n    <span>edges</span>, where each index <span>i</span> in\n    <span>edges</span> contains vertex <span>i</span>'s siblings, in no\n    particular order. Each of these siblings is an array of length two, with\n    the first value denoting the index in the list that this vertex is connected\n    to, and and the second value denoting the weight of the edge. Note that\n    this graph is undirected, meaning that if a vertex appears in the edge list\n    of another vertex, then the inverse will also be true (along with the same\n    weight).\n  </p>\n\n  <p>\n    Write a function implementing Kruskal's Algorithm to return a new\n    <span>edges</span> array that represents a minimum spanning tree. A\n    minimum spanning tree is a tree containing all of the vertices of the original\n    graph and a subset of the edges. These edges should connect all of the vertices\n    with the minimum total edge weight and without generating any cycles.\n  </p>\n\n  <p>\n    If the graph is not connected, your function should return the minimum spanning\n    forest (i.e. all of the nodes should be able to reach the same nodes as they\n    could in the initial edge list).\n  </p>\n\n  <p>\n    Note that the graph represented by <span>edges</span> won't contain any\n    self-loops (vertices that have an outbound edge to themselves) and will only\n    have positively weighted edges (i.e., no negative distances).\n  </p>\n\n  <p>\n    If you're unfamiliar with Kruskal's algorithm, we recommend watching the\n    Conceptual Overview section of this question's video explanation before\n    starting to code. If you're unfamiliar with the Union Find data structure,\n    we recommend completing that problem before attempting this one.\n  </p>\n  <h3>Sample Input</h3>\n  <pre><span class=\"CodeEditor-promptParameter\">edges</span> = [\n  [[1, 3], [2, 5]],\n  [[0, 3], [2, 10], [3, 12]],\n  [[0, 5], [1, 10]],\n  [[1, 12]]\n]</pre>\n  <h3>Sample Output</h3>\n  <pre>[\n  [[1, 3], [2, 5]],\n  [[0, 3], [3, 12]],\n  [[0, 5]],\n  [[1, 12]]\n]</pre>\n</div>",
  "hints": [
    "<p>\n  A good place to start is to transform the adjacency list into a list of\n  all of the edges, sorted by weight.\n</p>\n",
    "\n<p>\n  To check if adding a given edge creates a cycle, try using a disjoint set.\n  Start by thinking of each node as its own set. Then with each added edge,\n  combine the sets of the connected nodes.\n</p>"
  ],
  "spaceTime": "O(e * log(e)) time | O(e + v) space - where e is the number of edges in the input edges and v is the number of vertices",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\nvector<vector<vector<int>>> kruskalsAlgorithm(vector<vector<vector<int>>> edges\n) {\n  // Write your code here.\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\nusing namespace std;\n\nint find(int vertex, vector<int>& parents);\nvoid createUnion(\n  int vertex1Root, int vertex2Root, vector<int>& parents, vector<int>& ranks\n);\n\n// O(e * log(e)) time | O(e + v) space - where e is the number\n// of edges in the input edges and v is the number of vertices\nvector<vector<vector<int>>> kruskalsAlgorithm(vector<vector<vector<int>>> edges\n) {\n  vector<vector<int>> sortedEdges;\n  for (int sourceIndex = 0; sourceIndex < edges.size(); sourceIndex++) {\n    vector<vector<int>> vertex = edges[sourceIndex];\n    for (vector<int> edge : vertex) {\n      if (edge[0] > sourceIndex) {\n        sortedEdges.push_back({sourceIndex, edge[0], edge[1]});\n      }\n    }\n  }\n\n  sort(\n    sortedEdges.begin(),\n    sortedEdges.end(),\n    [](vector<int> edge1, vector<int> edge2) -> bool {\n      return edge1[2] < edge2[2];\n    }\n  );\n\n  vector<int> parents;\n  vector<int> ranks;\n  vector<vector<vector<int>>> mst;\n\n  for (int i = 0; i < edges.size(); i++) {\n    parents.push_back(i);\n    ranks.push_back(0);\n    mst.push_back({});\n  }\n\n  for (vector<int> edge : sortedEdges) {\n    int vertex1Root = find(edge[0], parents);\n    int vertex2Root = find(edge[1], parents);\n    if (vertex1Root != vertex2Root) {\n      mst[edge[0]].push_back({edge[1], edge[2]});\n      mst[edge[1]].push_back({edge[0], edge[2]});\n      createUnion(vertex1Root, vertex2Root, parents, ranks);\n    }\n  }\n\n  return mst;\n}\n\nint find(int vertex, vector<int>& parents) {\n  if (vertex != parents[vertex]) {\n    parents[vertex] = find(parents[vertex], parents);\n  }\n\n  return parents[vertex];\n}\n\nvoid createUnion(\n  int vertex1Root, int vertex2Root, vector<int>& parents, vector<int>& ranks\n) {\n  if (ranks[vertex1Root] < ranks[vertex2Root]) {\n    parents[vertex1Root] = vertex2Root;\n  } else if (ranks[vertex1Root] > ranks[vertex2Root]) {\n    parents[vertex2Root] = vertex1Root;\n  } else {\n    parents[vertex2Root] = vertex1Root;\n    ranks[vertex1Root]++;\n  }\n}"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<vector<int>>> input = {{{1, 1}}, {{0, 1}}};\n      vector<vector<vector<int>>> expected = {{{1, 1}}, {{0, 1}}};\n      auto actual = kruskalsAlgorithm(input);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<vector<int>>> input = {{{1, 1}}, {{0, 1}}};\n      vector<vector<vector<int>>> expected = {{{1, 1}}, {{0, 1}}};\n      auto actual = kruskalsAlgorithm(input);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public int[][][] KruskalsAlgorithm(int[][][] edges) {\n    // Write your code here.\n    return new int[][][] {};\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // O(e * log(e)) time | O(e + v) space - where e is the number\n  // of edges in the input edges and v is the number of vertices\n  public int[][][] KruskalsAlgorithm(int[][][] edges) {\n    List<List<int> > sortedEdges = new List<List<int> >();\n    for (int sourceIndex = 0; sourceIndex < edges.Length; sourceIndex++) {\n      foreach (var edge in edges[sourceIndex]) {\n        if (edge[0] > sourceIndex) {\n          sortedEdges.Add(new List<int> { sourceIndex, edge[0], edge[1] });\n        }\n      }\n    }\n\n    sortedEdges.Sort((edge1, edge2) => edge1[2] - edge2[2]);\n\n    int[] parents = new int[edges.Length];\n    int[] ranks = new int[edges.Length];\n    List<List<int[]> > mst = new List<List<int[]> >();\n\n    for (int i = 0; i < edges.Length; i++) {\n      parents[i] = i;\n      ranks[i] = 0;\n      mst.Insert(i, new List<int[]>());\n    }\n\n    foreach (var edge in sortedEdges) {\n      int vertex1Root = find(edge[0], parents);\n      int vertex2Root = find(edge[1], parents);\n      if (vertex1Root != vertex2Root) {\n        mst[edge[0]].Add(new int[] { edge[1], edge[2] });\n        mst[edge[1]].Add(new int[] { edge[0], edge[2] });\n        union\n        (vertex1Root, vertex2Root, parents, ranks);\n      }\n    }\n\n    int[][][] arrayMst = new int [edges.Length][][];\n    for (int i = 0; i < mst.Count; i++) {\n      arrayMst[i] = new int[mst[i].Count][];\n      for (int j = 0; j < mst[i].Count; j++) {\n        arrayMst[i][j] = mst[i][j];\n      }\n    }\n\n    return arrayMst;\n  }\n\n  private int find(int vertex, int[] parents) {\n    if (vertex != parents[vertex]) {\n      parents[vertex] = find(parents[vertex], parents);\n    }\n    return parents[vertex];\n  }\n\n  private void union\n  (int vertex1Root, int vertex2Root, int[] parents, int[] ranks) {\n    if (ranks[vertex1Root] < ranks[vertex2Root]) {\n      parents[vertex1Root] = vertex2Root;\n    } else if (ranks[vertex1Root] > ranks[vertex2Root]) {\n      parents[vertex2Root] = vertex1Root;\n    } else {\n      parents[vertex2Root] = vertex1Root;\n      ranks[vertex1Root]++;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var input = new int[][][] {\n      new int[][] { new int[] { 1, 1 } }, new int[][] { new int[] { 0, 1 } }\n    };\n    var expected = new int[][][] {\n      new int[][] { new int[] { 1, 1 } }, new int[][] { new int[] { 0, 1 } }\n    };\n    var actual = new Program().KruskalsAlgorithm(input);\n    Utils.AssertTrue(jaggedArrayDeepEqual(expected, actual));\n  }\n\n  public bool jaggedArrayDeepEqual(dynamic a, dynamic b) {\n    if (ReferenceEquals(a, b)) {\n      return true;\n    }\n\n    if (ReferenceEquals(a, null) || ReferenceEquals(b, null)) {\n      return false;\n    }\n\n    if (!a.GetType().IsArray || !b.GetType().IsArray) {\n      return Equals(a, b);\n    }\n\n    if (a.Length == b.Length) {\n      for (int i = 0; i < a.Length; i++) {\n        if (!jaggedArrayDeepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var input = new int[][][] {\n      new int[][] { new int[] { 1, 1 } }, new int[][] { new int[] { 0, 1 } }\n    };\n    var expected = new int[][][] {\n      new int[][] { new int[] { 1, 1 } }, new int[][] { new int[] { 0, 1 } }\n    };\n    var actual = new Program().KruskalsAlgorithm(input);\n    Utils.AssertTrue(jaggedArrayDeepEqual(expected, actual));\n  }\n\n  public bool jaggedArrayDeepEqual(dynamic a, dynamic b) {\n    if (ReferenceEquals(a, b)) {\n      return true;\n    }\n\n    if (ReferenceEquals(a, null) || ReferenceEquals(b, null)) {\n      return false;\n    }\n\n    if (!a.GetType().IsArray || !b.GetType().IsArray) {\n      return Equals(a, b);\n    }\n\n    if (a.Length == b.Length) {\n      for (int i = 0; i < a.Length; i++) {\n        if (!jaggedArrayDeepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc KruskalsAlgorithm(edges [][][]int) [][][]int {\n\t// Write your code here.\n\treturn [][][]int{}\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t\"sort\"\n)\n\n// O(e * log(e)) time | O(e + v) space - where e is the number\n// of edges in the input edges and v is the number of vertices\nfunc KruskalsAlgorithm(edges [][][]int) [][][]int {\n\tsortedEdges := [][]int{}\n\tfor sourceIndex, vertex := range edges {\n\t\tfor _, edge := range vertex {\n\t\t\tif edge[0] > sourceIndex {\n\t\t\t\tsortedEdges = append(sortedEdges, []int{sourceIndex, edge[0], edge[1]})\n\t\t\t}\n\t\t}\n\t}\n\n\tsort.Slice(sortedEdges, func(i, j int) bool {\n\t\tedge1, edge2 := sortedEdges[i], sortedEdges[j]\n\t\treturn edge1[2] < edge2[2]\n\t})\n\n\tparents := make([]int, len(edges))\n\tranks := make([]int, len(edges))\n\tmst := [][][]int{}\n\n\tfor i := range edges {\n\t\tparents[i] = i\n\t\tranks[i] = 0\n\t\tmst = append(mst, [][]int{})\n\t}\n\n\tfor _, edge := range sortedEdges {\n\t\tvertex1Root := find(edge[0], parents)\n\t\tvertex2Root := find(edge[1], parents)\n\t\tif vertex1Root != vertex2Root {\n\t\t\tmst[edge[0]] = append(mst[edge[0]], []int{edge[1], edge[2]})\n\t\t\tmst[edge[1]] = append(mst[edge[1]], []int{edge[0], edge[2]})\n\t\t\tunion(vertex1Root, vertex2Root, parents, ranks)\n\t\t}\n\t}\n\n\treturn mst\n}\n\nfunc find(vertex int, parents []int) int {\n\tif vertex != parents[vertex] {\n\t\tparents[vertex] = find(parents[vertex], parents)\n\t}\n\treturn parents[vertex]\n}\n\nfunc union(vertex1Root, vertex2Root int, parents, ranks []int) {\n\tif ranks[vertex1Root] < ranks[vertex2Root] {\n\t\tparents[vertex1Root] = vertex2Root\n\t} else if ranks[vertex1Root] > ranks[vertex2Root] {\n\t\tparents[vertex2Root] = vertex1Root\n\t} else {\n\t\tparents[vertex2Root] = vertex1Root\n\t\tranks[vertex1Root]++\n\t}\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][][]int{{{1, 1}}, {{0, 1}}}\n\texpected := [][][]int{{{1, 1}}, {{0, 1}}}\n\tactual := KruskalsAlgorithm(input)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][][]int{{{1, 1}}, {{0, 1}}}\n\texpected := [][][]int{{{1, 1}}, {{0, 1}}}\n\tactual := KruskalsAlgorithm(input)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public int[][][] kruskalsAlgorithm(int[][][] edges) {\n    // Write your code here.\n    return new int[][][] {};\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(e * log(e)) time | O(e + v) space - where e is the number\n  // of edges in the input edges and v is the number of vertices\n  public int[][][] kruskalsAlgorithm(int[][][] edges) {\n    ArrayList<List<Integer>> sortedEdges = new ArrayList<List<Integer>>();\n    for (int sourceIndex = 0; sourceIndex < edges.length; sourceIndex++) {\n      for (int[] edge : edges[sourceIndex]) {\n        if (edge[0] > sourceIndex) {\n          sortedEdges.add(Arrays.asList(sourceIndex, edge[0], edge[1]));\n        }\n      }\n    }\n\n    Collections.sort(\n      sortedEdges, (edge1, edge2) -> edge1.get(2) - edge2.get(2)\n    );\n\n    int[] parents = new int[edges.length];\n    int[] ranks = new int[edges.length];\n    ArrayList<ArrayList<int[]>> mst = new ArrayList<ArrayList<int[]>>();\n\n    for (int i = 0; i < edges.length; i++) {\n      parents[i] = i;\n      ranks[i] = 0;\n      mst.add(i, new ArrayList<int[]>());\n    }\n\n    for (List<Integer> edge : sortedEdges) {\n      int vertex1Root = find(edge.get(0), parents);\n      int vertex2Root = find(edge.get(1), parents);\n      if (vertex1Root != vertex2Root) {\n        mst.get(edge.get(0)).add(new int[] {edge.get(1), edge.get(2)});\n        mst.get(edge.get(1)).add(new int[] {edge.get(0), edge.get(2)});\n        union(vertex1Root, vertex2Root, parents, ranks);\n      }\n    }\n\n    int[][][] arrayMst = new int[edges.length][][];\n    for (int i = 0; i < mst.size(); i++) {\n      arrayMst[i] = new int[mst.get(i).size()][];\n      for (int j = 0; j < mst.get(i).size(); j++) {\n        arrayMst[i][j] = mst.get(i).get(j);\n      }\n    }\n\n    return arrayMst;\n  }\n\n  private int find(int vertex, int[] parents) {\n    if (vertex != parents[vertex]) {\n      parents[vertex] = find(parents[vertex], parents);\n    }\n    return parents[vertex];\n  }\n\n  private void union(\n    int vertex1Root, int vertex2Root, int[] parents, int[] ranks\n  ) {\n    if (ranks[vertex1Root] < ranks[vertex2Root]) {\n      parents[vertex1Root] = vertex2Root;\n    } else if (ranks[vertex1Root] > ranks[vertex2Root]) {\n      parents[vertex2Root] = vertex1Root;\n    } else {\n      parents[vertex2Root] = vertex1Root;\n      ranks[vertex1Root]++;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var input = new int[][][] {{{1, 1}}, {{0, 1}}};\n    var expected = new int[][][] {{{1, 1}}, {{0, 1}}};\n    var actual = new Program().kruskalsAlgorithm(input);\n    Utils.assertTrue(Arrays.deepEquals(expected, actual));\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var input = new int[][][] {{{1, 1}}, {{0, 1}}};\n    var expected = new int[][][] {{{1, 1}}, {{0, 1}}};\n    var actual = new Program().kruskalsAlgorithm(input);\n    Utils.assertTrue(Arrays.deepEquals(expected, actual));\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function kruskalsAlgorithm(edges) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.kruskalsAlgorithm = kruskalsAlgorithm;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(e * log(e)) time | O(e + v) space - where e is the number\n// of edges in the input edges and v is the number of vertices\nfunction kruskalsAlgorithm(edges) {\n  const edgeList = [];\n  for (let sourceIndex = 0; sourceIndex < edges.length; sourceIndex++) {\n    const vertex = edges[sourceIndex];\n    for (const edge of vertex) {\n      if (edge[0] > sourceIndex) {\n        edgeList.push([sourceIndex, edge[0], edge[1]]);\n      }\n    }\n  }\n  const sortedEdges = edgeList.sort((edgeA, edgeB) => {\n    if (edgeA[2] > edgeB[2]) return 1;\n    if (edgeA[2] < edgeB[2]) return -1;\n    return 0;\n  });\n\n  const parents = edges.map((_, i) => i);\n  const ranks = edges.map(_ => 0);\n  const mst = edges.map(_ => []);\n  for (const edge of sortedEdges) {\n    const vertex1Root = find(edge[0], parents);\n    const vertex2Root = find(edge[1], parents);\n    if (vertex1Root !== vertex2Root) {\n      mst[edge[0]].push([edge[1], edge[2]]);\n      mst[edge[1]].push([edge[0], edge[2]]);\n      union(vertex1Root, vertex2Root, parents, ranks);\n    }\n  }\n\n  return mst;\n}\n\nfunction find(vertex, parents) {\n  if (vertex !== parents[vertex]) {\n    parents[vertex] = find(parents[vertex], parents);\n  }\n\n  return parents[vertex];\n}\n\nfunction union(vertex1Root, vertex2Root, parents, ranks) {\n  if (ranks[vertex1Root] < ranks[vertex2Root]) {\n    parents[vertex1Root] = vertex2Root;\n  } else if (ranks[vertex1Root] > ranks[vertex2Root]) {\n    parents[vertex2Root] = vertex1Root;\n  } else {\n    parents[vertex2Root] = vertex1Root;\n    ranks[vertex1Root] += 1;\n  }\n}\n\n// Do not edit the line below.\nexports.kruskalsAlgorithm = kruskalsAlgorithm;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [[[1, 1]], [[0, 1]]];\n  const expected = [[[1, 1]], [[0, 1]]];\n  const actual = program.kruskalsAlgorithm(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [[[1, 1]], [[0, 1]]];\n  const expected = [[[1, 1]], [[0, 1]]];\n  const actual = program.kruskalsAlgorithm(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun kruskalsAlgorithm(edges: List<List<List<Int>>>): List<List<List<Int>>> {\n    // Write your code here.\n    return listOf()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(e * log(e)) time | O(e + v) space - where e is the number\n// of edges in the input edges and v is the number of vertices\nfun kruskalsAlgorithm(edges: List<List<List<Int>>>): List<List<List<Int>>> {\n    val edgeList = mutableListOf<List<Int>>()\n    for (sourceIndex in 0 until edges.size) {\n        val vertex = edges[sourceIndex]\n        for (edge in vertex) {\n            if (edge[0] > sourceIndex) {\n                edgeList.add(listOf(sourceIndex, edge[0], edge[1]))\n            }\n        }\n    }\n    val sortedEdges = edgeList.sortedWith(\n        Comparator<List<Int>> { edgeA, edgeB ->\n            edgeA[2] - edgeB[2]\n        },\n    )\n\n    val parents = MutableList(edges.size) { it }\n    val ranks = MutableList(edges.size) { 0 }\n    val mst = MutableList(edges.size) { mutableListOf<List<Int>>() }\n    for (edge in sortedEdges) {\n        val vertex1Root = find(edge[0], parents)\n        val vertex2Root = find(edge[1], parents)\n        if (vertex1Root != vertex2Root) {\n            mst[edge[0]].add(listOf(edge[1], edge[2]))\n            mst[edge[1]].add(listOf(edge[0], edge[2]))\n            union(vertex1Root, vertex2Root, parents, ranks)\n        }\n    }\n\n    return mst\n}\n\nfun find(vertex: Int, parents: MutableList<Int>): Int {\n    if (vertex != parents[vertex]) {\n        parents[vertex] = find(parents[vertex], parents)\n    }\n\n    return parents[vertex]\n}\n\nfun union(vertex1Root: Int, vertex2Root: Int, parents: MutableList<Int>, ranks: MutableList<Int>) {\n    if (ranks[vertex1Root] < ranks[vertex2Root]) {\n        parents[vertex1Root] = vertex2Root\n    } else if (ranks[vertex1Root] > ranks[vertex2Root]) {\n        parents[vertex2Root] = vertex1Root\n    } else {\n        parents[vertex2Root] = vertex1Root\n        ranks[vertex1Root] += 1\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.kruskalsAlgorithm\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(listOf(listOf(1, 1)), listOf(listOf(0, 1)))\n        val expected = listOf(listOf(listOf(1, 1)), listOf(listOf(0, 1)))\n        val output = kruskalsAlgorithm(input)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.kruskalsAlgorithm\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(listOf(listOf(1, 1)), listOf(listOf(0, 1)))\n        val expected = listOf(listOf(listOf(1, 1)), listOf(listOf(0, 1)))\n        val output = kruskalsAlgorithm(input)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def kruskalsAlgorithm(edges):\n    # Write your code here.\n    return []\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(e * log(e)) time | O(e + v) space - where e is the number\n# of edges in the input edges and v is the number of vertices\ndef kruskalsAlgorithm(edges):\n    edgeList = []\n    for sourceIndex, vertex in enumerate(edges):\n        for edge in vertex:\n            if edge[0] > sourceIndex:\n                edgeList.append([sourceIndex, edge[0], edge[1]])\n    sortedEdges = sorted(edgeList, key=lambda edge: edge[2])\n\n    parents = [vertex for vertex in range(len(edges))]\n    ranks = [0 for _ in range(len(edges))]\n    mst = [[] for _ in range(len(edges))]\n    for edge in sortedEdges:\n        vertex1Root = find(edge[0], parents)\n        vertex2Root = find(edge[1], parents)\n        if vertex1Root != vertex2Root:\n            mst[edge[0]].append([edge[1], edge[2]])\n            mst[edge[1]].append([edge[0], edge[2]])\n            union(vertex1Root, vertex2Root, parents, ranks)\n\n    return mst\n\n\ndef find(vertex, parents):\n    if vertex != parents[vertex]:\n        parents[vertex] = find(parents[vertex], parents)\n\n    return parents[vertex]\n\n\ndef union(vertex1Root, vertex2Root, parents, ranks):\n    if ranks[vertex1Root] < ranks[vertex2Root]:\n        parents[vertex1Root] = vertex2Root\n    elif ranks[vertex1Root] > ranks[vertex2Root]:\n        parents[vertex2Root] = vertex1Root\n    else:\n        parents[vertex2Root] = vertex1Root\n        ranks[vertex1Root] += 1\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [[[1, 1]], [[0, 1]]]\n        expected = [[[1, 1]], [[0, 1]]]\n        actual = program.kruskalsAlgorithm(input)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [[[1, 1]], [[0, 1]]]\n        expected = [[[1, 1]], [[0, 1]]]\n        actual = program.kruskalsAlgorithm(input)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "\nclass Program\n    def kruskalsAlgorithm(edges)\n        # Write your code here.\n        return []\n    end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n\nclass Program\n    def kruskalsAlgorithm(edges)\n        # Write your code here.\n        return []\n    end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire './program.rb'\n\nclass TestSuite\n    include Assertions\n    def test_1\n        # inputs = ...\n        # output = Program.new.kruskalsAlgorithm\n        # expected = ...\n        # assertEqual(expected, output)\n    end\nend\n\n",
      "unitTests": "require './program.rb'\n\nclass TestSuite\n    include Assertions\n    def test_1\n        # inputs = ...\n        # output = Program.new.kruskalsAlgorithm\n        # expected = ...\n        # assertEqual(expected, output)\n    end\nend\n\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func kruskalsAlgorithm(_ edges: [[[Int]]]) -> [[[Int]]] {\n    // Write your code here.\n    return [[[Int]]]()\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(e * log(e)) time | O(e + v) space - where e is the number\n  // of edges in the input edges and v is the number of vertices\n  func kruskalsAlgorithm(_ edges: [[[Int]]]) -> [[[Int]]] {\n    var sortedEdges = [[Int]]()\n    for (sourceIndex, vertex) in edges.enumerated() {\n      for edge in vertex {\n        if edge[0] > sourceIndex {\n          sortedEdges.append([sourceIndex, edge[0], edge[1]])\n        }\n      }\n    }\n\n    sortedEdges.sort(by: { $0[2] < $1[2] })\n\n    var parents = [Int](repeating: 0, count: edges.count)\n    var ranks = [Int](repeating: 0, count: edges.count)\n    var mst = [[[Int]]]()\n\n    for i in 0 ..< edges.count {\n      parents[i] = i\n      ranks[i] = 0\n      mst.append([[Int]]())\n    }\n\n    for edge in sortedEdges {\n      let vertex1Root = find(edge[0], &parents)\n      let vertex2Root = find(edge[1], &parents)\n      if vertex1Root != vertex2Root {\n        mst[edge[0]].append([edge[1], edge[2]])\n        mst[edge[1]].append([edge[0], edge[2]])\n        union(vertex1Root, vertex2Root, &parents, &ranks)\n      }\n    }\n    return mst\n  }\n\n  func find(_ vertex: Int, _ parents: inout [Int]) -> Int {\n    if vertex != parents[vertex] {\n      parents[vertex] = find(parents[vertex], &parents)\n    }\n    return parents[vertex]\n  }\n\n  func union(_ vertex1Root: Int, _ vertex2Root: Int, _ parents: inout [Int], _ ranks: inout [Int]) {\n    if ranks[vertex1Root] < ranks[vertex2Root] {\n      parents[vertex1Root] = vertex2Root\n    } else if ranks[vertex1Root] > ranks[vertex2Root] {\n      parents[vertex2Root] = vertex1Root\n    } else {\n      parents[vertex2Root] = vertex1Root\n      ranks[vertex1Root] += 1\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      var input = [[[1, 1]], [[0, 1]]]\n      var expected = [[[1, 1]], [[0, 1]]]\n      var actual = Program().kruskalsAlgorithm(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      var input = [[[1, 1]], [[0, 1]]]\n      var expected = [[[1, 1]], [[0, 1]]]\n      var actual = Program().kruskalsAlgorithm(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function kruskalsAlgorithm(edges: number[][][]) {\n  // Write your code here.\n  return [];\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(e * log(e)) time | O(e + v) space - where e is the number\n// of edges in the input edges and v is the number of vertices\nexport function kruskalsAlgorithm(edges: [number, number][][]) {\n  const edgeList: [number, number, number][] = [];\n  for (let sourceIndex = 0; sourceIndex < edges.length; sourceIndex++) {\n    const vertex = edges[sourceIndex];\n    for (const edge of vertex) {\n      if (edge[0] > sourceIndex) {\n        edgeList.push([sourceIndex, edge[0], edge[1]]);\n      }\n    }\n  }\n  const sortedEdges = edgeList.sort((edgeA, edgeB) => {\n    if (edgeA[2] > edgeB[2]) return 1;\n    if (edgeA[2] < edgeB[2]) return -1;\n    return 0;\n  });\n\n  const parents = edges.map((_, i) => i);\n  const ranks = edges.map(_ => 0);\n  const mst: [number, number][][] = edges.map(_ => []);\n  for (const edge of sortedEdges) {\n    const vertex1Root = find(edge[0], parents);\n    const vertex2Root = find(edge[1], parents);\n    if (vertex1Root !== vertex2Root) {\n      mst[edge[0]].push([edge[1], edge[2]]);\n      mst[edge[1]].push([edge[0], edge[2]]);\n      union(vertex1Root, vertex2Root, parents, ranks);\n    }\n  }\n\n  return mst;\n}\n\nfunction find(vertex: number, parents: number[]) {\n  if (vertex !== parents[vertex]) {\n    parents[vertex] = find(parents[vertex], parents);\n  }\n\n  return parents[vertex];\n}\n\nfunction union(vertex1Root: number, vertex2Root: number, parents: number[], ranks: number[]) {\n  if (ranks[vertex1Root] < ranks[vertex2Root]) {\n    parents[vertex1Root] = vertex2Root;\n  } else if (ranks[vertex1Root] > ranks[vertex2Root]) {\n    parents[vertex2Root] = vertex1Root;\n  } else {\n    parents[vertex2Root] = vertex1Root;\n    ranks[vertex1Root] += 1;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input: [number, number][][] = [[[1, 1]], [[0, 1]]];\n  const expected = [[[1, 1]], [[0, 1]]];\n  const actual = program.kruskalsAlgorithm(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input: [number, number][][] = [[[1, 1]], [[0, 1]]];\n  const expected = [[[1, 1]], [[0, 1]]];\n  const actual = program.kruskalsAlgorithm(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "edges",
      "example": [
        [
          [
            1,
            1
          ]
        ],
        [
          [
            0,
            1
          ]
        ]
      ],
      "schema": {
        "items": {
          "items": {
            "items": {
              "items": {
                "maxItems": 2,
                "minItems": 2
              },
              "type": "integer"
            },
            "type": "array"
          },
          "type": "array"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "edges": [
        [
          [
            1,
            1
          ]
        ],
        [
          [
            0,
            1
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            1
          ]
        ],
        [
          [
            0,
            1
          ],
          [
            2,
            2
          ]
        ],
        [
          [
            1,
            2
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            3
          ],
          [
            2,
            5
          ]
        ],
        [
          [
            0,
            3
          ],
          [
            2,
            10
          ],
          [
            3,
            12
          ]
        ],
        [
          [
            0,
            5
          ],
          [
            1,
            10
          ]
        ],
        [
          [
            1,
            12
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            3
          ],
          [
            2,
            5
          ]
        ],
        [
          [
            0,
            3
          ],
          [
            2,
            10
          ],
          [
            3,
            12
          ],
          [
            4,
            1
          ]
        ],
        [
          [
            0,
            5
          ],
          [
            1,
            10
          ],
          [
            4,
            7
          ]
        ],
        [
          [
            1,
            12
          ]
        ],
        [
          [
            1,
            1
          ],
          [
            2,
            7
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            3
          ],
          [
            2,
            5
          ]
        ],
        [
          [
            0,
            3
          ],
          [
            2,
            10
          ],
          [
            3,
            12
          ],
          [
            4,
            1
          ]
        ],
        [
          [
            0,
            5
          ],
          [
            1,
            10
          ],
          [
            4,
            7
          ]
        ],
        [
          [
            1,
            12
          ],
          [
            4,
            11
          ]
        ],
        [
          [
            1,
            1
          ],
          [
            2,
            7
          ],
          [
            3,
            11
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            7
          ]
        ],
        [
          [
            0,
            7
          ],
          [
            2,
            6
          ],
          [
            4,
            3
          ]
        ],
        [
          [
            1,
            6
          ]
        ],
        [
          [
            4,
            2
          ]
        ],
        [
          [
            1,
            3
          ],
          [
            3,
            2
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            7
          ]
        ],
        [
          [
            0,
            7
          ],
          [
            2,
            6
          ],
          [
            4,
            3
          ]
        ],
        [
          [
            1,
            6
          ],
          [
            3,
            14
          ]
        ],
        [
          [
            2,
            14
          ],
          [
            4,
            2
          ]
        ],
        [
          [
            1,
            3
          ],
          [
            3,
            2
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            7
          ]
        ],
        [
          [
            0,
            7
          ],
          [
            2,
            6
          ],
          [
            3,
            20
          ],
          [
            4,
            3
          ]
        ],
        [
          [
            1,
            6
          ],
          [
            3,
            14
          ]
        ],
        [
          [
            1,
            20
          ],
          [
            2,
            14
          ],
          [
            4,
            2
          ]
        ],
        [
          [
            1,
            3
          ],
          [
            3,
            2
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            7
          ],
          [
            2,
            5
          ]
        ],
        [
          [
            0,
            7
          ],
          [
            2,
            6
          ],
          [
            3,
            20
          ],
          [
            4,
            3
          ]
        ],
        [
          [
            0,
            5
          ],
          [
            1,
            6
          ],
          [
            3,
            14
          ]
        ],
        [
          [
            1,
            20
          ],
          [
            2,
            14
          ],
          [
            4,
            2
          ]
        ],
        [
          [
            1,
            3
          ],
          [
            3,
            2
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            1
          ]
        ],
        [
          [
            0,
            1
          ]
        ],
        [
          [
            3,
            1
          ]
        ],
        [
          [
            2,
            1
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            1
          ]
        ],
        [
          [
            0,
            1
          ]
        ],
        [
          [
            3,
            3
          ]
        ],
        [
          [
            2,
            3
          ]
        ],
        [
          [
            5,
            5
          ]
        ],
        [
          [
            4,
            5
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            3
          ]
        ],
        [
          [
            0,
            3
          ],
          [
            3,
            12
          ]
        ],
        [
          [
            4,
            10
          ],
          [
            5,
            20
          ]
        ],
        [
          [
            1,
            12
          ]
        ],
        [
          [
            2,
            10
          ],
          [
            5,
            15
          ]
        ],
        [
          [
            2,
            20
          ],
          [
            4,
            15
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            3
          ],
          [
            2,
            5
          ]
        ],
        [
          [
            0,
            3
          ],
          [
            2,
            12
          ],
          [
            3,
            20
          ],
          [
            4,
            3
          ]
        ],
        [
          [
            0,
            5
          ],
          [
            1,
            12
          ],
          [
            3,
            14
          ],
          [
            6,
            10
          ]
        ],
        [
          [
            1,
            20
          ],
          [
            2,
            14
          ],
          [
            4,
            2
          ]
        ],
        [
          [
            1,
            3
          ],
          [
            3,
            2
          ],
          [
            5,
            11
          ]
        ],
        [
          [
            4,
            11
          ],
          [
            6,
            2
          ]
        ],
        [
          [
            2,
            10
          ],
          [
            5,
            2
          ],
          [
            7,
            100
          ]
        ],
        [
          [
            6,
            100
          ]
        ]
      ]
    }
  ],
  "jsonTests": [
    {
      "edges": [
        [
          [
            1,
            1
          ]
        ],
        [
          [
            0,
            1
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            1
          ]
        ],
        [
          [
            0,
            1
          ],
          [
            2,
            2
          ]
        ],
        [
          [
            1,
            2
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            3
          ],
          [
            2,
            5
          ]
        ],
        [
          [
            0,
            3
          ],
          [
            2,
            10
          ],
          [
            3,
            12
          ]
        ],
        [
          [
            0,
            5
          ],
          [
            1,
            10
          ]
        ],
        [
          [
            1,
            12
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            3
          ],
          [
            2,
            5
          ]
        ],
        [
          [
            0,
            3
          ],
          [
            2,
            10
          ],
          [
            3,
            12
          ],
          [
            4,
            1
          ]
        ],
        [
          [
            0,
            5
          ],
          [
            1,
            10
          ],
          [
            4,
            7
          ]
        ],
        [
          [
            1,
            12
          ]
        ],
        [
          [
            1,
            1
          ],
          [
            2,
            7
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            3
          ],
          [
            2,
            5
          ]
        ],
        [
          [
            0,
            3
          ],
          [
            2,
            10
          ],
          [
            3,
            12
          ],
          [
            4,
            1
          ]
        ],
        [
          [
            0,
            5
          ],
          [
            1,
            10
          ],
          [
            4,
            7
          ]
        ],
        [
          [
            1,
            12
          ],
          [
            4,
            11
          ]
        ],
        [
          [
            1,
            1
          ],
          [
            2,
            7
          ],
          [
            3,
            11
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            7
          ]
        ],
        [
          [
            0,
            7
          ],
          [
            2,
            6
          ],
          [
            4,
            3
          ]
        ],
        [
          [
            1,
            6
          ]
        ],
        [
          [
            4,
            2
          ]
        ],
        [
          [
            1,
            3
          ],
          [
            3,
            2
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            7
          ]
        ],
        [
          [
            0,
            7
          ],
          [
            2,
            6
          ],
          [
            4,
            3
          ]
        ],
        [
          [
            1,
            6
          ],
          [
            3,
            14
          ]
        ],
        [
          [
            2,
            14
          ],
          [
            4,
            2
          ]
        ],
        [
          [
            1,
            3
          ],
          [
            3,
            2
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            7
          ]
        ],
        [
          [
            0,
            7
          ],
          [
            2,
            6
          ],
          [
            3,
            20
          ],
          [
            4,
            3
          ]
        ],
        [
          [
            1,
            6
          ],
          [
            3,
            14
          ]
        ],
        [
          [
            1,
            20
          ],
          [
            2,
            14
          ],
          [
            4,
            2
          ]
        ],
        [
          [
            1,
            3
          ],
          [
            3,
            2
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            7
          ],
          [
            2,
            5
          ]
        ],
        [
          [
            0,
            7
          ],
          [
            2,
            6
          ],
          [
            3,
            20
          ],
          [
            4,
            3
          ]
        ],
        [
          [
            0,
            5
          ],
          [
            1,
            6
          ],
          [
            3,
            14
          ]
        ],
        [
          [
            1,
            20
          ],
          [
            2,
            14
          ],
          [
            4,
            2
          ]
        ],
        [
          [
            1,
            3
          ],
          [
            3,
            2
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            1
          ]
        ],
        [
          [
            0,
            1
          ]
        ],
        [
          [
            3,
            1
          ]
        ],
        [
          [
            2,
            1
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            1
          ]
        ],
        [
          [
            0,
            1
          ]
        ],
        [
          [
            3,
            3
          ]
        ],
        [
          [
            2,
            3
          ]
        ],
        [
          [
            5,
            5
          ]
        ],
        [
          [
            4,
            5
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            3
          ]
        ],
        [
          [
            0,
            3
          ],
          [
            3,
            12
          ]
        ],
        [
          [
            4,
            10
          ],
          [
            5,
            20
          ]
        ],
        [
          [
            1,
            12
          ]
        ],
        [
          [
            2,
            10
          ],
          [
            5,
            15
          ]
        ],
        [
          [
            2,
            20
          ],
          [
            4,
            15
          ]
        ]
      ]
    },
    {
      "edges": [
        [
          [
            1,
            3
          ],
          [
            2,
            5
          ]
        ],
        [
          [
            0,
            3
          ],
          [
            2,
            12
          ],
          [
            3,
            20
          ],
          [
            4,
            3
          ]
        ],
        [
          [
            0,
            5
          ],
          [
            1,
            12
          ],
          [
            3,
            14
          ],
          [
            6,
            10
          ]
        ],
        [
          [
            1,
            20
          ],
          [
            2,
            14
          ],
          [
            4,
            2
          ]
        ],
        [
          [
            1,
            3
          ],
          [
            3,
            2
          ],
          [
            5,
            11
          ]
        ],
        [
          [
            4,
            11
          ],
          [
            6,
            2
          ]
        ],
        [
          [
            2,
            10
          ],
          [
            5,
            2
          ],
          [
            7,
            100
          ]
        ],
        [
          [
            6,
            100
          ]
        ]
      ]
    }
  ],
  "changelog": []
}