{
  "uid": "line-through-points",
  "testStrategy": "JSON",
  "name": "Line Through Points",
  "version": 0,
  "releaseDate": "2021-03-02T00:00:00Z",
  "category": "Arrays",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 3638,
    "failureCount": 1136
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "516359008",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 1678
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given an array of points plotted on a 2D graph (the xy-plane). Write a\n  function that returns the maximum number of points that a single line (or\n  potentially multiple lines) on the graph passes through.\n</p>\n<p>\n  The input array will contain points represented by an array of two integers\n  <span>[x, y]</span>. The input array will never contain duplicate points and\n  will always contain at least one point.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">points</span> = [\n  [1, 1],\n  [2, 2],\n  [3, 3],\n  [0, 4],\n  [-2, 6],\n  [4, 0],\n  [2, 1],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n4 <span class=\"CodeEditor-promptComment\">// A line passes through points: [-2, 6], [0, 4], [2, 2], [4, 0].</span>\n</pre>\n</div>",
  "hints": [
    "<p>\n  The brute-force approach to solve this problem is to consider every single\n  pair of points and to form a line using them. Then, for each line, you\n  determine how many points lie on that line by using the equation of the line\n  you formed and checking if each point's coordinates solve the equation. This\n  solution runs in <span>O(n^3)</span> time; can you come up with a better\n  approach?\n</p>\n",
    "\n<p>What does it mean if two lines have the same slope and share a point?</p>\n",
    "\n<p>\n  If two lines have the same slope and share a point, they're the same line. Try\n  using a hash table to store the slopes of lines that pass through certain\n  points. How does this help you write an algorithm that runs in\n  <span>O(n^2)</span> time?\n</p>\n",
    "\n<p>\n  Loop through every single pair of points, picking a <span>p2</span> for every\n  <span>p1</span> in order to form a line. For every pair <span>(p1, p2)</span>,\n  store the slope of the formed line in a hash table, and map it to the number\n  of points on that line. If you ever find two identical slopes for lines that\n  both use the same point <span>p1</span>, you can consider these lines to be\n  one and the same, meaning that points <span>p1, p2a, and p2b</span> are all on\n  the same line; in those cases, update the number of points on the slope (the\n  line) in the hash table accordingly. You'll need to reset the hash table at\n  each change of <span>p1</span>. See the Conceptual Overview section of this\n  question's video explanation for a more in-depth explanation.\n</p>"
  ],
  "spaceTime": "O(n^2) time | O(n) space - where n is the number of points",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nint lineThroughPoints(vector<vector<int>> points) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <cmath>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nvector<int> getSlopeOfLineBetweenPoints(vector<int> p1, vector<int> p2);\nstring createHashableKeyForRational(int numerator, int denominator);\nint getGreatestCommonDivisor(int num1, int num2);\n\n// O(n^2) time | O(n) space - where n is the number of points\nint lineThroughPoints(vector<vector<int>> points) {\n  int maxNumberOfPointsOnLine = 1;\n\n  for (int idx1 = 0; idx1 < points.size(); idx1++) {\n    auto p1 = points[idx1];\n    unordered_map<string, int> slopes;\n    for (int idx2 = idx1 + 1; idx2 < points.size(); idx2++) {\n      auto p2 = points[idx2];\n      auto slope = getSlopeOfLineBetweenPoints(p1, p2);\n      int rise = slope[0];\n      int run = slope[1];\n      string slopeKey = createHashableKeyForRational(rise, run);\n      if (slopes.find(slopeKey) == slopes.end()) slopes[slopeKey] = 1;\n\n      slopes[slopeKey]++;\n    }\n\n    int currentMaxNumberOfPointsOnLine = 0;\n    for (auto it : slopes) {\n      if (it.second > currentMaxNumberOfPointsOnLine) {\n        currentMaxNumberOfPointsOnLine = it.second;\n      }\n    }\n\n    maxNumberOfPointsOnLine =\n      max(maxNumberOfPointsOnLine, currentMaxNumberOfPointsOnLine);\n  }\n\n  return maxNumberOfPointsOnLine;\n}\n\nvector<int> getSlopeOfLineBetweenPoints(vector<int> p1, vector<int> p2) {\n  int p1x = p1[0];\n  int p1y = p1[1];\n  int p2x = p2[0];\n  int p2y = p2[1];\n  vector<int> slope = {1, 0};  // slope of a vertical lines\n\n  if (p1x != p2x) {\n    // if line is not vertical\n    int xDiff = p1x - p2x;\n    int yDiff = p1y - p2y;\n    int gcd = getGreatestCommonDivisor(abs(xDiff), abs(yDiff));\n    xDiff = xDiff / gcd;\n    yDiff = yDiff / gcd;\n    if (xDiff < 0) {\n      xDiff *= -1;\n      yDiff *= -1;\n    }\n\n    slope = {yDiff, xDiff};\n  }\n\n  return slope;\n}\n\nstring createHashableKeyForRational(int numerator, int denominator) {\n  return to_string(numerator) + \":\" + to_string(denominator);\n}\n\nint getGreatestCommonDivisor(int num1, int num2) {\n  int a = num1;\n  int b = num2;\n  while (true) {\n    if (a == 0) return b;\n    if (b == 0) return a;\n\n    int tempA = a;\n    a = b;\n    b = tempA % b;\n  }\n}"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> input = {\n        {1, 1}, {2, 2}, {3, 3}, {0, 4}, {-2, 6}, {4, 0}, {2, 1}};\n      auto expected = 4;\n      auto actual = lineThroughPoints(input);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> input = {\n        {1, 1}, {2, 2}, {3, 3}, {0, 4}, {-2, 6}, {4, 0}, {2, 1}};\n      auto expected = 4;\n      auto actual = lineThroughPoints(input);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public int LineThroughPoints(int[][] points) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // O(n^2) time | O(n) space - where n is the number of points\n  public int LineThroughPoints(int[][] points) {\n    int maxNumberOfPointsOnLine = 1;\n\n    for (int idx1 = 0; idx1 < points.Length; idx1++) {\n      int[] p1 = points[idx1];\n      Dictionary<string, int> slopes = new Dictionary<string, int>();\n\n      for (int idx2 = idx1 + 1; idx2 < points.Length; idx2++) {\n        int[] p2 = points[idx2];\n        int[] slopeOfLineBetweenPoints = getSlopeOfLineBetweenPoints(p1, p2);\n        int rise = slopeOfLineBetweenPoints[0];\n        int run = slopeOfLineBetweenPoints[1];\n\n        string slopeKey = createHashableKeyForRational(rise, run);\n        if (!slopes.ContainsKey(slopeKey)) {\n          slopes[slopeKey] = 1;\n        }\n        slopes[slopeKey] = slopes[slopeKey] + 1;\n      }\n\n      int currentMaxNumberOfPointsOnLine = maxSlope(slopes);\n      maxNumberOfPointsOnLine =\n        Math.Max(maxNumberOfPointsOnLine, currentMaxNumberOfPointsOnLine);\n    }\n\n    return maxNumberOfPointsOnLine;\n  }\n\n  public int[] getSlopeOfLineBetweenPoints(int[] p1, int[] p2) {\n    int p1x = p1[0];\n    int p1y = p1[1];\n    int p2x = p2[0];\n    int p2y = p2[1];\n\n    int[] slope = new int[] { 1, 0 };  // slope of a vertical line\n\n    if (p1x != p2x) {  // if line is not vertical\n      int xDiff = p1x - p2x;\n      int yDiff = p1y - p2y;\n      int gcd = getGreatestCommonDivisor(Math.Abs(xDiff), Math.Abs(yDiff));\n      xDiff = xDiff / gcd;\n      yDiff = yDiff / gcd;\n      if (xDiff < 0) {\n        xDiff *= -1;\n        yDiff *= -1;\n      }\n\n      slope = new int[] { yDiff, xDiff };\n    }\n\n    return slope;\n  }\n\n  public string createHashableKeyForRational(int numerator, int denominator) {\n    return numerator.ToString() + \":\" + denominator.ToString();\n  }\n\n  public int maxSlope(Dictionary<string, int> slopes) {\n    int currentMax = 0;\n    foreach (var slope in slopes) {\n      currentMax = Math.Max(slope.Value, currentMax);\n    }\n    return currentMax;\n  }\n\n  public int getGreatestCommonDivisor(int num1, int num2) {\n    int a = num1;\n    int b = num2;\n    while (true) {\n      if (a == 0) {\n        return b;\n      }\n      if (b == 0) {\n        return a;\n      }\n      int temp = a;\n      a = b;\n      b = temp % b;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[][] input = new int[][] {\n      new int[] { 1, 1 },\n      new int[] { 2, 2 },\n      new int[] { 3, 3 },\n      new int[] { 0, 4 },\n      new int[] { -2, 6 },\n      new int[] { 4, 0 },\n      new int[] { 2, 1 },\n    };\n    int expected = 4;\n    int actual = new Program().LineThroughPoints(input);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[][] input = new int[][] {\n      new int[] { 1, 1 },\n      new int[] { 2, 2 },\n      new int[] { 3, 3 },\n      new int[] { 0, 4 },\n      new int[] { -2, 6 },\n      new int[] { 4, 0 },\n      new int[] { 2, 1 },\n    };\n    int expected = 4;\n    int actual = new Program().LineThroughPoints(input);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc LineThroughPoints(points [][]int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// O(n^2) time | O(n) space - where n is the number of points\nfunc LineThroughPoints(points [][]int) int {\n\tmaxNumberOfPointsOnLine := 1\n\n\tfor idx1, p1 := range points {\n\t\tslopes := map[string]int{}\n\t\tfor idx2 := idx1 + 1; idx2 < len(points); idx2++ {\n\t\t\tp2 := points[idx2]\n\t\t\trise, run := getSlopeOfLineBetweenPoints(p1, p2)\n\t\t\tslopeKey := createHashtableKeyForRational(rise, run)\n\t\t\tif slopes[slopeKey] == 0 {\n\t\t\t\tslopes[slopeKey] = 1\n\t\t\t}\n\t\t\tslopes[slopeKey] += 1\n\t\t}\n\n\t\tcurrentMaxNumberOfPointsOnLine := maxSlope(slopes)\n\t\tmaxNumberOfPointsOnLine = max(maxNumberOfPointsOnLine, currentMaxNumberOfPointsOnLine)\n\t}\n\treturn maxNumberOfPointsOnLine\n}\n\nfunc getSlopeOfLineBetweenPoints(p1, p2 []int) (int, int) {\n\tp1x, p1y := p1[0], p1[1]\n\tp2x, p2y := p2[0], p2[1]\n\n\tif p1x == p2x {\n\t\treturn 1, 0\n\t}\n\n\tvar xDiff = p1x - p2x\n\tvar yDiff = p1y - p2y\n\tgcd := getGreatestCommonDivisor(abs(xDiff), abs(yDiff))\n\txDiff = xDiff / gcd\n\tyDiff = yDiff / gcd\n\tif xDiff < 0 {\n\t\txDiff *= -1\n\t\tyDiff *= -1\n\t}\n\n\treturn yDiff, xDiff\n}\n\nfunc getGreatestCommonDivisor(num1, num2 int) int {\n\ta := num1\n\tb := num2\n\tfor {\n\t\tif a == 0 {\n\t\t\treturn b\n\t\t}\n\t\tif b == 0 {\n\t\t\treturn a\n\t\t}\n\t\ta, b = b, a%b\n\t}\n}\n\nfunc createHashtableKeyForRational(numerator int, denominator int) string {\n\treturn fmt.Sprintf(\"%d:%d\", numerator, denominator)\n}\n\nfunc maxSlope(slopes map[string]int) int {\n\tcurrentMax := 0\n\tfor _, slope := range slopes {\n\t\tcurrentMax = max(slope, currentMax)\n\t}\n\treturn currentMax\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc abs(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{1, 1},\n\t\t{2, 2},\n\t\t{3, 3},\n\t\t{0, 4},\n\t\t{-2, 6},\n\t\t{4, 0},\n\t\t{2, 1},\n\t}\n\texpected := 4\n\tactual := LineThroughPoints(input)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{1, 1},\n\t\t{2, 2},\n\t\t{3, 3},\n\t\t{0, 4},\n\t\t{-2, 6},\n\t\t{4, 0},\n\t\t{2, 1},\n\t}\n\texpected := 4\n\tactual := LineThroughPoints(input)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public int lineThroughPoints(int[][] points) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n^2) time | O(n) space - where n is the number of points\n  public int lineThroughPoints(int[][] points) {\n    int maxNumberOfPointsOnLine = 1;\n\n    for (int idx1 = 0; idx1 < points.length; idx1++) {\n      int[] p1 = points[idx1];\n      HashMap<String, Integer> slopes = new HashMap<String, Integer>();\n\n      for (int idx2 = idx1 + 1; idx2 < points.length; idx2++) {\n        int[] p2 = points[idx2];\n        int[] slopeOfLineBetweenPoints = getSlopeOfLineBetweenPoints(p1, p2);\n        int rise = slopeOfLineBetweenPoints[0];\n        int run = slopeOfLineBetweenPoints[1];\n\n        String slopeKey = createHashableKeyForRational(rise, run);\n        if (!slopes.containsKey(slopeKey)) {\n          slopes.put(slopeKey, 1);\n        }\n        slopes.put(slopeKey, slopes.get(slopeKey) + 1);\n      }\n\n      int currentMaxNumberOfPointsOnLine = maxSlope(slopes);\n      maxNumberOfPointsOnLine =\n        Math.max(maxNumberOfPointsOnLine, currentMaxNumberOfPointsOnLine);\n    }\n\n    return maxNumberOfPointsOnLine;\n  }\n\n  public int[] getSlopeOfLineBetweenPoints(int[] p1, int[] p2) {\n    int p1x = p1[0];\n    int p1y = p1[1];\n    int p2x = p2[0];\n    int p2y = p2[1];\n\n    int[] slope = new int[] {1, 0}; // slope of a vertical line\n\n    if (p1x != p2x) { // if line is not vertical\n      int xDiff = p1x - p2x;\n      int yDiff = p1y - p2y;\n      int gcd = getGreatestCommonDivisor(Math.abs(xDiff), Math.abs(yDiff));\n      xDiff = xDiff / gcd;\n      yDiff = yDiff / gcd;\n      if (xDiff < 0) {\n        xDiff *= -1;\n        yDiff *= -1;\n      }\n\n      slope = new int[] {yDiff, xDiff};\n    }\n\n    return slope;\n  }\n\n  public String createHashableKeyForRational(int numerator, int denominator) {\n    return String.valueOf(numerator) + \":\" + String.valueOf(denominator);\n  }\n\n  public int maxSlope(HashMap<String, Integer> slopes) {\n    int currentMax = 0;\n    for (Map.Entry<String, Integer> slope : slopes.entrySet()) {\n      currentMax = Math.max(slope.getValue(), currentMax);\n    }\n    return currentMax;\n  }\n\n  public int getGreatestCommonDivisor(int num1, int num2) {\n    int a = num1;\n    int b = num2;\n    while (true) {\n      if (a == 0) {\n        return b;\n      }\n      if (b == 0) {\n        return a;\n      }\n      int temp = a;\n      a = b;\n      b = temp % b;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] input =\n      new int[][] {{1, 1}, {2, 2}, {3, 3}, {0, 4}, {-2, 6}, {4, 0}, {2, 1}};\n    int expected = 4;\n    int actual = new Program().lineThroughPoints(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] input =\n      new int[][] {{1, 1}, {2, 2}, {3, 3}, {0, 4}, {-2, 6}, {4, 0}, {2, 1}};\n    int expected = 4;\n    int actual = new Program().lineThroughPoints(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function lineThroughPoints(points) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.lineThroughPoints = lineThroughPoints;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space - where n is the number of points\nfunction lineThroughPoints(points) {\n  let maxNumberOfPointsOnLine = 1;\n\n  for (let idx1 = 0; idx1 < points.length; idx1++) {\n    const p1 = points[idx1];\n    const slopes = {};\n    for (let idx2 = idx1 + 1; idx2 < points.length; idx2++) {\n      const p2 = points[idx2];\n      const [rise, run] = getSlopeOfLineBetweenPoints(p1, p2);\n      const slopeKey = createHashableKeyForRational(rise, run);\n      if (!(slopeKey in slopes)) slopes[slopeKey] = 1;\n\n      slopes[slopeKey]++;\n    }\n\n    const currentMaxNumberOfPointsOnLine = Object.values(slopes).reduce(\n      (a, b) => Math.max(a, b),\n      0,\n    );\n    maxNumberOfPointsOnLine = Math.max(maxNumberOfPointsOnLine, currentMaxNumberOfPointsOnLine);\n  }\n\n  return maxNumberOfPointsOnLine;\n}\n\nfunction getSlopeOfLineBetweenPoints(p1, p2) {\n  const [p1x, p1y] = p1;\n  const [p2x, p2y] = p2;\n  let slope = [1, 0]; // slope of a vertical lines\n\n  if (p1x !== p2x) {\n    // if line is not vertical\n    let xDiff = p1x - p2x;\n    let yDiff = p1y - p2y;\n    let gcd = getGreatestCommonDivisor(Math.abs(xDiff), Math.abs(yDiff));\n    xDiff = Math.floor(xDiff / gcd);\n    yDiff = Math.floor(yDiff / gcd);\n    if (xDiff < 0) {\n      xDiff *= -1;\n      yDiff *= -1;\n    }\n\n    slope = [yDiff, xDiff];\n  }\n\n  return slope;\n}\n\nfunction createHashableKeyForRational(numerator, denominator) {\n  return numerator.toString() + ':' + denominator.toString();\n}\n\nfunction getGreatestCommonDivisor(num1, num2) {\n  let a = num1;\n  let b = num2;\n  while (true) {\n    if (a === 0) return b;\n    if (b === 0) return a;\n\n    const tempA = a;\n    a = b;\n    b = tempA % b;\n  }\n}\n\n// Do not edit the line below.\nexports.lineThroughPoints = lineThroughPoints;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 1],\n    [2, 2],\n    [3, 3],\n    [0, 4],\n    [-2, 6],\n    [4, 0],\n    [2, 1],\n  ];\n  const expected = 4;\n  const actual = program.lineThroughPoints(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 1],\n    [2, 2],\n    [3, 3],\n    [0, 4],\n    [-2, 6],\n    [4, 0],\n    [2, 1],\n  ];\n  const expected = 4;\n  const actual = program.lineThroughPoints(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun lineThroughPoints(points: List<List<Int>>): Int {\n    // Write your code here.\n    return -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.abs\nimport kotlin.math.max\n\n// O(n^2) time | O(n) space - where n is the number of points\nfun lineThroughPoints(points: List<List<Int>>): Int {\n    var maxNumberOfPointsOnLine = 1\n\n    for (idx1 in 0 until points.size) {\n        val p1 = points[idx1]\n        val slopes = mutableMapOf<String, Int>()\n        for (idx2 in idx1 + 1 until points.size) {\n            val p2 = points[idx2]\n            val (rise, run) = getSlopeOfLineBetweenPoints(p1, p2)\n            val slopeKey = createHashableKeyForRational(rise, run)\n            if (!(slopeKey in slopes)) slopes[slopeKey] = 1\n\n            slopes[slopeKey] = slopes[slopeKey]!! + 1\n        }\n\n        var currentMaxNumberOfPointsOnLine = slopes.values.toList().maxOrNull() ?: 0\n        if (currentMaxNumberOfPointsOnLine == null) currentMaxNumberOfPointsOnLine = 0\n        maxNumberOfPointsOnLine = max(maxNumberOfPointsOnLine, currentMaxNumberOfPointsOnLine)\n    }\n\n    return maxNumberOfPointsOnLine\n}\n\nfun getSlopeOfLineBetweenPoints(p1: List<Int>, p2: List<Int>): Pair<Int, Int> {\n    val (p1x, p1y) = p1\n    val (p2x, p2y) = p2\n    var slope = Pair(1, 0) // slope of a vertical line\n\n    if (p1x != p2x) { // if line is not vertical\n        var xDiff = p1x - p2x\n        var yDiff = p1y - p2y\n        val gcd = getGreatestCommonDivisor(abs(xDiff), abs(yDiff))\n        xDiff = xDiff / gcd\n        yDiff = yDiff / gcd\n        if (xDiff < 0) {\n            xDiff *= -1\n            yDiff *= -1\n        }\n\n        slope = Pair(yDiff, xDiff)\n    }\n\n    return slope\n}\n\nfun createHashableKeyForRational(numerator: Int, denominator: Int): String {\n    return numerator.toString() + \":\" + denominator.toString()\n}\n\nfun getGreatestCommonDivisor(num1: Int, num2: Int): Int {\n    var a = num1\n    var b = num2\n    while (true) {\n        if (a == 0) return b\n        if (b == 0) return a\n\n        val tempA = a\n        a = b\n        b = tempA % b\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.lineThroughPoints\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(\n            listOf(1, 1),\n            listOf(2, 2),\n            listOf(3, 3),\n            listOf(0, 4),\n            listOf(-2, 6),\n            listOf(4, 0),\n            listOf(2, 1),\n        )\n        val expected = 4\n        val output = lineThroughPoints(input)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.lineThroughPoints\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(\n            listOf(1, 1),\n            listOf(2, 2),\n            listOf(3, 3),\n            listOf(0, 4),\n            listOf(-2, 6),\n            listOf(4, 0),\n            listOf(2, 1),\n        )\n        val expected = 4\n        val output = lineThroughPoints(input)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def lineThroughPoints(points):\n    # Write your code here.\n    return 0\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n^2) time | O(n) space - where n is the number of points\ndef lineThroughPoints(points):\n    maxNumberOfPointsOnLine = 1\n\n    for idx1, p1 in enumerate(points):\n        slopes = {}\n        for idx2 in range(idx1 + 1, len(points)):\n            p2 = points[idx2]\n            rise, run = getSlopeOfLineBetweenPoints(p1, p2)\n            slopeKey = createHashableKeyForRational(rise, run)\n            if slopeKey not in slopes:\n                slopes[slopeKey] = 1\n\n            slopes[slopeKey] += 1\n\n        maxNumberOfPointsOnLine = max(maxNumberOfPointsOnLine, max(slopes.values(), default=0))\n\n    return maxNumberOfPointsOnLine\n\n\ndef getSlopeOfLineBetweenPoints(p1, p2):\n    p1x, p1y = p1\n    p2x, p2y = p2\n    slope = [1, 0]  # slope of a vertical line\n\n    if p1x != p2x:  # if line is not vertical\n        xDiff = p1x - p2x\n        yDiff = p1y - p2y\n        gcd = getGreatestCommonDivisor(abs(xDiff), abs(yDiff))\n        xDiff = xDiff // gcd\n        yDiff = yDiff // gcd\n        if xDiff < 0:\n            xDiff *= -1\n            yDiff *= -1\n\n        slope = [yDiff, xDiff]\n\n    return slope\n\n\ndef createHashableKeyForRational(numerator, denominator):\n    return str(numerator) + \":\" + str(denominator)\n\n\ndef getGreatestCommonDivisor(num1, num2):\n    a = num1\n    b = num2\n    while True:\n        if a == 0:\n            return b\n        if b == 0:\n            return a\n\n        a, b = b, a % b\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [[1, 1], [2, 2], [3, 3], [0, 4], [-2, 6], [4, 0], [2, 1]]\n        expected = 4\n        actual = program.lineThroughPoints(input)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [[1, 1], [2, 2], [3, 3], [0, 4], [-2, 6], [4, 0], [2, 1]]\n        expected = 4\n        actual = program.lineThroughPoints(input)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "class Program\n  def lineThroughPoints(points)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def lineThroughPoints(points)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.lineThroughPoints\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.lineThroughPoints\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func lineThroughPoints(_ points: [[Int]]) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^2) time | O(n) space - where n is the number of points\n  func lineThroughPoints(_ points: [[Int]]) -> Int {\n    var maxNumberOfPointsOnLine = 1\n\n    for (idx1, p1) in points.enumerated() {\n      var slopes = [String: Int]()\n      for idx2 in stride(from: idx1 + 1, to: points.count, by: 1) {\n        let p2 = points[idx2]\n        let (rise, run) = getSlopeOfLineBetweenPoints(p1, p2)\n        let slopeKey = createHashtableKeyForRational(rise, run)\n        if slopes[slopeKey] == nil {\n          slopes[slopeKey] = 1\n        }\n        slopes[slopeKey]! += 1\n      }\n\n      let currentMaxNumberOfPointsOnLine = maxSlope(slopes)\n      maxNumberOfPointsOnLine = max(maxNumberOfPointsOnLine, currentMaxNumberOfPointsOnLine)\n    }\n    return maxNumberOfPointsOnLine\n  }\n\n  func getSlopeOfLineBetweenPoints(_ p1: [Int], _ p2: [Int]) -> (Int, Int) {\n    let (p1x, p1y) = (p1[0], p1[1])\n    let (p2x, p2y) = (p2[0], p2[1])\n\n    if p1x == p2x {\n      return (1, 0)\n    }\n\n    var xDiff = p1x - p2x\n    var yDiff = p1y - p2y\n    let gcd = getGreatestCommonDivisor(abs(xDiff), abs(yDiff))\n    xDiff = xDiff / gcd\n    yDiff = yDiff / gcd\n    if xDiff < 0 {\n      xDiff *= -1\n      yDiff *= -1\n    }\n\n    return (yDiff, xDiff)\n  }\n\n  func getGreatestCommonDivisor(_ num1: Int, _ num2: Int) -> Int {\n    var a = num1\n    var b = num2\n    while true {\n      if a == 0 {\n        return b\n      }\n      if b == 0 {\n        return a\n      }\n      (a, b) = (b, a % b)\n    }\n  }\n\n  func createHashtableKeyForRational(_ numerator: Int, _ denominator: Int) -> String {\n    return String(numerator) + \":\" + String(denominator)\n  }\n\n  func maxSlope(_ slopes: [String: Int]) -> Int {\n    var currentMax = 0\n    for (_, slope) in slopes {\n      currentMax = max(slope, currentMax)\n    }\n    return currentMax\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let input = [\n        [1, 1],\n        [2, 2],\n        [3, 3],\n        [0, 4],\n        [-2, 6],\n        [4, 0],\n        [2, 1],\n      ]\n      let expected = 4\n      var actual = Program().lineThroughPoints(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let input = [\n        [1, 1],\n        [2, 2],\n        [3, 3],\n        [0, 4],\n        [-2, 6],\n        [4, 0],\n        [2, 1],\n      ]\n      let expected = 4\n      var actual = Program().lineThroughPoints(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function lineThroughPoints(points: number[][]) {\n  // Write your code here.\n  return 0;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space - where n is the number of points\nexport function lineThroughPoints(points: number[][]) {\n  let maxNumberOfPointsOnLine = 1;\n\n  for (let idx1 = 0; idx1 < points.length; idx1++) {\n    const p1 = points[idx1];\n    const slopes: {[slope: string]: number} = {};\n    for (let idx2 = idx1 + 1; idx2 < points.length; idx2++) {\n      const p2 = points[idx2];\n      const [rise, run] = getSlopeOfLineBetweenPoints(p1, p2);\n      const slopeKey = createHashableKeyForRational(rise, run);\n      if (!(slopeKey in slopes)) slopes[slopeKey] = 1;\n\n      slopes[slopeKey]++;\n    }\n\n    const currentMaxNumberOfPointsOnLine = Object.values(slopes).reduce(\n      (a, b) => Math.max(a, b),\n      0,\n    );\n    maxNumberOfPointsOnLine = Math.max(maxNumberOfPointsOnLine, currentMaxNumberOfPointsOnLine);\n  }\n\n  return maxNumberOfPointsOnLine;\n}\n\nfunction getSlopeOfLineBetweenPoints(p1: number[], p2: number[]) {\n  const [p1x, p1y] = p1;\n  const [p2x, p2y] = p2;\n  let slope = [1, 0]; // slope of a vertical lines\n\n  if (p1x !== p2x) {\n    // if line is not vertical\n    let xDiff = p1x - p2x;\n    let yDiff = p1y - p2y;\n    let gcd = getGreatestCommonDivisor(Math.abs(xDiff), Math.abs(yDiff));\n    xDiff = Math.floor(xDiff / gcd);\n    yDiff = Math.floor(yDiff / gcd);\n    if (xDiff < 0) {\n      xDiff *= -1;\n      yDiff *= -1;\n    }\n\n    slope = [yDiff, xDiff];\n  }\n\n  return slope;\n}\n\nfunction createHashableKeyForRational(numerator: number, denominator: number) {\n  return numerator.toString() + ':' + denominator.toString();\n}\n\nfunction getGreatestCommonDivisor(num1: number, num2: number) {\n  let a = num1;\n  let b = num2;\n  while (true) {\n    if (a === 0) return b;\n    if (b === 0) return a;\n\n    const tempA = a;\n    a = b;\n    b = tempA % b;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 1],\n    [2, 2],\n    [3, 3],\n    [0, 4],\n    [-2, 6],\n    [4, 0],\n    [2, 1],\n  ];\n  const expected = 4;\n  const actual = program.lineThroughPoints(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 1],\n    [2, 2],\n    [3, 3],\n    [0, 4],\n    [-2, 6],\n    [4, 0],\n    [2, 1],\n  ];\n  const expected = 4;\n  const actual = program.lineThroughPoints(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "points",
      "example": [
        [
          1,
          1
        ],
        [
          2,
          2
        ],
        [
          3,
          3
        ],
        [
          0,
          4
        ],
        [
          -2,
          6
        ],
        [
          4,
          0
        ],
        [
          2,
          1
        ]
      ],
      "schema": {
        "items": {
          "items": {
            "type": "integer"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        "minItems": 1,
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "points": [
        [
          1,
          1
        ],
        [
          2,
          2
        ],
        [
          3,
          3
        ],
        [
          0,
          4
        ],
        [
          -2,
          6
        ],
        [
          4,
          0
        ],
        [
          2,
          1
        ]
      ]
    },
    {
      "points": [
        [
          3,
          3
        ],
        [
          0,
          4
        ],
        [
          -2,
          6
        ],
        [
          4,
          0
        ],
        [
          2,
          1
        ],
        [
          3,
          4
        ],
        [
          5,
          6
        ],
        [
          0,
          0
        ]
      ]
    },
    {
      "points": [
        [
          1,
          4
        ],
        [
          3,
          5
        ],
        [
          7,
          1
        ],
        [
          5,
          4
        ],
        [
          4,
          5
        ],
        [
          9,
          2
        ],
        [
          1,
          3
        ],
        [
          2,
          8
        ]
      ]
    },
    {
      "points": [
        [
          1,
          4
        ],
        [
          4,
          1
        ],
        [
          3,
          3
        ]
      ]
    },
    {
      "points": [
        [
          0,
          0
        ]
      ]
    },
    {
      "points": [
        [
          1,
          4
        ],
        [
          4,
          1
        ],
        [
          1,
          1
        ],
        [
          4,
          4
        ],
        [
          2,
          3
        ],
        [
          3,
          2
        ],
        [
          3,
          3
        ],
        [
          2,
          2
        ],
        [
          0,
          3
        ]
      ]
    },
    {
      "points": [
        [
          1,
          4
        ],
        [
          4,
          1
        ],
        [
          1,
          1
        ],
        [
          4,
          4
        ],
        [
          2,
          3
        ],
        [
          3,
          2
        ],
        [
          3,
          3
        ],
        [
          2,
          2
        ],
        [
          0,
          3
        ],
        [
          5,
          3
        ],
        [
          3,
          -1
        ],
        [
          2,
          -3
        ],
        [
          1,
          -5
        ]
      ]
    },
    {
      "points": [
        [
          -1,
          -1
        ],
        [
          -3,
          -1
        ],
        [
          -4,
          -1
        ],
        [
          1,
          1
        ],
        [
          4,
          1
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          1,
          4
        ],
        [
          1,
          5
        ],
        [
          2,
          1
        ],
        [
          2,
          2
        ],
        [
          2,
          3
        ],
        [
          2,
          4
        ],
        [
          2,
          5
        ],
        [
          3,
          1
        ],
        [
          3,
          2
        ],
        [
          3,
          4
        ],
        [
          3,
          5
        ],
        [
          4,
          1
        ],
        [
          4,
          2
        ],
        [
          4,
          3
        ],
        [
          4,
          4
        ],
        [
          4,
          5
        ],
        [
          5,
          1
        ],
        [
          5,
          2
        ],
        [
          5,
          3
        ],
        [
          5,
          4
        ],
        [
          5,
          5
        ],
        [
          6,
          6
        ],
        [
          2,
          6
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          1,
          4
        ],
        [
          1,
          5
        ],
        [
          2,
          1
        ],
        [
          2,
          2
        ],
        [
          2,
          4
        ],
        [
          2,
          5
        ],
        [
          4,
          1
        ],
        [
          4,
          2
        ],
        [
          4,
          4
        ],
        [
          4,
          5
        ],
        [
          5,
          1
        ],
        [
          5,
          2
        ],
        [
          5,
          4
        ],
        [
          5,
          5
        ],
        [
          6,
          6
        ],
        [
          2,
          6
        ],
        [
          -1,
          -1
        ],
        [
          0,
          0
        ],
        [
          -2,
          -2
        ]
      ]
    },
    {
      "points": [
        [
          -78,
          -9
        ],
        [
          67,
          87
        ],
        [
          46,
          87
        ],
        [
          4,
          5
        ],
        [
          9,
          83
        ],
        [
          34,
          47
        ]
      ]
    },
    {
      "points": [
        [
          1000000001,
          1
        ],
        [
          1,
          1
        ],
        [
          0,
          0
        ]
      ]
    }
  ],
  "jsonTests": [
    {
      "points": [
        [
          1,
          1
        ],
        [
          2,
          2
        ],
        [
          3,
          3
        ],
        [
          0,
          4
        ],
        [
          -2,
          6
        ],
        [
          4,
          0
        ],
        [
          2,
          1
        ]
      ]
    },
    {
      "points": [
        [
          3,
          3
        ],
        [
          0,
          4
        ],
        [
          -2,
          6
        ],
        [
          4,
          0
        ],
        [
          2,
          1
        ],
        [
          3,
          4
        ],
        [
          5,
          6
        ],
        [
          0,
          0
        ]
      ]
    },
    {
      "points": [
        [
          1,
          4
        ],
        [
          3,
          5
        ],
        [
          7,
          1
        ],
        [
          5,
          4
        ],
        [
          4,
          5
        ],
        [
          9,
          2
        ],
        [
          1,
          3
        ],
        [
          2,
          8
        ]
      ]
    },
    {
      "points": [
        [
          1,
          4
        ],
        [
          4,
          1
        ],
        [
          3,
          3
        ]
      ]
    },
    {
      "points": [
        [
          0,
          0
        ]
      ]
    },
    {
      "points": [
        [
          1,
          4
        ],
        [
          4,
          1
        ],
        [
          1,
          1
        ],
        [
          4,
          4
        ],
        [
          2,
          3
        ],
        [
          3,
          2
        ],
        [
          3,
          3
        ],
        [
          2,
          2
        ],
        [
          0,
          3
        ]
      ]
    },
    {
      "points": [
        [
          1,
          4
        ],
        [
          4,
          1
        ],
        [
          1,
          1
        ],
        [
          4,
          4
        ],
        [
          2,
          3
        ],
        [
          3,
          2
        ],
        [
          3,
          3
        ],
        [
          2,
          2
        ],
        [
          0,
          3
        ],
        [
          5,
          3
        ],
        [
          3,
          -1
        ],
        [
          2,
          -3
        ],
        [
          1,
          -5
        ]
      ]
    },
    {
      "points": [
        [
          -1,
          -1
        ],
        [
          -3,
          -1
        ],
        [
          -4,
          -1
        ],
        [
          1,
          1
        ],
        [
          4,
          1
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          1,
          4
        ],
        [
          1,
          5
        ],
        [
          2,
          1
        ],
        [
          2,
          2
        ],
        [
          2,
          3
        ],
        [
          2,
          4
        ],
        [
          2,
          5
        ],
        [
          3,
          1
        ],
        [
          3,
          2
        ],
        [
          3,
          4
        ],
        [
          3,
          5
        ],
        [
          4,
          1
        ],
        [
          4,
          2
        ],
        [
          4,
          3
        ],
        [
          4,
          4
        ],
        [
          4,
          5
        ],
        [
          5,
          1
        ],
        [
          5,
          2
        ],
        [
          5,
          3
        ],
        [
          5,
          4
        ],
        [
          5,
          5
        ],
        [
          6,
          6
        ],
        [
          2,
          6
        ]
      ]
    },
    {
      "points": [
        [
          1,
          1
        ],
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          1,
          4
        ],
        [
          1,
          5
        ],
        [
          2,
          1
        ],
        [
          2,
          2
        ],
        [
          2,
          4
        ],
        [
          2,
          5
        ],
        [
          4,
          1
        ],
        [
          4,
          2
        ],
        [
          4,
          4
        ],
        [
          4,
          5
        ],
        [
          5,
          1
        ],
        [
          5,
          2
        ],
        [
          5,
          4
        ],
        [
          5,
          5
        ],
        [
          6,
          6
        ],
        [
          2,
          6
        ],
        [
          -1,
          -1
        ],
        [
          0,
          0
        ],
        [
          -2,
          -2
        ]
      ]
    },
    {
      "points": [
        [
          -78,
          -9
        ],
        [
          67,
          87
        ],
        [
          46,
          87
        ],
        [
          4,
          5
        ],
        [
          9,
          83
        ],
        [
          34,
          47
        ]
      ]
    },
    {
      "points": [
        [
          1000000001,
          1
        ],
        [
          1,
          1
        ],
        [
          0,
          0
        ]
      ]
    }
  ],
  "changelog": []
}