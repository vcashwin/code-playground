{
  "uid": "longest-increasing-subsequence",
  "testStrategy": "JSON",
  "name": "Longest Increasing Subsequence",
  "version": 0,
  "releaseDate": "2000-05-04T00:00:00Z",
  "category": "Dynamic Programming",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 6681,
    "failureCount": 2256
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "224892487",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 3247
  },
  "prompt": "<div class=\"html\">\n<p>\n  Given a non-empty array of integers, write a function that returns the longest\n  strictly-increasing subsequence in the array.\n</p>\n<p>\n  A subsequence of an array is a set of numbers that aren't necessarily adjacent\n  in the array but that are in the same order as they appear in the array. For\n  instance, the numbers <span>[1, 3, 4]</span> form a subsequence of the array\n  <span>[1, 2, 3, 4]</span>, and so do the numbers <span>[2, 4]</span>. Note\n  that a single number in an array and the array itself are both valid\n  subsequences of the array.\n</p>\n<p>\n  You can assume that there will only be one longest increasing subsequence.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">array</span> = [5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[-24, 2, 3, 5, 6, 35]\n</pre>\n</div>",
  "hints": [
    "<p>\nTry building an array of the same length as the input array. At each index in this new array, store the length of the longest increasing subsequence ending with the number found at that index in the input array.\n</p>\n",
    "\n<p>\nCan you efficiently keep track of potential sequences in another array? Instead of storing entire sequences, try storing the indices of previous numbers. For example, at index 3 in this other array, store the index of the before-last number in the longest increasing subsequence ending with the number at index 3.\n</p>\n",
    "\n<p>\nYou can optimize your algorithm by taking a slightly different approach. Instead of building the array mentioned in Hint #1, try building an array whose indices represent lengths of subsequences and whose values represent the smallest numbers in the input array that can end a subsequence of a given length. Traverse the input array, and for each number determine what the length L of the longest increasing subsequence ending with that number is; store the position of that number at index L in the new array that you're building. Find a way to use binary search to build this array.\n</p>"
  ],
  "spaceTime": "O(nlogn) time | O(n) space - where n is the length of the input array",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nvector<int> longestIncreasingSubsequence(vector<int> array) {\n  // Write your code here.\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <climits>\n#include <vector>\nusing namespace std;\n\nvector<int> buildSequence(\n  vector<int> array, vector<int> sequences, int currentIdx\n);\n\n// O(n^2) time | O(n) space\nvector<int> longestIncreasingSubsequence(vector<int> array) {\n  vector<int> sequences(array.size(), INT_MIN);\n  vector<int> lengths(array.size(), 1);\n  int maxLengthIdx = 0;\n  for (int i = 0; i < array.size(); i++) {\n    int currentNum = array[i];\n    for (int j = 0; j < i; j++) {\n      int otherNum = array[j];\n      if (otherNum < currentNum && lengths[j] + 1 >= lengths[i]) {\n        lengths[i] = lengths[j] + 1;\n        sequences[i] = j;\n      }\n    }\n    if (lengths[i] >= lengths[maxLengthIdx]) {\n      maxLengthIdx = i;\n    }\n  }\n  return buildSequence(array, sequences, maxLengthIdx);\n}\n\nvector<int> buildSequence(\n  vector<int> array, vector<int> sequences, int currentIdx\n) {\n  vector<int> sequence;\n  while (currentIdx != INT_MIN) {\n    sequence.insert(sequence.begin(), array[currentIdx]);\n    currentIdx = sequences[currentIdx];\n  }\n  return sequence;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <climits>\n#include <vector>\nusing namespace std;\n\nint binarySearch(\n  int startIdx, int endIdx, vector<int>& indices, vector<int>& array, int num\n);\nvector<int> buildSequence(\n  vector<int> array, vector<int> sequences, int currentIdx\n);\n\n// O(nlogn) time | O(n) space\nvector<int> longestIncreasingSubsequence(vector<int> array) {\n  vector<int> sequences(array.size(), 0);\n  vector<int> indices(array.size() + 1, INT_MIN);\n  int length = 0;\n  for (int i = 0; i < array.size(); i++) {\n    int num = array[i];\n    int newLength = binarySearch(1, length, indices, array, num);\n    sequences[i] = indices[newLength - 1];\n    indices[newLength] = i;\n    length = max(length, newLength);\n  }\n  return buildSequence(array, sequences, indices[length]);\n}\n\nint binarySearch(\n  int startIdx, int endIdx, vector<int>& indices, vector<int>& array, int num\n) {\n  if (startIdx > endIdx) {\n    return startIdx;\n  }\n  int middleIdx = (startIdx + endIdx) / 2;\n  if (array[indices[middleIdx]] < num) {\n    startIdx = middleIdx + 1;\n  } else {\n    endIdx = middleIdx - 1;\n  }\n  return binarySearch(startIdx, endIdx, indices, array, num);\n}\n\nvector<int> buildSequence(\n  vector<int> array, vector<int> sequences, int currentIdx\n) {\n  vector<int> sequence;\n  while (currentIdx != INT_MIN) {\n    sequence.insert(sequence.begin(), array[currentIdx]);\n    currentIdx = sequences[currentIdx];\n  }\n  return sequence;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<int> expected{-24, 2, 3, 5, 6, 35};\n      vector<int> input{5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35};\n      assert(longestIncreasingSubsequence(input) == expected);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<int> expected{-24, 2, 3, 5, 6, 35};\n      vector<int> input{5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35};\n      assert(longestIncreasingSubsequence(input) == expected);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n  public static List<int> LongestIncreasingSubsequence(int[] array) {\n    // Write your code here.\n    return new List<int>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(n^2) time | O(n) space\n  public static List<int> LongestIncreasingSubsequence(int[] array) {\n    int[] sequences = new int[array.Length];\n    Array.Fill(sequences, Int32.MinValue);\n    int[] lengths = new int[array.Length];\n    Array.Fill(lengths, 1);\n    int maxLengthIdx = 0;\n    for (int i = 0; i < array.Length; i++) {\n      int currentNum = array[i];\n      for (int j = 0; j < i; j++) {\n        int otherNum = array[j];\n        if (otherNum < currentNum && lengths[j] + 1 >= lengths[i]) {\n          lengths[i] = lengths[j] + 1;\n          sequences[i] = j;\n        }\n      }\n      if (lengths[i] >= lengths[maxLengthIdx]) {\n        maxLengthIdx = i;\n      }\n    }\n    return buildSequence(array, sequences, maxLengthIdx);\n  }\n\n  public static List<int> buildSequence(\n    int[] array, int[] sequences, int currentIdx\n  ) {\n    List<int> sequence = new List<int>();\n    while (currentIdx != Int32.MinValue) {\n      sequence.Insert(0, array[currentIdx]);\n      currentIdx = sequences[currentIdx];\n    }\n    return sequence;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(nlogn) time | O(n) space\n  public static List<int> LongestIncreasingSubsequence(int[] array) {\n    int[] sequences = new int[array.Length];\n    int[] indices = new int[array.Length + 1];\n    Array.Fill(indices, Int32.MinValue);\n    int length = 0;\n    for (int i = 0; i < array.Length; i++) {\n      int num = array[i];\n      int newLength = BinarySearch(1, length, indices, array, num);\n      sequences[i] = indices[newLength - 1];\n      indices[newLength] = i;\n      length = Math.Max(length, newLength);\n    }\n    return buildSequence(array, sequences, indices[length]);\n  }\n\n  public static int BinarySearch(\n    int startIdx, int endIdx, int[] indices, int[] array, int num\n  ) {\n    if (startIdx > endIdx) {\n      return startIdx;\n    }\n    int middleIdx = (startIdx + endIdx) / 2;\n    if (array[indices[middleIdx]] < num) {\n      startIdx = middleIdx + 1;\n    } else {\n      endIdx = middleIdx - 1;\n    }\n    return BinarySearch(startIdx, endIdx, indices, array, num);\n  }\n\n  public static List<int> buildSequence(\n    int[] array, int[] sequences, int currentIdx\n  ) {\n    List<int> sequence = new List<int>();\n    while (currentIdx != Int32.MinValue) {\n      sequence.Insert(0, array[currentIdx]);\n      currentIdx = sequences[currentIdx];\n    }\n    return sequence;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[] expected = { -24, 2, 3, 5, 6, 35 };\n    Utils.AssertTrue(compare(\n      Program.LongestIncreasingSubsequence(\n        new int[] { 5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35 }\n      ),\n      expected\n    ));\n  }\n\n  public static bool compare(List<int> arr1, int[] arr2) {\n    if (arr1.Count != arr2.Length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.Count; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[] expected = { -24, 2, 3, 5, 6, 35 };\n    Utils.AssertTrue(compare(\n      Program.LongestIncreasingSubsequence(\n        new int[] { 5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35 }\n      ),\n      expected\n    ));\n  }\n\n  public static bool compare(List<int> arr1, int[] arr2) {\n    if (arr1.Count != arr2.Length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.Count; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc LongestIncreasingSubsequence(input []int) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n^2) time | O(n) space\nfunc LongestIncreasingSubsequence(array []int) []int {\n\tsequences := make([]int, len(array))\n\tlengths := make([]int, len(array))\n\tfor i := range array {\n\t\tsequences[i] = -1\n\t\tlengths[i] = 1\n\t}\n\tfor i := range array {\n\t\tcurrentNum := array[i]\n\t\tfor j := 0; j < i; j++ {\n\t\t\totherNum := array[j]\n\t\t\tif otherNum < currentNum && lengths[j]+1 >= lengths[i] {\n\t\t\t\tlengths[i] = lengths[j] + 1\n\t\t\t\tsequences[i] = j\n\t\t\t}\n\t\t}\n\t}\n\tmaxLengthIndex := 0\n\tfor i := range array {\n\t\tif lengths[i] > lengths[maxLengthIndex] {\n\t\t\tmaxLengthIndex = i\n\t\t}\n\t}\n\treturn buildSequence(array, sequences, maxLengthIndex)\n}\n\nfunc buildSequence(array, sequences []int, index int) []int {\n\tout := []int{}\n\tfor index != -1 {\n\t\tout = append(out, array[index])\n\t\tindex = sequences[index]\n\t}\n\treverse(out)\n\treturn out\n}\n\nfunc reverse(numbers []int) {\n\tfor i, j := 0, len(numbers)-1; i < j; i, j = i+1, j-1 {\n\t\tnumbers[i], numbers[j] = numbers[j], numbers[i]\n\t}\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(nlogn) time | O(n) space\nfunc LongestIncreasingSubsequence(array []int) []int {\n\tsequences := make([]int, len(array))\n\tindices := make([]int, len(array)+1)\n\tfor i := range array {\n\t\tsequences[i] = -1\n\t\tindices[i] = -1\n\t}\n\tlength := 0\n\tfor i, num := range array {\n\t\tnewLength := binarySearch(1, length, indices, array, num)\n\t\tsequences[i] = indices[newLength-1]\n\t\tindices[newLength] = i\n\t\tlength = max(length, newLength)\n\t}\n\treturn buildSequence(array, sequences, indices[length])\n}\n\nfunc binarySearch(startIndex, endIndex int, indices, array []int, num int) int {\n\tif startIndex > endIndex {\n\t\treturn startIndex\n\t}\n\tmiddleIndex := (startIndex + endIndex) / 2\n\tif array[indices[middleIndex]] < num {\n\t\tstartIndex = middleIndex + 1\n\t} else {\n\t\tendIndex = middleIndex - 1\n\t}\n\treturn binarySearch(startIndex, endIndex, indices, array, num)\n}\n\nfunc buildSequence(array, sequences []int, index int) []int {\n\tout := []int{}\n\tfor index != -1 {\n\t\tout = append(out, array[index])\n\t\tindex = sequences[index]\n\t}\n\treverse(out)\n\treturn out\n}\n\nfunc max(arg int, rest ...int) int {\n\tfor _, num := range rest {\n\t\tif num > arg {\n\t\t\targ = num\n\t\t}\n\t}\n\treturn arg\n}\n\nfunc reverse(numbers []int) {\n\tfor i, j := 0, len(numbers)-1; i < j; i, j = i+1, j-1 {\n\t\tnumbers[i], numbers[j] = numbers[j], numbers[i]\n\t}\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{-24, 2, 3, 5, 6, 35}\n\tinput := []int{5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35}\n\toutput := LongestIncreasingSubsequence(input)\n\trequire.Equal(t, expected, output)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{-24, 2, 3, 5, 6, 35}\n\tinput := []int{5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35}\n\toutput := LongestIncreasingSubsequence(input)\n\trequire.Equal(t, expected, output)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static List<Integer> longestIncreasingSubsequence(int[] array) {\n    // Write your code here.\n    return new ArrayList<Integer>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n^2) time | O(n) space\n  public static List<Integer> longestIncreasingSubsequence(int[] array) {\n    int[] sequences = new int[array.length];\n    Arrays.fill(sequences, Integer.MIN_VALUE);\n    int[] lengths = new int[array.length];\n    Arrays.fill(lengths, 1);\n    int maxLengthIdx = 0;\n    for (int i = 0; i < array.length; i++) {\n      int currentNum = array[i];\n      for (int j = 0; j < i; j++) {\n        int otherNum = array[j];\n        if (otherNum < currentNum && lengths[j] + 1 >= lengths[i]) {\n          lengths[i] = lengths[j] + 1;\n          sequences[i] = j;\n        }\n      }\n      if (lengths[i] >= lengths[maxLengthIdx]) {\n        maxLengthIdx = i;\n      }\n    }\n    return buildSequence(array, sequences, maxLengthIdx);\n  }\n\n  public static List<Integer> buildSequence(\n    int[] array, int[] sequences, int currentIdx\n  ) {\n    List<Integer> sequence = new ArrayList<Integer>();\n    while (currentIdx != Integer.MIN_VALUE) {\n      sequence.add(0, array[currentIdx]);\n      currentIdx = sequences[currentIdx];\n    }\n    return sequence;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(nlogn) time | O(n) space\n  public static List<Integer> longestIncreasingSubsequence(int[] array) {\n    int[] sequences = new int[array.length];\n    int[] indices = new int[array.length + 1];\n    Arrays.fill(indices, Integer.MIN_VALUE);\n    int length = 0;\n    for (int i = 0; i < array.length; i++) {\n      int num = array[i];\n      int newLength = binarySearch(1, length, indices, array, num);\n      sequences[i] = indices[newLength - 1];\n      indices[newLength] = i;\n      length = Math.max(length, newLength);\n    }\n    return buildSequence(array, sequences, indices[length]);\n  }\n\n  public static int binarySearch(\n    int startIdx, int endIdx, int[] indices, int[] array, int num\n  ) {\n    if (startIdx > endIdx) {\n      return startIdx;\n    }\n    int middleIdx = (startIdx + endIdx) / 2;\n    if (array[indices[middleIdx]] < num) {\n      startIdx = middleIdx + 1;\n    } else {\n      endIdx = middleIdx - 1;\n    }\n    return binarySearch(startIdx, endIdx, indices, array, num);\n  }\n\n  public static List<Integer> buildSequence(\n    int[] array, int[] sequences, int currentIdx\n  ) {\n    List<Integer> sequence = new ArrayList<Integer>();\n    while (currentIdx != Integer.MIN_VALUE) {\n      sequence.add(0, array[currentIdx]);\n      currentIdx = sequences[currentIdx];\n    }\n    return sequence;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] expected = {-24, 2, 3, 5, 6, 35};\n    Utils.assertTrue(compare(\n      Program.longestIncreasingSubsequence(new int[] {\n        5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35}),\n      expected\n    ));\n  }\n\n  public static boolean compare(List<Integer> arr1, int[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] expected = {-24, 2, 3, 5, 6, 35};\n    Utils.assertTrue(compare(\n      Program.longestIncreasingSubsequence(new int[] {\n        5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35}),\n      expected\n    ));\n  }\n\n  public static boolean compare(List<Integer> arr1, int[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function longestIncreasingSubsequence(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.longestIncreasingSubsequence = longestIncreasingSubsequence;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space\nfunction longestIncreasingSubsequence(array) {\n  const sequences = new Array(array.length);\n  const lengths = array.map(num => 1);\n  let maxLengthIdx = 0;\n  for (let i = 0; i < array.length; i++) {\n    const currentNum = array[i];\n    for (let j = 0; j < i; j++) {\n      const otherNum = array[j];\n      if (otherNum < currentNum && lengths[j] + 1 >= lengths[i]) {\n        lengths[i] = lengths[j] + 1;\n        sequences[i] = j;\n      }\n    }\n    if (lengths[i] >= lengths[maxLengthIdx]) maxLengthIdx = i;\n  }\n  return buildSequence(array, sequences, maxLengthIdx);\n}\n\nfunction buildSequence(array, sequences, currentIdx) {\n  const sequence = [];\n  while (currentIdx !== undefined) {\n    sequence.unshift(array[currentIdx]);\n    currentIdx = sequences[currentIdx];\n  }\n  return sequence;\n}\n\nexports.longestIncreasingSubsequence = longestIncreasingSubsequence;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(nlogn) time | O(n) space\nfunction longestIncreasingSubsequence(array) {\n  const sequences = new Array(array.length);\n  const indices = new Array(array.length + 1);\n  let length = 0;\n  for (let i = 0; i < array.length; i++) {\n    const num = array[i];\n    const newLength = binarySearch(1, length, indices, array, num);\n    sequences[i] = indices[newLength - 1];\n    indices[newLength] = i;\n    length = Math.max(length, newLength);\n  }\n  return buildSequence(array, sequences, indices[length]);\n}\n\nfunction binarySearch(startIdx, endIdx, indices, array, num) {\n  if (startIdx > endIdx) return startIdx;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  if (array[indices[middleIdx]] < num) {\n    startIdx = middleIdx + 1;\n  } else {\n    endIdx = middleIdx - 1;\n  }\n  return binarySearch(startIdx, endIdx, indices, array, num);\n}\n\nfunction buildSequence(array, sequences, currentIdx) {\n  const sequence = [];\n  while (currentIdx !== undefined) {\n    sequence.unshift(array[currentIdx]);\n    currentIdx = sequences[currentIdx];\n  }\n  return sequence;\n}\n\nexports.longestIncreasingSubsequence = longestIncreasingSubsequence;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.longestIncreasingSubsequence([5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]))\n    .to.deep.equal([-24, 2, 3, 5, 6, 35]);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.longestIncreasingSubsequence([5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]))\n    .to.deep.equal([-24, 2, 3, 5, 6, 35]);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun longestIncreasingSubsequence(array: List<Int>): List<Int> {\n    // Write your code here.\n    return listOf()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n^2) time | O(n) space\nfun longestIncreasingSubsequence(array: List<Int>): List<Int> {\n    var sequences = MutableList(array.size) { Int.MIN_VALUE }\n    var lengths = MutableList(array.size) { 1 }\n    var maxLengthIdx = 0\n    for (i in 0 until array.size) {\n        var currentNum = array[i]\n        for (j in 0 until i) {\n            var otherNum = array[j]\n            if (otherNum < currentNum && lengths[j] + 1 >= lengths[i]) {\n                lengths[i] = lengths[j] + 1\n                sequences[i] = j\n            }\n        }\n        if (lengths[i] >= lengths[maxLengthIdx]) {\n            maxLengthIdx = i\n        }\n    }\n    return buildSequence(array, sequences, maxLengthIdx)\n}\n\nfun buildSequence(array: List<Int>, sequences: List<Int>, currentIdx: Int): List<Int> {\n    var sequence = mutableListOf<Int>()\n    var curr = currentIdx\n    while (curr != Int.MIN_VALUE) {\n        sequence.add(0, array[curr])\n        curr = sequences[curr]\n    }\n    return sequence\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.max\n\n// O(nlogn) time | O(n) space\nfun longestIncreasingSubsequence(array: List<Int>): List<Int> {\n    var sequences = MutableList(array.size) { 0 }\n    var indices = MutableList(array.size + 1) { Int.MIN_VALUE }\n    var length = 0\n    for (i in 0 until array.size) {\n        val num = array[i]\n        val newLength = binarySearch(1, length, indices, array, num)\n        sequences[i] = indices[newLength - 1]\n        indices[newLength] = i\n        length = max(length, newLength)\n    }\n    return buildSequence(array, sequences, indices[length])\n}\n\nfun binarySearch(startIdx: Int, endIdx: Int, indices: List<Int>, array: List<Int>, num: Int): Int {\n    var start = startIdx\n    var end = endIdx\n    if (start > end) {\n        return start\n    }\n    val middleIdx = (startIdx + endIdx) / 2\n    if (array[indices[middleIdx]] < num) {\n        start = middleIdx + 1\n    } else {\n        end = middleIdx - 1\n    }\n    return binarySearch(start, end, indices, array, num)\n}\n\nfun buildSequence(array: List<Int>, sequences: List<Int>, currentIdx: Int): List<Int> {\n    var sequence = mutableListOf<Int>()\n    var curr = currentIdx\n    while (curr != Int.MIN_VALUE) {\n        sequence.add(0, array[curr])\n        curr = sequences[curr]\n    }\n    return sequence\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.longestIncreasingSubsequence\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val expected = listOf(-24, 2, 3, 5, 6, 35)\n        val input = listOf(5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35)\n        val output = longestIncreasingSubsequence(input)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.longestIncreasingSubsequence\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val expected = listOf(-24, 2, 3, 5, 6, 35)\n        val input = listOf(5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35)\n        val output = longestIncreasingSubsequence(input)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def longestIncreasingSubsequence(array):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n^2) time | O(n) space\ndef longestIncreasingSubsequence(array):\n    sequences = [None for x in array]\n    lengths = [1 for x in array]\n    maxLengthIdx = 0\n    for i in range(len(array)):\n        currentNum = array[i]\n        for j in range(0, i):\n            otherNum = array[j]\n            if otherNum < currentNum and lengths[j] + 1 >= lengths[i]:\n                lengths[i] = lengths[j] + 1\n                sequences[i] = j\n        if lengths[i] >= lengths[maxLengthIdx]:\n            maxLengthIdx = i\n    return buildSequence(array, sequences, maxLengthIdx)\n\n\ndef buildSequence(array, sequences, currentIdx):\n    sequence = []\n    while currentIdx is not None:\n        sequence.append(array[currentIdx])\n        currentIdx = sequences[currentIdx]\n    return list(reversed(sequence))\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(nlogn) time | O(n) space\ndef longestIncreasingSubsequence(array):\n    sequences = [None for x in array]\n    indices = [None for x in range(len(array) + 1)]\n    length = 0\n    for i, num in enumerate(array):\n        newLength = binarySearch(1, length, indices, array, num)\n        sequences[i] = indices[newLength - 1]\n        indices[newLength] = i\n        length = max(length, newLength)\n    return buildSequence(array, sequences, indices[length])\n\n\ndef binarySearch(startIdx, endIdx, indices, array, num):\n    if startIdx > endIdx:\n        return startIdx\n    middleIdx = (startIdx + endIdx) // 2\n    if array[indices[middleIdx]] < num:\n        startIdx = middleIdx + 1\n    else:\n        endIdx = middleIdx - 1\n    return binarySearch(startIdx, endIdx, indices, array, num)\n\n\ndef buildSequence(array, sequences, currentIdx):\n    sequence = []\n    while currentIdx is not None:\n        sequence.append(array[currentIdx])\n        currentIdx = sequences[currentIdx]\n    return list(reversed(sequence))\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(\n            program.longestIncreasingSubsequence([5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]),\n            [-24, 2, 3, 5, 6, 35],\n        )\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(\n            program.longestIncreasingSubsequence([5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]),\n            [-24, 2, 3, 5, 6, 35],\n        )\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def longestIncreasingSubsequence(array)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def longestIncreasingSubsequence(array)\n    # Write your code here.\n    return []\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def longestIncreasingSubsequence(array)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.longestIncreasingSubsequence\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.longestIncreasingSubsequence\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func longestIncreasingSubsequence(_ array: [Int]) -> [Int] {\n    // Write your code here.\n    return []\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^2) time | O(n) space\n  func longestIncreasingSubsequence(_ array: [Int]) -> [Int] {\n    var indexOfMaxLength: Int? = 0\n    var lengths = Array(repeating: 1, count: array.count)\n    var sequences: [Int?] = Array(repeating: nil, count: array.count)\n\n    for i in 0 ..< array.count {\n      let currentNumber = array[i]\n\n      for j in 0 ..< i {\n        let otherNumber = array[j]\n\n        if otherNumber < currentNumber, lengths[i] <= lengths[j] + 1 {\n          lengths[i] = lengths[j] + 1\n          sequences[i] = j\n        }\n      }\n\n      if lengths[i] > lengths[indexOfMaxLength!] {\n        indexOfMaxLength = i\n      }\n    }\n\n    return buildSequence(array, sequences, &indexOfMaxLength)\n  }\n\n  func buildSequence(_ array: [Int], _ sequences: [Int?], _ currentIndex: inout Int?) -> [Int] {\n    var sequence = [Int]()\n\n    while currentIndex != nil {\n      sequence.insert(array[currentIndex!], at: 0)\n      currentIndex = sequences[currentIndex!]\n    }\n\n    return sequence\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(nlogn) time | O(n) space\n  func longestIncreasingSubsequence(_ array: [Int]) -> [Int] {\n    var length = 0\n    var indices: [Int?] = Array(repeating: nil, count: array.count + 1)\n    var sequences: [Int?] = Array(repeating: nil, count: array.count)\n\n    for i in 0 ..< array.count {\n      var startIndex = 1\n      var endIndex = length\n      let number = array[i]\n      let newLength = binarySearch(&startIndex, &endIndex, indices, array, number)\n\n      indices[newLength] = i\n      sequences[i] = indices[newLength - 1]\n      length = max(length, newLength)\n    }\n\n    return buildSequence(array, sequences, &indices[length])\n  }\n\n  func binarySearch(_ startIndex: inout Int, _ endIndex: inout Int, _ indices: [Int?], _ array: [Int], _ number: Int) -> Int {\n    if startIndex > endIndex {\n      return startIndex\n    }\n\n    var middleIndex = Double(startIndex + endIndex) / 2\n    middleIndex = middleIndex.rounded(.down)\n    let intMiddle = Int(middleIndex)\n\n    if let index = indices[intMiddle] {\n      let numberToCompare = array[index]\n\n      if numberToCompare < number {\n        startIndex = intMiddle + 1\n      } else {\n        endIndex = intMiddle - 1\n      }\n    }\n\n    return binarySearch(&startIndex, &endIndex, indices, array, number)\n  }\n\n  func buildSequence(_ array: [Int], _ sequences: [Int?], _ currentIndex: inout Int?) -> [Int] {\n    var sequence = [Int]()\n\n    while currentIndex != nil {\n      sequence.insert(array[currentIndex!], at: 0)\n      currentIndex = sequences[currentIndex!]\n    }\n\n    return sequence\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      try assertEqual([-24, 2, 3, 5, 6, 35], program.longestIncreasingSubsequence([5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]))\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      try assertEqual([-24, 2, 3, 5, 6, 35], program.longestIncreasingSubsequence([5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]))\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function longestIncreasingSubsequence(array: number[]) {\n  // Write your code here.\n  return [-1];\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space\nexport function longestIncreasingSubsequence(array: number[]) {\n  const sequences: number[] = new Array(array.length);\n  const lengths = array.map(num => 1);\n  let maxLengthIdx = 0;\n  for (let i = 0; i < array.length; i++) {\n    const currentNum = array[i];\n    for (let j = 0; j < i; j++) {\n      const otherNum = array[j];\n      if (otherNum < currentNum && lengths[j] + 1 >= lengths[i]) {\n        lengths[i] = lengths[j] + 1;\n        sequences[i] = j;\n      }\n    }\n    if (lengths[i] >= lengths[maxLengthIdx]) maxLengthIdx = i;\n  }\n  return buildSequence(array, sequences, maxLengthIdx);\n}\n\nfunction buildSequence(array: number[], sequences: number[], currentIdx: number) {\n  const sequence: number[] = [];\n  while (currentIdx !== undefined) {\n    sequence.unshift(array[currentIdx]);\n    currentIdx = sequences[currentIdx];\n  }\n  return sequence;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(nlogn) time | O(n) space\nexport function longestIncreasingSubsequence(array: number[]) {\n  const sequences: number[] = new Array(array.length);\n  const indices: number[] = new Array(array.length + 1);\n  let length = 0;\n  for (let i = 0; i < array.length; i++) {\n    const num = array[i];\n    const newLength = binarySearch(1, length, indices, array, num);\n    sequences[i] = indices[newLength - 1];\n    indices[newLength] = i;\n    length = Math.max(length, newLength);\n  }\n  return buildSequence(array, sequences, indices[length]);\n}\n\nfunction binarySearch(\n  startIdx: number,\n  endIdx: number,\n  indices: number[],\n  array: number[],\n  num: number,\n): number {\n  if (startIdx > endIdx) return startIdx;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  if (array[indices[middleIdx]] < num) {\n    startIdx = middleIdx + 1;\n  } else {\n    endIdx = middleIdx - 1;\n  }\n  return binarySearch(startIdx, endIdx, indices, array, num);\n}\n\nfunction buildSequence(array: number[], sequences: number[], currentIdx: number) {\n  const sequence = [];\n  while (currentIdx !== undefined) {\n    sequence.unshift(array[currentIdx]);\n    currentIdx = sequences[currentIdx];\n  }\n  return sequence;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.longestIncreasingSubsequence([5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]))\n    .to.deep.equal([-24, 2, 3, 5, 6, 35]);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.longestIncreasingSubsequence([5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]))\n    .to.deep.equal([-24, 2, 3, 5, 6, 35]);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "array",
      "example": [
        5,
        7,
        -24,
        12,
        10,
        2,
        3,
        12,
        5,
        6,
        35
      ],
      "schema": {
        "items": {
          "type": "integer"
        },
        "minItems": 1,
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "array": [
        5,
        7,
        -24,
        12,
        10,
        2,
        3,
        12,
        5,
        6,
        35
      ]
    },
    {
      "array": [
        -1
      ]
    },
    {
      "array": [
        -1,
        2
      ]
    },
    {
      "array": [
        -1,
        2,
        1,
        2
      ]
    },
    {
      "array": [
        1,
        5,
        -1,
        10
      ]
    },
    {
      "array": [
        1,
        5,
        -1,
        0,
        6,
        2,
        4
      ]
    },
    {
      "array": [
        3,
        4,
        -1
      ]
    },
    {
      "array": [
        29,
        2,
        32,
        12,
        30,
        31
      ]
    },
    {
      "array": [
        10,
        22,
        9,
        33,
        21,
        61,
        41,
        60,
        80
      ]
    },
    {
      "array": [
        100,
        1,
        2,
        3,
        4,
        101
      ]
    }
  ],
  "jsonTests": [
    {
      "array": [
        5,
        7,
        -24,
        12,
        10,
        2,
        3,
        12,
        5,
        6,
        35
      ]
    },
    {
      "array": [
        -1
      ]
    },
    {
      "array": [
        -1,
        2
      ]
    },
    {
      "array": [
        -1,
        2,
        1,
        2
      ]
    },
    {
      "array": [
        1,
        5,
        -1,
        10
      ]
    },
    {
      "array": [
        1,
        5,
        -1,
        0,
        6,
        2,
        4
      ]
    },
    {
      "array": [
        3,
        4,
        -1
      ]
    },
    {
      "array": [
        29,
        2,
        32,
        12,
        30,
        31
      ]
    },
    {
      "array": [
        10,
        22,
        9,
        33,
        21,
        61,
        41,
        60,
        80
      ]
    },
    {
      "array": [
        100,
        1,
        2,
        3,
        4,
        101
      ]
    }
  ],
  "changelog": []
}