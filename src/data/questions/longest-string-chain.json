{
  "uid": "longest-string-chain",
  "testStrategy": "JSON",
  "name": "Longest String Chain",
  "version": 0,
  "releaseDate": "2019-11-21T00:00:00Z",
  "category": "Dynamic Programming",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 4168,
    "failureCount": 1259
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "374201798",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1655
  },
  "prompt": "<div class=\"html\">\n<p>\n  Given a list of strings, write a function that returns the longest string\n  chain that can be built from those strings.\n</p>\n<p>\n  A string chain is defined as follows: let string <span>A</span> be a string in\n  the initial array; if removing any single character from string\n  <span>A</span> yields a new string <span>B</span> that's contained in the\n  initial array of strings, then strings <span>A</span> and <span>B</span> form\n  a string chain of length 2. Similarly, if removing any single character from\n  string <span>B</span> yields a new string <span>C</span> that's contained in\n  the initial array of strings, then strings <span>A</span>, <span>B</span>, and\n  <span>C</span> form a string chain of length 3.\n</p>\n<p>\n  The function should return the string chain in descending order (i.e., from\n  the longest string to the shortest one). Note that string chains of length 1\n  don't exist; if the list of strings doesn't contain any string chain formed by\n  two or more strings, the function should return an empty array.\n</p>\n<p>\n  You can assume that there will only be one longest string chain.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">strings</span> = [\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"]\n</pre>\n</div>",
  "hints": [
    "<p>\nFor each string, you will have to remove every letter one at a time to see if the resulting strings are contained in the input list of strings. What data structure lends itself to quickly checking if these strings are located in the list of input strings?\n</p>\n",
    "\n<p>\nRealize that every string in the input list of strings potentially has a string chain (and therefore a longest string chain) that starts with itself. Compute all of these string chains and store them so that you don't have to compute them more than once.\n</p>\n",
    "\n<p>\nSort the input list of strings (from shortest to longest string) in order to simplify the problem. Iterate through the list of sorted strings, and for each string, compute the longest string chain that starts with itself. To do so, try removing every letter from each string and seeing if the resulting strings are in the input list of strings; you can do so in constant time by dumping every string in a hash table. In the hash table, store the longest string chain of every string as you compute them. As you iterate through longer strings, whenever you find a shorter string for which you've already computed the longest string chain, you can very quickly append the longer string to that already-computed string chain. Do this for every string, and you'll eventually find the longest string chain that you're looking for.\n</p>\n",
    "\n<p>\nDo you need to store every string's longest string chain mentioned in Hint #3, or can you store less information per string so as to take up less auxiliary space?\n</p>"
  ],
  "spaceTime": "O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and m is the length of the longest string",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\n\nusing namespace std;\n\nvector<string> longestStringChain(vector<string> strings) {\n  // Write your code here.\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nstruct stringChain {\n  string nextString;\n  int maxChainLength;\n};\n\nvoid findLongestStringChain(\n  string str, unordered_map<string, stringChain>& stringChains\n);\nstring getSmallerString(string str, int index);\nvoid tryUpdateLongestStringChain(\n  string currentString,\n  string smallerString,\n  unordered_map<string, stringChain>& stringChains\n);\nvector<string> buildLongestStringChain(\n  vector<string> strings, unordered_map<string, stringChain> stringChains\n);\n\n// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings\n// and m is the length of the longest string\nvector<string> longestStringChain(vector<string> strings) {\n  // For every string, imagine the longest string chain that starts with it.\n  // Set up every string to point to the next string in its respective longest\n  // string chain. Also keep track of the lengths of these longest string\n  // chains.\n  unordered_map<string, stringChain> stringChains = {};\n  for (auto string : strings) {\n    stringChains[string] = {\"\", 1};\n  }\n\n  // Sort the strings based on their length so that whenever we visit a\n  // string (as we iterate through them from left to right), we can\n  // already have computed the longest string chains of any smaller strings.\n  vector<string> sortedStrings = strings;\n  sort(\n    sortedStrings.begin(),\n    sortedStrings.end(),\n    [](string a, string b) -> bool { return a.size() < b.size(); }\n  );\n\n  for (auto string : sortedStrings) {\n    findLongestStringChain(string, stringChains);\n  }\n\n  return buildLongestStringChain(strings, stringChains);\n}\n\nvoid findLongestStringChain(\n  string str, unordered_map<string, stringChain>& stringChains\n) {\n  // Try removing every letter of the current string to see if the\n  // remaining strings form a string chain.\n  for (int i = 0; i < str.size(); i++) {\n    string smallerString = getSmallerString(str, i);\n    if (stringChains.find(smallerString) == stringChains.end()) continue;\n    tryUpdateLongestStringChain(str, smallerString, stringChains);\n  }\n}\n\nstring getSmallerString(string str, int index) {\n  return str.substr(0, index) + str.substr(index + 1);\n}\n\nvoid tryUpdateLongestStringChain(\n  string currentString,\n  string smallerString,\n  unordered_map<string, stringChain>& stringChains\n) {\n  int smallerStringChainLength = stringChains[smallerString].maxChainLength;\n  int currentStringChainLength = stringChains[currentString].maxChainLength;\n  // Update the string chain of the current string only if the smaller string\n  // leads to a longer string chain.\n  if (smallerStringChainLength + 1 > currentStringChainLength) {\n    stringChains[currentString].maxChainLength = smallerStringChainLength + 1;\n    stringChains[currentString].nextString = smallerString;\n  }\n}\n\nvector<string> buildLongestStringChain(\n  vector<string> strings, unordered_map<string, stringChain> stringChains\n) {\n  // Find the string that starts the longest string chain.\n  int maxChainLength = 0;\n  string chainStartingString = \"\";\n  for (auto string : strings) {\n    if (stringChains[string].maxChainLength > maxChainLength) {\n      maxChainLength = stringChains[string].maxChainLength;\n      chainStartingString = string;\n    }\n  }\n\n  // Starting at the string found above, build the longest string chain.\n  vector<string> ourLongestStringChain;\n  string currentString = chainStartingString;\n  while (currentString != \"\") {\n    ourLongestStringChain.push_back(currentString);\n    currentString = stringChains[currentString].nextString;\n  }\n\n  return ourLongestStringChain.size() == 1 ? vector<string>{}\n                                           : ourLongestStringChain;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<string> strings = {\n        \"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"};\n      vector<string> expected = {\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"};\n      assert(longestStringChain(strings) == expected);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<string> strings = {\n        \"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"};\n      vector<string> expected = {\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"};\n      assert(longestStringChain(strings) == expected);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n  public static List<string> LongestStringChain(List<string> strings) {\n    // Write your code here.\n    return new List<string>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  public class stringChain {\n    public string nextstring;\n    public int maxChainLength;\n\n    public stringChain(string nextstring, int maxChainLength) {\n      this.nextstring = nextstring;\n      this.maxChainLength = maxChainLength;\n    }\n  }\n\n  // O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings\n  // and m is the length of the longest string\n  public static List<string> LongestStringChain(List<string> strings) {\n    // For every string, imagine the longest string chain that starts with it.\n    // Set up every string to point to the next string in its respective longest\n    // string chain. Also keep track of the lengths of these longest string\n    // chains.\n    Dictionary<string, stringChain> stringChains =\n      new Dictionary<string, stringChain>();\n    foreach (string str in strings) {\n      stringChains[str] = new stringChain(\"\", 1);\n    }\n\n    // Sort the strings based on their length so that whenever we visit a\n    // string (as we iterate through them from left to right), we can\n    // already have computed the longest string chains of any smaller strings.\n    List<string> sortedstrings = new List<string>(strings);\n    sortedstrings.Sort((a, b) => a.Length - b.Length);\n\n    foreach (string str in sortedstrings) {\n      findLongeststringChain(str, stringChains);\n    }\n\n    return buildLongeststringChain(strings, stringChains);\n  }\n\n  public static void findLongeststringChain(\n    string str, Dictionary<string, stringChain> stringChains\n  ) {\n    // Try removing every letter of the current string to see if the\n    // remaining strings form a string chain.\n    for (int i = 0; i < str.Length; i++) {\n      string smallerstring = getSmallerstring(str, i);\n      if (!stringChains.ContainsKey(smallerstring)) continue;\n      tryUpdateLongeststringChain(str, smallerstring, stringChains);\n    }\n  }\n\n  public static string getSmallerstring(string str, int index) {\n    return str.Substring(0, index) + str.Substring(index + 1);\n  }\n\n  public static void tryUpdateLongeststringChain(\n    string currentstring,\n    string smallerstring,\n    Dictionary<string, stringChain> stringChains\n  ) {\n    int smallerstringChainLength = stringChains[smallerstring].maxChainLength;\n    int currentstringChainLength = stringChains[currentstring].maxChainLength;\n    // Update the string chain of the current string only if the smaller string\n    // leads to a longer string chain.\n    if (smallerstringChainLength + 1 > currentstringChainLength) {\n      stringChains[currentstring].maxChainLength = smallerstringChainLength + 1;\n      stringChains[currentstring].nextstring = smallerstring;\n    }\n  }\n\n  public static List<string> buildLongeststringChain(\n    List<string> strings, Dictionary<string, stringChain> stringChains\n  ) {\n    // Find the string that starts the longest string chain.\n    int maxChainLength = 0;\n    string chainStartingstring = \"\";\n    foreach (string str in strings) {\n      if (stringChains[str].maxChainLength > maxChainLength) {\n        maxChainLength = stringChains[str].maxChainLength;\n        chainStartingstring = str;\n      }\n    }\n\n    // Starting at the string found above, build the longest string chain.\n    List<string> ourLongeststringChain = new List<string>();\n    string currentstring = chainStartingstring;\n    while (currentstring != \"\") {\n      ourLongeststringChain.Add(currentstring);\n      currentstring = stringChains[currentstring].nextstring;\n    }\n\n    return ourLongeststringChain.Count == 1 ? new List<string>()\n                                            : ourLongeststringChain;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    List<string> strings = new List<string>(\n      new[] { \"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\" }\n    );\n    List<string> expected =\n      new List<string>() { \"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\" };\n    Utils.AssertTrue(Program.LongestStringChain(strings).SequenceEqual(expected)\n    );\n  }\n}\n",
      "unitTests": "using System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    List<string> strings = new List<string>(\n      new[] { \"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\" }\n    );\n    List<string> expected =\n      new List<string>() { \"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\" };\n    Utils.AssertTrue(Program.LongestStringChain(strings).SequenceEqual(expected)\n    );\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc LongestStringChain(strings []string) []string {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t\"sort\"\n)\n\ntype Chain struct {\n\tNextString     string\n\tMaxChainLength int\n}\n\n// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n// m is the length of the longest string\nfunc LongestStringChain(strings []string) []string {\n\t// For every string, imagine the longest string chain that starts with it.\n\t// Set up every string to point to the next string in its respective longest\n\t// string chain. Also keep track of the lengths of these longest string chains.\n\tstringChains := map[string]*Chain{}\n\tfor _, str := range strings {\n\t\tstringChains[str] = &Chain{NextString: \"\", MaxChainLength: 1}\n\t}\n\n\t// Sort the strings based on their length so that whenever we visit a\n\t// string (as we iterate through them from left to right), we can\n\t// already have computed the longest string chains of any smaller strings.\n\tsort.Slice(strings, func(i, j int) bool {\n\t\treturn len(strings[i]) < len(strings[j])\n\t})\n\tsortedStrings := strings\n\n\tfor _, str := range sortedStrings {\n\t\tfindLongestStringChain(str, stringChains)\n\t}\n\treturn buildLongestStringChain(strings, stringChains)\n}\n\nfunc findLongestStringChain(str string, stringChains map[string]*Chain) {\n\t// Try removing every letter of the current string to see if the\n\t// remaining strings form a string chain.\n\tfor i := range str {\n\t\tsmallerString := getSmallerString(str, i)\n\t\tif _, found := stringChains[smallerString]; !found {\n\t\t\tcontinue\n\t\t}\n\t\ttryUpdateLongestStringChain(str, smallerString, stringChains)\n\t}\n}\n\nfunc getSmallerString(str string, index int) string {\n\treturn str[:index] + str[index+1:]\n}\n\nfunc tryUpdateLongestStringChain(currentString, smallerString string, stringChains map[string]*Chain) {\n\tsmallerStringChainLength := stringChains[smallerString].MaxChainLength\n\tcurrentStringChainLength := stringChains[currentString].MaxChainLength\n\t// Update the string chain of the current string only if the smaller string leads\n\t// to a longer string chain.\n\tif smallerStringChainLength+1 > currentStringChainLength {\n\t\tstringChains[currentString].MaxChainLength = smallerStringChainLength + 1\n\t\tstringChains[currentString].NextString = smallerString\n\t}\n}\n\nfunc buildLongestStringChain(strings []string, stringChains map[string]*Chain) []string {\n\t// Find the string that starts the longest string chain.\n\tmaxChainLength := 0\n\tchainStartingString := \"\"\n\tfor _, str := range strings {\n\t\tif stringChains[str].MaxChainLength > maxChainLength {\n\t\t\tmaxChainLength = stringChains[str].MaxChainLength\n\t\t\tchainStartingString = str\n\t\t}\n\t}\n\n\t// Starting at the string found above, build the longest string chain.\n\tourLongestStringChain := []string{}\n\tcurrentString := chainStartingString\n\tfor currentString != \"\" {\n\t\tourLongestStringChain = append(ourLongestStringChain, currentString)\n\t\tcurrentString = stringChains[currentString].NextString\n\t}\n\tif len(ourLongestStringChain) == 1 {\n\t\treturn []string{}\n\t}\n\treturn ourLongestStringChain\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []string{\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"}\n\texpected := []string{\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"}\n\toutput := LongestStringChain(input)\n\trequire.Equal(t, expected, output)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []string{\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"}\n\texpected := []string{\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"}\n\toutput := LongestStringChain(input)\n\trequire.Equal(t, expected, output)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static List<String> longestStringChain(List<String> strings) {\n    // Write your code here.\n    return new ArrayList<String>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  public static class stringChain {\n    String nextString;\n    Integer maxChainLength;\n\n    public stringChain(String nextString, Integer maxChainLength) {\n      this.nextString = nextString;\n      this.maxChainLength = maxChainLength;\n    }\n  }\n\n  // O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings\n  // and m is the length of the longest string\n  public static List<String> longestStringChain(List<String> strings) {\n    // For every string, imagine the longest string chain that starts with it.\n    // Set up every string to point to the next string in its respective longest\n    // string chain. Also keep track of the lengths of these longest string\n    // chains.\n    Map<String, stringChain> stringChains = new HashMap<String, stringChain>();\n    for (String string : strings) {\n      stringChains.put(string, new stringChain(\"\", 1));\n    }\n\n    // Sort the strings based on their length so that whenever we visit a\n    // string (as we iterate through them from left to right), we can\n    // already have computed the longest string chains of any smaller strings.\n    List<String> sortedStrings = new ArrayList<String>(strings);\n    sortedStrings.sort((a, b) -> a.length() - b.length());\n\n    for (String string : sortedStrings) {\n      findLongestStringChain(string, stringChains);\n    }\n\n    return buildLongestStringChain(strings, stringChains);\n  }\n\n  public static void findLongestStringChain(\n    String string, Map<String, stringChain> stringChains\n  ) {\n    // Try removing every letter of the current string to see if the\n    // remaining strings form a string chain.\n    for (int i = 0; i < string.length(); i++) {\n      String smallerString = getSmallerString(string, i);\n      if (!stringChains.containsKey(smallerString)) continue;\n      tryUpdateLongestStringChain(string, smallerString, stringChains);\n    }\n  }\n\n  public static String getSmallerString(String string, int index) {\n    return string.substring(0, index) + string.substring(index + 1);\n  }\n\n  public static void tryUpdateLongestStringChain(\n    String currentString,\n    String smallerString,\n    Map<String, stringChain> stringChains\n  ) {\n    int smallerStringChainLength =\n      stringChains.get(smallerString).maxChainLength;\n    int currentStringChainLength =\n      stringChains.get(currentString).maxChainLength;\n    // Update the string chain of the current string only if the smaller string\n    // leads to a longer string chain.\n    if (smallerStringChainLength + 1 > currentStringChainLength) {\n      stringChains.get(currentString).maxChainLength =\n        smallerStringChainLength + 1;\n      stringChains.get(currentString).nextString = smallerString;\n    }\n  }\n\n  public static List<String> buildLongestStringChain(\n    List<String> strings, Map<String, stringChain> stringChains\n  ) {\n    // Find the string that starts the longest string chain.\n    int maxChainLength = 0;\n    String chainStartingString = \"\";\n    for (String string : strings) {\n      if (stringChains.get(string).maxChainLength > maxChainLength) {\n        maxChainLength = stringChains.get(string).maxChainLength;\n        chainStartingString = string;\n      }\n    }\n\n    // Starting at the string found above, build the longest string chain.\n    List<String> ourLongestStringChain = new ArrayList<String>();\n    String currentString = chainStartingString;\n    while (currentString != \"\") {\n      ourLongestStringChain.add(currentString);\n      currentString = stringChains.get(currentString).nextString;\n    }\n\n    return ourLongestStringChain.size() == 1 ? new ArrayList<String>()\n                                             : ourLongestStringChain;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<String> strings = new ArrayList<String>(Arrays.asList(\n      \"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"\n    ));\n    List<String> expected = new ArrayList<String>(\n      Arrays.asList(\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\")\n    );\n    Utils.assertTrue(Program.longestStringChain(strings).equals(expected));\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<String> strings = new ArrayList<String>(Arrays.asList(\n      \"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"\n    ));\n    List<String> expected = new ArrayList<String>(\n      Arrays.asList(\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\")\n    );\n    Utils.assertTrue(Program.longestStringChain(strings).equals(expected));\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function longestStringChain(strings) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.longestStringChain = longestStringChain;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n// m is the length of the longest string\nfunction longestStringChain(strings) {\n  // For every string, imagine the longest string chain that starts with it.\n  // Set up every string to point to the next string in its respective longest\n  // string chain. Also keep track of the lengths of these longest string chains.\n  const stringChains = {};\n  for (const string of strings) {\n    stringChains[string] = {nextString: '', maxChainLength: 1};\n  }\n\n  // Sort the strings based on their length so that whenever we visit a\n  // string (as we iterate through them from left to right), we can\n  // already have computed the longest string chains of any smaller strings.\n  const sortedStrings = strings.sort((a, b) => a.length - b.length);\n  for (const string of sortedStrings) {\n    findLongestStringChain(string, stringChains);\n  }\n\n  return buildLongestStringChain(strings, stringChains);\n}\n\nfunction findLongestStringChain(string, stringChains) {\n  // Try removing every letter of the current string to see if the\n  // remaining strings form a string chain.\n  for (let i = 0; i < string.length; i++) {\n    const smallerString = getSmallerString(string, i);\n    if (!(smallerString in stringChains)) continue;\n    tryUpdateLongestStringChain(string, smallerString, stringChains);\n  }\n}\n\nfunction getSmallerString(string, index) {\n  return string.slice(0, index) + string.slice(index + 1);\n}\n\nfunction tryUpdateLongestStringChain(currentString, smallerString, stringChains) {\n  const smallerStringChainLength = stringChains[smallerString].maxChainLength;\n  const currentStringChainLength = stringChains[currentString].maxChainLength;\n  // Update the string chain of the current string only if the smaller string leads\n  // to a longer string chain.\n  if (smallerStringChainLength + 1 > currentStringChainLength) {\n    stringChains[currentString].maxChainLength = smallerStringChainLength + 1;\n    stringChains[currentString].nextString = smallerString;\n  }\n}\n\nfunction buildLongestStringChain(strings, stringChains) {\n  // Find the string that starts the longest string chain.\n  let maxChainLength = 0;\n  let chainStartingString = '';\n  for (const string of strings) {\n    if (stringChains[string].maxChainLength > maxChainLength) {\n      maxChainLength = stringChains[string].maxChainLength;\n      chainStartingString = string;\n    }\n  }\n\n  // Starting at the string found above, build the longest string chain.\n  const ourLongestStringChain = [];\n  let currentString = chainStartingString;\n  while (currentString !== '') {\n    ourLongestStringChain.push(currentString);\n    currentString = stringChains[currentString].nextString;\n  }\n\n  return ourLongestStringChain.length === 1 ? [] : ourLongestStringChain;\n}\n\nexports.longestStringChain = longestStringChain;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const strings = ['abde', 'abc', 'abd', 'abcde', 'ade', 'ae', '1abde', 'abcdef'];\n  const expected = ['abcdef', 'abcde', 'abde', 'ade', 'ae'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const strings = ['abde', 'abc', 'abd', 'abcde', 'ade', 'ae', '1abde', 'abcdef'];\n  const expected = ['abcdef', 'abcde', 'abde', 'ade', 'ae'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun longestStringChain(strings: List<String>): List<String> {\n    // Write your code here.\n    return listOf()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\ndata class StringChain(var nextString: String, var maxChainLength: Int)\n\n// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings\n// and m is the length of the longest string\nfun longestStringChain(strings: List<String>): List<String> {\n    // For every string, imagine the longest string chain that starts with it.\n    // Set up every string to point to the next string in its respective longest\n    // string chain. Also keep track of the lengths of these longest string\n    // chains.\n    val stringChains = mutableMapOf<String, StringChain>()\n    for (string in strings) {\n        stringChains[string] = StringChain(\"\", 1)\n    }\n\n    // Sort the strings based on their length so that whenever we visit a\n    // string (as we iterate through them from left to right), we can\n    // already have computed the longest string chains of any smaller strings.\n    val sortedStrings = strings.toMutableList().sortedWith(\n        Comparator<String> { a, b -> a.length - b.length },\n    )\n\n    for (string in sortedStrings) {\n        findLongestStringChain(string, stringChains)\n    }\n\n    return buildLongestStringChain(strings, stringChains)\n}\n\nfun findLongestStringChain(string: String, stringChains: Map<String, StringChain>) {\n    // Try removing every letter of the current string to see if the\n    // remaining strings form a string chain.\n    for (i in 0 until string.length) {\n        val smallerString = getSmallerString(string, i)\n        if (!stringChains.containsKey(smallerString)) continue\n        tryUpdateLongestStringChain(string, smallerString, stringChains)\n    }\n}\n\nfun getSmallerString(string: String, index: Int): String {\n    return string.substring(0, index) + string.substring(index + 1)\n}\n\nfun tryUpdateLongestStringChain(currentString: String, smallerString: String, stringChains: Map<String, StringChain>) {\n    val smallerStringChainLength = stringChains[smallerString]!!.maxChainLength\n    val currentStringChainLength = stringChains[currentString]!!.maxChainLength\n    // Update the string chain of the current string only if the smaller string\n    // leads to a longer string chain.\n    if (smallerStringChainLength + 1 > currentStringChainLength) {\n        stringChains[currentString]!!.maxChainLength = smallerStringChainLength + 1\n        stringChains[currentString]!!.nextString = smallerString\n    }\n}\n\nfun buildLongestStringChain(strings: List<String>, stringChains: Map<String, StringChain>): List<String> {\n    // Find the string that starts the longest string chain.\n    var maxChainLength = 0\n    var chainStartingString = \"\"\n    for (string in strings) {\n        if (stringChains[string]!!.maxChainLength > maxChainLength) {\n            maxChainLength = stringChains[string]!!.maxChainLength\n            chainStartingString = string\n        }\n    }\n\n    // Starting at the string found above, build the longest string chain.\n    val ourLongestStringChain = mutableListOf<String>()\n    var currentString = chainStartingString\n    while (currentString != \"\") {\n        ourLongestStringChain.add(currentString)\n        currentString = stringChains[currentString]!!.nextString\n    }\n\n    return if (ourLongestStringChain.size == 1) listOf() else ourLongestStringChain\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.longestStringChain\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val strings = listOf(\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\")\n        val expected = listOf(\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\")\n        assert(longestStringChain(strings).equals(expected))\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.longestStringChain\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val strings = listOf(\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\")\n        val expected = listOf(\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\")\n        assert(longestStringChain(strings).equals(expected))\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def longestStringChain(strings):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n# m is the length of the longest string\ndef longestStringChain(strings):\n    # For every string, imagine the longest string chain that starts with it.\n    # Set up every string to point to the next string in its respective longest\n    # string chain. Also keep track of the lengths of these longest string chains.\n    stringChains = {}\n    for string in strings:\n        stringChains[string] = {\"nextString\": \"\", \"maxChainLength\": 1}\n\n    # Sort the strings based on their length so that whenever we visit a\n    # string (as we iterate through them from left to right), we can\n    # already have computed the longest string chains of any smaller strings.\n    sortedStrings = sorted(strings, key=len)\n    for string in sortedStrings:\n        findLongestStringChain(string, stringChains)\n\n    return buildLongestStringChain(strings, stringChains)\n\n\ndef findLongestStringChain(string, stringChains):\n    # Try removing every letter of the current string to see if the\n    # remaining strings form a string chain.\n    for i in range(len(string)):\n        smallerString = getSmallerString(string, i)\n        if smallerString not in stringChains:\n            continue\n        tryUpdateLongestStringChain(string, smallerString, stringChains)\n\n\ndef getSmallerString(string, index):\n    return string[0:index] + string[index + 1 :]\n\n\ndef tryUpdateLongestStringChain(currentString, smallerString, stringChains):\n    smallerStringChainLength = stringChains[smallerString][\"maxChainLength\"]\n    currentStringChainLength = stringChains[currentString][\"maxChainLength\"]\n    # Update the string chain of the current string only if the smaller string leads\n    # to a longer string chain.\n    if smallerStringChainLength + 1 > currentStringChainLength:\n        stringChains[currentString][\"maxChainLength\"] = smallerStringChainLength + 1\n        stringChains[currentString][\"nextString\"] = smallerString\n\n\ndef buildLongestStringChain(strings, stringChains):\n    # Find the string that starts the longest string chain.\n    maxChainLength = 0\n    chainStartingString = \"\"\n    for string in strings:\n        if stringChains[string][\"maxChainLength\"] > maxChainLength:\n            maxChainLength = stringChains[string][\"maxChainLength\"]\n            chainStartingString = string\n\n    # Starting at the string found above, build the longest string chain.\n    ourLongestStringChain = []\n    currentString = chainStartingString\n    while currentString != \"\":\n        ourLongestStringChain.append(currentString)\n        currentString = stringChains[currentString][\"nextString\"]\n\n    return [] if len(ourLongestStringChain) == 1 else ourLongestStringChain\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        strings = [\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"]\n        expected = [\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"]\n        self.assertEqual(program.longestStringChain(strings), expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        strings = [\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"]\n        expected = [\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"]\n        self.assertEqual(program.longestStringChain(strings), expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def longestStringChain(strings)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def longestStringChain(strings)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.longestStringChain\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.longestStringChain\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func longestStringChain(_ strings: [String]) -> [String] {\n    // Write your code here.\n    return []\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class Chain {\n    var nextString: String\n    var maxChainLength: Int\n\n    init(_ nextString: String, _ maxChainLength: Int) {\n      self.nextString = nextString\n      self.maxChainLength = maxChainLength\n    }\n  }\n\n  // O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n  // m is the length of the longest string\n  func longestStringChain(_ strings: [String]) -> [String] {\n    // For every string, imagine the longest string chain that starts with it.\n    // Set up every string to point to the next string in its respective longest\n    // string chain. Also keep track of the lengths of these longest string chains.\n    var stringChains = [String: Chain]()\n    for str in strings {\n      stringChains[str] = Chain(\"\", 1)\n    }\n\n    // Sort the strings based on their length so that whenever we visit a\n    // string (as we iterate through them from left to right), we can\n    // already have computed the longest string chains of any smaller strings.\n    let sortedStrings = strings.sorted {\n      $0.length < $1.length\n    }\n\n    for str in sortedStrings {\n      findLongestStringChain(str, &stringChains)\n    }\n    return buildLongestStringChain(strings, &stringChains)\n  }\n\n  func findLongestStringChain(_ string: String, _ stringChains: inout [String: Chain]) {\n    // Try removing every letter of the current string to see if the\n    // remaining strings form a string chain.\n    for i in 0 ..< string.length {\n      let smallerString = getSmallerString(string, i)\n      if let _ = stringChains[smallerString] {\n        tryUpdateLongestStringChain(string, smallerString, &stringChains)\n      }\n    }\n  }\n\n  func getSmallerString(_ string: String, _ index: Int) -> String {\n    var s = string\n    let i = s.index(s.startIndex, offsetBy: index)\n    s.remove(at: i)\n    return s\n  }\n\n  func tryUpdateLongestStringChain(_ currentString: String, _ smallerString: String, _ stringChains: inout [String: Chain]) {\n    let smallerStringChainLength = stringChains[smallerString]!.maxChainLength\n    let currentStringChainLength = stringChains[currentString]!.maxChainLength\n    // Update the string chain of the current string only if the smaller string leads\n    // to a longer string chain.\n    if smallerStringChainLength + 1 > currentStringChainLength {\n      stringChains[currentString]!.maxChainLength = smallerStringChainLength + 1\n      stringChains[currentString]!.nextString = smallerString\n    }\n  }\n\n  func buildLongestStringChain(_ strings: [String], _ stringChains: inout [String: Chain]) -> [String] {\n    // Find the string that starts the longest string chain.\n    var maxChainLength = 0\n    var chainStartingString = \"\"\n    for str in strings {\n      if stringChains[str]!.maxChainLength > maxChainLength {\n        maxChainLength = stringChains[str]!.maxChainLength\n        chainStartingString = str\n      }\n    }\n\n    // Starting at the string found above, build the longest string chain.\n    var ourLongestStringChain = [String]()\n    var currentString = chainStartingString\n    while currentString != \"\" {\n      ourLongestStringChain.append(currentString)\n      currentString = stringChains[currentString]!.nextString\n    }\n\n    if ourLongestStringChain.count == 1 {\n      return [String]()\n    }\n    return ourLongestStringChain\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let input = [\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"]\n      let expected = [\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"]\n      let output = program.longestStringChain(input)\n      try assertEqual(output, expected)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let input = [\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"]\n      let expected = [\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"]\n      let output = program.longestStringChain(input)\n      try assertEqual(output, expected)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function longestStringChain(strings: string[]) {\n  // Write your code here.\n  return [''];\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\ninterface StringChains {\n  [key: string]: {\n    nextString: string;\n    maxChainLength: number;\n  };\n}\n\n// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n// m is the length of the longest string\nexport function longestStringChain(strings: string[]) {\n  // For every string, imagine the longest string chain that starts with it.\n  // Set up every string to point to the next string in its respective longest\n  // string chain. Also keep track of the lengths of these longest string chains.\n  const stringChains: StringChains = {};\n  for (const string of strings) {\n    stringChains[string] = {nextString: '', maxChainLength: 1};\n  }\n\n  // Sort the strings based on their length so that whenever we visit a\n  // string (as we iterate through them from left to right), we can\n  // already have computed the longest string chains of any smaller strings.\n  const sortedStrings = strings.sort((a, b) => a.length - b.length);\n  for (const string of sortedStrings) {\n    findLongestStringChain(string, stringChains);\n  }\n\n  return buildLongestStringChain(strings, stringChains);\n}\n\nfunction findLongestStringChain(string: string, stringChains: StringChains) {\n  // Try removing every letter of the current string to see if the\n  // remaining strings form a string chain.\n  for (let i = 0; i < string.length; i++) {\n    const smallerString = getSmallerString(string, i);\n    if (!(smallerString in stringChains)) continue;\n    tryUpdateLongestStringChain(string, smallerString, stringChains);\n  }\n}\n\nfunction getSmallerString(string: string, index: number) {\n  return string.slice(0, index) + string.slice(index + 1);\n}\n\nfunction tryUpdateLongestStringChain(\n  currentString: string,\n  smallerString: string,\n  stringChains: StringChains,\n) {\n  const smallerStringChainLength = stringChains[smallerString].maxChainLength;\n  const currentStringChainLength = stringChains[currentString].maxChainLength;\n  // Update the string chain of the current string only if the smaller string leads\n  // to a longer string chain.\n  if (smallerStringChainLength + 1 > currentStringChainLength) {\n    stringChains[currentString].maxChainLength = smallerStringChainLength + 1;\n    stringChains[currentString].nextString = smallerString;\n  }\n}\n\nfunction buildLongestStringChain(strings: string[], stringChains: StringChains) {\n  // Find the string that starts the longest string chain.\n  let maxChainLength = 0;\n  let chainStartingString = '';\n  for (const string of strings) {\n    if (stringChains[string].maxChainLength > maxChainLength) {\n      maxChainLength = stringChains[string].maxChainLength;\n      chainStartingString = string;\n    }\n  }\n\n  // Starting at the string found above, build the longest string chain.\n  const ourLongestStringChain: string[] = [];\n  let currentString = chainStartingString;\n  while (currentString !== '') {\n    ourLongestStringChain.push(currentString);\n    currentString = stringChains[currentString].nextString;\n  }\n\n  return ourLongestStringChain.length === 1 ? [] : ourLongestStringChain;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const strings = ['abde', 'abc', 'abd', 'abcde', 'ade', 'ae', '1abde', 'abcdef'];\n  const expected = ['abcdef', 'abcde', 'abde', 'ade', 'ae'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const strings = ['abde', 'abc', 'abd', 'abcde', 'ade', 'ae', '1abde', 'abcdef'];\n  const expected = ['abcdef', 'abcde', 'abde', 'ade', 'ae'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "strings",
      "example": [
        "abde",
        "abc",
        "abd",
        "abcde",
        "ade",
        "ae",
        "1abde",
        "abcdef"
      ],
      "schema": {
        "items": {
          "type": "string"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "strings": [
        "abde",
        "abc",
        "abd",
        "abcde",
        "ade",
        "ae",
        "1abde",
        "abcdef"
      ]
    },
    {
      "strings": [
        "abcdefg",
        "abcdef",
        "abcde",
        "abcd",
        "abc",
        "ab",
        "a"
      ]
    },
    {
      "strings": [
        "abcdefg",
        "abdefg",
        "abdfg",
        "bdfg",
        "bfg",
        "bg",
        "g"
      ]
    },
    {
      "strings": [
        "abcdefg",
        "1234",
        "abdefg",
        "abdfg",
        "123",
        "12",
        "bg",
        "g",
        "12345",
        "12a345"
      ]
    },
    {
      "strings": [
        "abcdefg1",
        "1234c",
        "abdefg2",
        "abdfg",
        "123",
        "122",
        "bgg",
        "g",
        "1a2345",
        "12a345"
      ]
    },
    {
      "strings": [
        "lgoprt",
        "12345678",
        "algoxpert",
        "abcde",
        "123468",
        "lgoxprt",
        "abde",
        "lgopt",
        "1234678",
        "ade",
        "ae",
        "algoxprt",
        "a",
        "1abde",
        "lgpt",
        "123456789",
        "234678",
        "algoexpert"
      ]
    },
    {
      "strings": [
        "12345678",
        "algoxpert",
        "123468",
        "abde",
        "lgopt",
        "1234678",
        "ade",
        "ae",
        "a",
        "1abde",
        "lgpt",
        "123456789",
        "234678",
        "algoexpert"
      ]
    }
  ],
  "jsonTests": [
    {
      "strings": [
        "abde",
        "abc",
        "abd",
        "abcde",
        "ade",
        "ae",
        "1abde",
        "abcdef"
      ]
    },
    {
      "strings": [
        "abcdefg",
        "abcdef",
        "abcde",
        "abcd",
        "abc",
        "ab",
        "a"
      ]
    },
    {
      "strings": [
        "abcdefg",
        "abdefg",
        "abdfg",
        "bdfg",
        "bfg",
        "bg",
        "g"
      ]
    },
    {
      "strings": [
        "abcdefg",
        "1234",
        "abdefg",
        "abdfg",
        "123",
        "12",
        "bg",
        "g",
        "12345",
        "12a345"
      ]
    },
    {
      "strings": [
        "abcdefg1",
        "1234c",
        "abdefg2",
        "abdfg",
        "123",
        "122",
        "bgg",
        "g",
        "1a2345",
        "12a345"
      ]
    },
    {
      "strings": [
        "lgoprt",
        "12345678",
        "algoxpert",
        "abcde",
        "123468",
        "lgoxprt",
        "abde",
        "lgopt",
        "1234678",
        "ade",
        "ae",
        "algoxprt",
        "a",
        "1abde",
        "lgpt",
        "123456789",
        "234678",
        "algoexpert"
      ]
    },
    {
      "strings": [
        "12345678",
        "algoxpert",
        "123468",
        "abde",
        "lgopt",
        "1234678",
        "ade",
        "ae",
        "a",
        "1abde",
        "lgpt",
        "123456789",
        "234678",
        "algoexpert"
      ]
    }
  ],
  "changelog": []
}