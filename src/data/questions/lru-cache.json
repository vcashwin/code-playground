{
  "uid": "lru-cache",
  "testStrategy": "JSON",
  "name": "LRU Cache",
  "version": 0,
  "releaseDate": "2000-05-04T00:00:00Z",
  "category": "Linked Lists",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 7566,
    "failureCount": 2936
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "251202282",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1721
  },
  "prompt": "<div class=\"html\">\n<p>\n  Implement an <span>LRUCache</span> class for a Least Recently Used (LRU)\n  cache. The class should support:\n</p>\n<ul>\n  <li>\n    Inserting key-value pairs with the <span>insertKeyValuePair</span> method.\n  </li>\n  <li>\n    Retrieving a key's value with the <span>getValueFromKey</span> method.\n  </li>\n  <li>\n    Retrieving the most recently used (the most recently inserted or\n    retrieved) key with the\n    <span>getMostRecentKey</span> method.\n  </li>\n</ul>\n<p>\n  Each of these methods should run in constant time.\n</p>\n<p>\n  Additionally, the <span>LRUCache</span> class should store a\n  <span>maxSize</span> property set to the size of the cache, which is passed in\n  as an argument during instantiation. This size represents the maximum number\n  of key-value pairs that the cache can store at once. If a key-value pair is\n  inserted in the cache when it has reached maximum capacity, the least recently\n  used key-value pair should be evicted from the cache and no longer\n  retrievable; the newly added key-value pair should effectively replace it.\n</p>\n<p>\n  Note that inserting a key-value pair with an already existing key should\n  simply replace the key's value in the cache with the new value and shouldn't\n  evict a key-value pair if the cache is full. Lastly, attempting to retrieve a\n  value from a key that isn't in the cache should return <span>None</span> /\n  <span>null</span>.\n</p>\n<h3>Sample Usage</h3>\n<pre>\n<span class=\"CodeEditor-promptComment\">// All operations below are performed sequentially.</span>\n<span class=\"CodeEditor-promptParameter\">LRUCache</span>(3): - <span class=\"CodeEditor-promptComment\">// instantiate an LRUCache of size 3</span>\n<span class=\"CodeEditor-promptParameter\">insertKeyValuePair</span>(\"b\", 2): -\n<span class=\"CodeEditor-promptParameter\">insertKeyValuePair</span>(\"a\", 1): -\n<span class=\"CodeEditor-promptParameter\">insertKeyValuePair</span>(\"c\", 3): -\n<span class=\"CodeEditor-promptParameter\">getMostRecentKey</span>(): \"c\" <span class=\"CodeEditor-promptComment\">// \"c\" was the most recently inserted key</span>\n<span class=\"CodeEditor-promptParameter\">getValueFromKey</span>(\"a\"): 1\n<span class=\"CodeEditor-promptParameter\">getMostRecentKey</span>(): \"a\" <span class=\"CodeEditor-promptComment\">// \"a\" was the most recently retrieved key</span>\n<span class=\"CodeEditor-promptParameter\">insertKeyValuePair</span>(\"d\", 4): - <span class=\"CodeEditor-promptComment\">// the cache had 3 entries; the least recently used one is evicted</span>\n<span class=\"CodeEditor-promptParameter\">getValueFromKey</span>(\"b\"): None <span class=\"CodeEditor-promptComment\">// \"b\" was evicted in the previous operation</span>\n<span class=\"CodeEditor-promptParameter\">insertKeyValuePair</span>(\"a\", 5): - <span class=\"CodeEditor-promptComment\">// \"a\" already exists in the cache so its value just gets replaced</span>\n<span class=\"CodeEditor-promptParameter\">getValueFromKey</span>(\"a\"): 5\n</pre>\n</div>",
  "hints": [
    "<p>\nWhat data structure could allow you to insert, retrieve, and evict resources as fast as possible, all the while keeping track of the least recently accessed resource - essentially keeping track of the order of the resources? A hash table would allow you to insert and retrieve resources fast, but it wouldn't allow you to keep track of their order. An array would let you keep track of their order, but it wouldn't let you access elements fast; it also wouldn't allow you to move an element from one position to another in constant time, which you would need to do to make a newly-accessed key / value pair the most recent one upon retrieval of a key's value. A linked list would allow you to keep track of elements' order and to move them seamlessly (if you knew their position), but it wouldn't allow you to access them easily without knowing their position beforehand. Could a heap help? What about a BST or a trie? Would any other data structures work?\n</p>\n",
    "\n<p>\nCould you use multiple data structures to make your LRU Cache's functionality fast and efficient? Could you store keys in one data structure, for instance, and values in an auxiliary data structure? What should these data structures be in order for all of the LRU Cache's methods to run in constant time?\n</p>\n",
    "\n<p>\nTry storing keys in a hash table and mapping them to nodes in a doubly linked list containing the keys' corresponding values (perhaps the nodes would also have to store the keys themselves). With these two data structures, you could access any key / value pair very easily via the hash table, and you could also effortlessly move nodes in the linked list so as to keep track of the most recent and least recent key / value pairs. The linked list would also allow you to keep track of the entire order of the key / value pairs, thus allowing you to perpetually update the least recent key / value pairs after evictions.\n</p>"
  ],
  "spaceTime": "(all 3 methods) O(1) time | O(1) space",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// Do not edit the class below except for the insertKeyValuePair,\n// getValueFromKey, and getMostRecentKey methods. Feel free\n// to add new properties and methods to the class.\nclass LRUCache {\n public:\n  int maxSize;\n\n  LRUCache(int maxSize) { this->maxSize = maxSize > 1 ? maxSize : 1; }\n\n  void insertKeyValuePair(string key, int value) {\n    // Write your code here.\n  }\n\n  int* getValueFromKey(string key) {\n    // Write your code here.\n    return nullptr;\n  }\n\n  string getMostRecentKey() {\n    // Write your code here.\n    return \"\";\n  }\n};\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nclass DoublyLinkedListNode {\n public:\n  string key;\n  int value;\n  DoublyLinkedListNode* prev;\n  DoublyLinkedListNode* next;\n\n  DoublyLinkedListNode(string key, int value) {\n    this->key = key;\n    this->value = value;\n    this->prev = nullptr;\n    this->next = nullptr;\n  }\n\n  void removeBindings() {\n    if (this->prev != nullptr) {\n      this->prev->next = this->next;\n    }\n    if (this->next != nullptr) {\n      this->next->prev = this->prev;\n    }\n    this->prev = nullptr;\n    this->next = nullptr;\n  }\n};\n\nclass DoublyLinkedList {\n public:\n  DoublyLinkedListNode* head;\n  DoublyLinkedListNode* tail;\n\n  DoublyLinkedList() {\n    this->head = nullptr;\n    this->tail = nullptr;\n  }\n\n  void setHeadTo(DoublyLinkedListNode* node) {\n    if (this->head == node) {\n      return;\n    } else if (this->head == nullptr) {\n      this->head = node;\n      this->tail = node;\n    } else if (this->head == this->tail) {\n      this->tail->prev = node;\n      this->head = node;\n      this->head->next = this->tail;\n    } else {\n      if (this->tail == node) {\n        this->removeTail();\n      }\n      node->removeBindings();\n      this->head->prev = node;\n      node->next = this->head;\n      this->head = node;\n    }\n  }\n\n  void removeTail() {\n    if (this->tail == nullptr) {\n      return;\n    }\n    if (this->tail == this->head) {\n      this->head = nullptr;\n      this->tail = nullptr;\n      return;\n    }\n    this->tail = this->tail->prev;\n    this->tail->next = nullptr;\n  }\n};\n\nclass LRUCache {\n public:\n  unordered_map<string, DoublyLinkedListNode*> cache;\n  int maxSize;\n  int currentSize;\n  DoublyLinkedList listOfMostRecent;\n\n  LRUCache(int maxSize) {\n    this->maxSize = maxSize > 1 ? maxSize : 1;\n    this->currentSize = 0;\n    this->listOfMostRecent = DoublyLinkedList();\n  }\n\n  // O(1) time | O(1) space\n  void insertKeyValuePair(string key, int value) {\n    if (this->cache.find(key) == this->cache.end()) {\n      if (this->currentSize == this->maxSize) {\n        this->evictLeastRecent();\n      } else {\n        this->currentSize++;\n      }\n      this->cache[key] = new DoublyLinkedListNode(key, value);\n    } else {\n      this->replaceKey(key, value);\n    }\n    this->updateMostRecent(this->cache[key]);\n  }\n\n  // O(1) time | O(1) space\n  int* getValueFromKey(string key) {\n    if (this->cache.find(key) == this->cache.end()) {\n      return nullptr;\n    }\n    this->updateMostRecent(this->cache[key]);\n    return &this->cache[key]->value;\n  }\n\n  // O(1) time | O(1) space\n  string getMostRecentKey() {\n    if (this->listOfMostRecent.head == nullptr) {\n      return \"\";\n    }\n    return this->listOfMostRecent.head->key;\n  }\n\n  void evictLeastRecent() {\n    string keyToRemove = this->listOfMostRecent.tail->key;\n    this->listOfMostRecent.removeTail();\n    this->cache.erase(keyToRemove);\n  }\n\n  void updateMostRecent(DoublyLinkedListNode* node) {\n    this->listOfMostRecent.setHeadTo(node);\n  }\n\n  void replaceKey(string key, int value) {\n    if (this->cache.find(key) == this->cache.end()) {\n      return;\n    }\n    this->cache[key]->value = value;\n  }\n};\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include <unordered_map>\n\nunordered_map<string, int> letterMaps{\n  {\"a\", 0},\n  {\"b\", 1},\n  {\"c\", 2},\n  {\"d\", 3},\n  {\"e\", 4},\n  {\"f\", 5},\n  {\"g\", 6},\n  {\"h\", 7},\n  {\"i\", 8},\n  {\"j\", 9}};\nvector<string> letters{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"};\n\n#define testLruOfSize(lruSize)                                           \\\n  {                                                                      \\\n    /* Instantiate cache and insert first key. */                        \\\n    LRUCache lru(lruSize);                                               \\\n    assert(lru.getValueFromKey(\"a\") == 0);                               \\\n    lru.insertKeyValuePair(\"a\", 99);                                     \\\n    assert(lru.getMostRecentKey() == \"a\");                               \\\n    assert(*lru.getValueFromKey(\"a\") == 99);                             \\\n    /* Add existing key when cache isn't full. */                        \\\n    lru.insertKeyValuePair(\"a\", 0);                                      \\\n    assert(lru.getMostRecentKey() == \"a\");                               \\\n    assert(*lru.getValueFromKey(\"a\") == 0);                              \\\n    /* Add keys until cache reaches maximum capacity. */                 \\\n    for (int i = 1; i < lruSize; i++) {                                  \\\n      string mostRecentLetter = letters[i - 1];                          \\\n      assert(lru.getMostRecentKey() == mostRecentLetter);                \\\n      /* Test key retrieval when cache isn't full. */                    \\\n      for (int j = 0; j < i; j++) {                                      \\\n        string letter = letters[j];                                      \\\n        assert(*lru.getValueFromKey(letter) == letterMaps[letter]);      \\\n        assert(lru.getMostRecentKey() == letter);                        \\\n      }                                                                  \\\n      string currentLetter = letters[i];                                 \\\n      assert(lru.getValueFromKey(currentLetter) == 0);                   \\\n      lru.insertKeyValuePair(currentLetter, letterMaps[currentLetter]);  \\\n      assert(lru.getMostRecentKey() == currentLetter);                   \\\n      assert(                                                            \\\n        *lru.getValueFromKey(currentLetter) == letterMaps[currentLetter] \\\n      );                                                                 \\\n    }                                                                    \\\n    /* Add keys now that cache is at maximum capacity. */                \\\n    for (int i = lruSize; i < letters.size(); i++) {                     \\\n      string mostRecentLetter = letters[i - 1];                          \\\n      assert(lru.getMostRecentKey() == mostRecentLetter);                \\\n      /* Test key retrieval when cache is full. */                       \\\n      for (int j = i - lruSize; j < i; j++) {                            \\\n        string letter = letters[j];                                      \\\n        assert(*lru.getValueFromKey(letter) == letterMaps[letter]);      \\\n        assert(lru.getMostRecentKey() == letter);                        \\\n      }                                                                  \\\n      string leastRecentLetter = letters[i - lruSize];                   \\\n      string currentLetter = letters[i];                                 \\\n      assert(lru.getValueFromKey(currentLetter) == 0);                   \\\n      lru.insertKeyValuePair(currentLetter, letterMaps[currentLetter]);  \\\n      assert(lru.getMostRecentKey() == currentLetter);                   \\\n      assert(                                                            \\\n        *lru.getValueFromKey(currentLetter) == letterMaps[currentLetter] \\\n      );                                                                 \\\n      assert(lru.getValueFromKey(leastRecentLetter) == 0);               \\\n    }                                                                    \\\n    /* Add existing keys. */                                             \\\n    for (int i = letters.size() - lruSize; i < letters.size(); i++) {    \\\n      string currentLetter = letters[i];                                 \\\n      assert(                                                            \\\n        *lru.getValueFromKey(currentLetter) == letterMaps[currentLetter] \\\n      );                                                                 \\\n      lru.insertKeyValuePair(                                            \\\n        currentLetter, (letterMaps[currentLetter] + 1) * 100             \\\n      );                                                                 \\\n      assert(                                                            \\\n        *lru.getValueFromKey(currentLetter) ==                           \\\n        (letterMaps[currentLetter] + 1) * 100                            \\\n      );                                                                 \\\n    }                                                                    \\\n  }\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      LRUCache lruCache(3);\n      lruCache.insertKeyValuePair(\"b\", 2);\n      lruCache.insertKeyValuePair(\"a\", 1);\n      lruCache.insertKeyValuePair(\"c\", 3);\n      assert(lruCache.getMostRecentKey() == \"c\");\n      assert(*lruCache.getValueFromKey(\"a\") == 1);\n      assert(lruCache.getMostRecentKey() == \"a\");\n      lruCache.insertKeyValuePair(\"d\", 4);\n      assert(lruCache.getValueFromKey(\"b\") == 0);\n      lruCache.insertKeyValuePair(\"a\", 5);\n      assert(*lruCache.getValueFromKey(\"a\") == 5);\n    });\n  }\n};\n",
      "unitTests": "#include <unordered_map>\n\nunordered_map<string, int> letterMaps{\n  {\"a\", 0},\n  {\"b\", 1},\n  {\"c\", 2},\n  {\"d\", 3},\n  {\"e\", 4},\n  {\"f\", 5},\n  {\"g\", 6},\n  {\"h\", 7},\n  {\"i\", 8},\n  {\"j\", 9}};\nvector<string> letters{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"};\n\n#define testLruOfSize(lruSize)                                           \\\n  {                                                                      \\\n    /* Instantiate cache and insert first key. */                        \\\n    LRUCache lru(lruSize);                                               \\\n    assert(lru.getValueFromKey(\"a\") == 0);                               \\\n    lru.insertKeyValuePair(\"a\", 99);                                     \\\n    assert(lru.getMostRecentKey() == \"a\");                               \\\n    assert(*lru.getValueFromKey(\"a\") == 99);                             \\\n    /* Add existing key when cache isn't full. */                        \\\n    lru.insertKeyValuePair(\"a\", 0);                                      \\\n    assert(lru.getMostRecentKey() == \"a\");                               \\\n    assert(*lru.getValueFromKey(\"a\") == 0);                              \\\n    /* Add keys until cache reaches maximum capacity. */                 \\\n    for (int i = 1; i < lruSize; i++) {                                  \\\n      string mostRecentLetter = letters[i - 1];                          \\\n      assert(lru.getMostRecentKey() == mostRecentLetter);                \\\n      /* Test key retrieval when cache isn't full. */                    \\\n      for (int j = 0; j < i; j++) {                                      \\\n        string letter = letters[j];                                      \\\n        assert(*lru.getValueFromKey(letter) == letterMaps[letter]);      \\\n        assert(lru.getMostRecentKey() == letter);                        \\\n      }                                                                  \\\n      string currentLetter = letters[i];                                 \\\n      assert(lru.getValueFromKey(currentLetter) == 0);                   \\\n      lru.insertKeyValuePair(currentLetter, letterMaps[currentLetter]);  \\\n      assert(lru.getMostRecentKey() == currentLetter);                   \\\n      assert(                                                            \\\n        *lru.getValueFromKey(currentLetter) == letterMaps[currentLetter] \\\n      );                                                                 \\\n    }                                                                    \\\n    /* Add keys now that cache is at maximum capacity. */                \\\n    for (int i = lruSize; i < letters.size(); i++) {                     \\\n      string mostRecentLetter = letters[i - 1];                          \\\n      assert(lru.getMostRecentKey() == mostRecentLetter);                \\\n      /* Test key retrieval when cache is full. */                       \\\n      for (int j = i - lruSize; j < i; j++) {                            \\\n        string letter = letters[j];                                      \\\n        assert(*lru.getValueFromKey(letter) == letterMaps[letter]);      \\\n        assert(lru.getMostRecentKey() == letter);                        \\\n      }                                                                  \\\n      string leastRecentLetter = letters[i - lruSize];                   \\\n      string currentLetter = letters[i];                                 \\\n      assert(lru.getValueFromKey(currentLetter) == 0);                   \\\n      lru.insertKeyValuePair(currentLetter, letterMaps[currentLetter]);  \\\n      assert(lru.getMostRecentKey() == currentLetter);                   \\\n      assert(                                                            \\\n        *lru.getValueFromKey(currentLetter) == letterMaps[currentLetter] \\\n      );                                                                 \\\n      assert(lru.getValueFromKey(leastRecentLetter) == 0);               \\\n    }                                                                    \\\n    /* Add existing keys. */                                             \\\n    for (int i = letters.size() - lruSize; i < letters.size(); i++) {    \\\n      string currentLetter = letters[i];                                 \\\n      assert(                                                            \\\n        *lru.getValueFromKey(currentLetter) == letterMaps[currentLetter] \\\n      );                                                                 \\\n      lru.insertKeyValuePair(                                            \\\n        currentLetter, (letterMaps[currentLetter] + 1) * 100             \\\n      );                                                                 \\\n      assert(                                                            \\\n        *lru.getValueFromKey(currentLetter) ==                           \\\n        (letterMaps[currentLetter] + 1) * 100                            \\\n      );                                                                 \\\n    }                                                                    \\\n  }\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      LRUCache lruCache(3);\n      lruCache.insertKeyValuePair(\"b\", 2);\n      lruCache.insertKeyValuePair(\"a\", 1);\n      lruCache.insertKeyValuePair(\"c\", 3);\n      assert(lruCache.getMostRecentKey() == \"c\");\n      assert(*lruCache.getValueFromKey(\"a\") == 1);\n      assert(lruCache.getMostRecentKey() == \"a\");\n      lruCache.insertKeyValuePair(\"d\", 4);\n      assert(lruCache.getValueFromKey(\"b\") == 0);\n      lruCache.insertKeyValuePair(\"a\", 5);\n      assert(*lruCache.getValueFromKey(\"a\") == 5);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n// Do not edit the class below except for the InsertKeyValuePair,\n// GetValueFromKey, and GetMostRecentKey methods. Feel free\n// to add new properties and methods to the class.\npublic class Program {\n  public class LRUCache {\n    public int maxSize;\n\n    public LRUCache(int maxSize) {\n      this.maxSize = maxSize > 1 ? maxSize : 1;\n    }\n\n    public void InsertKeyValuePair(string key, int value) {\n      // Write your code here.\n    }\n\n    public LRUResult GetValueFromKey(string key) {\n      // Write your code here.\n      return null;\n    }\n\n    public string GetMostRecentKey() {\n      // Write your code here.\n      return null;\n    }\n  }\n\n  public class LRUResult {\n    public bool found;\n    public int value;\n\n    public LRUResult(bool found, int value) {\n      this.found = found;\n      this.value = value;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  public class LRUCache {\n    public Dictionary<string, DoublyLinkedListNode> cache =\n      new Dictionary<string, DoublyLinkedListNode>();\n    public int maxSize;\n    public int currentSize = 0;\n    public DoublyLinkedList listOfMostRecent = new DoublyLinkedList();\n\n    public LRUCache(int maxSize) {\n      this.maxSize = maxSize > 1 ? maxSize : 1;\n    }\n\n    // O(1) time | O(1) space\n    public void InsertKeyValuePair(string key, int value) {\n      if (!cache.ContainsKey(key)) {\n        if (currentSize == maxSize) {\n          evictLeastRecent();\n        } else {\n          currentSize++;\n        }\n        cache.Add(key, new DoublyLinkedListNode(key, value));\n      } else {\n        replaceKey(key, value);\n      }\n      updateMostRecent(cache[key]);\n    }\n\n    // O(1) time | O(1) space\n    public LRUResult GetValueFromKey(string key) {\n      if (!cache.ContainsKey(key)) {\n        return new LRUResult(false, -1);\n      }\n      updateMostRecent(cache[key]);\n      return new LRUResult(true, cache[key].value);\n    }\n\n    // O(1) time | O(1) space\n    public string GetMostRecentKey() {\n      if (listOfMostRecent.head == null) {\n        return \"\";\n      }\n      return listOfMostRecent.head.key;\n    }\n\n    public void evictLeastRecent() {\n      string keyToRemove = listOfMostRecent.tail.key;\n      listOfMostRecent.removeTail();\n      cache.Remove(keyToRemove);\n    }\n\n    public void updateMostRecent(DoublyLinkedListNode node) {\n      listOfMostRecent.setHeadTo(node);\n    }\n\n    public void replaceKey(string key, int value) {\n      if (!this.cache.ContainsKey(key)) {\n        return;\n      }\n      cache[key].value = value;\n    }\n  }\n\n  public class DoublyLinkedList {\n    public DoublyLinkedListNode head = null;\n    public DoublyLinkedListNode tail = null;\n\n    public void setHeadTo(DoublyLinkedListNode node) {\n      if (head == node) {\n        return;\n      } else if (head == null) {\n        head = node;\n        tail = node;\n      } else if (head == tail) {\n        tail.prev = node;\n        head = node;\n        head.next = tail;\n      } else {\n        if (tail == node) {\n          removeTail();\n        }\n        node.removeBindings();\n        head.prev = node;\n        node.next = head;\n        head = node;\n      }\n    }\n\n    public void removeTail() {\n      if (tail == null) {\n        return;\n      }\n      if (tail == head) {\n        head = null;\n        tail = null;\n        return;\n      }\n      tail = tail.prev;\n      tail.next = null;\n    }\n  }\n\n  public class DoublyLinkedListNode {\n    public string key;\n    public int value;\n    public DoublyLinkedListNode prev = null;\n    public DoublyLinkedListNode next = null;\n\n    public DoublyLinkedListNode(string key, int value) {\n      this.key = key;\n      this.value = value;\n    }\n\n    public void removeBindings() {\n      if (prev != null) {\n        prev.next = next;\n      }\n      if (next != null) {\n        next.prev = prev;\n      }\n      prev = null;\n      next = null;\n    }\n  }\n\n  public class LRUResult {\n    public bool found;\n    public int value;\n\n    public LRUResult(bool found, int value) {\n      this.found = found;\n      this.value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.LRUCache lruCache = new Program.LRUCache(3);\n    lruCache.InsertKeyValuePair(\"b\", 2);\n    lruCache.InsertKeyValuePair(\"a\", 1);\n    lruCache.InsertKeyValuePair(\"c\", 3);\n    Utils.AssertTrue(lruCache.GetMostRecentKey() == \"c\");\n    Utils.AssertTrue(lruCache.GetValueFromKey(\"a\").value == 1);\n    Utils.AssertTrue(lruCache.GetMostRecentKey() == \"a\");\n    lruCache.InsertKeyValuePair(\"d\", 4);\n    var evictedValue = lruCache.GetValueFromKey(\"b\");\n    Utils.AssertTrue(evictedValue == null || evictedValue.found == false);\n    lruCache.InsertKeyValuePair(\"a\", 5);\n    Utils.AssertTrue(lruCache.GetValueFromKey(\"a\").value == 5);\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.LRUCache lruCache = new Program.LRUCache(3);\n    lruCache.InsertKeyValuePair(\"b\", 2);\n    lruCache.InsertKeyValuePair(\"a\", 1);\n    lruCache.InsertKeyValuePair(\"c\", 3);\n    Utils.AssertTrue(lruCache.GetMostRecentKey() == \"c\");\n    Utils.AssertTrue(lruCache.GetValueFromKey(\"a\").value == 1);\n    Utils.AssertTrue(lruCache.GetMostRecentKey() == \"a\");\n    lruCache.InsertKeyValuePair(\"d\", 4);\n    var evictedValue = lruCache.GetValueFromKey(\"b\");\n    Utils.AssertTrue(evictedValue == null || evictedValue.found == false);\n    lruCache.InsertKeyValuePair(\"a\", 5);\n    Utils.AssertTrue(lruCache.GetValueFromKey(\"a\").value == 5);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// Do not edit the class below except for the insertKeyValuePair,\n// getValueFromKey, and getMostRecentKey methods. Feel free\n// to add new properties and methods to the class.\ntype LRUCache struct {\n\tmaxSize int\n\t// Add fields here.\n}\n\nfunc NewLRUCache(size int) *LRUCache {\n\t// Write your code here.\n\treturn nil\n}\n\nfunc (cache *LRUCache) InsertKeyValuePair(key string, value int) {\n\t// Write your code here.\n}\n\n// The second return value indicates whether or not the key was found\n// in the cache.\nfunc (cache *LRUCache) GetValueFromKey(key string) (int, bool) {\n\t// Write your code here.\n\treturn -1, false\n}\n\n// The second return value is false if the cache is empty.\nfunc (cache *LRUCache) GetMostRecentKey() (string, bool) {\n\t// Write your code here.\n\treturn \"\", false\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype LRUCache struct {\n\tindex            map[string]*DoublyLinkedListNode\n\tmaxSize          int\n\tcurrentSize      int\n\tlistOfMostRecent *DoublyLinkedList\n}\n\nfunc NewLRUCache(size int) *LRUCache {\n\tlru := &LRUCache{\n\t\tindex:            map[string]*DoublyLinkedListNode{},\n\t\tmaxSize:          size,\n\t\tcurrentSize:      0,\n\t\tlistOfMostRecent: &DoublyLinkedList{},\n\t}\n\tif lru.maxSize < 1 {\n\t\tlru.maxSize = 1\n\t}\n\treturn lru\n}\n\n// O(1) time | O(1) space\nfunc (cache *LRUCache) InsertKeyValuePair(key string, value int) {\n\tif _, found := cache.index[key]; !found {\n\t\tif cache.currentSize == cache.maxSize {\n\t\t\tcache.evictLeastRecent()\n\t\t} else {\n\t\t\tcache.currentSize += 1\n\t\t}\n\t\tcache.index[key] = &DoublyLinkedListNode{\n\t\t\tkey:   key,\n\t\t\tvalue: value,\n\t\t}\n\t} else {\n\t\tcache.replaceKey(key, value)\n\t}\n\tcache.updateMostRecent(cache.index[key])\n}\n\n// O(1) time | O(1) space\nfunc (cache *LRUCache) GetValueFromKey(key string) (int, bool) {\n\tif node, found := cache.index[key]; !found {\n\t\treturn 0, false\n\t} else {\n\t\tcache.updateMostRecent(node)\n\t\treturn node.value, true\n\t}\n}\n\n// O(1) time | O(1) space\nfunc (cache *LRUCache) GetMostRecentKey() (string, bool) {\n\tif cache.listOfMostRecent.head == nil {\n\t\treturn \"\", false\n\t}\n\treturn cache.listOfMostRecent.head.key, true\n}\n\nfunc (cache *LRUCache) evictLeastRecent() {\n\tkey := cache.listOfMostRecent.tail.key\n\tcache.listOfMostRecent.removeTail()\n\tdelete(cache.index, key)\n}\n\nfunc (cache *LRUCache) updateMostRecent(node *DoublyLinkedListNode) {\n\tcache.listOfMostRecent.setHeadTo(node)\n}\n\nfunc (cache *LRUCache) replaceKey(key string, value int) {\n\tif node, found := cache.index[key]; !found {\n\t\tpanic(\"The provided key isn't in the cache!\")\n\t} else {\n\t\tnode.value = value\n\t}\n}\n\ntype DoublyLinkedList struct {\n\thead *DoublyLinkedListNode\n\ttail *DoublyLinkedListNode\n}\n\nfunc (list *DoublyLinkedList) setHeadTo(node *DoublyLinkedListNode) {\n\tif list.head == node {\n\t\treturn\n\t}\n\tif list.head == nil {\n\t\tlist.head, list.tail = node, node\n\t\treturn\n\t}\n\tif list.head == list.tail {\n\t\tlist.tail.prev = node\n\t\tlist.head = node\n\t\tlist.head.next = list.tail\n\t\treturn\n\t}\n\tif list.tail == node {\n\t\tlist.removeTail()\n\t}\n\tnode.removeBindings()\n\tlist.head.prev = node\n\tnode.next = list.head\n\tlist.head = node\n}\n\nfunc (list *DoublyLinkedList) removeTail() {\n\tif list.tail == nil {\n\t\treturn\n\t}\n\tif list.tail == list.head {\n\t\tlist.head, list.tail = nil, nil\n\t\treturn\n\t}\n\tlist.tail = list.tail.prev\n\tlist.tail.next = nil\n}\n\ntype DoublyLinkedListNode struct {\n\tkey   string\n\tvalue int\n\tprev  *DoublyLinkedListNode\n\tnext  *DoublyLinkedListNode\n}\n\nfunc (node *DoublyLinkedListNode) removeBindings() {\n\tif node.prev != nil {\n\t\tnode.prev.next = node.next\n\t}\n\tif node.next != nil {\n\t\tnode.next.prev = node.prev\n\t}\n\tnode.prev, node.next = nil, nil\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tlruCache := NewLRUCache(3)\n\tlruCache.InsertKeyValuePair(\"b\", 2)\n\tlruCache.InsertKeyValuePair(\"a\", 1)\n\tlruCache.InsertKeyValuePair(\"c\", 3)\n\tkey, _ := lruCache.GetMostRecentKey()\n\trequire.True(t, key == \"c\")\n\tvalue, _ := lruCache.GetValueFromKey(\"a\")\n\trequire.True(t, value == 1)\n\tkey, _ = lruCache.GetMostRecentKey()\n\trequire.True(t, key == \"a\")\n\tlruCache.InsertKeyValuePair(\"d\", 4)\n\t_, found := lruCache.GetValueFromKey(\"b\")\n\trequire.True(t, !found)\n\tlruCache.InsertKeyValuePair(\"a\", 5)\n\tvalue, _ = lruCache.GetValueFromKey(\"a\")\n\trequire.True(t, value == 5)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tlruCache := NewLRUCache(3)\n\tlruCache.InsertKeyValuePair(\"b\", 2)\n\tlruCache.InsertKeyValuePair(\"a\", 1)\n\tlruCache.InsertKeyValuePair(\"c\", 3)\n\tkey, _ := lruCache.GetMostRecentKey()\n\trequire.True(t, key == \"c\")\n\tvalue, _ := lruCache.GetValueFromKey(\"a\")\n\trequire.True(t, value == 1)\n\tkey, _ = lruCache.GetMostRecentKey()\n\trequire.True(t, key == \"a\")\n\tlruCache.InsertKeyValuePair(\"d\", 4)\n\t_, found := lruCache.GetValueFromKey(\"b\")\n\trequire.True(t, !found)\n\tlruCache.InsertKeyValuePair(\"a\", 5)\n\tvalue, _ = lruCache.GetValueFromKey(\"a\")\n\trequire.True(t, value == 5)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\n// Do not edit the class below except for the insertKeyValuePair,\n// getValueFromKey, and getMostRecentKey methods. Feel free\n// to add new properties and methods to the class.\nclass Program {\n  static class LRUCache {\n    int maxSize;\n\n    public LRUCache(int maxSize) {\n      this.maxSize = maxSize > 1 ? maxSize : 1;\n    }\n\n    public void insertKeyValuePair(String key, int value) {\n      // Write your code here.\n    }\n\n    public LRUResult getValueFromKey(String key) {\n      // Write your code here.\n      return null;\n    }\n\n    public String getMostRecentKey() {\n      // Write your code here.\n      return null;\n    }\n  }\n\n  static class LRUResult {\n    boolean found;\n    int value;\n\n    public LRUResult(boolean found, int value) {\n      this.found = found;\n      this.value = value;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  static class LRUCache {\n    Map<String, DoublyLinkedListNode> cache =\n      new HashMap<String, DoublyLinkedListNode>();\n    int maxSize;\n    int currentSize = 0;\n    DoublyLinkedList listOfMostRecent = new DoublyLinkedList();\n\n    public LRUCache(int maxSize) {\n      this.maxSize = maxSize > 1 ? maxSize : 1;\n    }\n\n    // O(1) time | O(1) space\n    public void insertKeyValuePair(String key, int value) {\n      if (!cache.containsKey(key)) {\n        if (currentSize == maxSize) {\n          evictLeastRecent();\n        } else {\n          currentSize++;\n        }\n        cache.put(key, new DoublyLinkedListNode(key, value));\n      } else {\n        replaceKey(key, value);\n      }\n      updateMostRecent(cache.get(key));\n    }\n\n    // O(1) time | O(1) space\n    public LRUResult getValueFromKey(String key) {\n      if (!cache.containsKey(key)) {\n        return new LRUResult(false, -1);\n      }\n      updateMostRecent(cache.get(key));\n      return new LRUResult(true, cache.get(key).value);\n    }\n\n    // O(1) time | O(1) space\n    public String getMostRecentKey() {\n      if (listOfMostRecent.head == null) {\n        return \"\";\n      }\n      return listOfMostRecent.head.key;\n    }\n\n    public void evictLeastRecent() {\n      String keyToRemove = listOfMostRecent.tail.key;\n      listOfMostRecent.removeTail();\n      cache.remove(keyToRemove);\n    }\n\n    public void updateMostRecent(DoublyLinkedListNode node) {\n      listOfMostRecent.setHeadTo(node);\n    }\n\n    public void replaceKey(String key, int value) {\n      if (!this.cache.containsKey(key)) {\n        return;\n      }\n      cache.get(key).value = value;\n    }\n  }\n\n  static class DoublyLinkedList {\n    DoublyLinkedListNode head = null;\n    DoublyLinkedListNode tail = null;\n\n    public void setHeadTo(DoublyLinkedListNode node) {\n      if (head == node) {\n        return;\n      } else if (head == null) {\n        head = node;\n        tail = node;\n      } else if (head == tail) {\n        tail.prev = node;\n        head = node;\n        head.next = tail;\n      } else {\n        if (tail == node) {\n          removeTail();\n        }\n        node.removeBindings();\n        head.prev = node;\n        node.next = head;\n        head = node;\n      }\n    }\n\n    public void removeTail() {\n      if (tail == null) {\n        return;\n      }\n      if (tail == head) {\n        head = null;\n        tail = null;\n        return;\n      }\n      tail = tail.prev;\n      tail.next = null;\n    }\n  }\n\n  static class DoublyLinkedListNode {\n    String key;\n    int value;\n    DoublyLinkedListNode prev = null;\n    DoublyLinkedListNode next = null;\n\n    public DoublyLinkedListNode(String key, int value) {\n      this.key = key;\n      this.value = value;\n    }\n\n    public void removeBindings() {\n      if (prev != null) {\n        prev.next = next;\n      }\n      if (next != null) {\n        next.prev = prev;\n      }\n      prev = null;\n      next = null;\n    }\n  }\n\n  static class LRUResult {\n    boolean found;\n    int value;\n\n    public LRUResult(boolean found, int value) {\n      this.found = found;\n      this.value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.LRUCache lruCache = new Program.LRUCache(3);\n    lruCache.insertKeyValuePair(\"b\", 2);\n    lruCache.insertKeyValuePair(\"a\", 1);\n    lruCache.insertKeyValuePair(\"c\", 3);\n    Utils.assertTrue(lruCache.getMostRecentKey() == \"c\");\n    Utils.assertTrue(lruCache.getValueFromKey(\"a\").value == 1);\n    Utils.assertTrue(lruCache.getMostRecentKey() == \"a\");\n    lruCache.insertKeyValuePair(\"d\", 4);\n    var evictedValue = lruCache.getValueFromKey(\"b\");\n    Utils.assertTrue(evictedValue == null || evictedValue.found == false);\n    lruCache.insertKeyValuePair(\"a\", 5);\n    Utils.assertTrue(lruCache.getValueFromKey(\"a\").value == 5);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.LRUCache lruCache = new Program.LRUCache(3);\n    lruCache.insertKeyValuePair(\"b\", 2);\n    lruCache.insertKeyValuePair(\"a\", 1);\n    lruCache.insertKeyValuePair(\"c\", 3);\n    Utils.assertTrue(lruCache.getMostRecentKey() == \"c\");\n    Utils.assertTrue(lruCache.getValueFromKey(\"a\").value == 1);\n    Utils.assertTrue(lruCache.getMostRecentKey() == \"a\");\n    lruCache.insertKeyValuePair(\"d\", 4);\n    var evictedValue = lruCache.getValueFromKey(\"b\");\n    Utils.assertTrue(evictedValue == null || evictedValue.found == false);\n    lruCache.insertKeyValuePair(\"a\", 5);\n    Utils.assertTrue(lruCache.getValueFromKey(\"a\").value == 5);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// Do not edit the class below except for the insertKeyValuePair,\n// getValueFromKey, and getMostRecentKey methods. Feel free\n// to add new properties and methods to the class.\nclass LRUCache {\n  constructor(maxSize) {\n    this.maxSize = maxSize || 1;\n  }\n\n  insertKeyValuePair(key, value) {\n    // Write your code here.\n  }\n\n  getValueFromKey(key) {\n    // Write your code here.\n  }\n\n  getMostRecentKey() {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.LRUCache = LRUCache;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass LRUCache {\n  constructor(maxSize) {\n    this.cache = {};\n    this.maxSize = maxSize || 1;\n    this.currentSize = 0;\n    this.listOfMostRecent = new DoublyLinkedList();\n  }\n\n  // O(1) time | O(1) space\n  insertKeyValuePair(key, value) {\n    if (!(key in this.cache)) {\n      if (this.currentSize === this.maxSize) {\n        this.evictLeastRecent();\n      } else {\n        this.currentSize++;\n      }\n      this.cache[key] = new DoublyLinkedListNode(key, value);\n    } else {\n      this.replaceKey(key, value);\n    }\n    this.updateMostRecent(this.cache[key]);\n  }\n\n  // O(1) time | O(1) space\n  getValueFromKey(key) {\n    if (!(key in this.cache)) return null;\n    this.updateMostRecent(this.cache[key]);\n    return this.cache[key].value;\n  }\n\n  // O(1) time | O(1) space\n  getMostRecentKey() {\n    if (!this.listOfMostRecent.head) return;\n    return this.listOfMostRecent.head.key;\n  }\n\n  evictLeastRecent() {\n    const keyToRemove = this.listOfMostRecent.tail.key;\n    this.listOfMostRecent.removeTail();\n    delete this.cache[keyToRemove];\n  }\n\n  updateMostRecent(node) {\n    this.listOfMostRecent.setHeadTo(node);\n  }\n\n  replaceKey(key, value) {\n    if (!(key in this.cache)) {\n      throw new Error(\"The provided key isn't in the cache!\");\n    }\n    this.cache[key].value = value;\n  }\n}\n\nclass DoublyLinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  setHeadTo(node) {\n    if (this.head === node) {\n      return;\n    } else if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n    } else if (this.head === this.tail) {\n      this.tail.prev = node;\n      this.head = node;\n      this.head.next = this.tail;\n    } else {\n      if (this.tail === node) this.removeTail();\n      node.removeBindings();\n      this.head.prev = node;\n      node.next = this.head;\n      this.head = node;\n    }\n  }\n\n  removeTail() {\n    if (this.tail === null) return;\n    if (this.tail === this.head) {\n      this.head = null;\n      this.tail = null;\n      return;\n    }\n    this.tail = this.tail.prev;\n    this.tail.next = null;\n  }\n}\n\nclass DoublyLinkedListNode {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n\n  removeBindings() {\n    if (this.prev !== null) {\n      this.prev.next = this.next;\n    }\n    if (this.next !== null) {\n      this.next.prev = this.prev;\n    }\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nexports.LRUCache = LRUCache;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const lruCache = new program.LRUCache(3);\n  lruCache.insertKeyValuePair('b', 2);\n  lruCache.insertKeyValuePair('a', 1);\n  lruCache.insertKeyValuePair('c', 3);\n  chai.expect(lruCache.getMostRecentKey()).to.deep.equal('c');\n  chai.expect(lruCache.getValueFromKey('a')).to.deep.equal(1);\n  chai.expect(lruCache.getMostRecentKey()).to.deep.equal('a');\n  lruCache.insertKeyValuePair('d', 4);\n  chai.expect(lruCache.getValueFromKey('b')).to.deep.equal(null);\n  lruCache.insertKeyValuePair('a', 5);\n  chai.expect(lruCache.getValueFromKey('a')).to.deep.equal(5);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const lruCache = new program.LRUCache(3);\n  lruCache.insertKeyValuePair('b', 2);\n  lruCache.insertKeyValuePair('a', 1);\n  lruCache.insertKeyValuePair('c', 3);\n  chai.expect(lruCache.getMostRecentKey()).to.deep.equal('c');\n  chai.expect(lruCache.getValueFromKey('a')).to.deep.equal(1);\n  chai.expect(lruCache.getMostRecentKey()).to.deep.equal('a');\n  lruCache.insertKeyValuePair('d', 4);\n  chai.expect(lruCache.getValueFromKey('b')).to.deep.equal(null);\n  lruCache.insertKeyValuePair('a', 5);\n  chai.expect(lruCache.getValueFromKey('a')).to.deep.equal(5);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nclass LRUCache(maxSize: Int) {\n    fun insertKeyValuePair(key: String, value: Int) {\n        // Write your code here.\n    }\n\n    fun getValueFromKey(key: String): Int? {\n        // Write your code here.\n        return null\n    }\n\n    fun getMostRecentKey(): String? {\n        // Write your code here.\n        return null\n    }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nclass LRUCache(maxSize: Int) {\n    val maxSize = maxSize\n    var currentSize = 0\n    var cache: MutableMap<String, Node> = mutableMapOf()\n    var listOfMostRecent = DoublyLinkedList()\n\n    // O(1) time | O(1) space\n    fun insertKeyValuePair(key: String, value: Int) {\n        if (!cache.containsKey(key)) {\n            if (currentSize == maxSize) {\n                evictLeastRecent()\n            } else {\n                currentSize++\n            }\n            cache[key] = Node(key, value)\n        } else {\n            replaceKey(key, value)\n        }\n        updateMostRecent(cache[key]!!)\n    }\n\n    // O(1) time | O(1) space\n    fun getValueFromKey(key: String): Int? {\n        val node = cache[key]\n        if (node == null) return null\n        updateMostRecent(node)\n        return node.value\n    }\n\n    // O(1) time | O(1) space\n    fun getMostRecentKey(): String? {\n        val head = listOfMostRecent.getHead()\n        if (head == null) return null\n        return head.key\n    }\n\n    fun evictLeastRecent() {\n        val tail = listOfMostRecent.getTail()\n        if (tail == null) return\n        val keyToRemove = tail.key\n        listOfMostRecent.remove(tail)\n        cache.remove(keyToRemove)\n    }\n\n    fun updateMostRecent(node: Node) {\n        listOfMostRecent.setHead(node)\n    }\n\n    fun replaceKey(key: String, value: Int) {\n        val node = cache[key]\n        if (node == null) return\n        node.value = value\n    }\n}\n\nclass Node(key: String, value: Int) {\n    val key = key\n    var value = value\n    var prev: Node? = null\n    var next: Node? = null\n}\n\nclass DoublyLinkedList {\n    private var head: Node? = null\n    private var tail: Node? = null\n\n    fun setHead(node: Node) {\n        if (this.head == null) {\n            this.head = node\n            this.tail = node\n            return\n        }\n        this.insertBefore(this.head!!, node)\n    }\n\n    fun setTail(node: Node) {\n        if (this.tail == null) {\n            setHead(node)\n            return\n        }\n        insertAfter(this.tail!!, node)\n    }\n\n    fun insertBefore(node: Node, nodeToInsert: Node) {\n        if (nodeToInsert == this.head && nodeToInsert == this.tail) return\n        remove(nodeToInsert)\n        nodeToInsert.prev = node.prev\n        nodeToInsert.next = node\n        if (node.prev == null) {\n            this.head = nodeToInsert\n        } else {\n            node.prev!!.next = nodeToInsert\n        }\n        node.prev = nodeToInsert\n    }\n\n    fun insertAfter(node: Node, nodeToInsert: Node) {\n        if (nodeToInsert == this.head && nodeToInsert == tail) return\n        remove(nodeToInsert)\n        nodeToInsert.prev = node\n        nodeToInsert.next = node.next\n        if (node.next == null) {\n            this.tail = nodeToInsert\n        } else {\n            node.next!!.prev = nodeToInsert\n        }\n        node.next = nodeToInsert\n    }\n\n    fun remove(node: Node) {\n        if (node == this.head) this.head = node.next\n        if (node == this.tail) this.tail = node.prev\n        removeNodeBindings(node)\n    }\n\n    fun removeNodeBindings(node: Node) {\n        if (node.prev != null) node.prev!!.next = node.next\n        if (node.next != null) node.next!!.prev = node.prev\n        node.prev = null\n        node.next = null\n    }\n\n    fun getHead(): Node? { return this.head }\n\n    fun getTail(): Node? { return this.tail }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.LRUCache\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val lruCache = LRUCache(3)\n\n        lruCache.insertKeyValuePair(\"b\", 2)\n        lruCache.insertKeyValuePair(\"a\", 1)\n        lruCache.insertKeyValuePair(\"c\", 3)\n\n        assert(lruCache.getMostRecentKey() == \"c\")\n        assert(lruCache.getValueFromKey(\"a\") == 1)\n        assert(lruCache.getMostRecentKey() == \"a\")\n\n        lruCache.insertKeyValuePair(\"d\", 4)\n        val evictedValue = lruCache.getValueFromKey(\"b\")\n        assert(evictedValue == null)\n\n        lruCache.insertKeyValuePair(\"a\", 5)\n        assert(lruCache.getValueFromKey(\"a\") == 5)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.LRUCache\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val lruCache = LRUCache(3)\n\n        lruCache.insertKeyValuePair(\"b\", 2)\n        lruCache.insertKeyValuePair(\"a\", 1)\n        lruCache.insertKeyValuePair(\"c\", 3)\n\n        assert(lruCache.getMostRecentKey() == \"c\")\n        assert(lruCache.getValueFromKey(\"a\") == 1)\n        assert(lruCache.getMostRecentKey() == \"a\")\n\n        lruCache.insertKeyValuePair(\"d\", 4)\n        val evictedValue = lruCache.getValueFromKey(\"b\")\n        assert(evictedValue == null)\n\n        lruCache.insertKeyValuePair(\"a\", 5)\n        assert(lruCache.getValueFromKey(\"a\") == 5)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# Do not edit the class below except for the insertKeyValuePair,\n# getValueFromKey, and getMostRecentKey methods. Feel free\n# to add new properties and methods to the class.\nclass LRUCache:\n    def __init__(self, maxSize):\n        self.maxSize = maxSize or 1\n\n    def insertKeyValuePair(self, key, value):\n        # Write your code here.\n        pass\n\n    def getValueFromKey(self, key):\n        # Write your code here.\n        pass\n\n    def getMostRecentKey(self):\n        # Write your code here.\n        pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass LRUCache:\n    def __init__(self, maxSize):\n        self.cache = {}\n        self.maxSize = maxSize or 1\n        self.currentSize = 0\n        self.listOfMostRecent = DoublyLinkedList()\n\n    # O(1) time | O(1) space\n    def insertKeyValuePair(self, key, value):\n        if key not in self.cache:\n            if self.currentSize == self.maxSize:\n                self.evictLeastRecent()\n            else:\n                self.currentSize += 1\n            self.cache[key] = DoublyLinkedListNode(key, value)\n        else:\n            self.replaceKey(key, value)\n        self.updateMostRecent(self.cache[key])\n\n    # O(1) time | O(1) space\n    def getValueFromKey(self, key):\n        if key not in self.cache:\n            return None\n        self.updateMostRecent(self.cache[key])\n        return self.cache[key].value\n\n    # O(1) time | O(1) space\n    def getMostRecentKey(self):\n        if self.listOfMostRecent.head is None:\n            return None\n        return self.listOfMostRecent.head.key\n\n    def evictLeastRecent(self):\n        keyToRemove = self.listOfMostRecent.tail.key\n        self.listOfMostRecent.removeTail()\n        del self.cache[keyToRemove]\n\n    def updateMostRecent(self, node):\n        self.listOfMostRecent.setHeadTo(node)\n\n    def replaceKey(self, key, value):\n        if key not in self.cache:\n            raise Exception(\"The provided key isn't in the cache!\")\n        self.cache[key].value = value\n\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def setHeadTo(self, node):\n        if self.head == node:\n            return\n        elif self.head is None:\n            self.head = node\n            self.tail = node\n        elif self.head == self.tail:\n            self.tail.prev = node\n            self.head = node\n            self.head.next = self.tail\n        else:\n            if self.tail == node:\n                self.removeTail()\n            node.removeBindings()\n            self.head.prev = node\n            node.next = self.head\n            self.head = node\n\n    def removeTail(self):\n        if self.tail is None:\n            return\n        if self.tail == self.head:\n            self.head = None\n            self.tail = None\n            return\n        self.tail = self.tail.prev\n        self.tail.next = None\n\n\nclass DoublyLinkedListNode:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n    def removeBindings(self):\n        if self.prev is not None:\n            self.prev.next = self.next\n        if self.next is not None:\n            self.next.prev = self.prev\n        self.prev = None\n        self.next = None\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        lruCache = program.LRUCache(3)\n        lruCache.insertKeyValuePair(\"b\", 2)\n        lruCache.insertKeyValuePair(\"a\", 1)\n        lruCache.insertKeyValuePair(\"c\", 3)\n        self.assertEqual(lruCache.getMostRecentKey(), \"c\")\n        self.assertEqual(lruCache.getValueFromKey(\"a\"), 1)\n        self.assertEqual(lruCache.getMostRecentKey(), \"a\")\n        lruCache.insertKeyValuePair(\"d\", 4)\n        self.assertEqual(lruCache.getValueFromKey(\"b\"), None)\n        lruCache.insertKeyValuePair(\"a\", 5)\n        self.assertEqual(lruCache.getValueFromKey(\"a\"), 5)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        lruCache = program.LRUCache(3)\n        lruCache.insertKeyValuePair(\"b\", 2)\n        lruCache.insertKeyValuePair(\"a\", 1)\n        lruCache.insertKeyValuePair(\"c\", 3)\n        self.assertEqual(lruCache.getMostRecentKey(), \"c\")\n        self.assertEqual(lruCache.getValueFromKey(\"a\"), 1)\n        self.assertEqual(lruCache.getMostRecentKey(), \"a\")\n        lruCache.insertKeyValuePair(\"d\", 4)\n        self.assertEqual(lruCache.getValueFromKey(\"b\"), None)\n        lruCache.insertKeyValuePair(\"a\", 5)\n        self.assertEqual(lruCache.getValueFromKey(\"a\"), 5)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def lruCache(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def lruCache(n)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.lruCache\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.lruCache\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  class LRUCache {\n    var maxSize: Int\n\n    init(maxSize: Int) {\n      self.maxSize = maxSize\n      // Write your code here.\n    }\n\n    func insertKeyValuePair(_ key: String, _ value: Int) {\n      // Write your code here.\n    }\n\n    func getValueFromKey(_ key: String) -> Int? {\n      // Write your code here.\n      return nil\n    }\n\n    func getMostRecentKey() -> String? {\n      // Write your code here.\n      return nil\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class LRUCache {\n    var maxSize: Int\n    var currentSize = 0\n    var cache = [String: DoublyLinkedListNode]()\n    var listOfMostRecent = DoublyLinkedList()\n\n    init(maxSize: Int) {\n      self.maxSize = maxSize\n    }\n\n    // O(1) time | O(1) space\n    func insertKeyValuePair(_ key: String, _ value: Int) {\n      if !cache.keys.contains(key) {\n        if currentSize == maxSize {\n          evictLeastRecent()\n        } else {\n          currentSize += 1\n        }\n\n        cache[key] = DoublyLinkedListNode(key, value)\n      } else if let existingNode = cache[key] {\n        existingNode.value = value\n      }\n\n      if let node = cache[key] {\n        updateMostRecent(node)\n      }\n    }\n\n    func evictLeastRecent() {\n      if let key = listOfMostRecent.tail?.key {\n        listOfMostRecent.removeTail()\n        cache[key] = nil\n      }\n    }\n\n    func updateMostRecent(_ node: DoublyLinkedListNode) {\n      listOfMostRecent.setHeadTo(node)\n    }\n\n    // O(1) time | O(1) space\n    func getValueFromKey(_ key: String) -> Int? {\n      if let existingNode = cache[key] {\n        updateMostRecent(existingNode)\n        return existingNode.value\n      } else {\n        return nil\n      }\n    }\n\n    // O(1) time | O(1) space\n    func getMostRecentKey() -> String? {\n      if listOfMostRecent.head === nil {\n        return nil\n      }\n      return listOfMostRecent.head?.key\n    }\n  }\n\n  class DoublyLinkedListNode {\n    let key: String\n    var value: Int\n    var previous: DoublyLinkedListNode?\n    var next: DoublyLinkedListNode?\n\n    init(_ key: String, _ value: Int) {\n      self.key = key\n      self.value = value\n      previous = nil\n      next = nil\n    }\n\n    func removeBindings() {\n      if let previous = previous {\n        previous.next = next\n      }\n\n      if let next = next {\n        next.previous = previous\n      }\n\n      previous = nil\n      next = nil\n    }\n  }\n\n  class DoublyLinkedList {\n    var head: DoublyLinkedListNode?\n    var tail: DoublyLinkedListNode?\n\n    init() {\n      head = nil\n      tail = nil\n    }\n\n    func setHeadTo(_ node: DoublyLinkedListNode) {\n      if head === node {\n        return\n      } else if head === nil {\n        head = node\n        tail = node\n      } else if head === tail {\n        tail?.previous = node\n        head = node\n        head?.next = tail\n      } else {\n        if tail === node {\n          removeTail()\n        }\n\n        node.removeBindings()\n        head?.previous = node\n        node.next = head\n        head = node\n      }\n    }\n\n    func removeTail() {\n      if tail === nil {\n        return\n      }\n\n      if head === tail {\n        head = nil\n        tail = nil\n        return\n      }\n\n      tail = tail?.previous\n      tail?.next = nil\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  let program = Program()\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      let lruCache = Program.LRUCache(maxSize: 3)\n      lruCache.insertKeyValuePair(\"b\", 2)\n      lruCache.insertKeyValuePair(\"a\", 1)\n      lruCache.insertKeyValuePair(\"c\", 3)\n      try assertEqual(\"c\", lruCache.getMostRecentKey())\n      try assertEqual(1, lruCache.getValueFromKey(\"a\"))\n      try assertEqual(\"a\", lruCache.getMostRecentKey())\n      lruCache.insertKeyValuePair(\"d\", 4)\n      try assertEqual(nil, lruCache.getValueFromKey(\"b\"))\n      lruCache.insertKeyValuePair(\"a\", 5)\n      try assertEqual(5, lruCache.getValueFromKey(\"a\"))\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  let program = Program()\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      let lruCache = Program.LRUCache(maxSize: 3)\n      lruCache.insertKeyValuePair(\"b\", 2)\n      lruCache.insertKeyValuePair(\"a\", 1)\n      lruCache.insertKeyValuePair(\"c\", 3)\n      try assertEqual(\"c\", lruCache.getMostRecentKey())\n      try assertEqual(1, lruCache.getValueFromKey(\"a\"))\n      try assertEqual(\"a\", lruCache.getMostRecentKey())\n      lruCache.insertKeyValuePair(\"d\", 4)\n      try assertEqual(nil, lruCache.getValueFromKey(\"b\"))\n      lruCache.insertKeyValuePair(\"a\", 5)\n      try assertEqual(5, lruCache.getValueFromKey(\"a\"))\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// Do not edit the class below except for the insertKeyValuePair,\n// getValueFromKey, and getMostRecentKey methods. Feel free\n// to add new properties and methods to the class.\nexport class LRUCache {\n  maxSize: number;\n\n  constructor(maxSize: number) {\n    this.maxSize = maxSize || 1;\n  }\n\n  insertKeyValuePair(key: string, value: number) {\n    // Write your code here.\n  }\n\n  getValueFromKey(key: string) {\n    // Write your code here.\n  }\n\n  getMostRecentKey() {\n    // Write your code here.\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nexport class LRUCache {\n  cache: {[key: string]: DoublyLinkedListNode};\n  maxSize: number;\n  currentSize: number;\n  listOfMostRecent: DoublyLinkedList;\n\n  constructor(maxSize: number) {\n    this.cache = {};\n    this.maxSize = maxSize || 1;\n    this.currentSize = 0;\n    this.listOfMostRecent = new DoublyLinkedList();\n  }\n\n  // O(1) time | O(1) space\n  insertKeyValuePair(key: string, value: number) {\n    if (!(key in this.cache)) {\n      if (this.currentSize === this.maxSize) {\n        this.evictLeastRecent();\n      } else {\n        this.currentSize++;\n      }\n      this.cache[key] = new DoublyLinkedListNode(key, value);\n    } else {\n      this.replaceKey(key, value);\n    }\n    this.updateMostRecent(this.cache[key]);\n  }\n\n  // O(1) time | O(1) space\n  getValueFromKey(key: string) {\n    if (!(key in this.cache)) return null;\n    this.updateMostRecent(this.cache[key]);\n    return this.cache[key].value;\n  }\n\n  // O(1) time | O(1) space\n  getMostRecentKey() {\n    if (!this.listOfMostRecent.head) return null;\n    return this.listOfMostRecent.head.key;\n  }\n\n  evictLeastRecent() {\n    const keyToRemove = this.listOfMostRecent.tail!.key;\n    this.listOfMostRecent.removeTail();\n    delete this.cache[keyToRemove];\n  }\n\n  updateMostRecent(node: DoublyLinkedListNode) {\n    this.listOfMostRecent.setHeadTo(node);\n  }\n\n  replaceKey(key: string, value: number) {\n    if (!(key in this.cache)) {\n      throw new Error(\"The provided key isn't in the cache!\");\n    }\n    this.cache[key].value = value;\n  }\n}\n\nclass DoublyLinkedList {\n  head: DoublyLinkedListNode | null;\n  tail: DoublyLinkedListNode | null;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  setHeadTo(node: DoublyLinkedListNode) {\n    if (this.head === node) {\n      return;\n    } else if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n    } else if (this.head === this.tail) {\n      this.tail.prev = node;\n      this.head = node;\n      this.head.next = this.tail;\n    } else {\n      if (this.tail === node) this.removeTail();\n      node.removeBindings();\n      this.head.prev = node;\n      node.next = this.head;\n      this.head = node;\n    }\n  }\n\n  removeTail() {\n    if (this.tail === null) return;\n    if (this.tail === this.head) {\n      this.head = null;\n      this.tail = null;\n      return;\n    }\n    this.tail = this.tail.prev!;\n    this.tail.next = null;\n  }\n}\n\nclass DoublyLinkedListNode {\n  key: string;\n  value: number;\n  prev: DoublyLinkedListNode | null;\n  next: DoublyLinkedListNode | null;\n\n  constructor(key: string, value: number) {\n    this.key = key;\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n\n  removeBindings() {\n    if (this.prev !== null) {\n      this.prev.next = this.next;\n    }\n    if (this.next !== null) {\n      this.next.prev = this.prev;\n    }\n    this.prev = null;\n    this.next = null;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const lruCache = new program.LRUCache(3);\n  lruCache.insertKeyValuePair('b', 2);\n  lruCache.insertKeyValuePair('a', 1);\n  lruCache.insertKeyValuePair('c', 3);\n  chai.expect(lruCache.getMostRecentKey()).to.deep.equal('c');\n  chai.expect(lruCache.getValueFromKey('a')).to.deep.equal(1);\n  chai.expect(lruCache.getMostRecentKey()).to.deep.equal('a');\n  lruCache.insertKeyValuePair('d', 4);\n  chai.expect(lruCache.getValueFromKey('b')).to.deep.equal(null);\n  lruCache.insertKeyValuePair('a', 5);\n  chai.expect(lruCache.getValueFromKey('a')).to.deep.equal(5);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const lruCache = new program.LRUCache(3);\n  lruCache.insertKeyValuePair('b', 2);\n  lruCache.insertKeyValuePair('a', 1);\n  lruCache.insertKeyValuePair('c', 3);\n  chai.expect(lruCache.getMostRecentKey()).to.deep.equal('c');\n  chai.expect(lruCache.getValueFromKey('a')).to.deep.equal(1);\n  chai.expect(lruCache.getMostRecentKey()).to.deep.equal('a');\n  lruCache.insertKeyValuePair('d', 4);\n  chai.expect(lruCache.getValueFromKey('b')).to.deep.equal(null);\n  lruCache.insertKeyValuePair('a', 5);\n  chai.expect(lruCache.getValueFromKey('a')).to.deep.equal(5);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "maxSize",
      "example": 3,
      "schema": {
        "minimum": 0,
        "type": "integer"
      }
    },
    {
      "name": "classMethodsToCall",
      "example": [
        {
          "arguments": [
            "b",
            2
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a",
            1
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "c",
            3
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "d",
            4
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "a",
            5
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        }
      ],
      "schema": {
        "description": "These methods will be called in the order that they appear in below\non an <span>LRUCache</span> of size <span>maxSize</span> and with their respective arguments.\n",
        "items": {
          "properties": {
            "arguments": {
              "maxItems": 2,
              "type": "array"
            },
            "method": {
              "enum": [
                "getMostRecentKey",
                "getValueFromKey",
                "insertKeyValuePair"
              ],
              "type": "string"
            }
          },
          "required": [
            "method",
            "arguments"
          ],
          "type": "object"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "b",
            2
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a",
            1
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "c",
            3
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "d",
            4
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "a",
            5
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        }
      ],
      "maxSize": 3
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "a",
            1
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "a",
            9001
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "b",
            2
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "c",
            3
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "c"
          ],
          "method": "getValueFromKey"
        }
      ],
      "maxSize": 1
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "a",
            1
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "b",
            2
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "c",
            3
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "d",
            4
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "c"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "d"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "e",
            5
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "c"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "d"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "e"
          ],
          "method": "getValueFromKey"
        }
      ],
      "maxSize": 4
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "a",
            1
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "b",
            2
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "c",
            3
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "d",
            4
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "c"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "d"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "e",
            5
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        }
      ],
      "maxSize": 4
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "a",
            1
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "b",
            2
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "c",
            3
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "d",
            4
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "e",
            5
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "c"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "f",
            5
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "c"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "d"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "g",
            5
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "e"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "c"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "f"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "g"
          ],
          "method": "getValueFromKey"
        }
      ],
      "maxSize": 4
    }
  ],
  "jsonTests": [
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "b",
            2
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a",
            1
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "c",
            3
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "d",
            4
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "a",
            5
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        }
      ],
      "maxSize": 3
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "a",
            1
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "a",
            9001
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "b",
            2
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "c",
            3
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "c"
          ],
          "method": "getValueFromKey"
        }
      ],
      "maxSize": 1
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "a",
            1
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "b",
            2
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "c",
            3
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "d",
            4
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "c"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "d"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "e",
            5
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "c"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "d"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "e"
          ],
          "method": "getValueFromKey"
        }
      ],
      "maxSize": 4
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "a",
            1
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "b",
            2
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "c",
            3
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "d",
            4
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "c"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "d"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        },
        {
          "arguments": [
            "e",
            5
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [],
          "method": "getMostRecentKey"
        }
      ],
      "maxSize": 4
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "a",
            1
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "b",
            2
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "c",
            3
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "d",
            4
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "e",
            5
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "b"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "c"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "f",
            5
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "c"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "d"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "g",
            5
          ],
          "method": "insertKeyValuePair"
        },
        {
          "arguments": [
            "e"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "a"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "c"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "f"
          ],
          "method": "getValueFromKey"
        },
        {
          "arguments": [
            "g"
          ],
          "method": "getValueFromKey"
        }
      ],
      "maxSize": 4
    }
  ],
  "changelog": []
}