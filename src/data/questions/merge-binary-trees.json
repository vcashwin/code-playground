{
  "uid": "merge-binary-trees",
  "testStrategy": "JSON",
  "name": "Merge Binary Trees",
  "version": 0,
  "releaseDate": "2022-12-15T00:00:00Z",
  "category": "Binary Trees",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 4921,
    "failureCount": 358
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "762487112",
    "duration": 0,
    "annotations": [],
    "instructor": "Conner Ardman",
    "overviewTime": 0,
    "codeWalkthroughTime": 936
  },
  "prompt": "<div class=\"html\">\n  <p>\n    Write a function that takes in two Binary Trees, merges them, and returns\n    the resulting tree. If two nodes overlap during the merge, the value of the\n    merged node should be the sum of the overlapping nodes' values.\n  </p>\n  <p>\n    Note that your solution can either mutate the input trees or return a new\n    tree.\n  </p>\n  <p>\n    Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n    <span>left</span> child node, and a <span>right</span> child node. Children\n    nodes can either be <span>BinaryTree</span> nodes themselves or\n    <span>None</span> / <span>null</span>.\n  </p>\n  <h3>Sample Input</h3>\n  <pre>\n<span class=\"CodeEditor-promptParameter\">tree1</span> =   1\n        /   \\\n       3     2\n     /   \\\n    7     4\n\n<span class=\"CodeEditor-promptParameter\">tree2</span> =   1\n        /   \\\n       5     9\n     /      / \\\n    2      7   6\n</pre>\n  <h3>Sample Output</h3>\n  <pre>\n<span class=\"CodeEditor-promptParameter\">output</span> =  2\n        /   \\\n      8      11\n    /  \\    /  \\\n  9     4  7    6\n</pre>\n</div>",
  "hints": [
    "<p>\nIf the function takes two tree nodes as parameters then what should be returned if either of the two nodes is null?\nRemember, if two nodes overlap during the merger then sum the values, otherwise use the existing node. How can you sum\nthe tree node values when they overlap?\n</p>\n",
    "\n<p>\nIf two tree nodes overlap then sum the values into either one of the nodes. This node will be returned from the function.\nRecursively call the function twice passing in both trees' left nodes as well as their right nodes.\n</p>\n",
    "\n<p>\nThe iterative approach to this problem uses a stack in replacement of the recusions stack space. What would you push onto\nthe stack in order to traverse and merge the binary trees?\n</p>\n",
    "\n<p>\nYou can either use a single stack and push associated pairs of nodes on the stack,\nor you can maintain a stack for each tree.\n</p>"
  ],
  "spaceTime": "O(n) time | O(h) space - where n is the number of nodes in the smaller of the two trees and h is the height of the shorter tree.",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left = nullptr;\n  BinaryTree* right = nullptr;\n\n  BinaryTree(int value) { this->value = value; }\n};\n\nBinaryTree* mergeBinaryTrees(BinaryTree* tree1, BinaryTree* tree2) {\n  // Write your code here.\n  return nullptr;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left = nullptr;\n  BinaryTree* right = nullptr;\n\n  BinaryTree(int value) { this->value = value; }\n};\n\n// O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n// two trees and h is the height of the shorter tree.\nBinaryTree* mergeBinaryTrees(BinaryTree* tree1, BinaryTree* tree2) {\n  if (tree1 == nullptr) return tree2;\n  if (tree2 == nullptr) return tree1;\n  tree1->value += tree2->value;\n  tree1->left = mergeBinaryTrees(tree1->left, tree2->left);\n  tree1->right = mergeBinaryTrees(tree1->right, tree2->right);\n  return tree1;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <stack>\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left = nullptr;\n  BinaryTree* right = nullptr;\n\n  BinaryTree(int value) { this->value = value; }\n};\n\n// O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n// two trees and h is the height of the shorter tree.\nBinaryTree* mergeBinaryTrees(BinaryTree* tree1, BinaryTree* tree2) {\n  if (tree1 == nullptr) {\n    return tree2;\n  }\n\n  stack<BinaryTree*> tree1Stack;\n  tree1Stack.push(tree1);\n  stack<BinaryTree*> tree2Stack;\n  tree2Stack.push(tree2);\n\n  while (!tree1Stack.empty()) {\n    BinaryTree* tree1Node = tree1Stack.top();\n    tree1Stack.pop();\n    BinaryTree* tree2Node = tree2Stack.top();\n    tree2Stack.pop();\n\n    if (tree2Node == nullptr) {\n      continue;\n    }\n\n    tree1Node->value += tree2Node->value;\n\n    if (tree1Node->left == nullptr) {\n      tree1Node->left = tree2Node->left;\n    } else {\n      tree1Stack.push(tree1Node->left);\n      tree2Stack.push(tree2Node->left);\n    }\n\n    if (tree1Node->right == nullptr) {\n      tree1Node->right = tree2Node->right;\n    } else {\n      tree1Stack.push(tree1Node->right);\n      tree2Stack.push(tree2Node->right);\n    }\n  }\n\n  return tree1;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree* tree1 = new BinaryTree(1);\n      tree1->left = new BinaryTree(3);\n      tree1->left->left = new BinaryTree(7);\n      tree1->left->right = new BinaryTree(4);\n      tree1->right = new BinaryTree(2);\n\n      BinaryTree* tree2 = new BinaryTree(1);\n      tree2->left = new BinaryTree(5);\n      tree2->left->left = new BinaryTree(2);\n      tree2->right = new BinaryTree(9);\n      tree2->right->left = new BinaryTree(7);\n      tree2->right->right = new BinaryTree(6);\n\n      auto actual = mergeBinaryTrees(tree1, tree2);\n      assert(actual->value == 2);\n      assert(actual->left->value == 8);\n      assert(actual->left->left->value == 9);\n      assert(actual->left->right->value == 4);\n      assert(actual->right->value == 11);\n      assert(actual->right->left->value == 7);\n      assert(actual->right->right->value == 6);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree* tree1 = new BinaryTree(1);\n      tree1->left = new BinaryTree(3);\n      tree1->left->left = new BinaryTree(7);\n      tree1->left->right = new BinaryTree(4);\n      tree1->right = new BinaryTree(2);\n\n      BinaryTree* tree2 = new BinaryTree(1);\n      tree2->left = new BinaryTree(5);\n      tree2->left->left = new BinaryTree(2);\n      tree2->right = new BinaryTree(9);\n      tree2->right->left = new BinaryTree(7);\n      tree2->right->right = new BinaryTree(6);\n\n      auto actual = mergeBinaryTrees(tree1, tree2);\n      assert(actual->value == 2);\n      assert(actual->left->value == 8);\n      assert(actual->left->left->value == 9);\n      assert(actual->left->right->value == 4);\n      assert(actual->right->value == 11);\n      assert(actual->right->left->value == 7);\n      assert(actual->right->right->value == 6);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  public BinaryTree MergeBinaryTrees(BinaryTree tree1, BinaryTree tree2) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the smaller of\n  // the two trees and h is the height of the shorter tree.\n  public BinaryTree MergeBinaryTrees(BinaryTree tree1, BinaryTree tree2) {\n    if (tree1 == null) return tree2;\n    if (tree2 == null) return tree1;\n    tree1.value += tree2.value;\n    tree1.left = MergeBinaryTrees(tree1.left, tree2.left);\n    tree1.right = MergeBinaryTrees(tree1.right, tree2.right);\n    return tree1;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the smaller of\n  // the two trees and h is the height of the shorter tree.\n  public BinaryTree MergeBinaryTrees(BinaryTree tree1, BinaryTree tree2) {\n    if (tree1 == null) {\n      return tree2;\n    }\n\n    Stack<BinaryTree> tree1Stack = new Stack<BinaryTree>();\n    tree1Stack.Push(tree1);\n    Stack<BinaryTree> tree2Stack = new Stack<BinaryTree>();\n    tree2Stack.Push(tree2);\n\n    while (tree1Stack.Count != 0) {\n      BinaryTree tree1Node = tree1Stack.Pop();\n      BinaryTree tree2Node = tree2Stack.Pop();\n\n      if (tree2Node == null) {\n        continue;\n      }\n\n      tree1Node.value += tree2Node.value;\n\n      if (tree1Node.left == null) {\n        tree1Node.left = tree2Node.left;\n      } else {\n        tree1Stack.Push(tree1Node.left);\n        tree2Stack.Push(tree2Node.left);\n      }\n\n      if (tree1Node.right == null) {\n        tree1Node.right = tree2Node.right;\n      } else {\n        tree1Stack.Push(tree1Node.right);\n        tree2Stack.Push(tree2Node.right);\n      }\n    }\n\n    return tree1;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.BinaryTree tree1 = new Program.BinaryTree(1);\n    tree1.left = new Program.BinaryTree(3);\n    tree1.left.left = new Program.BinaryTree(7);\n    tree1.left.right = new Program.BinaryTree(4);\n    tree1.right = new Program.BinaryTree(2);\n\n    Program.BinaryTree tree2 = new Program.BinaryTree(1);\n    tree2.left = new Program.BinaryTree(5);\n    tree2.left.left = new Program.BinaryTree(2);\n    tree2.right = new Program.BinaryTree(9);\n    tree2.right.left = new Program.BinaryTree(7);\n    tree2.right.right = new Program.BinaryTree(6);\n\n    Program.BinaryTree expected = new Program.BinaryTree(2);\n    expected.left = new Program.BinaryTree(8);\n    expected.left.left = new Program.BinaryTree(9);\n    expected.left.right = new Program.BinaryTree(4);\n    expected.right = new Program.BinaryTree(11);\n    expected.right.left = new Program.BinaryTree(7);\n    expected.right.right = new Program.BinaryTree(6);\n\n    Program.BinaryTree actual = new Program().MergeBinaryTrees(tree1, tree2);\n\n    Utils.AssertTrue(areTreesEqual(expected, actual));\n  }\n\n  public bool areTreesEqual(\n    Program.BinaryTree tree1, Program.BinaryTree tree2\n  ) {\n    if (tree1 == null && tree2 == null) return true;\n\n    if (tree1 == null && tree2 != null) {\n      return false;\n    } else if (tree1 != null && tree2 == null) {\n      return false;\n    }\n\n    if (tree1.value != tree2.value) return false;\n    return areTreesEqual(tree1.left, tree2.left) &&\n           areTreesEqual(tree1.right, tree2.right);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.BinaryTree tree1 = new Program.BinaryTree(1);\n    tree1.left = new Program.BinaryTree(3);\n    tree1.left.left = new Program.BinaryTree(7);\n    tree1.left.right = new Program.BinaryTree(4);\n    tree1.right = new Program.BinaryTree(2);\n\n    Program.BinaryTree tree2 = new Program.BinaryTree(1);\n    tree2.left = new Program.BinaryTree(5);\n    tree2.left.left = new Program.BinaryTree(2);\n    tree2.right = new Program.BinaryTree(9);\n    tree2.right.left = new Program.BinaryTree(7);\n    tree2.right.right = new Program.BinaryTree(6);\n\n    Program.BinaryTree expected = new Program.BinaryTree(2);\n    expected.left = new Program.BinaryTree(8);\n    expected.left.left = new Program.BinaryTree(9);\n    expected.left.right = new Program.BinaryTree(4);\n    expected.right = new Program.BinaryTree(11);\n    expected.right.left = new Program.BinaryTree(7);\n    expected.right.right = new Program.BinaryTree(6);\n\n    Program.BinaryTree actual = new Program().MergeBinaryTrees(tree1, tree2);\n\n    Utils.AssertTrue(areTreesEqual(expected, actual));\n  }\n\n  public bool areTreesEqual(\n    Program.BinaryTree tree1, Program.BinaryTree tree2\n  ) {\n    if (tree1 == null && tree2 == null) return true;\n\n    if (tree1 == null && tree2 != null) {\n      return false;\n    } else if (tree1 != null && tree2 == null) {\n      return false;\n    }\n\n    if (tree1.value != tree2.value) return false;\n    return areTreesEqual(tree1.left, tree2.left) &&\n           areTreesEqual(tree1.right, tree2.right);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\nfunc MergeBinaryTrees(tree1 *BinaryTree, tree2 *BinaryTree) *BinaryTree {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n// two trees and h is the height of the shorter tree.\nfunc MergeBinaryTrees(tree1 *BinaryTree, tree2 *BinaryTree) *BinaryTree {\n\tif tree1 == nil {\n\t\treturn tree2\n\t}\n\tif tree2 == nil {\n\t\treturn tree1\n\t}\n\n\ttree1.Value += tree2.Value\n\ttree1.Left = MergeBinaryTrees(tree1.Left, tree2.Left)\n\ttree1.Right = MergeBinaryTrees(tree1.Right, tree2.Right)\n\treturn tree1\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n// two trees and h is the height of the shorter tree.\nfunc MergeBinaryTrees(tree1 *BinaryTree, tree2 *BinaryTree) *BinaryTree {\n\tif tree1 == nil {\n\t\treturn tree2\n\t}\n\n\ttree1Stack := []*BinaryTree{tree1}\n\ttree2Stack := []*BinaryTree{tree2}\n\n\tfor len(tree1Stack) > 0 {\n\t\tvar tree1Node, tree2Node *BinaryTree\n\t\ttree1Node, tree1Stack = tree1Stack[len(tree1Stack)-1], tree1Stack[:len(tree1Stack)-1]\n\t\ttree2Node, tree2Stack = tree2Stack[len(tree2Stack)-1], tree2Stack[:len(tree2Stack)-1]\n\n\t\tif tree2Node == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\ttree1Node.Value += tree2Node.Value\n\n\t\tif tree1Node.Left == nil {\n\t\t\ttree1Node.Left = tree2Node.Left\n\t\t} else {\n\t\t\ttree1Stack = append(tree1Stack, tree1Node.Left)\n\t\t\ttree2Stack = append(tree2Stack, tree2Node.Left)\n\t\t}\n\n\t\tif tree1Node.Right == nil {\n\t\t\ttree1Node.Right = tree2Node.Right\n\t\t} else {\n\t\t\ttree1Stack = append(tree1Stack, tree1Node.Right)\n\t\t\ttree2Stack = append(tree2Stack, tree2Node.Right)\n\t\t}\n\t}\n\n\treturn tree1\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\ttree1 := &BinaryTree{Value: 1}\n\ttree1.Left = &BinaryTree{Value: 3}\n\ttree1.Left.Left = &BinaryTree{Value: 7}\n\ttree1.Left.Right = &BinaryTree{Value: 4}\n\ttree1.Right = &BinaryTree{Value: 2}\n\n\ttree2 := &BinaryTree{Value: 1}\n\ttree2.Left = &BinaryTree{Value: 5}\n\ttree2.Left.Left = &BinaryTree{Value: 2}\n\ttree2.Right = &BinaryTree{Value: 9}\n\ttree2.Right.Left = &BinaryTree{Value: 7}\n\ttree2.Right.Right = &BinaryTree{Value: 6}\n\n\texpected := &BinaryTree{Value: 2}\n\texpected.Left = &BinaryTree{Value: 8}\n\texpected.Left.Left = &BinaryTree{Value: 9}\n\texpected.Left.Right = &BinaryTree{Value: 4}\n\texpected.Right = &BinaryTree{Value: 11}\n\texpected.Right.Left = &BinaryTree{Value: 7}\n\texpected.Right.Right = &BinaryTree{Value: 6}\n\n\tactual := MergeBinaryTrees(tree1, tree2)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\ttree1 := &BinaryTree{Value: 1}\n\ttree1.Left = &BinaryTree{Value: 3}\n\ttree1.Left.Left = &BinaryTree{Value: 7}\n\ttree1.Left.Right = &BinaryTree{Value: 4}\n\ttree1.Right = &BinaryTree{Value: 2}\n\n\ttree2 := &BinaryTree{Value: 1}\n\ttree2.Left = &BinaryTree{Value: 5}\n\ttree2.Left.Left = &BinaryTree{Value: 2}\n\ttree2.Right = &BinaryTree{Value: 9}\n\ttree2.Right.Left = &BinaryTree{Value: 7}\n\ttree2.Right.Right = &BinaryTree{Value: 6}\n\n\texpected := &BinaryTree{Value: 2}\n\texpected.Left = &BinaryTree{Value: 8}\n\texpected.Left.Left = &BinaryTree{Value: 9}\n\texpected.Left.Right = &BinaryTree{Value: 4}\n\texpected.Right = &BinaryTree{Value: 11}\n\texpected.Right.Left = &BinaryTree{Value: 7}\n\texpected.Right.Right = &BinaryTree{Value: 6}\n\n\tactual := MergeBinaryTrees(tree1, tree2)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  public BinaryTree mergeBinaryTrees(BinaryTree tree1, BinaryTree tree2) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the smaller of\n  // the two trees and h is the height of the shorter tree.\n  public BinaryTree mergeBinaryTrees(BinaryTree tree1, BinaryTree tree2) {\n    if (tree1 == null) return tree2;\n    if (tree2 == null) return tree1;\n    tree1.value += tree2.value;\n    tree1.left = mergeBinaryTrees(tree1.left, tree2.left);\n    tree1.right = mergeBinaryTrees(tree1.right, tree2.right);\n    return tree1;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the smaller of\n  // the two trees and h is the height of the shorter tree.\n  public BinaryTree mergeBinaryTrees(BinaryTree tree1, BinaryTree tree2) {\n    if (tree1 == null) {\n      return tree2;\n    }\n\n    Stack<BinaryTree> tree1Stack = new Stack<BinaryTree>();\n    tree1Stack.push(tree1);\n    Stack<BinaryTree> tree2Stack = new Stack<BinaryTree>();\n    tree2Stack.push(tree2);\n\n    while (!tree1Stack.isEmpty()) {\n      BinaryTree tree1Node = tree1Stack.pop();\n      BinaryTree tree2Node = tree2Stack.pop();\n\n      if (tree2Node == null) {\n        continue;\n      }\n\n      tree1Node.value += tree2Node.value;\n\n      if (tree1Node.left == null) {\n        tree1Node.left = tree2Node.left;\n      } else {\n        tree1Stack.push(tree1Node.left);\n        tree2Stack.push(tree2Node.left);\n      }\n\n      if (tree1Node.right == null) {\n        tree1Node.right = tree2Node.right;\n      } else {\n        tree1Stack.push(tree1Node.right);\n        tree2Stack.push(tree2Node.right);\n      }\n    }\n\n    return tree1;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.BinaryTree tree1 = new Program.BinaryTree(1);\n    tree1.left = new Program.BinaryTree(3);\n    tree1.left.left = new Program.BinaryTree(7);\n    tree1.left.right = new Program.BinaryTree(4);\n    tree1.right = new Program.BinaryTree(2);\n\n    Program.BinaryTree tree2 = new Program.BinaryTree(1);\n    tree2.left = new Program.BinaryTree(5);\n    tree2.left.left = new Program.BinaryTree(2);\n    tree2.right = new Program.BinaryTree(9);\n    tree2.right.left = new Program.BinaryTree(7);\n    tree2.right.right = new Program.BinaryTree(6);\n\n    Program.BinaryTree actual = new Program().mergeBinaryTrees(tree1, tree2);\n\n    Utils.assertTrue(actual.value == 2);\n    Utils.assertTrue(actual.left.value == 8);\n    Utils.assertTrue(actual.left.left.value == 9);\n    Utils.assertTrue(actual.left.right.value == 4);\n    Utils.assertTrue(actual.right.value == 11);\n    Utils.assertTrue(actual.right.left.value == 7);\n    Utils.assertTrue(actual.right.right.value == 6);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.BinaryTree tree1 = new Program.BinaryTree(1);\n    tree1.left = new Program.BinaryTree(3);\n    tree1.left.left = new Program.BinaryTree(7);\n    tree1.left.right = new Program.BinaryTree(4);\n    tree1.right = new Program.BinaryTree(2);\n\n    Program.BinaryTree tree2 = new Program.BinaryTree(1);\n    tree2.left = new Program.BinaryTree(5);\n    tree2.left.left = new Program.BinaryTree(2);\n    tree2.right = new Program.BinaryTree(9);\n    tree2.right.left = new Program.BinaryTree(7);\n    tree2.right.right = new Program.BinaryTree(6);\n\n    Program.BinaryTree actual = new Program().mergeBinaryTrees(tree1, tree2);\n\n    Utils.assertTrue(actual.value == 2);\n    Utils.assertTrue(actual.left.value == 8);\n    Utils.assertTrue(actual.left.left.value == 9);\n    Utils.assertTrue(actual.left.right.value == 4);\n    Utils.assertTrue(actual.right.value == 11);\n    Utils.assertTrue(actual.right.left.value == 7);\n    Utils.assertTrue(actual.right.right.value == 6);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.BinaryTree = BinaryTree;\n\nfunction mergeBinaryTrees(tree1, tree2) {\n  // Write your code here.\n  return null;\n}\n\n// Do not edit the line below.\nexports.mergeBinaryTrees = mergeBinaryTrees;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n// two trees and h is the height of the shorter tree.\nfunction mergeBinaryTrees(tree1, tree2) {\n  if (tree1 === null) return tree2;\n  if (tree2 === null) return tree1;\n\n  tree1.value += tree2.value;\n  tree1.left = mergeBinaryTrees(tree1.left, tree2.left);\n  tree1.right = mergeBinaryTrees(tree1.right, tree2.right);\n  return tree1;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.mergeBinaryTrees = mergeBinaryTrees;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n// two trees and h is the height of the shorter tree.\nfunction mergeBinaryTrees(tree1, tree2) {\n  if (tree1 === null) return tree2;\n\n  const tree1Stack = [tree1];\n  const tree2Stack = [tree2];\n\n  while (tree1Stack.length > 0) {\n    const tree1Node = tree1Stack.pop();\n    const tree2Node = tree2Stack.pop();\n\n    if (tree2Node === null) continue;\n\n    tree1Node.value += tree2Node.value;\n\n    if (tree1Node.left === null) {\n      tree1Node.left = tree2Node.left;\n    } else {\n      tree1Stack.push(tree1Node.left);\n      tree2Stack.push(tree2Node.left);\n    }\n\n    if (tree1Node.right === null) {\n      tree1Node.right = tree2Node.right;\n    } else {\n      tree1Stack.push(tree1Node.right);\n      tree2Stack.push(tree2Node.right);\n    }\n  }\n\n  return tree1;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.mergeBinaryTrees = mergeBinaryTrees;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree1 = new program.BinaryTree(1);\n  tree1.left = new program.BinaryTree(3);\n  tree1.left.left = new program.BinaryTree(7);\n  tree1.left.right = new program.BinaryTree(4);\n  tree1.right = new program.BinaryTree(2);\n\n  const tree2 = new program.BinaryTree(1);\n  tree2.left = new program.BinaryTree(5);\n  tree2.left.left = new program.BinaryTree(2);\n  tree2.right = new program.BinaryTree(9);\n  tree2.right.left = new program.BinaryTree(7);\n  tree2.right.right = new program.BinaryTree(6);\n\n  const actual = program.mergeBinaryTrees(tree1, tree2);\n  chai.expect(actual.value).to.deep.equal(2);\n  chai.expect(actual.left.value).to.deep.equal(8);\n  chai.expect(actual.left.left.value).to.deep.equal(9);\n  chai.expect(actual.left.right.value).to.deep.equal(4);\n  chai.expect(actual.right.value).to.deep.equal(11);\n  chai.expect(actual.right.left.value).to.deep.equal(7);\n  chai.expect(actual.right.right.value).to.deep.equal(6);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree1 = new program.BinaryTree(1);\n  tree1.left = new program.BinaryTree(3);\n  tree1.left.left = new program.BinaryTree(7);\n  tree1.left.right = new program.BinaryTree(4);\n  tree1.right = new program.BinaryTree(2);\n\n  const tree2 = new program.BinaryTree(1);\n  tree2.left = new program.BinaryTree(5);\n  tree2.left.left = new program.BinaryTree(2);\n  tree2.right = new program.BinaryTree(9);\n  tree2.right.left = new program.BinaryTree(7);\n  tree2.right.right = new program.BinaryTree(6);\n\n  const actual = program.mergeBinaryTrees(tree1, tree2);\n  chai.expect(actual.value).to.deep.equal(2);\n  chai.expect(actual.left.value).to.deep.equal(8);\n  chai.expect(actual.left.left.value).to.deep.equal(9);\n  chai.expect(actual.left.right.value).to.deep.equal(4);\n  chai.expect(actual.right.value).to.deep.equal(11);\n  chai.expect(actual.right.left.value).to.deep.equal(7);\n  chai.expect(actual.right.right.value).to.deep.equal(6);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\nfun mergeBinaryTrees(tree1: BinaryTree, tree2: BinaryTree): BinaryTree {\n    // Write your code here.\n    return BinaryTree(-1)\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n// two trees and h is the height of the shorter tree.\nfun mergeBinaryTrees(tree1: BinaryTree?, tree2: BinaryTree?): BinaryTree? {\n    if (tree1 == null) return tree2\n    if (tree2 == null) return tree1\n\n    tree1.value += tree2.value\n    tree1.left = mergeBinaryTrees(tree1.left, tree2.left)\n    tree1.right = mergeBinaryTrees(tree1.right, tree2.right)\n    return tree1\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport java.util.Stack\n\n// This is an input class. Do not edit.\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n// two trees and h is the height of the shorter tree.\nfun mergeBinaryTrees(tree1: BinaryTree?, tree2: BinaryTree?): BinaryTree? {\n    if (tree1 == null) return tree2\n\n    val tree1Stack = Stack<BinaryTree>()\n    val tree2Stack = Stack<BinaryTree?>()\n    tree1Stack.add(tree1)\n    tree2Stack.add(tree2)\n\n    while (tree1Stack.size > 0) {\n        val tree1Node = tree1Stack.pop()!!\n        val tree2Node = tree2Stack.pop()\n\n        if (tree2Node == null) continue\n\n        tree1Node.value += tree2Node.value\n\n        if (tree1Node.left == null) {\n            tree1Node.left = tree2Node.left\n        } else {\n            tree1Stack.add(tree1Node.left)\n            tree2Stack.add(tree2Node.left)\n        }\n\n        if (tree1Node.right == null) {\n            tree1Node.right = tree2Node.right\n        } else {\n            tree1Stack.add(tree1Node.right)\n            tree2Stack.add(tree2Node.right)\n        }\n    }\n\n    return tree1\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.mergeBinaryTrees\nimport com.algoexpert.program.BinaryTree as BinaryTree\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree1 = BinaryTree(1)\n        tree1.left = BinaryTree(3)\n        tree1.left!!.left = BinaryTree(7)\n        tree1.left!!.right = BinaryTree(4)\n        tree1.right = BinaryTree(2)\n\n        val tree2 = BinaryTree(1)\n        tree2.left = BinaryTree(5)\n        tree2.left!!.left = BinaryTree(2)\n        tree2.right = BinaryTree(9)\n        tree2.right!!.left = BinaryTree(7)\n        tree2.right!!.right = BinaryTree(6)\n\n        val output = mergeBinaryTrees(tree1, tree2)!!\n        assert(output.value == 2)\n        assert(output.left!!.value == 8)\n        assert(output.left!!.left!!.value == 9)\n        assert(output.left!!.right!!.value == 4)\n        assert(output.right!!.value == 11)\n        assert(output.right!!.left!!.value == 7)\n        assert(output.right!!.right!!.value == 6)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.mergeBinaryTrees\nimport com.algoexpert.program.BinaryTree as BinaryTree\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree1 = BinaryTree(1)\n        tree1.left = BinaryTree(3)\n        tree1.left!!.left = BinaryTree(7)\n        tree1.left!!.right = BinaryTree(4)\n        tree1.right = BinaryTree(2)\n\n        val tree2 = BinaryTree(1)\n        tree2.left = BinaryTree(5)\n        tree2.left!!.left = BinaryTree(2)\n        tree2.right = BinaryTree(9)\n        tree2.right!!.left = BinaryTree(7)\n        tree2.right!!.right = BinaryTree(6)\n\n        val output = mergeBinaryTrees(tree1, tree2)!!\n        assert(output.value == 2)\n        assert(output.left!!.value == 8)\n        assert(output.left!!.left!!.value == 9)\n        assert(output.left!!.right!!.value == 4)\n        assert(output.right!!.value == 11)\n        assert(output.right!!.left!!.value == 7)\n        assert(output.right!!.right!!.value == 6)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef mergeBinaryTrees(tree1, tree2):\n    # Write your code here.\n    return None\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n# two trees and h is the height of the shorter tree.\ndef mergeBinaryTrees(tree1, tree2):\n    if tree1 is None:\n        return tree2\n    if tree2 is None:\n        return tree1\n\n    tree1.value += tree2.value\n    tree1.left = mergeBinaryTrees(tree1.left, tree2.left)\n    tree1.right = mergeBinaryTrees(tree1.right, tree2.right)\n    return tree1\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n# two trees and h is the height of the shorter tree.\ndef mergeBinaryTrees(tree1, tree2):\n    if tree1 is None:\n        return tree2\n\n    tree1Stack = [tree1]\n    tree2Stack = [tree2]\n\n    while len(tree1Stack) > 0:\n        tree1Node = tree1Stack.pop()\n        tree2Node = tree2Stack.pop()\n\n        if tree2Node is None:\n            continue\n\n        tree1Node.value += tree2Node.value\n\n        if tree1Node.left is None:\n            tree1Node.left = tree2Node.left\n        else:\n            tree1Stack.append(tree1Node.left)\n            tree2Stack.append(tree2Node.left)\n\n        if tree1Node.right is None:\n            tree1Node.right = tree2Node.right\n        else:\n            tree1Stack.append(tree1Node.right)\n            tree2Stack.append(tree2Node.right)\n\n    return tree1\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        tree1 = program.BinaryTree(1)\n        tree1.left = program.BinaryTree(3)\n        tree1.left.left = program.BinaryTree(7)\n        tree1.left.right = program.BinaryTree(4)\n        tree1.right = program.BinaryTree(2)\n\n        tree2 = program.BinaryTree(1)\n        tree2.left = program.BinaryTree(5)\n        tree2.left.left = program.BinaryTree(2)\n        tree2.right = program.BinaryTree(9)\n        tree2.right.left = program.BinaryTree(7)\n        tree2.right.right = program.BinaryTree(6)\n\n        actual = program.mergeBinaryTrees(tree1, tree2)\n        self.assertEqual(actual.value, 2)\n        self.assertEqual(actual.left.value, 8)\n        self.assertEqual(actual.left.left.value, 9)\n        self.assertEqual(actual.left.right.value, 4)\n        self.assertEqual(actual.right.value, 11)\n        self.assertEqual(actual.right.left.value, 7)\n        self.assertEqual(actual.right.right.value, 6)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        tree1 = program.BinaryTree(1)\n        tree1.left = program.BinaryTree(3)\n        tree1.left.left = program.BinaryTree(7)\n        tree1.left.right = program.BinaryTree(4)\n        tree1.right = program.BinaryTree(2)\n\n        tree2 = program.BinaryTree(1)\n        tree2.left = program.BinaryTree(5)\n        tree2.left.left = program.BinaryTree(2)\n        tree2.right = program.BinaryTree(9)\n        tree2.right.left = program.BinaryTree(7)\n        tree2.right.right = program.BinaryTree(6)\n\n        actual = program.mergeBinaryTrees(tree1, tree2)\n        self.assertEqual(actual.value, 2)\n        self.assertEqual(actual.left.value, 8)\n        self.assertEqual(actual.left.left.value, 9)\n        self.assertEqual(actual.left.right.value, 4)\n        self.assertEqual(actual.right.value, 11)\n        self.assertEqual(actual.right.left.value, 7)\n        self.assertEqual(actual.right.right.value, 6)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "# This is an input struct. Do not edit.\nclass BinaryTree\n    attr_accessor :value\n    attr_accessor :left\n    attr_accessor :right\n\n    def initialize(value)\n        @value = value\n        @left = nil\n        @right = nil\n    end\nend\n\n\nclass Program\n    def mergeBinaryTrees(tree1, tree2)\n        # Write your code here.\n        return nil\n    end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BinaryTree\n    attr_accessor :value\n    attr_accessor :left\n    attr_accessor :right\n\n    def initialize(value)\n        @value = value\n        @left = nil\n        @right = nil\n    end\nend\n\n\nclass Program\n    def mergeBinaryTrees(tree1, tree2)\n        # Write your code here.\n        return nil\n    end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire './program.rb'\n\nclass TestSuite\n    include Assertions\n    def test_1\n        # inputs = ...\n        # output = Program.new.mergeBinaryTrees\n        # expected = ...\n        # assertEqual(expected, output)\n    end\nend\n\n",
      "unitTests": "require './program.rb'\n\nclass TestSuite\n    include Assertions\n    def test_1\n        # inputs = ...\n        # output = Program.new.mergeBinaryTrees\n        # expected = ...\n        # assertEqual(expected, output)\n    end\nend\n\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  func mergeBinaryTrees(_ tree1: BinaryTree?, _ tree2: BinaryTree?) -> BinaryTree? {\n    // Write your code here.\n    return BinaryTree(value: -1)\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n  // two trees and h is the height of the shorter tree.\n  func mergeBinaryTrees(_ tree1: BinaryTree?, _ tree2: BinaryTree?) -> BinaryTree? {\n    if tree1 == nil {\n      return tree2\n    }\n    if tree2 == nil {\n      return tree1\n    }\n\n    tree1!.value += tree2!.value\n    tree1!.left = mergeBinaryTrees(tree1!.left, tree2!.left)\n    tree1!.right = mergeBinaryTrees(tree1!.right, tree2!.right)\n    return tree1\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n  // two trees and h is the height of the shorter tree.\n  func mergeBinaryTrees(_ tree1: BinaryTree?, _ tree2: BinaryTree?) -> BinaryTree? {\n    if tree1 == nil {\n      return tree2\n    }\n\n    var tree1Stack = [tree1]\n    var tree2Stack = [tree2]\n\n    while tree1Stack.count > 0 {\n      let tree1Node = tree1Stack.popLast()!\n      let tree2Node = tree2Stack.popLast()!\n\n      if tree2Node == nil {\n        continue\n      }\n\n      tree1Node!.value += tree2Node!.value\n\n      if tree1Node!.left == nil {\n        tree1Node!.left = tree2Node!.left\n      } else {\n        tree1Stack.append(tree1Node!.left)\n        tree2Stack.append(tree2Node!.left)\n      }\n\n      if tree1Node!.right == nil {\n        tree1Node!.right = tree2Node!.right\n      } else {\n        tree1Stack.append(tree1Node!.right)\n        tree2Stack.append(tree2Node!.right)\n      }\n    }\n    return tree1\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      var tree1 = Program.BinaryTree(value: 1)\n      tree1.left = Program.BinaryTree(value: 3)\n      tree1.left!.left = Program.BinaryTree(value: 7)\n      tree1.left!.right = Program.BinaryTree(value: 4)\n      tree1.right = Program.BinaryTree(value: 2)\n\n      var tree2 = Program.BinaryTree(value: 1)\n      tree2.left = Program.BinaryTree(value: 5)\n      tree2.left!.left = Program.BinaryTree(value: 2)\n      tree2.right = Program.BinaryTree(value: 9)\n      tree2.right!.left = Program.BinaryTree(value: 7)\n      tree2.right!.right = Program.BinaryTree(value: 6)\n\n      var expected = Program.BinaryTree(value: 2)\n      expected.left = Program.BinaryTree(value: 8)\n      expected.left!.left = Program.BinaryTree(value: 9)\n      expected.left!.right = Program.BinaryTree(value: 4)\n      expected.right = Program.BinaryTree(value: 11)\n      expected.right!.left = Program.BinaryTree(value: 7)\n      expected.right!.right = Program.BinaryTree(value: 6)\n\n      var actual = Program().mergeBinaryTrees(tree1, tree2)\n\n      try assertEqual(true, areTreesEqual(expected, actual))\n    }\n  }\n\n  func areTreesEqual(_ tree1: Program.BinaryTree?, _ tree2: Program.BinaryTree?) -> Bool {\n    if tree1 == nil && tree2 == nil {\n      return true\n    } else if tree1 == nil || tree2 == nil {\n      return false\n    }\n\n    if tree1!.value != tree2!.value {\n      return false\n    }\n    return areTreesEqual(tree1!.left, tree2!.left) && areTreesEqual(tree1!.right, tree2!.right)\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      var tree1 = Program.BinaryTree(value: 1)\n      tree1.left = Program.BinaryTree(value: 3)\n      tree1.left!.left = Program.BinaryTree(value: 7)\n      tree1.left!.right = Program.BinaryTree(value: 4)\n      tree1.right = Program.BinaryTree(value: 2)\n\n      var tree2 = Program.BinaryTree(value: 1)\n      tree2.left = Program.BinaryTree(value: 5)\n      tree2.left!.left = Program.BinaryTree(value: 2)\n      tree2.right = Program.BinaryTree(value: 9)\n      tree2.right!.left = Program.BinaryTree(value: 7)\n      tree2.right!.right = Program.BinaryTree(value: 6)\n\n      var expected = Program.BinaryTree(value: 2)\n      expected.left = Program.BinaryTree(value: 8)\n      expected.left!.left = Program.BinaryTree(value: 9)\n      expected.left!.right = Program.BinaryTree(value: 4)\n      expected.right = Program.BinaryTree(value: 11)\n      expected.right!.left = Program.BinaryTree(value: 7)\n      expected.right!.right = Program.BinaryTree(value: 6)\n\n      var actual = Program().mergeBinaryTrees(tree1, tree2)\n\n      try assertEqual(true, areTreesEqual(expected, actual))\n    }\n  }\n\n  func areTreesEqual(_ tree1: Program.BinaryTree?, _ tree2: Program.BinaryTree?) -> Bool {\n    if tree1 == nil && tree2 == nil {\n      return true\n    } else if tree1 == nil || tree2 == nil {\n      return false\n    }\n\n    if tree1!.value != tree2!.value {\n      return false\n    }\n    return areTreesEqual(tree1!.left, tree2!.left) && areTreesEqual(tree1!.right, tree2!.right)\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport function mergeBinaryTrees(tree1: BinaryTree, tree2: BinaryTree) {\n  // Write your code here.\n  return null;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n// two trees and h is the height of the shorter tree.\nexport function mergeBinaryTrees(tree1: BinaryTree | null, tree2: BinaryTree | null) {\n  if (tree1 === null) return tree2;\n  if (tree2 === null) return tree1;\n\n  tree1.value += tree2.value;\n  tree1.left = mergeBinaryTrees(tree1.left, tree2.left);\n  tree1.right = mergeBinaryTrees(tree1.right, tree2.right);\n  return tree1;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n// two trees and h is the height of the shorter tree.\nexport function mergeBinaryTrees(tree1: BinaryTree | null, tree2: BinaryTree | null) {\n  if (tree1 === null) return tree2;\n\n  const tree1Stack = [tree1];\n  const tree2Stack = [tree2];\n\n  while (tree1Stack.length > 0) {\n    const tree1Node = tree1Stack.pop()!;\n    const tree2Node = tree2Stack.pop();\n\n    if (tree2Node === null) continue;\n\n    tree1Node.value += tree2Node!.value;\n\n    if (tree1Node.left === null) {\n      tree1Node.left = tree2Node!.left;\n    } else {\n      tree1Stack.push(tree1Node.left);\n      tree2Stack.push(tree2Node!.left);\n    }\n\n    if (tree1Node.right === null) {\n      tree1Node.right = tree2Node!.right;\n    } else {\n      tree1Stack.push(tree1Node.right);\n      tree2Stack.push(tree2Node!.right);\n    }\n  }\n\n  return tree1;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const tree1 = new program.BinaryTree(1);\n  tree1.left = new program.BinaryTree(3);\n  tree1.left!.left = new program.BinaryTree(7);\n  tree1.left!.right = new program.BinaryTree(4);\n  tree1.right = new program.BinaryTree(2);\n\n  const tree2 = new program.BinaryTree(1);\n  tree2.left = new program.BinaryTree(5);\n  tree2.left!.left = new program.BinaryTree(2);\n  tree2.right = new program.BinaryTree(9);\n  tree2.right!.left = new program.BinaryTree(7);\n  tree2.right!.right = new program.BinaryTree(6);\n\n  const actual = program.mergeBinaryTrees(tree1, tree2);\n  chai.expect(actual!.value).to.deep.equal(2);\n  chai.expect(actual!.left!.value).to.deep.equal(8);\n  chai.expect(actual!.left!.left!.value).to.deep.equal(9);\n  chai.expect(actual!.left!.right!.value).to.deep.equal(4);\n  chai.expect(actual!.right!.value).to.deep.equal(11);\n  chai.expect(actual!.right!.left!.value).to.deep.equal(7);\n  chai.expect(actual!.right!.right!.value).to.deep.equal(6);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const tree1 = new program.BinaryTree(1);\n  tree1.left = new program.BinaryTree(3);\n  tree1.left!.left = new program.BinaryTree(7);\n  tree1.left!.right = new program.BinaryTree(4);\n  tree1.right = new program.BinaryTree(2);\n\n  const tree2 = new program.BinaryTree(1);\n  tree2.left = new program.BinaryTree(5);\n  tree2.left!.left = new program.BinaryTree(2);\n  tree2.right = new program.BinaryTree(9);\n  tree2.right!.left = new program.BinaryTree(7);\n  tree2.right!.right = new program.BinaryTree(6);\n\n  const actual = program.mergeBinaryTrees(tree1, tree2);\n  chai.expect(actual!.value).to.deep.equal(2);\n  chai.expect(actual!.left!.value).to.deep.equal(8);\n  chai.expect(actual!.left!.left!.value).to.deep.equal(9);\n  chai.expect(actual!.left!.right!.value).to.deep.equal(4);\n  chai.expect(actual!.right!.value).to.deep.equal(11);\n  chai.expect(actual!.right!.left!.value).to.deep.equal(7);\n  chai.expect(actual!.right!.right!.value).to.deep.equal(6);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "tree1",
      "example": {
        "nodes": [
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          }
        ],
        "root": "7"
      },
      "schema": {
        "description": "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "left": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "right": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "left",
                "right"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "root": {
            "type": "string"
          }
        },
        "required": [
          "root",
          "nodes"
        ],
        "type": "object"
      }
    },
    {
      "name": "tree2",
      "example": {
        "nodes": [
          {
            "id": "2",
            "left": "3",
            "right": "6",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "6",
            "left": null,
            "right": "7",
            "value": 6
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          }
        ],
        "root": "2"
      },
      "schema": {
        "description": "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "left": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "right": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "left",
                "right"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "root": {
            "type": "string"
          }
        },
        "required": [
          "root",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "tree1": {
        "nodes": [
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          }
        ],
        "root": "7"
      },
      "tree2": {
        "nodes": [
          {
            "id": "2",
            "left": "3",
            "right": "6",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "6",
            "left": null,
            "right": "7",
            "value": 6
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          }
        ],
        "root": "2"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "3",
            "right": "2",
            "value": 1
          },
          {
            "id": "3",
            "left": "5",
            "right": null,
            "value": 3
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "2",
            "left": "3",
            "right": "6",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "6",
            "left": null,
            "right": "7",
            "value": 6
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          }
        ],
        "root": "2"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "3",
            "right": "2",
            "value": 1
          },
          {
            "id": "3",
            "left": "7",
            "right": "4",
            "value": 3
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "5",
            "right": "9",
            "value": 1
          },
          {
            "id": "5",
            "left": "2",
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "9",
            "left": "7",
            "right": "6",
            "value": 9
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "4",
            "left": "5",
            "right": "6",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          }
        ],
        "root": "4"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "4",
            "left": "5",
            "right": "6",
            "value": 4
          },
          {
            "id": "5",
            "left": "1",
            "right": "8",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "4"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "4",
            "left": "5",
            "right": "6",
            "value": 4
          },
          {
            "id": "5",
            "left": "1",
            "right": "8",
            "value": 5
          },
          {
            "id": "6",
            "left": "10",
            "right": "15",
            "value": 6
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "15",
            "left": null,
            "right": null,
            "value": 15
          }
        ],
        "root": "4"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "5",
            "right": "8",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "4",
            "left": "5",
            "right": "6",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          }
        ],
        "root": "4"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "2",
            "left": "4",
            "right": "1",
            "value": 2
          },
          {
            "id": "4",
            "left": "6",
            "right": null,
            "value": 4
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          }
        ],
        "root": "2"
      },
      "tree2": {
        "nodes": [
          {
            "id": "3",
            "left": "1",
            "right": "6",
            "value": 3
          },
          {
            "id": "1",
            "left": null,
            "right": "9",
            "value": 1
          },
          {
            "id": "6",
            "left": null,
            "right": "8",
            "value": 6
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "3"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "3",
            "right": null,
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "4",
            "value": 1
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "4",
            "right": null,
            "value": 1
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      }
    }
  ],
  "jsonTests": [
    {
      "tree1": {
        "nodes": [
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          }
        ],
        "root": "7"
      },
      "tree2": {
        "nodes": [
          {
            "id": "2",
            "left": "3",
            "right": "6",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "6",
            "left": null,
            "right": "7",
            "value": 6
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          }
        ],
        "root": "2"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "3",
            "right": "2",
            "value": 1
          },
          {
            "id": "3",
            "left": "5",
            "right": null,
            "value": 3
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "2",
            "left": "3",
            "right": "6",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "6",
            "left": null,
            "right": "7",
            "value": 6
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          }
        ],
        "root": "2"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "3",
            "right": "2",
            "value": 1
          },
          {
            "id": "3",
            "left": "7",
            "right": "4",
            "value": 3
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "5",
            "right": "9",
            "value": 1
          },
          {
            "id": "5",
            "left": "2",
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "9",
            "left": "7",
            "right": "6",
            "value": 9
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "4",
            "left": "5",
            "right": "6",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          }
        ],
        "root": "4"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "4",
            "left": "5",
            "right": "6",
            "value": 4
          },
          {
            "id": "5",
            "left": "1",
            "right": "8",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "4"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "4",
            "left": "5",
            "right": "6",
            "value": 4
          },
          {
            "id": "5",
            "left": "1",
            "right": "8",
            "value": 5
          },
          {
            "id": "6",
            "left": "10",
            "right": "15",
            "value": 6
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "15",
            "left": null,
            "right": null,
            "value": 15
          }
        ],
        "root": "4"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "5",
            "right": "8",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "4",
            "left": "5",
            "right": "6",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          }
        ],
        "root": "4"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "2",
            "left": "4",
            "right": "1",
            "value": 2
          },
          {
            "id": "4",
            "left": "6",
            "right": null,
            "value": 4
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          }
        ],
        "root": "2"
      },
      "tree2": {
        "nodes": [
          {
            "id": "3",
            "left": "1",
            "right": "6",
            "value": 3
          },
          {
            "id": "1",
            "left": null,
            "right": "9",
            "value": 1
          },
          {
            "id": "6",
            "left": null,
            "right": "8",
            "value": 6
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "3"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "3",
            "right": null,
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "4",
            "value": 1
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "4",
            "right": null,
            "value": 1
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      }
    }
  ],
  "changelog": []
}