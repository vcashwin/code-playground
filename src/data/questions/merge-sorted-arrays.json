{
  "uid": "merge-sorted-arrays",
  "testStrategy": "JSON",
  "name": "Merge Sorted Arrays",
  "version": 0,
  "releaseDate": "2020-05-11T00:00:00Z",
  "category": "Heaps",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 8401,
    "failureCount": 2037
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "416801866",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1863
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in a non-empty list of non-empty sorted arrays of\n  integers and returns a merged list of all of those arrays.\n</p>\n<p>The integers in the merged list should be in sorted order.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">arrays</span> = [\n  [1, 5, 9, 21],\n  [-1, 0],\n  [-124, 81, 121],\n  [3, 6, 12, 20, 150],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150]\n</pre>\n</div>",
  "hints": [
    "<p>\nIf you were given just two sorted lists of numbers in real life, what steps would you take to merge them into a single sorted list? Apply the same process to k sorted lists.\n</p>\n",
    "\n<p>\nThe first element in each array is the smallest element in the respective array; to find the first element to add to the final sorted list, pick the smallest integer out of all of the smallest elements. Once you've found the smallest integer, move one position forward in the array that it came from and continue applying this logic until you run out of elements.\n</p>\n",
    "\n<p>\nThe approach described in Hint #2 involves repeatedly finding the smallest of k elements, since there are k arrays. Doing so can be naively implemented using a simple loop through the k relevant elements, which results in an O(k)-time operation. Can you speed up this operation by using a specific data structure that lends itself to quickly finding the minimum value in a set of values.\n</p>\n",
    "\n<p>\nFollow the approach described in Hint #2, using a Min Heap to store the k smallest elements at any given point in your algorithm.\n</p>"
  ],
  "spaceTime": "O(nlog(k) + k) time | O(n + k) space - where where n is the total number of array elements and k is the number of arrays",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\nvector<int> mergeSortedArrays(vector<vector<int>> arrays) {\n  // Write your code here.\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\nstruct Item {\n  int arrayIdx;\n  int num;\n};\n\nItem getMinValue(vector<Item> items);\n\n// O(nk) time | O(n + k) space - where n is the total\n// number of array elements and k is the number of arrays\nvector<int> mergeSortedArrays(vector<vector<int>> arrays) {\n  vector<int> sortedList;\n  vector<int> elementIdxs(arrays.size(), 0);\n\n  while (true) {\n    vector<Item> smallestItems;\n    for (int arrayIdx = 0; arrayIdx < arrays.size(); arrayIdx++) {\n      vector<int> relevantArray = arrays[arrayIdx];\n      int elementIdx = elementIdxs[arrayIdx];\n      if (elementIdx == relevantArray.size()) continue;\n      smallestItems.push_back(Item{arrayIdx, relevantArray[elementIdx]});\n    }\n    if (smallestItems.size() == 0) break;\n    Item nextItem = getMinValue(smallestItems);\n    sortedList.push_back(nextItem.num);\n    elementIdxs[nextItem.arrayIdx]++;\n  }\n\n  return sortedList;\n}\n\nItem getMinValue(vector<Item> items) {\n  int minValueIdx = 0;\n  for (int i = 1; i < items.size(); i++) {\n    if (items[i].num < items[minValueIdx].num) minValueIdx = i;\n  }\n  return items[minValueIdx];\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct Item {\n  int arrayIdx;\n  int elementIdx;\n  int num;\n};\n\nclass MinHeap {\n public:\n  vector<Item> heap;\n\n  MinHeap(vector<Item> array) { heap = buildHeap(array); }\n\n  bool isEmpty() { return heap.size() == 0; }\n\n  vector<Item> buildHeap(vector<Item> array) {\n    int firstParentIdx = (array.size() - 2) / 2;\n    for (int currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      siftDown(currentIdx, array.size() - 1, array);\n    }\n    return array;\n  }\n\n  void siftDown(int currentIdx, int endIdx, vector<Item>& heap) {\n    int childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      int childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      int idxToSwap;\n      if (childTwoIdx != -1 && heap[childTwoIdx].num < heap[childOneIdx].num) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap].num < heap[currentIdx].num) {\n        swap(heap[currentIdx], heap[idxToSwap]);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  void siftUp(int currentIdx, vector<Item>& heap) {\n    int parentIdx = (currentIdx - 1) / 2;\n    while (currentIdx > 0 && heap[currentIdx].num < heap[parentIdx].num) {\n      swap(heap[currentIdx], heap[parentIdx]);\n      currentIdx = parentIdx;\n      parentIdx = (currentIdx - 1) / 2;\n    }\n  }\n\n  Item remove() {\n    swap(heap[0], heap[heap.size() - 1]);\n    Item valueToRemove = heap.back();\n    heap.pop_back();\n    siftDown(0, heap.size() - 1, heap);\n    return valueToRemove;\n  }\n\n  void insert(Item value) {\n    heap.push_back(value);\n    siftUp(heap.size() - 1, heap);\n  }\n};\n\n// O(nlog(k) + k) time | O(n + k) space - where n is the total\n// number of array elements and k is the number of arrays\nvector<int> mergeSortedArrays(vector<vector<int>> arrays) {\n  vector<int> sortedList;\n  vector<Item> smallestItems;\n\n  for (int arrayIdx = 0; arrayIdx < arrays.size(); arrayIdx++) {\n    smallestItems.push_back(Item{\n      arrayIdx,\n      0,\n      arrays[arrayIdx][0],\n    });\n  }\n\n  MinHeap minHeap(smallestItems);\n  while (!minHeap.isEmpty()) {\n    Item smallestItem = minHeap.remove();\n    sortedList.push_back(smallestItem.num);\n    if (smallestItem.elementIdx == arrays[smallestItem.arrayIdx].size() - 1)\n      continue;\n    minHeap.insert(Item{\n      smallestItem.arrayIdx,\n      smallestItem.elementIdx + 1,\n      arrays[smallestItem.arrayIdx][smallestItem.elementIdx + 1],\n    });\n  }\n\n  return sortedList;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> arrays = {\n        {1, 5, 9, 21},\n        {-1, 0},\n        {-124, 81, 121},\n        {3, 6, 12, 20, 150},\n      };\n      auto output = mergeSortedArrays(arrays);\n      vector<int> expected{\n        -124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150};\n      assert(output == expected);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> arrays = {\n        {1, 5, 9, 21},\n        {-1, 0},\n        {-124, 81, 121},\n        {3, 6, 12, 20, 150},\n      };\n      auto output = mergeSortedArrays(arrays);\n      vector<int> expected{\n        -124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150};\n      assert(output == expected);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n  public static List<int> MergeSortedArrays(List<List<int> > arrays) {\n    // Write your code here.\n    return new List<int>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(nk) time | O(n + k) space - where n is the total\n  // number of array elements and k is the number of arrays\n  public static List<int> MergeSortedArrays(List<List<int> > arrays) {\n    List<int> sortedList = new List<int>();\n    List<int> elementIdxs = Enumerable.Repeat(0, arrays.Count).ToList();\n    while (true) {\n      List<Item> smallestItems = new List<Item>();\n      for (int arrayIdx = 0; arrayIdx < arrays.Count; arrayIdx++) {\n        List<int> relevantArray = arrays[arrayIdx];\n        int elementIdx = elementIdxs[arrayIdx];\n        if (elementIdx == relevantArray.Count) continue;\n        smallestItems.Add(new Item(arrayIdx, relevantArray[elementIdx]));\n      }\n      if (smallestItems.Count == 0) break;\n      Item nextItem = getMinValue(smallestItems);\n      sortedList.Add(nextItem.num);\n      elementIdxs[nextItem.arrayIdx] = elementIdxs[nextItem.arrayIdx] + 1;\n    }\n\n    return sortedList;\n  }\n\n  public static Item getMinValue(List<Item> items) {\n    int minValueIdx = 0;\n    for (int i = 1; i < items.Count; i++) {\n      if (items[i].num < items[minValueIdx].num) minValueIdx = i;\n    }\n    return items[minValueIdx];\n  }\n\n  public class Item {\n    public int arrayIdx;\n    public int num;\n\n    public Item(int arrayIdx, int num) {\n      this.arrayIdx = arrayIdx;\n      this.num = num;\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(nlog(k) + k) time | O(n + k) space - where n is the total\n  // number of array elements and k is the number of arrays\n  public static List<int> MergeSortedArrays(List<List<int> > arrays) {\n    List<int> sortedList = new List<int>();\n    List<Item> smallestItems = new List<Item>();\n\n    for (int arrayIdx = 0; arrayIdx < arrays.Count; arrayIdx++) {\n      smallestItems.Add(new Item(arrayIdx, 0, arrays[arrayIdx][0]));\n    }\n\n    MinHeap minHeap = new MinHeap(smallestItems);\n    while (!minHeap.isEmpty()) {\n      Item smallestItem = minHeap.Remove();\n      sortedList.Add(smallestItem.num);\n      if (smallestItem.elementIdx == arrays[smallestItem.arrayIdx].Count - 1)\n        continue;\n      minHeap.Insert(new Item(\n        smallestItem.arrayIdx,\n        smallestItem.elementIdx + 1,\n        arrays[smallestItem.arrayIdx][smallestItem.elementIdx + 1]\n      ));\n    }\n\n    return sortedList;\n  }\n\n  public class Item {\n    public int arrayIdx;\n    public int elementIdx;\n    public int num;\n\n    public Item(int arrayIdx, int elementIdx, int num) {\n      this.arrayIdx = arrayIdx;\n      this.elementIdx = elementIdx;\n      this.num = num;\n    }\n  }\n\n  public class MinHeap {\n    List<Item> heap = new List<Item>();\n\n    public MinHeap(List<Item> array) {\n      heap = buildHeap(array);\n    }\n\n    public bool isEmpty() {\n      return heap.Count == 0;\n    }\n\n    public List<Item> buildHeap(List<Item> array) {\n      int firstParentIdx = (array.Count - 2) / 2;\n      for (int currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n        siftDown(currentIdx, array.Count - 1, array);\n      }\n      return array;\n    }\n\n    public void siftDown(int currentIdx, int endIdx, List<Item> heap) {\n      int childOneIdx = currentIdx * 2 + 1;\n      while (childOneIdx <= endIdx) {\n        int childTwoIdx =\n          currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n        int idxToSwap;\n        if (childTwoIdx != -1 && heap[childTwoIdx].num < heap[childOneIdx].num) {\n          idxToSwap = childTwoIdx;\n        } else {\n          idxToSwap = childOneIdx;\n        }\n        if (heap[idxToSwap].num < heap[currentIdx].num) {\n          swap(currentIdx, idxToSwap, heap);\n          currentIdx = idxToSwap;\n          childOneIdx = currentIdx * 2 + 1;\n        } else {\n          return;\n        }\n      }\n    }\n\n    public void siftUp(int currentIdx, List<Item> heap) {\n      int parentIdx = (currentIdx - 1) / 2;\n      while (currentIdx > 0 && heap[currentIdx].num < heap[parentIdx].num) {\n        swap(currentIdx, parentIdx, heap);\n        currentIdx = parentIdx;\n        parentIdx = (currentIdx - 1) / 2;\n      }\n    }\n\n    public Item Remove() {\n      swap(0, heap.Count - 1, heap);\n      Item valueToRemove = heap[heap.Count - 1];\n      heap.RemoveAt(heap.Count - 1);\n      siftDown(0, heap.Count - 1, heap);\n      return valueToRemove;\n    }\n\n    public void Insert(Item value) {\n      heap.Add(value);\n      siftUp(heap.Count - 1, heap);\n    }\n\n    public void swap(int i, int j, List<Item> heap) {\n      Item temp = heap[j];\n      heap[j] = heap[i];\n      heap[i] = temp;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var arrays = new List<List<int> > {\n      new List<int> { 1, 5, 9, 21 },\n      new List<int> { -1, 0 },\n      new List<int> { -124, 81, 121 },\n      new List<int> { 3, 6, 12, 20, 150 },\n    };\n    var actual = Program.MergeSortedArrays(arrays);\n    var expected =\n      new List<int> { -124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150 };\n    Utils.AssertTrue(Enumerable.SequenceEqual(expected, actual));\n  }\n}\n",
      "unitTests": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var arrays = new List<List<int> > {\n      new List<int> { 1, 5, 9, 21 },\n      new List<int> { -1, 0 },\n      new List<int> { -124, 81, 121 },\n      new List<int> { 3, 6, 12, 20, 150 },\n    };\n    var actual = Program.MergeSortedArrays(arrays);\n    var expected =\n      new List<int> { -124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150 };\n    Utils.AssertTrue(Enumerable.SequenceEqual(expected, actual));\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc MergeSortedArrays(arrays [][]int) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype Item struct {\n\tArrayIdx int\n\tNum      int\n}\n\n// O(nk) time | O(n + k) space - where n is the total\n// number of array elements and k is the number of arrays\nfunc MergeSortedArrays(arrays [][]int) []int {\n\tsortedList := []int{}\n\telementIdxs := make([]int, len(arrays))\n\n\tfor {\n\t\tsmallestItems := []Item{}\n\t\tfor arrayIdx := 0; arrayIdx < len(arrays); arrayIdx++ {\n\t\t\trelevantArray := arrays[arrayIdx]\n\t\t\telementIdx := elementIdxs[arrayIdx]\n\t\t\tif elementIdx == len(relevantArray) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsmallestItems = append(smallestItems, Item{\n\t\t\t\tArrayIdx: arrayIdx,\n\t\t\t\tNum:      relevantArray[elementIdx],\n\t\t\t})\n\t\t}\n\n\t\tif len(smallestItems) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tnextItem := getMinValue(smallestItems)\n\t\tsortedList = append(sortedList, nextItem.Num)\n\t\telementIdxs[nextItem.ArrayIdx] += 1\n\t}\n\treturn sortedList\n}\n\nfunc getMinValue(items []Item) Item {\n\tminValueItem := items[0]\n\tfor i := 1; i < len(items); i++ {\n\t\tif items[i].Num < minValueItem.Num {\n\t\t\tminValueItem = items[i]\n\t\t}\n\t}\n\treturn minValueItem\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype Item struct {\n\tArrayIdx   int\n\tElementIdx int\n\tNum        int\n}\n\n// O(nlog(k) + k) time | O(n + k) space - where n is the total\n// number of array elements and k is the number of arrays\nfunc MergeSortedArrays(arrays [][]int) []int {\n\tsortedList := []int{}\n\tsmallestItems := []Item{}\n\n\tfor arrayIdx := 0; arrayIdx < len(arrays); arrayIdx++ {\n\t\tsmallestItems = append(smallestItems, Item{\n\t\t\tArrayIdx:   arrayIdx,\n\t\t\tElementIdx: 0,\n\t\t\tNum:        arrays[arrayIdx][0],\n\t\t})\n\t}\n\n\tmh := NewMinHeap(smallestItems)\n\tfor mh.length() != 0 {\n\t\tsmallestItem := mh.Remove()\n\t\tsortedList = append(sortedList, smallestItem.Num)\n\t\tif smallestItem.ElementIdx == len(arrays[smallestItem.ArrayIdx])-1 {\n\t\t\tcontinue\n\t\t}\n\t\tmh.Insert(Item{\n\t\t\tArrayIdx:   smallestItem.ArrayIdx,\n\t\t\tElementIdx: smallestItem.ElementIdx + 1,\n\t\t\tNum:        arrays[smallestItem.ArrayIdx][smallestItem.ElementIdx+1],\n\t\t})\n\t}\n\treturn sortedList\n}\n\ntype MinHeap []Item\n\nfunc NewMinHeap(array []Item) *MinHeap {\n\theap := MinHeap(array)\n\tptr := &heap\n\tptr.BuildHeap(array)\n\treturn ptr\n}\n\n// O(n) time | O(1) space\nfunc (h *MinHeap) BuildHeap(array []Item) {\n\tfirst := (len(array) - 2) / 2\n\tfor currentIndex := first + 1; currentIndex >= 0; currentIndex-- {\n\t\th.siftDown(currentIndex, len(array)-1)\n\t}\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) siftDown(currentIndex, endIndex int) {\n\tchildOneIdx := currentIndex*2 + 1\n\tfor childOneIdx <= endIndex {\n\t\tchildTwoIdx := -1\n\t\tif currentIndex*2+2 <= endIndex {\n\t\t\tchildTwoIdx = currentIndex*2 + 2\n\t\t}\n\t\tindexToSwap := childOneIdx\n\t\tif childTwoIdx > -1 && (*h)[childTwoIdx].Num < (*h)[childOneIdx].Num {\n\t\t\tindexToSwap = childTwoIdx\n\t\t}\n\t\tif (*h)[indexToSwap].Num < (*h)[currentIndex].Num {\n\t\t\th.swap(currentIndex, indexToSwap)\n\t\t\tcurrentIndex = indexToSwap\n\t\t\tchildOneIdx = currentIndex*2 + 1\n\t\t} else {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) siftUp() {\n\tcurrentIndex := h.length() - 1\n\tparentIndex := (currentIndex - 1) / 2\n\tfor currentIndex > 0 {\n\t\tcurrent, parent := (*h)[currentIndex].Num, (*h)[parentIndex].Num\n\t\tif current < parent {\n\t\t\th.swap(currentIndex, parentIndex)\n\t\t\tcurrentIndex = parentIndex\n\t\t\tparentIndex = (currentIndex - 1) / 2\n\t\t} else {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) Remove() Item {\n\tl := h.length()\n\th.swap(0, l-1)\n\tpeeked := (*h)[l-1]\n\t*h = (*h)[0 : l-1]\n\th.siftDown(0, l-2)\n\treturn peeked\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) Insert(value Item) {\n\t*h = append(*h, value)\n\th.siftUp()\n}\n\nfunc (h MinHeap) swap(i, j int) {\n\th[i], h[j] = h[j], h[i]\n}\n\nfunc (h MinHeap) length() int {\n\treturn len(h)\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tarrays := [][]int{\n\t\t{1, 5, 9, 21},\n\t\t{-1, 0},\n\t\t{-124, 81, 121},\n\t\t{3, 6, 12, 20, 150},\n\t}\n\texpected := []int{-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150}\n\tactual := MergeSortedArrays(arrays)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tarrays := [][]int{\n\t\t{1, 5, 9, 21},\n\t\t{-1, 0},\n\t\t{-124, 81, 121},\n\t\t{3, 6, 12, 20, 150},\n\t}\n\texpected := []int{-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150}\n\tactual := MergeSortedArrays(arrays)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static List<Integer> mergeSortedArrays(List<List<Integer>> arrays) {\n    // Write your code here.\n    return new ArrayList<Integer>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(nk) time | O(n + k) space - where n is the total\n  // number of array elements and k is the number of arrays\n  public static List<Integer> mergeSortedArrays(List<List<Integer>> arrays) {\n    List<Integer> sortedList = new ArrayList<Integer>();\n    List<Integer> elementIdxs =\n      new ArrayList<Integer>(Collections.nCopies(arrays.size(), 0));\n    while (true) {\n      List<Item> smallestItems = new ArrayList<Item>();\n      for (int arrayIdx = 0; arrayIdx < arrays.size(); arrayIdx++) {\n        List<Integer> relevantArray = arrays.get(arrayIdx);\n        int elementIdx = elementIdxs.get(arrayIdx);\n        if (elementIdx == relevantArray.size()) continue;\n        smallestItems.add(new Item(arrayIdx, relevantArray.get(elementIdx)));\n      }\n      if (smallestItems.size() == 0) break;\n      Item nextItem = getMinValue(smallestItems);\n      sortedList.add(nextItem.num);\n      elementIdxs.set(\n        nextItem.arrayIdx, elementIdxs.get(nextItem.arrayIdx) + 1\n      );\n    }\n\n    return sortedList;\n  }\n\n  public static Item getMinValue(List<Item> items) {\n    int minValueIdx = 0;\n    for (int i = 1; i < items.size(); i++) {\n      if (items.get(i).num < items.get(minValueIdx).num) minValueIdx = i;\n    }\n    return items.get(minValueIdx);\n  }\n\n  static class Item {\n    public int arrayIdx;\n    public int num;\n\n    public Item(int arrayIdx, int num) {\n      this.arrayIdx = arrayIdx;\n      this.num = num;\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(nlog(k) + k) time | O(n + k) space - where n is the total\n  // number of array elements and k is the number of arrays\n  public static List<Integer> mergeSortedArrays(List<List<Integer>> arrays) {\n    List<Integer> sortedList = new ArrayList<Integer>();\n    List<Item> smallestItems = new ArrayList<Item>();\n\n    for (int arrayIdx = 0; arrayIdx < arrays.size(); arrayIdx++) {\n      smallestItems.add(new Item(arrayIdx, 0, arrays.get(arrayIdx).get(0)));\n    }\n\n    MinHeap minHeap = new MinHeap(smallestItems);\n    while (!minHeap.isEmpty()) {\n      Item smallestItem = minHeap.remove();\n      sortedList.add(smallestItem.num);\n      if (smallestItem.elementIdx == arrays.get(smallestItem.arrayIdx).size() - 1)\n        continue;\n      minHeap.insert(new Item(\n        smallestItem.arrayIdx,\n        smallestItem.elementIdx + 1,\n        arrays.get(smallestItem.arrayIdx).get(smallestItem.elementIdx + 1)\n      ));\n    }\n\n    return sortedList;\n  }\n\n  static class Item {\n    public int arrayIdx;\n    public int elementIdx;\n    public int num;\n\n    public Item(int arrayIdx, int elementIdx, int num) {\n      this.arrayIdx = arrayIdx;\n      this.elementIdx = elementIdx;\n      this.num = num;\n    }\n  }\n\n  static class MinHeap {\n    List<Item> heap = new ArrayList<Item>();\n\n    public MinHeap(List<Item> array) {\n      heap = buildHeap(array);\n    }\n\n    public boolean isEmpty() {\n      return heap.size() == 0;\n    }\n\n    public List<Item> buildHeap(List<Item> array) {\n      int firstParentIdx = (array.size() - 2) / 2;\n      for (int currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n        siftDown(currentIdx, array.size() - 1, array);\n      }\n      return array;\n    }\n\n    public void siftDown(int currentIdx, int endIdx, List<Item> heap) {\n      int childOneIdx = currentIdx * 2 + 1;\n      while (childOneIdx <= endIdx) {\n        int childTwoIdx =\n          currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n        int idxToSwap;\n        if (childTwoIdx != -1\n            && heap.get(childTwoIdx).num < heap.get(childOneIdx).num) {\n          idxToSwap = childTwoIdx;\n        } else {\n          idxToSwap = childOneIdx;\n        }\n        if (heap.get(idxToSwap).num < heap.get(currentIdx).num) {\n          swap(currentIdx, idxToSwap, heap);\n          currentIdx = idxToSwap;\n          childOneIdx = currentIdx * 2 + 1;\n        } else {\n          return;\n        }\n      }\n    }\n\n    public void siftUp(int currentIdx, List<Item> heap) {\n      int parentIdx = (currentIdx - 1) / 2;\n      while (currentIdx > 0\n             && heap.get(currentIdx).num < heap.get(parentIdx).num) {\n        swap(currentIdx, parentIdx, heap);\n        currentIdx = parentIdx;\n        parentIdx = (currentIdx - 1) / 2;\n      }\n    }\n\n    public Item remove() {\n      swap(0, heap.size() - 1, heap);\n      Item valueToRemove = heap.get(heap.size() - 1);\n      heap.remove(heap.size() - 1);\n      siftDown(0, heap.size() - 1, heap);\n      return valueToRemove;\n    }\n\n    public void insert(Item value) {\n      heap.add(value);\n      siftUp(heap.size() - 1, heap);\n    }\n\n    public void swap(int i, int j, List<Item> heap) {\n      Item temp = heap.get(j);\n      heap.set(j, heap.get(i));\n      heap.set(i, temp);\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<List<Integer>> arrays = new ArrayList<List<Integer>>();\n    arrays.add(Arrays.asList(new Integer[] {1, 5, 9, 21}));\n    arrays.add(Arrays.asList(new Integer[] {-1, 0}));\n    arrays.add(Arrays.asList(new Integer[] {-124, 81, 121}));\n    arrays.add(Arrays.asList(new Integer[] {3, 6, 12, 20, 150}));\n    var actual = Program.mergeSortedArrays(arrays);\n    var expected = Arrays.asList(new Integer[] {\n      -124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150});\n    Utils.assertTrue(actual.equals(expected));\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<List<Integer>> arrays = new ArrayList<List<Integer>>();\n    arrays.add(Arrays.asList(new Integer[] {1, 5, 9, 21}));\n    arrays.add(Arrays.asList(new Integer[] {-1, 0}));\n    arrays.add(Arrays.asList(new Integer[] {-124, 81, 121}));\n    arrays.add(Arrays.asList(new Integer[] {3, 6, 12, 20, 150}));\n    var actual = Program.mergeSortedArrays(arrays);\n    var expected = Arrays.asList(new Integer[] {\n      -124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150});\n    Utils.assertTrue(actual.equals(expected));\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function mergeSortedArrays(arrays) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.mergeSortedArrays = mergeSortedArrays;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(nk) time | O(n + k) space - where n is the total\n// number of array elements and k is the number of arrays\nfunction mergeSortedArrays(arrays) {\n  const sortedList = [];\n  const elementIdxs = arrays.map(() => 0);\n  while (true) {\n    const smallestItems = [];\n    for (let arrayIdx = 0; arrayIdx < arrays.length; arrayIdx++) {\n      const relevantArray = arrays[arrayIdx];\n      const elementIdx = elementIdxs[arrayIdx];\n      if (elementIdx === relevantArray.length) continue;\n      smallestItems.push({\n        arrayIdx,\n        num: relevantArray[elementIdx],\n      });\n    }\n    if (smallestItems.length === 0) break;\n    const nextItem = getMinValue(smallestItems);\n    sortedList.push(nextItem.num);\n    elementIdxs[nextItem.arrayIdx]++;\n  }\n  return sortedList;\n}\n\nfunction getMinValue(items) {\n  let minValueIdx = 0;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].num < items[minValueIdx].num) minValueIdx = i;\n  }\n  return items[minValueIdx];\n}\n\nexports.mergeSortedArrays = mergeSortedArrays;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(nlog(k) + k) time | O(n + k) space - where n is the total\n// number of array elements and k is the number of arrays\nfunction mergeSortedArrays(arrays) {\n  const sortedList = [];\n  const smallestItems = [];\n  for (let arrayIdx = 0; arrayIdx < arrays.length; arrayIdx++) {\n    smallestItems.push({\n      arrayIdx,\n      elementIdx: 0,\n      num: arrays[arrayIdx][0],\n    });\n  }\n  const minHeap = new MinHeap(smallestItems);\n  while (!minHeap.isEmpty()) {\n    const smallestItem = minHeap.remove();\n    const {arrayIdx, elementIdx, num} = smallestItem;\n    sortedList.push(num);\n    if (elementIdx === arrays[arrayIdx].length - 1) continue;\n    minHeap.insert({\n      arrayIdx,\n      elementIdx: elementIdx + 1,\n      num: arrays[arrayIdx][elementIdx + 1],\n    });\n  }\n  return sortedList;\n}\n\nclass MinHeap {\n  constructor(array) {\n    this.heap = this.buildHeap(array);\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx].num < heap[childOneIdx].num) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap].num < heap[currentIdx].num) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx].num < heap[parentIdx].num) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  remove() {\n    this.swap(0, this.heap.length - 1, this.heap);\n    const valueToRemove = this.heap.pop();\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return valueToRemove;\n  }\n\n  insert(value) {\n    this.heap.push(value);\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i, j, heap) {\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n}\n\nexports.mergeSortedArrays = mergeSortedArrays;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const arrays = [\n    [1, 5, 9, 21],\n    [-1, 0],\n    [-124, 81, 121],\n    [3, 6, 12, 20, 150],\n  ];\n  const output = program.mergeSortedArrays(arrays);\n  chai.expect(output).to.deep.equal([-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150]);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const arrays = [\n    [1, 5, 9, 21],\n    [-1, 0],\n    [-124, 81, 121],\n    [3, 6, 12, 20, 150],\n  ];\n  const output = program.mergeSortedArrays(arrays);\n  chai.expect(output).to.deep.equal([-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150]);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun mergeSortedArrays(arrays: List<List<Int>>): List<Int> {\n    // Write your code here.\n    return listOf()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class Item(arrayIdx: Int, num: Int) {\n    val arrayIdx = arrayIdx\n    val num = num\n}\n\n// O(nk) time | O(n + k) space - where n is the total\n// number of array elements and k is the number of arrays\nfun mergeSortedArrays(arrays: List<List<Int>>): List<Int> {\n    val sortedList = mutableListOf<Int>()\n    val elementIdxs = arrays.map() { 0 }.toMutableList()\n    while (true) {\n        val smallestItems = mutableListOf<Item>()\n        for (arrayIdx in 0 until arrays.size) {\n            val relevantArray = arrays[arrayIdx]\n            val elementIdx = elementIdxs[arrayIdx]\n            if (elementIdx == relevantArray.size) continue\n            smallestItems.add(Item(arrayIdx, relevantArray[elementIdx]))\n        }\n        if (smallestItems.size == 0) break\n        val nextItem = getMinValue(smallestItems)\n        sortedList.add(nextItem.num)\n        elementIdxs[nextItem.arrayIdx]++\n    }\n    return sortedList\n}\n\nfun getMinValue(items: List<Item>): Item {\n    var minValueIdx = 0\n    for (i in 1 until items.size) {\n        if (items[i].num < items[minValueIdx].num) minValueIdx = i\n    }\n    return items[minValueIdx]\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class Item(arrayIdx: Int, elementIdx: Int, num: Int) {\n    val arrayIdx = arrayIdx\n    val elementIdx = elementIdx\n    val num = num\n}\n\n// O(nlog(k) + k) time | O(n + k) space - where n is the total\n// number of array elements and k is the number of arrays\nfun mergeSortedArrays(arrays: List<List<Int>>): List<Int> {\n    val sortedList = mutableListOf<Int>()\n    val smallestItems = mutableListOf<Item>()\n    for (arrayIdx in 0 until arrays.size) {\n        smallestItems.add(Item(arrayIdx, 0, arrays[arrayIdx][0]))\n    }\n    val minHeap = MinHeap(smallestItems)\n    while (!minHeap.isEmpty()) {\n        val smallestItem = minHeap.remove()!!\n        val arrayIdx = smallestItem.arrayIdx\n        val elementIdx = smallestItem.elementIdx\n        val num = smallestItem.num\n        sortedList.add(num)\n        if (elementIdx == arrays[arrayIdx].size - 1) continue\n        minHeap.insert(Item(arrayIdx, elementIdx + 1, arrays[arrayIdx][elementIdx + 1]))\n    }\n    return sortedList\n}\n\nopen class MinHeap(array: MutableList<Item>) {\n    val heap = this.buildHeap(array)\n\n    fun isEmpty(): Boolean {\n        return this.heap.size == 0\n    }\n\n    fun buildHeap(array: MutableList<Item>): MutableList<Item> {\n        val firstParentIdx = (array.size - 2) / 2\n        for (currentIdx in firstParentIdx downTo 0) {\n            this.siftDown(currentIdx, array.size - 1, array)\n        }\n        return array\n    }\n\n    fun siftDown(currentIdx: Int, endIdx: Int, heap: MutableList<Item>) {\n        var newCurrentIdx = currentIdx\n        var childOneIdx = currentIdx * 2 + 1\n        while (childOneIdx <= endIdx) {\n            var childTwoIdx = if (newCurrentIdx * 2 + 2 <= endIdx) newCurrentIdx * 2 + 2 else -1\n            var idxToSwap: Int\n            if (childTwoIdx != -1 && heap[childTwoIdx].num < heap[childOneIdx].num) {\n                idxToSwap = childTwoIdx\n            } else {\n                idxToSwap = childOneIdx\n            }\n            if (heap[idxToSwap].num < heap[newCurrentIdx].num) {\n                this.swap(newCurrentIdx, idxToSwap, heap)\n                newCurrentIdx = idxToSwap\n                childOneIdx = newCurrentIdx * 2 + 1\n            } else {\n                return\n            }\n        }\n    }\n\n    fun siftUp(currentIdx: Int, heap: MutableList<Item>) {\n        var newCurrentIdx = currentIdx\n        var parentIdx = (currentIdx - 1) / 2\n        while (newCurrentIdx > 0 && heap[newCurrentIdx].num < heap[parentIdx].num) {\n            this.swap(newCurrentIdx, parentIdx, heap)\n            newCurrentIdx = parentIdx\n            parentIdx = (newCurrentIdx - 1) / 2\n        }\n    }\n\n    fun peek(): Item? {\n        return this.heap[0]\n    }\n\n    fun remove(): Item? {\n        this.swap(0, this.heap.size - 1, this.heap)\n        val valueToRemove = this.heap.removeAt(this.heap.size - 1)\n        this.siftDown(0, this.heap.size - 1, this.heap)\n        return valueToRemove\n    }\n\n    fun insert(value: Item) {\n        this.heap.add(value)\n        this.siftUp(this.heap.size - 1, this.heap)\n    }\n\n    fun swap(i: Int, j: Int, heap: MutableList<Item>) {\n        val temp = heap[j]\n        heap[j] = heap[i]\n        heap[i] = temp\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.mergeSortedArrays as mergeSortedArrays\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val arrays = listOf(\n            listOf(1, 5, 9, 21),\n            listOf(-1, 0),\n            listOf(-124, 81, 121),\n            listOf(3, 6, 12, 20, 150),\n        )\n        val output = mergeSortedArrays(arrays)\n        assert(output == listOf(-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150))\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.mergeSortedArrays as mergeSortedArrays\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val arrays = listOf(\n            listOf(1, 5, 9, 21),\n            listOf(-1, 0),\n            listOf(-124, 81, 121),\n            listOf(3, 6, 12, 20, 150),\n        )\n        val output = mergeSortedArrays(arrays)\n        assert(output == listOf(-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150))\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def mergeSortedArrays(arrays):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(nk) time | O(n + k) space - where n is the total\n# number of array elements and k is the number of arrays\ndef mergeSortedArrays(arrays):\n    sortedList = []\n    elementIdxs = [0 for array in arrays]\n    while True:\n        smallestItems = []\n        for arrayIdx in range(len(arrays)):\n            relevantArray = arrays[arrayIdx]\n            elementIdx = elementIdxs[arrayIdx]\n            if elementIdx == len(relevantArray):\n                continue\n            smallestItems.append({\"arrayIdx\": arrayIdx, \"num\": relevantArray[elementIdx]})\n        if len(smallestItems) == 0:\n            break\n        nextItem = getMinValue(smallestItems)\n        sortedList.append(nextItem[\"num\"])\n        elementIdxs[nextItem[\"arrayIdx\"]] += 1\n    return sortedList\n\n\ndef getMinValue(items):\n    minValueIdx = 0\n    for i in range(1, len(items)):\n        if items[i][\"num\"] < items[minValueIdx][\"num\"]:\n            minValueIdx = i\n    return items[minValueIdx]\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(nlog(k) + k) time | O(n + k) space - where n is the total\n# number of array elements and k is the number of arrays\ndef mergeSortedArrays(arrays):\n    sortedList = []\n    smallestItems = []\n    for arrayIdx in range(len(arrays)):\n        smallestItems.append({\"arrayIdx\": arrayIdx, \"elementIdx\": 0, \"num\": arrays[arrayIdx][0]})\n    minHeap = MinHeap(smallestItems)\n    while not minHeap.isEmpty():\n        smallestItem = minHeap.remove()\n        arrayIdx, elementIdx, num = (\n            smallestItem[\"arrayIdx\"],\n            smallestItem[\"elementIdx\"],\n            smallestItem[\"num\"],\n        )\n        sortedList.append(num)\n        if elementIdx == len(arrays[arrayIdx]) - 1:\n            continue\n        minHeap.insert(\n            {\n                \"arrayIdx\": arrayIdx,\n                \"elementIdx\": elementIdx + 1,\n                \"num\": arrays[arrayIdx][elementIdx + 1],\n            }\n        )\n    return sortedList\n\n\nclass MinHeap:\n    def __init__(self, array):\n        self.heap = self.buildHeap(array)\n\n    def isEmpty(self):\n        return len(self.heap) == 0\n\n    def buildHeap(self, array):\n        firstParentIdx = (len(array) - 2) // 2\n        for currentIdx in reversed(range(firstParentIdx + 1)):\n            self.siftDown(currentIdx, len(array) - 1, array)\n        return array\n\n    def siftDown(self, currentIdx, endIdx, heap):\n        childOneIdx = currentIdx * 2 + 1\n        while childOneIdx <= endIdx:\n            childTwoIdx = currentIdx * 2 + 2 if currentIdx * 2 + 2 <= endIdx else -1\n            if childTwoIdx != -1 and heap[childTwoIdx][\"num\"] < heap[childOneIdx][\"num\"]:\n                idxToSwap = childTwoIdx\n            else:\n                idxToSwap = childOneIdx\n            if heap[idxToSwap][\"num\"] < heap[currentIdx][\"num\"]:\n                self.swap(currentIdx, idxToSwap, heap)\n                currentIdx = idxToSwap\n                childOneIdx = currentIdx * 2 + 1\n            else:\n                return\n\n    def siftUp(self, currentIdx, heap):\n        parentIdx = (currentIdx - 1) // 2\n        while currentIdx > 0 and heap[currentIdx][\"num\"] < heap[parentIdx][\"num\"]:\n            self.swap(currentIdx, parentIdx, heap)\n            currentIdx = parentIdx\n            parentIdx = (currentIdx - 1) // 2\n\n    def remove(self):\n        self.swap(0, len(self.heap) - 1, self.heap)\n        valueToRemove = self.heap.pop()\n        self.siftDown(0, len(self.heap) - 1, self.heap)\n        return valueToRemove\n\n    def insert(self, value):\n        self.heap.append(value)\n        self.siftUp(len(self.heap) - 1, self.heap)\n\n    def swap(self, i, j, heap):\n        heap[i], heap[j] = heap[j], heap[i]\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        arrays = [\n            [1, 5, 9, 21],\n            [-1, 0],\n            [-124, 81, 121],\n            [3, 6, 12, 20, 150],\n        ]\n        output = program.mergeSortedArrays(arrays)\n        self.assertEqual(output, [-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150])\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        arrays = [\n            [1, 5, 9, 21],\n            [-1, 0],\n            [-124, 81, 121],\n            [3, 6, 12, 20, 150],\n        ]\n        output = program.mergeSortedArrays(arrays)\n        self.assertEqual(output, [-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150])\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def mergeSortedArrays(arrays)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def mergeSortedArrays(arrays)\n    # Write your code here.\n    return []\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def mergeSortedArrays(arrays)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.mergeSortedArrays\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.mergeSortedArrays\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  static func mergeSortedArrays(_ arrays: [[Int]]) -> [Int] {\n    // Write your code here.\n    return [Int]()\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  struct Item {\n    var arrayIdx: Int\n    var num: Int\n  }\n\n  // O(nk) time | O(n + k) space - where n is the total\n  // number of array elements and k is the number of arrays\n  static func mergeSortedArrays(_ arrays: [[Int]]) -> [Int] {\n    var sortedList = [Int]()\n    var elementIdxs = [Int]()\n    for el in arrays {\n      elementIdxs.append(0)\n    }\n\n    while true {\n      var smallestItems = [Item]()\n      for arrayIdx in 0 ..< arrays.count {\n        var relevantArray = arrays[arrayIdx]\n        var elementIdx = elementIdxs[arrayIdx]\n        if elementIdx == relevantArray.count {\n          continue\n        }\n        smallestItems.append(Item(arrayIdx: arrayIdx, num: relevantArray[elementIdx]))\n      }\n\n      if smallestItems.count == 0 {\n        break\n      }\n      var nextItem = getMinValue(&smallestItems)\n      sortedList.append(nextItem.num)\n      elementIdxs[nextItem.arrayIdx] += 1\n    }\n    return sortedList\n  }\n\n  static func getMinValue(_ items: inout [Item]) -> Item {\n    var minValueItem = items[0]\n    for i in 1 ..< items.count {\n      if items[i].num < minValueItem.num {\n        minValueItem = items[i]\n      }\n    }\n    return minValueItem\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  struct Item {\n    var arrayIdx: Int\n    var elementIdx: Int\n    var num: Int\n  }\n\n  // O(nlog(k) + k) time | O(n + k) space - where n is the total\n  // number of array elements and k is the number of arrays\n  static func mergeSortedArrays(_ arrays: [[Int]]) -> [Int] {\n    var sortedList = [Int]()\n    var smallestItems = [Item]()\n\n    for arrayIdx in 0 ..< arrays.count {\n      smallestItems.append(Item(arrayIdx: arrayIdx, elementIdx: 0, num: arrays[arrayIdx][0]))\n    }\n\n    var mh = MinHeap(array: smallestItems)\n    while mh.length() != 0 {\n      var smallestItem = mh.remove()\n      sortedList.append(smallestItem.num)\n      if smallestItem.elementIdx == arrays[smallestItem.arrayIdx].count - 1 {\n        continue\n      }\n      mh.insert(Item(arrayIdx: smallestItem.arrayIdx, elementIdx: smallestItem.elementIdx + 1,\n                     num: arrays[smallestItem.arrayIdx][smallestItem.elementIdx + 1]))\n    }\n    return sortedList\n  }\n\n  class MinHeap {\n    var heap = [Item]()\n\n    init(array: [Item]) {\n      heap = array\n      buildHeap(array: array)\n    }\n\n    // O(n) time | O(1) space\n    func buildHeap(array: [Item]) {\n      var firstParentIndex = Double((array.count - 2) / 2)\n      firstParentIndex = firstParentIndex.rounded(.down)\n\n      for var currentIndex in (0 ... Int(firstParentIndex)).reversed() {\n        var endIndex = array.count - 1\n        siftDown(currentIndex: currentIndex, endIndex: endIndex)\n      }\n    }\n\n    // O(log(n)) time | O(1) space\n    func siftDown(currentIndex: Int, endIndex: Int) {\n      var childOneIdx = currentIndex * 2 + 1\n      var current = currentIndex\n      while childOneIdx <= endIndex {\n        var childTwoIdx = -1\n        if current * 2 + 2 <= endIndex {\n          childTwoIdx = current * 2 + 2\n        }\n        var indexToSwap = childOneIdx\n        if childTwoIdx > -1, heap[childTwoIdx].num < heap[childOneIdx].num {\n          indexToSwap = childTwoIdx\n        }\n\n        if heap[indexToSwap].num < heap[current].num {\n          swap(firstIndex: current, secondIndex: indexToSwap)\n          current = indexToSwap\n          childOneIdx = current * 2 + 1\n        } else {\n          return\n        }\n      }\n    }\n\n    // O(log(n)) time | O(1) space\n    func siftUp() {\n      var currentIndex = heap.count - 1\n      var parentIndex = (currentIndex - 1) / 2\n\n      while currentIndex > 0 {\n        var current = heap[currentIndex].num\n        var parent = heap[Int(parentIndex)].num\n        if current < parent {\n          swap(firstIndex: currentIndex, secondIndex: parentIndex)\n          currentIndex = parentIndex\n          parentIndex = (currentIndex - 1) / 2\n        } else {\n          return\n        }\n      }\n    }\n\n    // O(1) time | O(1) space\n    func peek() -> Item {\n      return heap[0]\n    }\n\n    // O(log(n)) time | O(1) space\n    func remove() -> Item {\n      var l = heap.count\n      swap(firstIndex: 0, secondIndex: l - 1)\n      var peeked = heap[l - 1]\n      heap.removeLast()\n      siftDown(currentIndex: 0, endIndex: l - 2)\n      return peeked\n    }\n\n    // O(log(n)) time | O(1) space\n    func insert(_ value: Item) {\n      heap.append(value)\n      siftUp()\n    }\n\n    // Generic swap function\n    func swap(firstIndex: Int, secondIndex: Int) {\n      let temp = heap[firstIndex]\n      heap[firstIndex] = heap[secondIndex]\n      heap[secondIndex] = temp\n    }\n\n    func length() -> Int {\n      return heap.count\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var arrays = [\n        [1, 5, 9, 21],\n        [-1, 0],\n        [-124, 81, 121],\n        [3, 6, 12, 20, 150],\n      ]\n      var expected = [-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150]\n      var actual = Program.mergeSortedArrays(arrays)\n      try assert(expected == actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var arrays = [\n        [1, 5, 9, 21],\n        [-1, 0],\n        [-124, 81, 121],\n        [3, 6, 12, 20, 150],\n      ]\n      var expected = [-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150]\n      var actual = Program.mergeSortedArrays(arrays)\n      try assert(expected == actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function mergeSortedArrays(arrays: number[][]) {\n  // Write your code here.\n  return [];\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\ninterface Item {\n  arrayIdx: number;\n  num: number;\n}\n\n// O(nk) time | O(n + k) space - where n is the total\n// number of array elements and k is the number of arrays\nexport function mergeSortedArrays(arrays: number[][]) {\n  const sortedList: number[] = [];\n  const elementIdxs = arrays.map(() => 0);\n  while (true) {\n    const smallestItems: Item[] = [];\n    for (let arrayIdx = 0; arrayIdx < arrays.length; arrayIdx++) {\n      const relevantArray = arrays[arrayIdx];\n      const elementIdx = elementIdxs[arrayIdx];\n      if (elementIdx === relevantArray.length) continue;\n      smallestItems.push({\n        arrayIdx,\n        num: relevantArray[elementIdx],\n      });\n    }\n    if (smallestItems.length === 0) break;\n    const nextItem = getMinValue(smallestItems);\n    sortedList.push(nextItem.num);\n    elementIdxs[nextItem.arrayIdx]++;\n  }\n  return sortedList;\n}\n\nfunction getMinValue(items: Item[]) {\n  let minValueIdx = 0;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].num < items[minValueIdx].num) minValueIdx = i;\n  }\n  return items[minValueIdx];\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\ninterface Item {\n  arrayIdx: number;\n  elementIdx: number;\n  num: number;\n}\n\n// O(nlog(k) + k) time | O(n + k) space - where n is the total\n// number of array elements and k is the number of arrays\nexport function mergeSortedArrays(arrays: number[][]) {\n  const sortedList: number[] = [];\n  const smallestItems: Item[] = [];\n  for (let arrayIdx = 0; arrayIdx < arrays.length; arrayIdx++) {\n    smallestItems.push({\n      arrayIdx,\n      elementIdx: 0,\n      num: arrays[arrayIdx][0],\n    });\n  }\n  const minHeap = new MinHeap(smallestItems);\n  while (!minHeap.isEmpty()) {\n    const smallestItem = minHeap.remove()!;\n    const {arrayIdx, elementIdx, num} = smallestItem;\n    sortedList.push(num);\n    if (elementIdx === arrays[arrayIdx].length - 1) continue;\n    minHeap.insert({\n      arrayIdx,\n      elementIdx: elementIdx + 1,\n      num: arrays[arrayIdx][elementIdx + 1],\n    });\n  }\n  return sortedList;\n}\n\nclass MinHeap {\n  heap: Item[];\n\n  constructor(array: Item[]) {\n    this.heap = this.buildHeap(array);\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  buildHeap(array: Item[]) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  siftDown(currentIdx: number, endIdx: number, heap: Item[]) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx].num < heap[childOneIdx].num) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap].num < heap[currentIdx].num) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  siftUp(currentIdx: number, heap: Item[]) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx].num < heap[parentIdx].num) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  remove() {\n    this.swap(0, this.heap.length - 1, this.heap);\n    const valueToRemove = this.heap.pop();\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return valueToRemove;\n  }\n\n  insert(value: Item) {\n    this.heap.push(value);\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i: number, j: number, heap: Item[]) {\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const arrays = [\n    [1, 5, 9, 21],\n    [-1, 0],\n    [-124, 81, 121],\n    [3, 6, 12, 20, 150],\n  ];\n  const output = program.mergeSortedArrays(arrays);\n  chai.expect(output).to.deep.equal([-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150]);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const arrays = [\n    [1, 5, 9, 21],\n    [-1, 0],\n    [-124, 81, 121],\n    [3, 6, 12, 20, 150],\n  ];\n  const output = program.mergeSortedArrays(arrays);\n  chai.expect(output).to.deep.equal([-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150]);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "arrays",
      "example": [
        [
          1,
          5,
          9,
          21
        ],
        [
          -1,
          0
        ],
        [
          -124,
          81,
          121
        ],
        [
          3,
          6,
          12,
          20,
          150
        ]
      ],
      "schema": {
        "items": {
          "items": {
            "type": "integer"
          },
          "minItems": 1,
          "type": "array"
        },
        "minItems": 1,
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "arrays": [
        [
          1,
          5,
          9,
          21
        ],
        [
          -1,
          0
        ],
        [
          -124,
          81,
          121
        ],
        [
          3,
          6,
          12,
          20,
          150
        ]
      ]
    },
    {
      "arrays": [
        [
          -92,
          -78,
          -68,
          43,
          46,
          46,
          79,
          79
        ],
        [
          -66,
          -49,
          -26,
          -16,
          21,
          28,
          33,
          50
        ],
        [
          -40,
          -8,
          12,
          20,
          36,
          38,
          81
        ],
        [
          -76,
          -74,
          -62,
          -46,
          -23,
          33,
          42,
          48,
          55,
          94
        ]
      ]
    },
    {
      "arrays": [
        [
          -95,
          -74,
          1
        ],
        [
          -28,
          28,
          95
        ],
        [
          -89,
          -78,
          -67,
          -66,
          -25,
          -22,
          2,
          38
        ],
        [
          -86,
          -35,
          -25,
          -13,
          41
        ],
        [
          -85,
          -77,
          -21,
          72
        ],
        [
          -55,
          4,
          84,
          98
        ],
        [
          -75,
          -73,
          22
        ]
      ]
    },
    {
      "arrays": [
        [
          -79,
          -43,
          -15,
          89
        ],
        [
          -48,
          13,
          20
        ],
        [
          -33,
          -19,
          -8,
          12,
          40,
          44,
          50,
          52,
          91,
          95
        ],
        [
          -100,
          -43,
          -8,
          17
        ],
        [
          -15,
          81
        ]
      ]
    },
    {
      "arrays": [
        [
          -88,
          -56,
          -43,
          -41,
          -13,
          -8,
          82
        ],
        [
          -38,
          53
        ],
        [
          -75,
          -48,
          -42,
          -27,
          20,
          35,
          55
        ],
        [
          -55,
          -50,
          -48,
          -45,
          62,
          69,
          77
        ],
        [
          -90,
          -27,
          -22,
          -19,
          -6,
          -3,
          4,
          6,
          91
        ],
        [
          -86,
          -67,
          -66,
          2,
          8,
          8,
          39,
          74
        ],
        [
          -62,
          34,
          40,
          42,
          47,
          48,
          55,
          56,
          68,
          87
        ]
      ]
    },
    {
      "arrays": [
        [
          -93,
          -83,
          -43,
          -32,
          -32,
          -15,
          -14,
          12,
          78,
          80
        ],
        [
          -83
        ],
        [
          -82,
          -51,
          -29,
          40,
          60,
          76,
          80
        ],
        [
          50
        ],
        [
          -33,
          -16
        ],
        [
          -100
        ],
        [
          -33,
          -11,
          23,
          29,
          29,
          43
        ],
        [
          0,
          70
        ],
        [
          -57,
          -43,
          -41,
          -18,
          -5,
          74
        ]
      ]
    },
    {
      "arrays": [
        [
          98
        ],
        [
          -87,
          -79,
          -56,
          -33,
          -20,
          -10,
          -5,
          19,
          49,
          86
        ],
        [
          -73,
          -49
        ],
        [
          -98,
          -63,
          -47,
          -4,
          21
        ],
        [
          -56,
          -43,
          -24,
          8,
          34,
          80,
          83
        ],
        [
          -83,
          -65,
          -61,
          -30,
          -26,
          -16,
          16,
          19
        ],
        [
          -91,
          -42,
          -21,
          91
        ],
        [
          -73,
          -62,
          -56,
          -30,
          11,
          67
        ],
        [
          -91,
          -90,
          -40,
          32,
          94
        ]
      ]
    },
    {
      "arrays": [
        [
          -81,
          36,
          57,
          59
        ],
        [
          -65,
          -58,
          -47,
          -39,
          29,
          53,
          66,
          75,
          88,
          92
        ],
        [
          -67,
          -54,
          -40,
          -25,
          9,
          17,
          55,
          75,
          94
        ],
        [
          -35,
          -3,
          24,
          82
        ],
        [
          -86,
          32,
          95
        ]
      ]
    },
    {
      "arrays": [
        [
          -93,
          -83,
          -78,
          -75,
          -40,
          -32,
          48
        ],
        [
          -90,
          -75,
          -57,
          7,
          11,
          21,
          53,
          84,
          89
        ],
        [
          -50,
          -40,
          -20,
          71,
          96
        ],
        [
          -49,
          13,
          18,
          61,
          97
        ],
        [
          42,
          96
        ]
      ]
    },
    {
      "arrays": [
        [
          -63,
          -55,
          -9,
          37,
          86,
          97
        ],
        [
          -62,
          -48,
          -37,
          -16,
          11,
          33,
          80,
          97
        ],
        [
          -51,
          5,
          34
        ],
        [
          -24,
          -24,
          -19,
          32,
          46,
          97
        ],
        [
          -98,
          -56,
          -12,
          -2,
          -1,
          11,
          47,
          79
        ],
        [
          -59,
          64,
          93,
          96
        ],
        [
          -96,
          -51,
          -21,
          -18,
          29,
          57,
          87,
          90,
          92
        ],
        [
          -89,
          -85,
          -55,
          -12,
          27
        ],
        [
          -96,
          -96,
          -95,
          -95,
          -71,
          -45,
          -28,
          8,
          19,
          100
        ]
      ]
    },
    {
      "arrays": [
        [
          49,
          72
        ],
        [
          -95,
          -49,
          -18,
          -16,
          1,
          16,
          36,
          40,
          75,
          92
        ],
        [
          -77,
          11,
          65,
          91
        ]
      ]
    },
    {
      "arrays": [
        [
          -94,
          -93,
          -25,
          -2,
          67,
          85
        ],
        [
          -83,
          -74,
          64
        ],
        [
          -83,
          10,
          46,
          64
        ],
        [
          -94,
          -54,
          -40,
          9,
          22,
          49
        ]
      ]
    },
    {
      "arrays": [
        [
          -87,
          -67,
          -56,
          -15,
          67
        ],
        [
          -98,
          -90,
          -85,
          -3,
          5,
          43,
          44
        ],
        [
          -97,
          -78,
          -73,
          -65,
          -17,
          27,
          66,
          77,
          78,
          92
        ],
        [
          -99,
          -62,
          11,
          15,
          50
        ]
      ]
    },
    {
      "arrays": [
        [
          -79,
          -77,
          -48,
          -39,
          -27,
          10,
          39,
          61,
          83,
          99
        ],
        [
          -93,
          10
        ],
        [
          -98,
          -90,
          -44,
          -33,
          -5,
          40,
          69,
          90,
          96
        ],
        [
          -93
        ],
        [
          -32,
          9,
          14,
          20,
          85
        ]
      ]
    },
    {
      "arrays": [
        [
          14
        ],
        [
          -88,
          -16,
          26,
          38,
          51,
          62,
          84,
          88
        ]
      ]
    },
    {
      "arrays": [
        [
          -62,
          -54,
          -54,
          31,
          34,
          51
        ],
        [
          -41
        ],
        [
          33,
          34
        ],
        [
          -98,
          68,
          83
        ],
        [
          -25,
          -14
        ]
      ]
    },
    {
      "arrays": [
        [
          -53,
          -16,
          -13,
          -11,
          -6,
          21,
          26,
          35
        ],
        [
          -99,
          -93,
          -62,
          -47,
          -16,
          4,
          55,
          59,
          64,
          76
        ],
        [
          -96,
          -41,
          -8
        ],
        [
          -39,
          -28,
          -4
        ],
        [
          -95,
          -48,
          -45,
          -25,
          63,
          64,
          98
        ],
        [
          -38,
          -32,
          -7,
          82
        ],
        [
          -42,
          25,
          49,
          79,
          86
        ],
        [
          -88,
          -65,
          7,
          8,
          44
        ]
      ]
    },
    {
      "arrays": [
        [
          -33,
          57,
          74
        ],
        [
          -76,
          -72,
          -46,
          -21,
          -16,
          -10,
          16,
          21,
          47,
          67
        ],
        [
          -59,
          -55,
          -47,
          -46,
          -35,
          38
        ],
        [
          -62,
          -25,
          3,
          30,
          46,
          71
        ],
        [
          -91,
          -37,
          -26,
          -12,
          -8,
          2,
          9,
          46,
          56,
          93
        ],
        [
          -58,
          82,
          97
        ]
      ]
    },
    {
      "arrays": [
        [
          -64,
          -51,
          -5,
          1,
          6,
          12,
          27,
          32,
          62,
          88
        ],
        [
          -66,
          -65,
          -60,
          17,
          22
        ],
        [
          -57,
          -7,
          13,
          70,
          79
        ],
        [
          -88,
          -86,
          -73,
          -59,
          -36,
          -12,
          11,
          48,
          58,
          99
        ],
        [
          -71,
          -28
        ],
        [
          21,
          38
        ],
        [
          -55,
          -44,
          -27
        ],
        [
          -96,
          -93,
          -5,
          13
        ],
        [
          -19,
          -11,
          27,
          36,
          43,
          79,
          87
        ],
        [
          -72,
          -53,
          -10,
          1,
          27,
          77,
          88
        ]
      ]
    },
    {
      "arrays": [
        [
          -19,
          33,
          34
        ],
        [
          -94,
          -53,
          -10,
          -3,
          44,
          73
        ],
        [
          27,
          42,
          70,
          86
        ],
        [
          -28,
          91
        ],
        [
          -53,
          -27,
          31,
          77,
          96,
          99
        ]
      ]
    }
  ],
  "jsonTests": [
    {
      "arrays": [
        [
          1,
          5,
          9,
          21
        ],
        [
          -1,
          0
        ],
        [
          -124,
          81,
          121
        ],
        [
          3,
          6,
          12,
          20,
          150
        ]
      ]
    },
    {
      "arrays": [
        [
          -92,
          -78,
          -68,
          43,
          46,
          46,
          79,
          79
        ],
        [
          -66,
          -49,
          -26,
          -16,
          21,
          28,
          33,
          50
        ],
        [
          -40,
          -8,
          12,
          20,
          36,
          38,
          81
        ],
        [
          -76,
          -74,
          -62,
          -46,
          -23,
          33,
          42,
          48,
          55,
          94
        ]
      ]
    },
    {
      "arrays": [
        [
          -95,
          -74,
          1
        ],
        [
          -28,
          28,
          95
        ],
        [
          -89,
          -78,
          -67,
          -66,
          -25,
          -22,
          2,
          38
        ],
        [
          -86,
          -35,
          -25,
          -13,
          41
        ],
        [
          -85,
          -77,
          -21,
          72
        ],
        [
          -55,
          4,
          84,
          98
        ],
        [
          -75,
          -73,
          22
        ]
      ]
    },
    {
      "arrays": [
        [
          -79,
          -43,
          -15,
          89
        ],
        [
          -48,
          13,
          20
        ],
        [
          -33,
          -19,
          -8,
          12,
          40,
          44,
          50,
          52,
          91,
          95
        ],
        [
          -100,
          -43,
          -8,
          17
        ],
        [
          -15,
          81
        ]
      ]
    },
    {
      "arrays": [
        [
          -88,
          -56,
          -43,
          -41,
          -13,
          -8,
          82
        ],
        [
          -38,
          53
        ],
        [
          -75,
          -48,
          -42,
          -27,
          20,
          35,
          55
        ],
        [
          -55,
          -50,
          -48,
          -45,
          62,
          69,
          77
        ],
        [
          -90,
          -27,
          -22,
          -19,
          -6,
          -3,
          4,
          6,
          91
        ],
        [
          -86,
          -67,
          -66,
          2,
          8,
          8,
          39,
          74
        ],
        [
          -62,
          34,
          40,
          42,
          47,
          48,
          55,
          56,
          68,
          87
        ]
      ]
    },
    {
      "arrays": [
        [
          -93,
          -83,
          -43,
          -32,
          -32,
          -15,
          -14,
          12,
          78,
          80
        ],
        [
          -83
        ],
        [
          -82,
          -51,
          -29,
          40,
          60,
          76,
          80
        ],
        [
          50
        ],
        [
          -33,
          -16
        ],
        [
          -100
        ],
        [
          -33,
          -11,
          23,
          29,
          29,
          43
        ],
        [
          0,
          70
        ],
        [
          -57,
          -43,
          -41,
          -18,
          -5,
          74
        ]
      ]
    },
    {
      "arrays": [
        [
          98
        ],
        [
          -87,
          -79,
          -56,
          -33,
          -20,
          -10,
          -5,
          19,
          49,
          86
        ],
        [
          -73,
          -49
        ],
        [
          -98,
          -63,
          -47,
          -4,
          21
        ],
        [
          -56,
          -43,
          -24,
          8,
          34,
          80,
          83
        ],
        [
          -83,
          -65,
          -61,
          -30,
          -26,
          -16,
          16,
          19
        ],
        [
          -91,
          -42,
          -21,
          91
        ],
        [
          -73,
          -62,
          -56,
          -30,
          11,
          67
        ],
        [
          -91,
          -90,
          -40,
          32,
          94
        ]
      ]
    },
    {
      "arrays": [
        [
          -81,
          36,
          57,
          59
        ],
        [
          -65,
          -58,
          -47,
          -39,
          29,
          53,
          66,
          75,
          88,
          92
        ],
        [
          -67,
          -54,
          -40,
          -25,
          9,
          17,
          55,
          75,
          94
        ],
        [
          -35,
          -3,
          24,
          82
        ],
        [
          -86,
          32,
          95
        ]
      ]
    },
    {
      "arrays": [
        [
          -93,
          -83,
          -78,
          -75,
          -40,
          -32,
          48
        ],
        [
          -90,
          -75,
          -57,
          7,
          11,
          21,
          53,
          84,
          89
        ],
        [
          -50,
          -40,
          -20,
          71,
          96
        ],
        [
          -49,
          13,
          18,
          61,
          97
        ],
        [
          42,
          96
        ]
      ]
    },
    {
      "arrays": [
        [
          -63,
          -55,
          -9,
          37,
          86,
          97
        ],
        [
          -62,
          -48,
          -37,
          -16,
          11,
          33,
          80,
          97
        ],
        [
          -51,
          5,
          34
        ],
        [
          -24,
          -24,
          -19,
          32,
          46,
          97
        ],
        [
          -98,
          -56,
          -12,
          -2,
          -1,
          11,
          47,
          79
        ],
        [
          -59,
          64,
          93,
          96
        ],
        [
          -96,
          -51,
          -21,
          -18,
          29,
          57,
          87,
          90,
          92
        ],
        [
          -89,
          -85,
          -55,
          -12,
          27
        ],
        [
          -96,
          -96,
          -95,
          -95,
          -71,
          -45,
          -28,
          8,
          19,
          100
        ]
      ]
    },
    {
      "arrays": [
        [
          49,
          72
        ],
        [
          -95,
          -49,
          -18,
          -16,
          1,
          16,
          36,
          40,
          75,
          92
        ],
        [
          -77,
          11,
          65,
          91
        ]
      ]
    },
    {
      "arrays": [
        [
          -94,
          -93,
          -25,
          -2,
          67,
          85
        ],
        [
          -83,
          -74,
          64
        ],
        [
          -83,
          10,
          46,
          64
        ],
        [
          -94,
          -54,
          -40,
          9,
          22,
          49
        ]
      ]
    },
    {
      "arrays": [
        [
          -87,
          -67,
          -56,
          -15,
          67
        ],
        [
          -98,
          -90,
          -85,
          -3,
          5,
          43,
          44
        ],
        [
          -97,
          -78,
          -73,
          -65,
          -17,
          27,
          66,
          77,
          78,
          92
        ],
        [
          -99,
          -62,
          11,
          15,
          50
        ]
      ]
    },
    {
      "arrays": [
        [
          -79,
          -77,
          -48,
          -39,
          -27,
          10,
          39,
          61,
          83,
          99
        ],
        [
          -93,
          10
        ],
        [
          -98,
          -90,
          -44,
          -33,
          -5,
          40,
          69,
          90,
          96
        ],
        [
          -93
        ],
        [
          -32,
          9,
          14,
          20,
          85
        ]
      ]
    },
    {
      "arrays": [
        [
          14
        ],
        [
          -88,
          -16,
          26,
          38,
          51,
          62,
          84,
          88
        ]
      ]
    },
    {
      "arrays": [
        [
          -62,
          -54,
          -54,
          31,
          34,
          51
        ],
        [
          -41
        ],
        [
          33,
          34
        ],
        [
          -98,
          68,
          83
        ],
        [
          -25,
          -14
        ]
      ]
    },
    {
      "arrays": [
        [
          -53,
          -16,
          -13,
          -11,
          -6,
          21,
          26,
          35
        ],
        [
          -99,
          -93,
          -62,
          -47,
          -16,
          4,
          55,
          59,
          64,
          76
        ],
        [
          -96,
          -41,
          -8
        ],
        [
          -39,
          -28,
          -4
        ],
        [
          -95,
          -48,
          -45,
          -25,
          63,
          64,
          98
        ],
        [
          -38,
          -32,
          -7,
          82
        ],
        [
          -42,
          25,
          49,
          79,
          86
        ],
        [
          -88,
          -65,
          7,
          8,
          44
        ]
      ]
    },
    {
      "arrays": [
        [
          -33,
          57,
          74
        ],
        [
          -76,
          -72,
          -46,
          -21,
          -16,
          -10,
          16,
          21,
          47,
          67
        ],
        [
          -59,
          -55,
          -47,
          -46,
          -35,
          38
        ],
        [
          -62,
          -25,
          3,
          30,
          46,
          71
        ],
        [
          -91,
          -37,
          -26,
          -12,
          -8,
          2,
          9,
          46,
          56,
          93
        ],
        [
          -58,
          82,
          97
        ]
      ]
    },
    {
      "arrays": [
        [
          -64,
          -51,
          -5,
          1,
          6,
          12,
          27,
          32,
          62,
          88
        ],
        [
          -66,
          -65,
          -60,
          17,
          22
        ],
        [
          -57,
          -7,
          13,
          70,
          79
        ],
        [
          -88,
          -86,
          -73,
          -59,
          -36,
          -12,
          11,
          48,
          58,
          99
        ],
        [
          -71,
          -28
        ],
        [
          21,
          38
        ],
        [
          -55,
          -44,
          -27
        ],
        [
          -96,
          -93,
          -5,
          13
        ],
        [
          -19,
          -11,
          27,
          36,
          43,
          79,
          87
        ],
        [
          -72,
          -53,
          -10,
          1,
          27,
          77,
          88
        ]
      ]
    },
    {
      "arrays": [
        [
          -19,
          33,
          34
        ],
        [
          -94,
          -53,
          -10,
          -3,
          44,
          73
        ],
        [
          27,
          42,
          70,
          86
        ],
        [
          -28,
          91
        ],
        [
          -53,
          -27,
          31,
          77,
          96,
          99
        ]
      ]
    }
  ],
  "changelog": []
}