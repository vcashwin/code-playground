{
  "uid": "merging-linked-lists",
  "testStrategy": "JSON",
  "name": "Merging Linked Lists",
  "version": 0,
  "releaseDate": "2022-12-15T00:00:00Z",
  "category": "Linked Lists",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 4236,
    "failureCount": 416
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "768838681",
    "duration": 0,
    "annotations": [],
    "instructor": "Conner Ardman",
    "overviewTime": 0,
    "codeWalkthroughTime": 722
  },
  "prompt": "<div class=\"html\">\n  <p>\n    You're given two Linked Lists of potentially unequal length. These Linked\n    Lists potentially merge at a shared intersection node. Write a function\n    that returns the intersection node or returns <span>None</span> /\n    <span>null</span> if there is no intersection.\n  </p>\n  <p>\n    Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n    a <span>next</span> node pointing to the next node in the list or to\n    <span>None</span> / <span>null</span> if it's the tail of the list.\n  </p>\n  <p>\n    Note: Your function should return an existing node. It should not modify\n    either Linked List, and it should not create any new Linked Lists.\n  </p>\n  <h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">linkedListOne</span> = 2 -> 3 -> 1 -> 4\n<span class=\"CodeEditor-promptParameter\">linkedListTwo</span> = 8 -> 7 -> 1 -> 4\n</pre>\n  <h3>Sample Output</h3>\n<pre>\n1 -> 4 <span class=\"CodeEditor-promptComment\">// The lists intersect at the node with value 1</span>\n</pre>\n  </div>",
  "hints": [
    "<p>\n  All of the nodes after the intersection point of two Linked Lists will be the\n  same.\n</p>\n",
    "\n<p>\n  If the two Linked Lists are of different lengths, then none of the extra nodes\n  of the longer list at the beginning can be the intersection point, since the\n  ends must be the same.\n</p>\n",
    "\n<p>\n  The length of the first list + the distance of the second head from the\n  intersection point will be equal to the length of the second list + the\n  distance of the first head from the intersection point. This can be proven\n  using the information from hints 1 and 2.\n</p>"
  ],
  "spaceTime": "O(n + m) time | O(1) space - where n is the length of the first Linked List and m is the length of the second Linked List",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is an input struct. Do not edit.\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next = nullptr;\n\n  LinkedList(int value) { this->value = value; }\n};\n\nLinkedList* mergingLinkedLists(\n  LinkedList* linkedListOne, LinkedList* linkedListTwo\n) {\n  // Write your code here.\n  return nullptr;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <unordered_set>\nusing namespace std;\n\n// This is an input struct. Do not edit.\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next = nullptr;\n\n  LinkedList(int value) { this->value = value; }\n};\n\n// O(n + m) time | O(n) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nLinkedList* mergingLinkedLists(\n  LinkedList* linkedListOne, LinkedList* linkedListTwo\n) {\n  unordered_set<LinkedList*> listOneNodes;\n\n  LinkedList* currentNodeOne = linkedListOne;\n  while (currentNodeOne != nullptr) {\n    listOneNodes.insert(currentNodeOne);\n    currentNodeOne = currentNodeOne->next;\n  }\n\n  LinkedList* currentNodeTwo = linkedListTwo;\n  while (currentNodeTwo != nullptr) {\n    if (listOneNodes.find(currentNodeTwo) != listOneNodes.end()) {\n      return currentNodeTwo;\n    }\n    currentNodeTwo = currentNodeTwo->next;\n  }\n\n  return nullptr;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <cmath>\nusing namespace std;\n\n// This is an input struct. Do not edit.\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next = nullptr;\n\n  LinkedList(int value) { this->value = value; }\n};\n\n// O(n + m) time | O(1) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nLinkedList* mergingLinkedLists(\n  LinkedList* linkedListOne, LinkedList* linkedListTwo\n) {\n  LinkedList* currentNodeOne = linkedListOne;\n  int countOne = 0;\n  while (currentNodeOne != nullptr) {\n    countOne++;\n    currentNodeOne = currentNodeOne->next;\n  }\n\n  LinkedList* currentNodeTwo = linkedListTwo;\n  int countTwo = 0;\n  while (currentNodeTwo != nullptr) {\n    countTwo++;\n    currentNodeTwo = currentNodeTwo->next;\n  }\n\n  int difference = abs(countTwo - countOne);\n  LinkedList* biggerCurrentNode =\n    countOne > countTwo ? linkedListOne : linkedListTwo;\n  LinkedList* smallerCurrentNode =\n    countOne > countTwo ? linkedListTwo : linkedListOne;\n\n  for (int i = 0; i < difference; i++) {\n    biggerCurrentNode = biggerCurrentNode->next;\n  }\n\n  while (biggerCurrentNode != smallerCurrentNode) {\n    biggerCurrentNode = biggerCurrentNode->next;\n    smallerCurrentNode = smallerCurrentNode->next;\n  }\n\n  return biggerCurrentNode;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <unordered_set>\nusing namespace std;\n\n// This is an input struct. Do not edit.\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next = nullptr;\n\n  LinkedList(int value) { this->value = value; }\n};\n\n// O(n + m) time | O(1) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nLinkedList* mergingLinkedLists(\n  LinkedList* linkedListOne, LinkedList* linkedListTwo\n) {\n  LinkedList* curr = linkedListOne;\n  LinkedList* curr2 = linkedListTwo;\n  while (curr != curr2) {\n    if (curr == nullptr) {\n      curr = linkedListTwo;\n    } else {\n      curr = curr->next;\n    }\n\n    if (curr2 == nullptr) {\n      curr2 = linkedListOne;\n    } else {\n      curr2 = curr2->next;\n    }\n  }\n\n  return curr;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      LinkedList* l1 = new LinkedList(1);\n      l1->next = new LinkedList(2);\n      LinkedList* l2 = new LinkedList(3);\n      l2->next = l1->next;\n      LinkedList* expected = l1->next;\n      auto actual = mergingLinkedLists(l1, l2);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      LinkedList* l1 = new LinkedList(1);\n      l1->next = new LinkedList(2);\n      LinkedList* l2 = new LinkedList(3);\n      l2->next = l1->next;\n      LinkedList* expected = l1->next;\n      auto actual = mergingLinkedLists(l1, l2);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  public LinkedList MergingLinkedLists(\n    LinkedList linkedListOne, LinkedList linkedListTwo\n  ) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  // O(n + m) time | O(n) space - where n is the length of the\n  // first Linked List and m is the length of the second Linked List\n  public LinkedList MergingLinkedLists(\n    LinkedList linkedListOne, LinkedList linkedListTwo\n  ) {\n    HashSet<LinkedList> listOneNodes = new HashSet<LinkedList>();\n\n    LinkedList currentNodeOne = linkedListOne;\n    while (currentNodeOne != null) {\n      listOneNodes.Add(currentNodeOne);\n      currentNodeOne = currentNodeOne.next;\n    }\n\n    LinkedList currentNodeTwo = linkedListTwo;\n    while (currentNodeTwo != null) {\n      if (listOneNodes.Contains(currentNodeTwo)) {\n        return currentNodeTwo;\n      }\n      currentNodeTwo = currentNodeTwo.next;\n    }\n\n    return null;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  // O(n + m) time | O(1) space - where n is the length of the\n  // first Linked List and m is the length of the second Linked List\n  public LinkedList MergingLinkedLists(\n    LinkedList linkedListOne, LinkedList linkedListTwo\n  ) {\n    LinkedList currentNodeOne = linkedListOne;\n    int countOne = 0;\n    while (currentNodeOne != null) {\n      countOne++;\n      currentNodeOne = currentNodeOne.next;\n    }\n\n    LinkedList currentNodeTwo = linkedListTwo;\n    int countTwo = 0;\n    while (currentNodeTwo != null) {\n      countTwo++;\n      currentNodeTwo = currentNodeTwo.next;\n    }\n\n    int difference = Math.Abs(countTwo - countOne);\n    LinkedList biggerCurrentNode =\n      countOne > countTwo ? linkedListOne : linkedListTwo;\n    LinkedList smallerCurrentNode =\n      countOne > countTwo ? linkedListTwo : linkedListOne;\n\n    for (int i = 0; i < difference; i++) {\n      biggerCurrentNode = biggerCurrentNode.next;\n    }\n\n    while (biggerCurrentNode != smallerCurrentNode) {\n      biggerCurrentNode = biggerCurrentNode.next;\n      smallerCurrentNode = smallerCurrentNode.next;\n    }\n\n    return biggerCurrentNode;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  // O(n + m) time | O(1) space - where n is the length of the\n  // first Linked List and m is the length of the second Linked List\n  public LinkedList MergingLinkedLists(\n    LinkedList linkedListOne, LinkedList linkedListTwo\n  ) {\n    LinkedList curr = linkedListOne;\n    LinkedList curr2 = linkedListTwo;\n    while (curr != curr2) {\n      if (curr == null) {\n        curr = linkedListTwo;\n      } else {\n        curr = curr.next;\n      }\n\n      if (curr2 == null) {\n        curr2 = linkedListOne;\n      } else {\n        curr2 = curr2.next;\n      }\n    }\n\n    return curr;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var l1 = new Program.LinkedList(1);\n    l1.next = new Program.LinkedList(2);\n    var l2 = new Program.LinkedList(3);\n    l2.next = l1.next;\n\n    var expected = l1.next;\n    var actual = new Program().MergingLinkedLists(l1, l2);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var l1 = new Program.LinkedList(1);\n    l1.next = new Program.LinkedList(2);\n    var l2 = new Program.LinkedList(3);\n    l2.next = l1.next;\n\n    var expected = l1.next;\n    var actual = new Program().MergingLinkedLists(l1, l2);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is an input struct. Do not edit.\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\nfunc MergingLinkedLists(linkedListOne *LinkedList, linkedListTwo *LinkedList) *LinkedList {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input struct. Do not edit.\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\n// O(n + m) time | O(n) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfunc MergingLinkedLists(linkedListOne *LinkedList, linkedListTwo *LinkedList) *LinkedList {\n\tlistOneNodes := map[*LinkedList]bool{}\n\n\tcurrentNodeOne := linkedListOne\n\tfor currentNodeOne != nil {\n\t\tlistOneNodes[currentNodeOne] = true\n\t\tcurrentNodeOne = currentNodeOne.Next\n\t}\n\n\tcurrentNodeTwo := linkedListTwo\n\tfor currentNodeTwo != nil {\n\t\tif _, found := listOneNodes[currentNodeTwo]; found {\n\t\t\treturn currentNodeTwo\n\t\t}\n\t\tcurrentNodeTwo = currentNodeTwo.Next\n\t}\n\n\treturn nil\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input struct. Do not edit.\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\n// O(n + m) time | O(1) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfunc MergingLinkedLists(linkedListOne *LinkedList, linkedListTwo *LinkedList) *LinkedList {\n\tcurrentNodeOne := linkedListOne\n\tcountOne := 0\n\tfor currentNodeOne != nil {\n\t\tcountOne += 1\n\t\tcurrentNodeOne = currentNodeOne.Next\n\t}\n\n\tcurrentNodeTwo := linkedListTwo\n\tcountTwo := 0\n\tfor currentNodeTwo != nil {\n\t\tcountTwo += 1\n\t\tcurrentNodeTwo = currentNodeTwo.Next\n\t}\n\n\tdifference := abs(countTwo - countOne)\n\tvar biggerCurrentNode, smallerCurrentNode *LinkedList\n\tif countOne > countTwo {\n\t\tbiggerCurrentNode = linkedListOne\n\t\tsmallerCurrentNode = linkedListTwo\n\t} else {\n\t\tbiggerCurrentNode = linkedListTwo\n\t\tsmallerCurrentNode = linkedListOne\n\t}\n\n\tfor i := 0; i < difference; i++ {\n\t\tbiggerCurrentNode = biggerCurrentNode.Next\n\t}\n\n\tfor biggerCurrentNode != smallerCurrentNode {\n\t\tbiggerCurrentNode = biggerCurrentNode.Next\n\t\tsmallerCurrentNode = smallerCurrentNode.Next\n\t}\n\treturn biggerCurrentNode\n}\n\nfunc abs(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input struct. Do not edit.\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\n// O(n + m) time | O(1) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfunc MergingLinkedLists(linkedListOne *LinkedList, linkedListTwo *LinkedList) *LinkedList {\n\tcurr, curr2 := linkedListOne, linkedListTwo\n\n\tfor curr != curr2 {\n\t\tif curr == nil {\n\t\t\tcurr = linkedListTwo\n\t\t} else {\n\t\t\tcurr = curr.Next\n\t\t}\n\n\t\tif curr2 == nil {\n\t\t\tcurr2 = linkedListOne\n\t\t} else {\n\t\t\tcurr2 = curr2.Next\n\t\t}\n\t}\n\treturn curr\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tl1 := &LinkedList{Value: 1}\n\tl1.Next = &LinkedList{Value: 2}\n\tl2 := &LinkedList{Value: 3}\n\tl2.Next = l1.Next\n\n\texpected := l1.Next\n\tactual := MergingLinkedLists(l1, l2)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tl1 := &LinkedList{Value: 1}\n\tl1.Next = &LinkedList{Value: 2}\n\tl2 := &LinkedList{Value: 3}\n\tl2.Next = l1.Next\n\n\texpected := l1.Next\n\tactual := MergingLinkedLists(l1, l2)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  public static class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  public LinkedList mergingLinkedLists(\n    LinkedList linkedListOne, LinkedList linkedListTwo\n  ) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  public static class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  // O(n + m) time | O(n) space - where n is the length of the\n  // first Linked List and m is the length of the second Linked List\n  public LinkedList mergingLinkedLists(\n    LinkedList linkedListOne, LinkedList linkedListTwo\n  ) {\n    Set<LinkedList> listOneNodes = new HashSet<LinkedList>();\n\n    LinkedList currentNodeOne = linkedListOne;\n    while (currentNodeOne != null) {\n      listOneNodes.add(currentNodeOne);\n      currentNodeOne = currentNodeOne.next;\n    }\n\n    LinkedList currentNodeTwo = linkedListTwo;\n    while (currentNodeTwo != null) {\n      if (listOneNodes.contains(currentNodeTwo)) {\n        return currentNodeTwo;\n      }\n      currentNodeTwo = currentNodeTwo.next;\n    }\n\n    return null;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  public static class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  // O(n + m) time | O(1) space - where n is the length of the\n  // first Linked List and m is the length of the second Linked List\n  public LinkedList mergingLinkedLists(\n    LinkedList linkedListOne, LinkedList linkedListTwo\n  ) {\n    LinkedList currentNodeOne = linkedListOne;\n    int countOne = 0;\n    while (currentNodeOne != null) {\n      countOne++;\n      currentNodeOne = currentNodeOne.next;\n    }\n\n    LinkedList currentNodeTwo = linkedListTwo;\n    int countTwo = 0;\n    while (currentNodeTwo != null) {\n      countTwo++;\n      currentNodeTwo = currentNodeTwo.next;\n    }\n\n    int difference = Math.abs(countTwo - countOne);\n    LinkedList biggerCurrentNode =\n      countOne > countTwo ? linkedListOne : linkedListTwo;\n    LinkedList smallerCurrentNode =\n      countOne > countTwo ? linkedListTwo : linkedListOne;\n\n    for (int i = 0; i < difference; i++) {\n      biggerCurrentNode = biggerCurrentNode.next;\n    }\n\n    while (biggerCurrentNode != smallerCurrentNode) {\n      biggerCurrentNode = biggerCurrentNode.next;\n      smallerCurrentNode = smallerCurrentNode.next;\n    }\n\n    return biggerCurrentNode;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  public static class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  // O(n + m) time | O(1) space - where n is the length of the\n  // first Linked List and m is the length of the second Linked List\n  public LinkedList mergingLinkedLists(\n    LinkedList linkedListOne, LinkedList linkedListTwo\n  ) {\n    LinkedList curr = linkedListOne;\n    LinkedList curr2 = linkedListTwo;\n    while (curr != curr2) {\n      if (curr == null) {\n        curr = linkedListTwo;\n      } else {\n        curr = curr.next;\n      }\n\n      if (curr2 == null) {\n        curr2 = linkedListOne;\n      } else {\n        curr2 = curr2.next;\n      }\n    }\n\n    return curr;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var l1 = new Program.LinkedList(1);\n    l1.next = new Program.LinkedList(2);\n    var l2 = new Program.LinkedList(3);\n    l2.next = l1.next;\n\n    var expected = l1.next;\n    var actual = new Program().mergingLinkedLists(l1, l2);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var l1 = new Program.LinkedList(1);\n    l1.next = new Program.LinkedList(2);\n    var l2 = new Program.LinkedList(3);\n    l2.next = l1.next;\n\n    var expected = l1.next;\n    var actual = new Program().mergingLinkedLists(l1, l2);\n    Utils.assertTrue(expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nexports.LinkedList = LinkedList;\n\nfunction mergingLinkedLists(linkedListOne, linkedListTwo) {\n  // Write your code here.\n  return null;\n}\n\n// Do not edit the line below.\nexports.mergingLinkedLists = mergingLinkedLists;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n + m) time | O(n) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfunction mergingLinkedLists(linkedListOne, linkedListTwo) {\n  const listOneNodes = new Set();\n  let currentNodeOne = linkedListOne;\n  while (currentNodeOne !== null) {\n    listOneNodes.add(currentNodeOne);\n    currentNodeOne = currentNodeOne.next;\n  }\n\n  let currentNodeTwo = linkedListTwo;\n  while (currentNodeTwo !== null) {\n    if (listOneNodes.has(currentNodeTwo)) return currentNodeTwo;\n    currentNodeTwo = currentNodeTwo.next;\n  }\n\n  return null;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.mergingLinkedLists = mergingLinkedLists;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n + m) time | O(1) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfunction mergingLinkedLists(linkedListOne, linkedListTwo) {\n  let currentNodeOne = linkedListOne;\n  let countOne = 0;\n  while (currentNodeOne !== null) {\n    countOne++;\n    currentNodeOne = currentNodeOne.next;\n  }\n\n  let currentNodeTwo = linkedListTwo;\n  let countTwo = 0;\n  while (currentNodeTwo !== null) {\n    countTwo++;\n    currentNodeTwo = currentNodeTwo.next;\n  }\n\n  const difference = Math.abs(countTwo - countOne);\n  let biggerCurrentNode = countOne > countTwo ? linkedListOne : linkedListTwo;\n  let smallerCurrentNode = countOne > countTwo ? linkedListTwo : linkedListOne;\n\n  for (let i = 0; i < difference; i++) {\n    biggerCurrentNode = biggerCurrentNode.next;\n  }\n\n  while (biggerCurrentNode !== smallerCurrentNode) {\n    biggerCurrentNode = biggerCurrentNode.next;\n    smallerCurrentNode = smallerCurrentNode.next;\n  }\n\n  return biggerCurrentNode;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.mergingLinkedLists = mergingLinkedLists;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n + m) time | O(1) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfunction mergingLinkedLists(linkedListOne, linkedListTwo) {\n  let currentNodeOne = linkedListOne;\n  let currentNodeTwo = linkedListTwo;\n\n  while (currentNodeOne !== currentNodeTwo) {\n    if (currentNodeOne === null) {\n      currentNodeOne = linkedListTwo;\n    } else {\n      currentNodeOne = currentNodeOne.next;\n    }\n\n    if (currentNodeTwo === null) {\n      currentNodeTwo = linkedListOne;\n    } else {\n      currentNodeTwo = currentNodeTwo.next;\n    }\n  }\n\n  return currentNodeOne;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.mergingLinkedLists = mergingLinkedLists;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const l1 = new program.LinkedList(1);\n  l1.next = new program.LinkedList(2);\n  const l2 = new program.LinkedList(3);\n  l2.next = l1.next;\n\n  const expected = l1.next;\n  const actual = program.mergingLinkedLists(l1, l2);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const l1 = new program.LinkedList(1);\n  l1.next = new program.LinkedList(2);\n  const l2 = new program.LinkedList(3);\n  l2.next = l1.next;\n\n  const expected = l1.next;\n  const actual = program.mergingLinkedLists(l1, l2);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\nfun mergingLinkedLists(linkedListOne: LinkedList, linkedListTwo: LinkedList): LinkedList? {\n    // Write your code here.\n    return LinkedList(-1)\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\n// O(n + m) time | O(n) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfun mergingLinkedLists(linkedListOne: LinkedList, linkedListTwo: LinkedList): LinkedList? {\n    val listOneNodes = mutableSetOf<LinkedList>()\n    var currentNodeOne: LinkedList? = linkedListOne\n    while (currentNodeOne != null) {\n        listOneNodes.add(currentNodeOne)\n        currentNodeOne = currentNodeOne.next\n    }\n\n    var currentNodeTwo: LinkedList? = linkedListTwo\n    while (currentNodeTwo != null) {\n        if (listOneNodes.contains(currentNodeTwo)) return currentNodeTwo\n        currentNodeTwo = currentNodeTwo.next\n    }\n\n    return null\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.abs\n\n// This is an input class. Do not edit.\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\n// O(n + m) time | O(1) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfun mergingLinkedLists(linkedListOne: LinkedList, linkedListTwo: LinkedList): LinkedList? {\n    var currentNodeOne: LinkedList? = linkedListOne\n    var countOne = 0\n    while (currentNodeOne != null) {\n        countOne++\n        currentNodeOne = currentNodeOne.next\n    }\n\n    var currentNodeTwo: LinkedList? = linkedListTwo\n    var countTwo = 0\n    while (currentNodeTwo != null) {\n        countTwo++\n        currentNodeTwo = currentNodeTwo.next\n    }\n\n    val difference = abs(countTwo - countOne)\n    var biggerCurrentNode: LinkedList? = if (countOne > countTwo) linkedListOne else linkedListTwo\n    var smallerCurrentNode: LinkedList? = if (countOne > countTwo) linkedListTwo else linkedListOne\n\n    for (i in 0 until difference) {\n        biggerCurrentNode = biggerCurrentNode!!.next\n    }\n\n    while (biggerCurrentNode != smallerCurrentNode) {\n        biggerCurrentNode = biggerCurrentNode!!.next\n        smallerCurrentNode = smallerCurrentNode!!.next\n    }\n    println(\"bar\")\n\n    return biggerCurrentNode\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\n// O(n + m) time | O(1) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfun mergingLinkedLists(linkedListOne: LinkedList, linkedListTwo: LinkedList): LinkedList? {\n    var currentNodeOne: LinkedList? = linkedListOne\n    var currentNodeTwo: LinkedList? = linkedListTwo\n\n    while (currentNodeOne != currentNodeTwo) {\n        if (currentNodeOne == null) {\n            currentNodeOne = linkedListTwo\n        } else {\n            currentNodeOne = currentNodeOne.next\n        }\n\n        if (currentNodeTwo == null) {\n            currentNodeTwo = linkedListOne\n        } else {\n            currentNodeTwo = currentNodeTwo.next\n        }\n    }\n\n    return currentNodeOne\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.mergingLinkedLists\nimport com.algoexpert.program.LinkedList as LinkedList\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val l1 = LinkedList(1)\n        l1.next = LinkedList(2)\n        val l2 = LinkedList(3)\n        l2.next = l1.next\n\n        val expected = l1.next\n        val output = mergingLinkedLists(l1, l2)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.mergingLinkedLists\nimport com.algoexpert.program.LinkedList as LinkedList\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val l1 = LinkedList(1)\n        l1.next = LinkedList(2)\n        val l2 = LinkedList(3)\n        l2.next = l1.next\n\n        val expected = l1.next\n        val output = mergingLinkedLists(l1, l2)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\ndef mergingLinkedLists(linkedListOne, linkedListTwo):\n    # Write your code here.\n    return None\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\n# O(n + m) time | O(n) space - where n is the length of the\n# first Linked List and m is the length of the second Linked List\ndef mergingLinkedLists(linkedListOne, linkedListTwo):\n    listOneNodes = set()\n    currentNodeOne = linkedListOne\n    while currentNodeOne is not None:\n        listOneNodes.add(currentNodeOne)\n        currentNodeOne = currentNodeOne.next\n\n    currentNodeTwo = linkedListTwo\n    while currentNodeTwo is not None:\n        if currentNodeTwo in listOneNodes:\n            return currentNodeTwo\n        currentNodeTwo = currentNodeTwo.next\n\n    return None\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\n# O(n + m) time | O(1) space - where n is the length of the\n# first Linked List and m is the length of the second Linked List\ndef mergingLinkedLists(linkedListOne, linkedListTwo):\n    currentNodeOne = linkedListOne\n    countOne = 0\n    while currentNodeOne is not None:\n        countOne += 1\n        currentNodeOne = currentNodeOne.next\n\n    currentNodeTwo = linkedListTwo\n    countTwo = 0\n    while currentNodeTwo is not None:\n        countTwo += 1\n        currentNodeTwo = currentNodeTwo.next\n\n    difference = abs(countTwo - countOne)\n    biggerCurrentNode = linkedListOne if countOne > countTwo else linkedListTwo\n    smallerCurrentNode = linkedListTwo if countOne > countTwo else linkedListOne\n\n    for _ in range(difference):\n        biggerCurrentNode = biggerCurrentNode.next\n\n    while biggerCurrentNode is not smallerCurrentNode:\n        biggerCurrentNode = biggerCurrentNode.next\n        smallerCurrentNode = smallerCurrentNode.next\n\n    return biggerCurrentNode\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\n# O(n + m) time | O(1) space - where n is the length of the\n# first Linked List and m is the length of the second Linked List\ndef mergingLinkedLists(linkedListOne, linkedListTwo):\n    currentNodeOne = linkedListOne\n    currentNodeTwo = linkedListTwo\n\n    while currentNodeOne is not currentNodeTwo:\n        if not currentNodeOne:\n            currentNodeOne = linkedListTwo\n        else:\n            currentNodeOne = currentNodeOne.next\n\n        if not currentNodeTwo:\n            currentNodeTwo = linkedListOne\n        else:\n            currentNodeTwo = currentNodeTwo.next\n\n    return currentNodeOne\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        l1 = program.LinkedList(1)\n        l1.next = program.LinkedList(2)\n        l2 = program.LinkedList(3)\n        l2.next = l1.next\n\n        expected = l1.next\n        actual = program.mergingLinkedLists(l1, l2)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        l1 = program.LinkedList(1)\n        l1.next = program.LinkedList(2)\n        l2 = program.LinkedList(3)\n        l2.next = l1.next\n\n        expected = l1.next\n        actual = program.mergingLinkedLists(l1, l2)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "# This is an input struct. Do not edit.\nclass LinkedList\n    attr_accessor :value\n    attr_accessor :next\n\n    def initialize(value)\n        @value = value\n        @next = nil\n    end\nend\n\n\nclass Program\n    def mergingLinkedLists(linkedListOne, linkedListTwo)\n        # Write your code here.\n        return nil\n    end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass LinkedList\n    attr_accessor :value\n    attr_accessor :next\n\n    def initialize(value)\n        @value = value\n        @next = nil\n    end\nend\n\n\nclass Program\n    def mergingLinkedLists(linkedListOne, linkedListTwo)\n        # Write your code here.\n        return nil\n    end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire './program.rb'\n\nclass TestSuite\n    include Assertions\n    def test_1\n        # inputs = ...\n        # output = Program.new.mergingLinkedLists\n        # expected = ...\n        # assertEqual(expected, output)\n    end\nend\n\n",
      "unitTests": "require './program.rb'\n\nclass TestSuite\n    include Assertions\n    def test_1\n        # inputs = ...\n        # output = Program.new.mergingLinkedLists\n        # expected = ...\n        # assertEqual(expected, output)\n    end\nend\n\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class LinkedList: Hashable {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n\n    func hash(into hasher: inout Hasher) {\n      hasher.combine(ObjectIdentifier(self).hashValue)\n    }\n\n    static func == (left: LinkedList, right: LinkedList) -> Bool {\n      return left === right\n    }\n  }\n\n  func mergingLinkedLists(_ linkedListOne: LinkedList, _ linkedListTwo: LinkedList) -> LinkedList? {\n    // Write your code here.\n    return LinkedList(value: -1)\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class LinkedList: Hashable {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n\n    func hash(into hasher: inout Hasher) {\n      hasher.combine(ObjectIdentifier(self).hashValue)\n    }\n\n    static func == (left: LinkedList, right: LinkedList) -> Bool {\n      return left === right\n    }\n  }\n\n  // O(n + m) time | O(n) space - where n is the length of the\n  // first Linked List and m is the length of the second Linked List\n  func mergingLinkedLists(_ linkedListOne: LinkedList, _ linkedListTwo: LinkedList) -> LinkedList? {\n    var listOneNodes = Set<LinkedList>()\n\n    var currentNodeOne: LinkedList? = linkedListOne\n    while currentNodeOne != nil {\n      listOneNodes.insert(currentNodeOne!)\n      currentNodeOne = currentNodeOne!.next\n    }\n\n    var currentNodeTwo: LinkedList? = linkedListTwo\n    while currentNodeTwo != nil {\n      if listOneNodes.contains(currentNodeTwo!) {\n        return currentNodeTwo\n      }\n\n      currentNodeTwo = currentNodeTwo!.next\n    }\n    return nil\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class LinkedList: Hashable {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n\n    func hash(into hasher: inout Hasher) {\n      hasher.combine(ObjectIdentifier(self).hashValue)\n    }\n\n    static func == (left: LinkedList, right: LinkedList) -> Bool {\n      return left === right\n    }\n  }\n\n  // O(n + m) time | O(1) space - where n is the length of the\n  // first Linked List and m is the length of the second Linked List\n  func mergingLinkedLists(_ linkedListOne: LinkedList, _ linkedListTwo: LinkedList) -> LinkedList? {\n    var currentNodeOne: LinkedList? = linkedListOne\n    var countOne = 0\n    while currentNodeOne != nil {\n      countOne += 1\n      currentNodeOne = currentNodeOne!.next\n    }\n\n    var currentNodeTwo: LinkedList? = linkedListTwo\n    var countTwo = 0\n    while currentNodeTwo != nil {\n      countTwo += 1\n      currentNodeTwo = currentNodeTwo!.next\n    }\n\n    let difference = abs(countTwo - countOne)\n    var biggerCurrentNode: LinkedList?\n    var smallerCurrentNode: LinkedList?\n    if countOne > countTwo {\n      biggerCurrentNode = linkedListOne\n      smallerCurrentNode = linkedListTwo\n    } else {\n      biggerCurrentNode = linkedListTwo\n      smallerCurrentNode = linkedListOne\n    }\n\n    for i in 0 ..< difference {\n      biggerCurrentNode = biggerCurrentNode!.next\n    }\n\n    while biggerCurrentNode !== smallerCurrentNode {\n      biggerCurrentNode = biggerCurrentNode!.next\n      smallerCurrentNode = smallerCurrentNode!.next\n    }\n\n    return biggerCurrentNode\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class LinkedList: Hashable {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n\n    func hash(into hasher: inout Hasher) {\n      hasher.combine(ObjectIdentifier(self).hashValue)\n    }\n\n    static func == (left: LinkedList, right: LinkedList) -> Bool {\n      return left === right\n    }\n  }\n\n  // O(n + m) time | O(1) space - where n is the length of the\n  // first Linked List and m is the length of the second Linked List\n  func mergingLinkedLists(_ linkedListOne: LinkedList, _ linkedListTwo: LinkedList) -> LinkedList? {\n    var curr: LinkedList? = linkedListOne\n    var curr2: LinkedList? = linkedListTwo\n    while curr !== curr2 {\n      if curr == nil {\n        curr = linkedListTwo\n      } else {\n        curr = curr!.next\n      }\n\n      if curr2 == nil {\n        curr2 = linkedListOne\n      } else {\n        curr2 = curr2!.next\n      }\n    }\n    return curr\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      var l1 = Program.LinkedList(value: 1)\n      l1.next = Program.LinkedList(value: 2)\n      var l2 = Program.LinkedList(value: 3)\n      l2.next = l1.next\n\n      var expected = l1.next\n      var actual = Program().mergingLinkedLists(l1, l2)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      var l1 = Program.LinkedList(value: 1)\n      l1.next = Program.LinkedList(value: 2)\n      var l2 = Program.LinkedList(value: 3)\n      l2.next = l1.next\n\n      var expected = l1.next\n      var actual = Program().mergingLinkedLists(l1, l2)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nexport function mergingLinkedLists(linkedListOne: LinkedList, linkedListTwo: LinkedList) {\n  // Write your code here.\n  return null;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n + m) time | O(n) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nexport function mergingLinkedLists(linkedListOne: LinkedList, linkedListTwo: LinkedList) {\n  const listOneNodes = new Set<LinkedList>();\n  let currentNodeOne: LinkedList | null = linkedListOne;\n  while (currentNodeOne !== null) {\n    listOneNodes.add(currentNodeOne);\n    currentNodeOne = currentNodeOne.next;\n  }\n\n  let currentNodeTwo: LinkedList | null = linkedListTwo;\n  while (currentNodeTwo !== null) {\n    if (listOneNodes.has(currentNodeTwo)) return currentNodeTwo;\n    currentNodeTwo = currentNodeTwo.next;\n  }\n\n  return null;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n + m) time | O(1) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nexport function mergingLinkedLists(linkedListOne: LinkedList, linkedListTwo: LinkedList) {\n  let currentNodeOne: LinkedList | null = linkedListOne;\n  let countOne = 0;\n  while (currentNodeOne !== null) {\n    countOne++;\n    currentNodeOne = currentNodeOne.next;\n  }\n\n  let currentNodeTwo: LinkedList | null = linkedListTwo;\n  let countTwo = 0;\n  while (currentNodeTwo !== null) {\n    countTwo++;\n    currentNodeTwo = currentNodeTwo.next;\n  }\n\n  const difference = Math.abs(countTwo - countOne);\n  let biggerCurrentNode: LinkedList | null = countOne > countTwo ? linkedListOne : linkedListTwo;\n  let smallerCurrentNode: LinkedList | null = countOne > countTwo ? linkedListTwo : linkedListOne;\n\n  for (let i = 0; i < difference; i++) {\n    biggerCurrentNode = biggerCurrentNode!.next;\n  }\n\n  while (biggerCurrentNode !== smallerCurrentNode) {\n    biggerCurrentNode = biggerCurrentNode!.next;\n    smallerCurrentNode = smallerCurrentNode!.next;\n  }\n\n  return biggerCurrentNode;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n + m) time | O(1) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nexport function mergingLinkedLists(linkedListOne: LinkedList, linkedListTwo: LinkedList) {\n  let currentNodeOne: LinkedList | null = linkedListOne;\n  let currentNodeTwo: LinkedList | null = linkedListTwo;\n\n  while (currentNodeOne !== currentNodeTwo) {\n    if (currentNodeOne === null) {\n      currentNodeOne = linkedListTwo;\n    } else {\n      currentNodeOne = currentNodeOne.next;\n    }\n\n    if (currentNodeTwo === null) {\n      currentNodeTwo = linkedListOne;\n    } else {\n      currentNodeTwo = currentNodeTwo.next;\n    }\n  }\n\n  return currentNodeOne;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const l1 = new program.LinkedList(1);\n  l1.next = new program.LinkedList(2);\n  const l2 = new program.LinkedList(3);\n  l2.next = l1.next;\n\n  const expected = l1.next;\n  const actual = program.mergingLinkedLists(l1, l2);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const l1 = new program.LinkedList(1);\n  l1.next = new program.LinkedList(2);\n  const l2 = new program.LinkedList(3);\n  l2.next = l1.next;\n\n  const expected = l1.next;\n  const actual = program.mergingLinkedLists(l1, l2);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "linkedListOne",
      "example": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      },
      "schema": {
        "description": "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
        "properties": {
          "head": {
            "type": "string"
          },
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "next": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "next"
              ],
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "head",
          "nodes"
        ],
        "type": "object"
      }
    },
    {
      "name": "linkedListTwo",
      "example": {
        "head": "2",
        "nodes": [
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      },
      "schema": {
        "description": "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
        "properties": {
          "head": {
            "type": "string"
          },
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "next": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "next"
              ],
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "head",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      },
      "linkedListTwo": {
        "head": "2",
        "nodes": [
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      },
      "linkedListTwo": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      },
      "linkedListTwo": {
        "head": "4",
        "nodes": [
          {
            "id": "4",
            "next": "2",
            "value": 4
          },
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": null,
            "value": 3
          }
        ]
      },
      "linkedListTwo": {
        "head": "4",
        "nodes": [
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "3",
            "value": 5
          },
          {
            "id": "3",
            "next": null,
            "value": 3
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": null,
            "value": 4
          }
        ]
      },
      "linkedListTwo": {
        "head": "5",
        "nodes": [
          {
            "id": "5",
            "next": "3",
            "value": 5
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": null,
            "value": 4
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      },
      "linkedListTwo": {
        "head": "2",
        "nodes": [
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "1",
            "value": 4
          },
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "5",
        "nodes": [
          {
            "id": "5",
            "next": "12",
            "value": 5
          },
          {
            "id": "12",
            "next": "14",
            "value": 12
          },
          {
            "id": "14",
            "next": "2",
            "value": 14
          },
          {
            "id": "2",
            "next": "13",
            "value": 2
          },
          {
            "id": "13",
            "next": "21",
            "value": 13
          },
          {
            "id": "21",
            "next": "33",
            "value": 21
          },
          {
            "id": "33",
            "next": "9",
            "value": 33
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      },
      "linkedListTwo": {
        "head": "10",
        "nodes": [
          {
            "id": "10",
            "next": "3",
            "value": 10
          },
          {
            "id": "3",
            "next": "48",
            "value": 3
          },
          {
            "id": "48",
            "next": "0",
            "value": 48
          },
          {
            "id": "0",
            "next": "13",
            "value": 0
          },
          {
            "id": "13",
            "next": "21",
            "value": 13
          },
          {
            "id": "21",
            "next": "33",
            "value": 21
          },
          {
            "id": "33",
            "next": "9",
            "value": 33
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      },
      "linkedListTwo": {
        "head": "3",
        "nodes": [
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": null,
            "value": 4
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      },
      "linkedListTwo": {
        "head": "3",
        "nodes": [
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": null,
            "value": 6
          }
        ]
      }
    }
  ],
  "jsonTests": [
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      },
      "linkedListTwo": {
        "head": "2",
        "nodes": [
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      },
      "linkedListTwo": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      },
      "linkedListTwo": {
        "head": "4",
        "nodes": [
          {
            "id": "4",
            "next": "2",
            "value": 4
          },
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": null,
            "value": 3
          }
        ]
      },
      "linkedListTwo": {
        "head": "4",
        "nodes": [
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "3",
            "value": 5
          },
          {
            "id": "3",
            "next": null,
            "value": 3
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": null,
            "value": 4
          }
        ]
      },
      "linkedListTwo": {
        "head": "5",
        "nodes": [
          {
            "id": "5",
            "next": "3",
            "value": 5
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": null,
            "value": 4
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      },
      "linkedListTwo": {
        "head": "2",
        "nodes": [
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "1",
            "value": 4
          },
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "5",
        "nodes": [
          {
            "id": "5",
            "next": "12",
            "value": 5
          },
          {
            "id": "12",
            "next": "14",
            "value": 12
          },
          {
            "id": "14",
            "next": "2",
            "value": 14
          },
          {
            "id": "2",
            "next": "13",
            "value": 2
          },
          {
            "id": "13",
            "next": "21",
            "value": 13
          },
          {
            "id": "21",
            "next": "33",
            "value": 21
          },
          {
            "id": "33",
            "next": "9",
            "value": 33
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      },
      "linkedListTwo": {
        "head": "10",
        "nodes": [
          {
            "id": "10",
            "next": "3",
            "value": 10
          },
          {
            "id": "3",
            "next": "48",
            "value": 3
          },
          {
            "id": "48",
            "next": "0",
            "value": 48
          },
          {
            "id": "0",
            "next": "13",
            "value": 0
          },
          {
            "id": "13",
            "next": "21",
            "value": 13
          },
          {
            "id": "21",
            "next": "33",
            "value": 21
          },
          {
            "id": "33",
            "next": "9",
            "value": 33
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      },
      "linkedListTwo": {
        "head": "3",
        "nodes": [
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": null,
            "value": 4
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      },
      "linkedListTwo": {
        "head": "3",
        "nodes": [
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": null,
            "value": 6
          }
        ]
      }
    }
  ],
  "changelog": []
}