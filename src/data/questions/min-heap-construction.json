{
  "uid": "min-heap-construction",
  "testStrategy": "JSON",
  "name": "Min Heap Construction",
  "version": 0,
  "releaseDate": "2000-05-04T00:00:00Z",
  "category": "Heaps",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 18470,
    "failureCount": 7869
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "228208211",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 2366
  },
  "prompt": "<div class=\"html\">\n<p>Implement a <span>MinHeap</span> class that supports:</p>\n<ul>\n  <li>Building a Min Heap from an input array of integers.</li>\n  <li>Inserting integers in the heap.</li>\n  <li>Removing the heap's minimum / root value.</li>\n  <li>Peeking at the heap's minimum / root value.</li>\n  <li>\n    Sifting integers up and down the heap, which is to be used when inserting\n    and removing values.\n  </li>\n</ul>\n<p>Note that the heap should be represented in the form of an array.</p>\n<p>\n  If you're unfamiliar with Min Heaps, we recommend watching the\n  Conceptual Overview section of this question's video explanation before\n  starting to code.\n</p>\n<h3>Sample Usage</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">array</span> = [48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41]\n\n<span class=\"CodeEditor-promptComment\">// All operations below are performed sequentially.</span>\n<span class=\"CodeEditor-promptParameter\">MinHeap</span>(array): - <span class=\"CodeEditor-promptComment\">// instantiate a MinHeap (calls the buildHeap method and populates the heap)</span>\n<span class=\"CodeEditor-promptParameter\">buildHeap</span>(array): - <span class=\"CodeEditor-promptComment\">[-5, 2, 6, 7, 8, 8, 24, 391, 24, 56, 12, 24, 48, 41]</span>\n<span class=\"CodeEditor-promptParameter\">insert</span>(76): - <span class=\"CodeEditor-promptComment\">[-5, 2, 6, 7, 8, 8, 24, 391, 24, 56, 12, 24, 48, 41, 76]</span>\n<span class=\"CodeEditor-promptParameter\">peek</span>(): -5\n<span class=\"CodeEditor-promptParameter\">remove</span>(): -5 <span class=\"CodeEditor-promptComment\">[2, 7, 6, 24, 8, 8, 24, 391, 76, 56, 12, 24, 48, 41]</span>\n<span class=\"CodeEditor-promptParameter\">peek</span>(): 2\n<span class=\"CodeEditor-promptParameter\">remove</span>(): 2 <span class=\"CodeEditor-promptComment\">[6, 7, 8, 24, 8, 24, 24, 391, 76, 56, 12, 41, 48]</span>\n<span class=\"CodeEditor-promptParameter\">peek</span>(): 6\n<span class=\"CodeEditor-promptParameter\">insert</span>(87): - <span class=\"CodeEditor-promptComment\">[6, 7, 8, 24, 8, 24, 24, 391, 76, 56, 12, 41, 48, 87]</span>\n</pre>\n</div>",
  "hints": [
    "<p>\nFor the buildHeap(), remove(), and insert() methods of the Heap, you will need to use the siftDown() and siftUp() methods. These two methods should essentially allow you to take any node in the heap and move it either down or up in the heap until it's in its final, appropriate position. This can be done by comparing the node in question to its child nodes in the case of siftDown() or to its parent node in the case of siftUp().\n</p>\n",
    "\n<p>\nIn an array-based Heap, you can easily access a node's children nodes and parent node by using the nodes' indices. If a node is located at index i, then its children nodes are located at indices 2 * i + 1 and 2 * i + 2, and its parent node is located at index Math.floor((i - 1) / 2).\n</p>\n",
    "\n<p>\nTo implement the buildHeap() method, you can either sift every node in the input array down to its final, correct position, or you can sift every node in the input array up to its final, correct position. What are the runtime implications of both approaches? Which methods (siftDown() or siftUp()) will insert() and remove() utilize? What about peek()?\n</p>"
  ],
  "spaceTime": "BuildHeap: O(n) time | O(1) space - where n is the length of the input array\nSiftDown: O(log(n)) time | O(1) space - where n is the length of the heap\nSiftUp: O(log(n)) time | O(1) space - where n is the length of the heap\nPeek: O(1) | O(1)\nRemove: O(log(n)) time | O(1) space - where n is the length of the heap\nInsert: O(log(n)) time | O(1) space - where n is the length of the heap",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\n// Do not edit the class below except for the buildHeap,\n// siftDown, siftUp, peek, remove, and insert methods.\n// Feel free to add new properties and methods to the class.\nclass MinHeap {\n public:\n  vector<int> heap;\n\n  MinHeap(vector<int> vector) { heap = buildHeap(vector); }\n\n  vector<int> buildHeap(vector<int>& vector) {\n    // Write your code here.\n    return {};\n  }\n\n  void siftDown(int currentIdx, int endIdx, vector<int>& heap) {\n    // Write your code here.\n  }\n\n  void siftUp(int currentIdx, vector<int>& heap) {\n    // Write your code here.\n  }\n\n  int peek() {\n    // Write your code here.\n    return -1;\n  }\n\n  int remove() {\n    // Write your code here.\n    return -1;\n  }\n\n  void insert(int value) {\n    // Write your code here.\n  }\n};\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nclass MinHeap {\n public:\n  vector<int> heap;\n\n  MinHeap(vector<int> vector) { heap = buildHeap(vector); }\n\n  // O(n) time | O(1) space\n  vector<int> buildHeap(vector<int>& vector) {\n    int firstParentIdx = (vector.size() - 2) / 2;\n    for (int currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      siftDown(currentIdx, vector.size() - 1, vector);\n    }\n    return vector;\n  }\n\n  // O(log(n)) time | O(1) space\n  void siftDown(int currentIdx, int endIdx, vector<int>& heap) {\n    int childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      int childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      int idxToSwap;\n      if (childTwoIdx != -1 && heap[childTwoIdx] < heap[childOneIdx]) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap] < heap[currentIdx]) {\n        swap(heap[currentIdx], heap[idxToSwap]);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  void siftUp(int currentIdx) {\n    int parentIdx = (currentIdx - 1) / 2;\n    while (currentIdx > 0 && heap[currentIdx] < heap[parentIdx]) {\n      swap(heap[currentIdx], heap[parentIdx]);\n      currentIdx = parentIdx;\n      parentIdx = (currentIdx - 1) / 2;\n    }\n  }\n\n  int peek() { return heap[0]; }\n\n  int remove() {\n    swap(heap[0], heap[heap.size() - 1]);\n    int valueToRemove = heap.back();\n    heap.pop_back();\n    siftDown(0, heap.size() - 1, heap);\n    return valueToRemove;\n  }\n\n  void insert(int value) {\n    heap.push_back(value);\n    siftUp(heap.size() - 1);\n  }\n};\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include <algorithm>\n\nbool isMinHeapPropertySatisfied(vector<int> array) {\n  for (int currentIdx = 1; currentIdx < array.size(); currentIdx++) {\n    int parentIdx = (currentIdx - 1) / 2;\n    if (parentIdx < 0) {\n      return true;\n    }\n    if (array[parentIdx] > array[currentIdx]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      MinHeap minHeap({48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41});\n      minHeap.insert(76);\n      assert(isMinHeapPropertySatisfied(minHeap.heap));\n      assert(minHeap.peek() == -5);\n      assert(minHeap.remove() == -5);\n      assert(isMinHeapPropertySatisfied(minHeap.heap));\n      assert(minHeap.peek() == 2);\n      assert(minHeap.remove() == 2);\n      assert(isMinHeapPropertySatisfied(minHeap.heap));\n      assert(minHeap.peek() == 6);\n      minHeap.insert(87);\n      assert(isMinHeapPropertySatisfied(minHeap.heap));\n    });\n  }\n};\n",
      "unitTests": "#include <algorithm>\n\nbool isMinHeapPropertySatisfied(vector<int> array) {\n  for (int currentIdx = 1; currentIdx < array.size(); currentIdx++) {\n    int parentIdx = (currentIdx - 1) / 2;\n    if (parentIdx < 0) {\n      return true;\n    }\n    if (array[parentIdx] > array[currentIdx]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      MinHeap minHeap({48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41});\n      minHeap.insert(76);\n      assert(isMinHeapPropertySatisfied(minHeap.heap));\n      assert(minHeap.peek() == -5);\n      assert(minHeap.remove() == -5);\n      assert(isMinHeapPropertySatisfied(minHeap.heap));\n      assert(minHeap.peek() == 2);\n      assert(minHeap.remove() == 2);\n      assert(isMinHeapPropertySatisfied(minHeap.heap));\n      assert(minHeap.peek() == 6);\n      minHeap.insert(87);\n      assert(isMinHeapPropertySatisfied(minHeap.heap));\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\nusing System.Collections.Generic;\n\n// Do not edit the class below except for the buildHeap,\n// siftDown, siftUp, Peek, Remove, and Insert methods.\n// Feel free to add new properties and methods to the class.\npublic class Program {\n  public class MinHeap {\n    public List<int> heap = new List<int>();\n\n    public MinHeap(List<int> array) {\n      heap = buildHeap(array);\n    }\n\n    public List<int> buildHeap(List<int> array) {\n      // Write your code here.\n      return new List<int>();\n    }\n\n    public void siftDown(int currentIdx, int endIdx, List<int> heap) {\n      // Write your code here.\n    }\n\n    public void siftUp(int currentIdx, List<int> heap) {\n      // Write your code here.\n    }\n\n    public int Peek() {\n      // Write your code here.\n      return -1;\n    }\n\n    public int Remove() {\n      // Write your code here.\n      return -1;\n    }\n\n    public void Insert(int value) {\n      // Write your code here.\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  public class MinHeap {\n    public List<int> heap = new List<int>();\n\n    public MinHeap(List<int> array) {\n      heap = buildHeap(array);\n    }\n\n    // O(n) time | O(1) space\n    public List<int> buildHeap(List<int> array) {\n      int firstParentIdx = (array.Count - 2) / 2;\n      for (int currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n        siftDown(currentIdx, array.Count - 1, array);\n      }\n      return array;\n    }\n\n    // O(log(n)) time | O(1) space\n    public void siftDown(int currentIdx, int endIdx, List<int> heap) {\n      int childOneIdx = currentIdx * 2 + 1;\n      while (childOneIdx <= endIdx) {\n        int childTwoIdx =\n          currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n        int idxToSwap;\n        if (childTwoIdx != -1 && heap[childTwoIdx] < heap[childOneIdx]) {\n          idxToSwap = childTwoIdx;\n        } else {\n          idxToSwap = childOneIdx;\n        }\n        if (heap[idxToSwap] < heap[currentIdx]) {\n          swap(currentIdx, idxToSwap, heap);\n          currentIdx = idxToSwap;\n          childOneIdx = currentIdx * 2 + 1;\n        } else {\n          return;\n        }\n      }\n    }\n\n    // O(log(n)) time | O(1) space\n    public void siftUp(int currentIdx, List<int> heap) {\n      int parentIdx = (currentIdx - 1) / 2;\n      while (currentIdx > 0 && heap[currentIdx] < heap[parentIdx]) {\n        swap(currentIdx, parentIdx, heap);\n        currentIdx = parentIdx;\n        parentIdx = (currentIdx - 1) / 2;\n      }\n    }\n\n    public int Peek() {\n      return heap[0];\n    }\n\n    public int Remove() {\n      swap(0, heap.Count - 1, heap);\n      int valueToRemove = heap[heap.Count - 1];\n      heap.RemoveAt(heap.Count - 1);\n      siftDown(0, heap.Count - 1, heap);\n      return valueToRemove;\n    }\n\n    public void Insert(int value) {\n      heap.Add(value);\n      siftUp(heap.Count - 1, heap);\n    }\n\n    public void swap(int i, int j, List<int> heap) {\n      int temp = heap[j];\n      heap[j] = heap[i];\n      heap[i] = temp;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.MinHeap minHeap = new Program.MinHeap(new List<int>(\n    ) { 48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41 });\n    minHeap.Insert(76);\n    Utils.AssertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n    Utils.AssertTrue(minHeap.Peek() == -5);\n    Utils.AssertTrue(minHeap.Remove() == -5);\n    Utils.AssertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n    Utils.AssertTrue(minHeap.Peek() == 2);\n    Utils.AssertTrue(minHeap.Remove() == 2);\n    Utils.AssertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n    Utils.AssertTrue(minHeap.Peek() == 6);\n    minHeap.Insert(87);\n    Utils.AssertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n  }\n\n  bool isMinHeapPropertySatisfied(List<int> array) {\n    for (int currentIdx = 1; currentIdx < array.Count; currentIdx++) {\n      int parentIdx = (currentIdx - 1) / 2;\n      if (parentIdx < 0) {\n        return true;\n      }\n      if (array[parentIdx] > array[currentIdx]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n",
      "unitTests": "using System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.MinHeap minHeap = new Program.MinHeap(new List<int>(\n    ) { 48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41 });\n    minHeap.Insert(76);\n    Utils.AssertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n    Utils.AssertTrue(minHeap.Peek() == -5);\n    Utils.AssertTrue(minHeap.Remove() == -5);\n    Utils.AssertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n    Utils.AssertTrue(minHeap.Peek() == 2);\n    Utils.AssertTrue(minHeap.Remove() == 2);\n    Utils.AssertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n    Utils.AssertTrue(minHeap.Peek() == 6);\n    minHeap.Insert(87);\n    Utils.AssertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n  }\n\n  bool isMinHeapPropertySatisfied(List<int> array) {\n    for (int currentIdx = 1; currentIdx < array.Count; currentIdx++) {\n      int parentIdx = (currentIdx - 1) / 2;\n      if (parentIdx < 0) {\n        return true;\n      }\n      if (array[parentIdx] > array[currentIdx]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// Do not edit the class below except for the buildHeap,\n// siftDown, siftUp, peek, remove, and insert methods.\n// Feel free to add new properties and methods to the class.\ntype MinHeap []int\n\nfunc NewMinHeap(array []int) *MinHeap {\n\t// Do not edit the lines below.\n\theap := MinHeap(array)\n\tptr := &heap\n\tptr.BuildHeap(array)\n\treturn ptr\n}\n\nfunc (h *MinHeap) BuildHeap(array []int) {\n\t// Write your code here.\n}\n\nfunc (h *MinHeap) siftDown(currentIndex, endIndex int) {\n\t// Write your code here.\n}\n\nfunc (h *MinHeap) siftUp() {\n\t// Write your code here.\n}\n\nfunc (h MinHeap) Peek() int {\n\t// Write your code here.\n\treturn -1\n}\n\nfunc (h *MinHeap) Remove() int {\n\t// Write your code here.\n\treturn -1\n}\n\nfunc (h *MinHeap) Insert(value int) {\n\t// Write your code here.\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype MinHeap []int\n\nfunc NewMinHeap(array []int) *MinHeap {\n\theap := MinHeap(array)\n\tptr := &heap\n\tptr.BuildHeap(array)\n\treturn ptr\n}\n\n// O(n) time | O(1) space\nfunc (h *MinHeap) BuildHeap(array []int) {\n\tfirst := (len(array) - 2) / 2\n\tfor currentIndex := first + 1; currentIndex >= 0; currentIndex-- {\n\t\th.siftDown(currentIndex, len(array)-1)\n\t}\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) siftDown(currentIndex, endIndex int) {\n\tchildOneIdx := currentIndex*2 + 1\n\tfor childOneIdx <= endIndex {\n\t\tchildTwoIdx := -1\n\t\tif currentIndex*2+2 <= endIndex {\n\t\t\tchildTwoIdx = currentIndex*2 + 2\n\t\t}\n\t\tindexToSwap := childOneIdx\n\t\tif childTwoIdx > -1 && (*h)[childTwoIdx] < (*h)[childOneIdx] {\n\t\t\tindexToSwap = childTwoIdx\n\t\t}\n\t\tif (*h)[indexToSwap] < (*h)[currentIndex] {\n\t\t\th.swap(currentIndex, indexToSwap)\n\t\t\tcurrentIndex = indexToSwap\n\t\t\tchildOneIdx = currentIndex*2 + 1\n\t\t} else {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) siftUp() {\n\tcurrentIndex := h.length() - 1\n\tparentIndex := (currentIndex - 1) / 2\n\tfor currentIndex > 0 {\n\t\tcurrent, parent := (*h)[currentIndex], (*h)[parentIndex]\n\t\tif current < parent {\n\t\t\th.swap(currentIndex, parentIndex)\n\t\t\tcurrentIndex = parentIndex\n\t\t\tparentIndex = (currentIndex - 1) / 2\n\t\t} else {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// O(1) time | O(1) space\nfunc (h MinHeap) Peek() int {\n\tif len(h) == 0 {\n\t\treturn -1\n\t}\n\treturn h[0]\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) Remove() int {\n\tl := h.length()\n\th.swap(0, l-1)\n\tpeeked := (*h)[l-1]\n\t*h = (*h)[0 : l-1]\n\th.siftDown(0, l-2)\n\treturn peeked\n}\n\n// O(log(n)) time | O(1) space\nfunc (h *MinHeap) Insert(value int) {\n\t*h = append(*h, value)\n\th.siftUp()\n}\n\nfunc (h MinHeap) swap(i, j int) {\n\th[i], h[j] = h[j], h[i]\n}\n\nfunc (h MinHeap) length() int {\n\treturn len(h)\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport \"github.com/stretchr/testify/require\"\n\nfunc isMinHeapPropertySatisfied(heap MinHeap) bool {\n\tfor i := 1; i < len(heap); i++ {\n\t\tparentIdx := (i - 1) / 2\n\t\tif parentIdx < 0 {\n\t\t\treturn true\n\t\t}\n\n\t\tif heap[parentIdx] > heap[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tvar minHeap = NewMinHeap([]int{48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41})\n\tminHeap.Insert(76)\n\trequire.Equal(t, true, isMinHeapPropertySatisfied(*minHeap))\n\trequire.Equal(t, -5, minHeap.Peek())\n\trequire.Equal(t, -5, minHeap.Remove())\n\trequire.Equal(t, true, isMinHeapPropertySatisfied(*minHeap))\n\trequire.Equal(t, 2, minHeap.Peek())\n\trequire.Equal(t, 2, minHeap.Remove())\n\trequire.Equal(t, true, isMinHeapPropertySatisfied(*minHeap))\n\trequire.Equal(t, 6, minHeap.Peek())\n\tminHeap.Insert(87)\n\trequire.Equal(t, true, isMinHeapPropertySatisfied(*minHeap))\n}\n",
      "unitTests": "package main\n\nimport \"github.com/stretchr/testify/require\"\n\nfunc isMinHeapPropertySatisfied(heap MinHeap) bool {\n\tfor i := 1; i < len(heap); i++ {\n\t\tparentIdx := (i - 1) / 2\n\t\tif parentIdx < 0 {\n\t\t\treturn true\n\t\t}\n\n\t\tif heap[parentIdx] > heap[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tvar minHeap = NewMinHeap([]int{48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41})\n\tminHeap.Insert(76)\n\trequire.Equal(t, true, isMinHeapPropertySatisfied(*minHeap))\n\trequire.Equal(t, -5, minHeap.Peek())\n\trequire.Equal(t, -5, minHeap.Remove())\n\trequire.Equal(t, true, isMinHeapPropertySatisfied(*minHeap))\n\trequire.Equal(t, 2, minHeap.Peek())\n\trequire.Equal(t, 2, minHeap.Remove())\n\trequire.Equal(t, true, isMinHeapPropertySatisfied(*minHeap))\n\trequire.Equal(t, 6, minHeap.Peek())\n\tminHeap.Insert(87)\n\trequire.Equal(t, true, isMinHeapPropertySatisfied(*minHeap))\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\n// Do not edit the class below except for the buildHeap,\n// siftDown, siftUp, peek, remove, and insert methods.\n// Feel free to add new properties and methods to the class.\nclass Program {\n  static class MinHeap {\n    List<Integer> heap = new ArrayList<Integer>();\n\n    public MinHeap(List<Integer> array) {\n      heap = buildHeap(array);\n    }\n\n    public List<Integer> buildHeap(List<Integer> array) {\n      // Write your code here.\n      return new ArrayList<Integer>();\n    }\n\n    public void siftDown(int currentIdx, int endIdx, List<Integer> heap) {\n      // Write your code here.\n    }\n\n    public void siftUp(int currentIdx, List<Integer> heap) {\n      // Write your code here.\n    }\n\n    public int peek() {\n      // Write your code here.\n      return -1;\n    }\n\n    public int remove() {\n      // Write your code here.\n      return -1;\n    }\n\n    public void insert(int value) {\n      // Write your code here.\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  static class MinHeap {\n    List<Integer> heap = new ArrayList<Integer>();\n\n    public MinHeap(List<Integer> array) {\n      heap = buildHeap(array);\n    }\n\n    // O(n) time | O(1) space\n    public List<Integer> buildHeap(List<Integer> array) {\n      int firstParentIdx = (array.size() - 2) / 2;\n      for (int currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n        siftDown(currentIdx, array.size() - 1, array);\n      }\n      return array;\n    }\n\n    // O(log(n)) time | O(1) space\n    public void siftDown(int currentIdx, int endIdx, List<Integer> heap) {\n      int childOneIdx = currentIdx * 2 + 1;\n      while (childOneIdx <= endIdx) {\n        int childTwoIdx =\n          currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n        int idxToSwap;\n        if (childTwoIdx != -1 && heap.get(childTwoIdx) < heap.get(childOneIdx)) {\n          idxToSwap = childTwoIdx;\n        } else {\n          idxToSwap = childOneIdx;\n        }\n        if (heap.get(idxToSwap) < heap.get(currentIdx)) {\n          swap(currentIdx, idxToSwap, heap);\n          currentIdx = idxToSwap;\n          childOneIdx = currentIdx * 2 + 1;\n        } else {\n          return;\n        }\n      }\n    }\n\n    // O(log(n)) time | O(1) space\n    public void siftUp(int currentIdx, List<Integer> heap) {\n      int parentIdx = (currentIdx - 1) / 2;\n      while (currentIdx > 0 && heap.get(currentIdx) < heap.get(parentIdx)) {\n        swap(currentIdx, parentIdx, heap);\n        currentIdx = parentIdx;\n        parentIdx = (currentIdx - 1) / 2;\n      }\n    }\n\n    public int peek() {\n      return heap.get(0);\n    }\n\n    public int remove() {\n      swap(0, heap.size() - 1, heap);\n      int valueToRemove = heap.get(heap.size() - 1);\n      heap.remove(heap.size() - 1);\n      siftDown(0, heap.size() - 1, heap);\n      return valueToRemove;\n    }\n\n    public void insert(int value) {\n      heap.add(value);\n      siftUp(heap.size() - 1, heap);\n    }\n\n    public void swap(int i, int j, List<Integer> heap) {\n      Integer temp = heap.get(j);\n      heap.set(j, heap.get(i));\n      heap.set(i, temp);\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.MinHeap minHeap = new Program.MinHeap(new ArrayList<Integer>(\n      Arrays.asList(48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41)\n    ));\n    minHeap.insert(76);\n    Utils.assertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n    Utils.assertTrue(minHeap.peek() == -5);\n    Utils.assertTrue(minHeap.remove() == -5);\n    Utils.assertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n    Utils.assertTrue(minHeap.peek() == 2);\n    Utils.assertTrue(minHeap.remove() == 2);\n    Utils.assertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n    Utils.assertTrue(minHeap.peek() == 6);\n    minHeap.insert(87);\n    Utils.assertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n  }\n\n  boolean isMinHeapPropertySatisfied(List<Integer> array) {\n    for (int currentIdx = 1; currentIdx < array.size(); currentIdx++) {\n      int parentIdx = (currentIdx - 1) / 2;\n      if (parentIdx < 0) {\n        return true;\n      }\n      if (array.get(parentIdx) > array.get(currentIdx)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.MinHeap minHeap = new Program.MinHeap(new ArrayList<Integer>(\n      Arrays.asList(48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41)\n    ));\n    minHeap.insert(76);\n    Utils.assertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n    Utils.assertTrue(minHeap.peek() == -5);\n    Utils.assertTrue(minHeap.remove() == -5);\n    Utils.assertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n    Utils.assertTrue(minHeap.peek() == 2);\n    Utils.assertTrue(minHeap.remove() == 2);\n    Utils.assertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n    Utils.assertTrue(minHeap.peek() == 6);\n    minHeap.insert(87);\n    Utils.assertTrue(isMinHeapPropertySatisfied(minHeap.heap));\n  }\n\n  boolean isMinHeapPropertySatisfied(List<Integer> array) {\n    for (int currentIdx = 1; currentIdx < array.size(); currentIdx++) {\n      int parentIdx = (currentIdx - 1) / 2;\n      if (parentIdx < 0) {\n        return true;\n      }\n      if (array.get(parentIdx) > array.get(currentIdx)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// Do not edit the class below except for the buildHeap,\n// siftDown, siftUp, peek, remove, and insert methods.\n// Feel free to add new properties and methods to the class.\nclass MinHeap {\n  constructor(array) {\n    this.heap = this.buildHeap(array);\n  }\n\n  buildHeap(array) {\n    // Write your code here.\n  }\n\n  siftDown() {\n    // Write your code here.\n  }\n\n  siftUp() {\n    // Write your code here.\n  }\n\n  peek() {\n    // Write your code here.\n  }\n\n  remove() {\n    // Write your code here.\n  }\n\n  insert(value) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.MinHeap = MinHeap;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass MinHeap {\n  constructor(array) {\n    this.heap = this.buildHeap(array);\n  }\n\n  // O(n) time | O(1) space\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  // O(log(n)) time | O(1) space\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx] < heap[childOneIdx]) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap] < heap[currentIdx]) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx] < heap[parentIdx]) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  // O(1) time | O(1) space\n  peek() {\n    return this.heap[0];\n  }\n\n  // O(log(n)) time | O(1) space\n  remove() {\n    this.swap(0, this.heap.length - 1, this.heap);\n    const valueToRemove = this.heap.pop();\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return valueToRemove;\n  }\n\n  // O(log(n)) time | O(1) space\n  insert(value) {\n    this.heap.push(value);\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i, j, heap) {\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n}\n\n// Do not edit the line below.\nexports.MinHeap = MinHeap;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nconst isMinHeapPropertySatisfied = array => {\n  for (let currentIdx = 1; currentIdx < array.length; currentIdx++) {\n    const parentIdx = Math.floor((currentIdx - 1) / 2);\n    if (array[parentIdx] > array[currentIdx]) return false;\n  }\n  return true;\n};\n\nit('Test Case #1', function () {\n  const minHeap = new program.MinHeap([48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41]);\n  minHeap.insert(76);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(-5);\n  chai.expect(minHeap.remove()).to.deep.equal(-5);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(2);\n  chai.expect(minHeap.remove()).to.deep.equal(2);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(6);\n  minHeap.insert(87);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nconst isMinHeapPropertySatisfied = array => {\n  for (let currentIdx = 1; currentIdx < array.length; currentIdx++) {\n    const parentIdx = Math.floor((currentIdx - 1) / 2);\n    if (array[parentIdx] > array[currentIdx]) return false;\n  }\n  return true;\n};\n\nit('Test Case #1', function () {\n  const minHeap = new program.MinHeap([48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41]);\n  minHeap.insert(76);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(-5);\n  chai.expect(minHeap.remove()).to.deep.equal(-5);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(2);\n  chai.expect(minHeap.remove()).to.deep.equal(2);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(6);\n  minHeap.insert(87);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// Do not edit the class below except for the buildHeap,\n// siftDown, siftUp, peek, remove, and insert methods.\n// Feel free to add new properties and methods to the class.\nopen class MinHeap(array: MutableList<Int>) {\n    val heap = this.buildHeap(array)\n\n    fun buildHeap(array: MutableList<Int>): MutableList<Int> {\n        // Write your code here.\n        return array\n    }\n\n    fun siftDown(currentIdx: Int, endIdx: Int, heap: MutableList<Int>) {\n        // Write your code here.\n    }\n\n    fun siftUp(currentIdx: Int, heap: MutableList<Int>) {\n        // Write your code here.\n    }\n\n    fun peek(): Int? {\n        // Write your code here.\n        return -1\n    }\n\n    fun remove(): Int? {\n        // Write your code here.\n        return -1\n    }\n\n    fun insert(value: Int) {\n        // Write your code here.\n    }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class MinHeap(array: MutableList<Int>) {\n    val heap = this.buildHeap(array)\n\n    // O(n) time | O(1) space\n    fun buildHeap(array: MutableList<Int>): MutableList<Int> {\n        val firstParentIdx = (array.size - 2) / 2\n        for (currentIdx in firstParentIdx downTo 0) {\n            this.siftDown(currentIdx, array.size - 1, array)\n        }\n        return array\n    }\n\n    // O(log(n)) time | O(1) space\n    fun siftDown(currentIdx: Int, endIdx: Int, heap: MutableList<Int>) {\n        var newCurrentIdx = currentIdx\n        var childOneIdx = currentIdx * 2 + 1\n        while (childOneIdx <= endIdx) {\n            var childTwoIdx = if (newCurrentIdx * 2 + 2 <= endIdx) newCurrentIdx * 2 + 2 else -1\n            var idxToSwap: Int\n            if (childTwoIdx != -1 && heap[childTwoIdx] < heap[childOneIdx]) {\n                idxToSwap = childTwoIdx\n            } else {\n                idxToSwap = childOneIdx\n            }\n            if (heap[idxToSwap] < heap[newCurrentIdx]) {\n                this.swap(newCurrentIdx, idxToSwap, heap)\n                newCurrentIdx = idxToSwap\n                childOneIdx = newCurrentIdx * 2 + 1\n            } else {\n                return\n            }\n        }\n    }\n\n    // O(log(n)) time | O(1) space\n    fun siftUp(currentIdx: Int, heap: MutableList<Int>) {\n        var newCurrentIdx = currentIdx\n        var parentIdx = (currentIdx - 1) / 2\n        while (newCurrentIdx > 0 && heap[newCurrentIdx] < heap[parentIdx]) {\n            this.swap(newCurrentIdx, parentIdx, heap)\n            newCurrentIdx = parentIdx\n            parentIdx = (newCurrentIdx - 1) / 2\n        }\n    }\n\n    // O(1) time | O(1) space\n    fun peek(): Int? {\n        return this.heap[0]\n    }\n\n    // O(log(n)) time | O(1) space\n    fun remove(): Int? {\n        this.swap(0, this.heap.size - 1, this.heap)\n        val valueToRemove = this.heap.removeAt(this.heap.size - 1)\n        this.siftDown(0, this.heap.size - 1, this.heap)\n        return valueToRemove\n    }\n\n    // O(log(n)) time | O(1) space\n    fun insert(value: Int) {\n        this.heap.add(value)\n        this.siftUp(this.heap.size - 1, this.heap)\n    }\n\n    fun swap(i: Int, j: Int, heap: MutableList<Int>) {\n        val temp = heap[j]\n        heap[j] = heap[i]\n        heap[i] = temp\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.MinHeap as MinHeap\n\nfun isMinHeapPropertySatisfied(array: MutableList<Int>): Boolean {\n    for (currentIdx in 1 until array.size) {\n        val parentIdx = (currentIdx - 1) / 2\n        if (array[parentIdx] > array[currentIdx]) return false\n    }\n    return true\n}\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val minHeap = MinHeap(mutableListOf(48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41))\n        minHeap.insert(76)\n        assert(isMinHeapPropertySatisfied(minHeap.heap))\n        assert(minHeap.peek() == -5)\n        assert(minHeap.remove() == -5)\n        assert(isMinHeapPropertySatisfied(minHeap.heap))\n        assert(minHeap.peek() == 2)\n        assert(minHeap.remove() == 2)\n        assert(isMinHeapPropertySatisfied(minHeap.heap))\n        assert(minHeap.peek() == 6)\n        minHeap.insert(87)\n        assert(isMinHeapPropertySatisfied(minHeap.heap))\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.MinHeap as MinHeap\n\nfun isMinHeapPropertySatisfied(array: MutableList<Int>): Boolean {\n    for (currentIdx in 1 until array.size) {\n        val parentIdx = (currentIdx - 1) / 2\n        if (array[parentIdx] > array[currentIdx]) return false\n    }\n    return true\n}\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val minHeap = MinHeap(mutableListOf(48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41))\n        minHeap.insert(76)\n        assert(isMinHeapPropertySatisfied(minHeap.heap))\n        assert(minHeap.peek() == -5)\n        assert(minHeap.remove() == -5)\n        assert(isMinHeapPropertySatisfied(minHeap.heap))\n        assert(minHeap.peek() == 2)\n        assert(minHeap.remove() == 2)\n        assert(isMinHeapPropertySatisfied(minHeap.heap))\n        assert(minHeap.peek() == 6)\n        minHeap.insert(87)\n        assert(isMinHeapPropertySatisfied(minHeap.heap))\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# Do not edit the class below except for the buildHeap,\n# siftDown, siftUp, peek, remove, and insert methods.\n# Feel free to add new properties and methods to the class.\nclass MinHeap:\n    def __init__(self, array):\n        # Do not edit the line below.\n        self.heap = self.buildHeap(array)\n\n    def buildHeap(self, array):\n        # Write your code here.\n        pass\n\n    def siftDown(self):\n        # Write your code here.\n        pass\n\n    def siftUp(self):\n        # Write your code here.\n        pass\n\n    def peek(self):\n        # Write your code here.\n        pass\n\n    def remove(self):\n        # Write your code here.\n        pass\n\n    def insert(self, value):\n        # Write your code here.\n        pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass MinHeap:\n    def __init__(self, array):\n        self.heap = self.buildHeap(array)\n\n    # O(n) time | O(1) space\n    def buildHeap(self, array):\n        firstParentIdx = (len(array) - 2) // 2\n        for currentIdx in reversed(range(firstParentIdx + 1)):\n            self.siftDown(currentIdx, len(array) - 1, array)\n        return array\n\n    # O(log(n)) time | O(1) space\n    def siftDown(self, currentIdx, endIdx, heap):\n        childOneIdx = currentIdx * 2 + 1\n        while childOneIdx <= endIdx:\n            childTwoIdx = currentIdx * 2 + 2 if currentIdx * 2 + 2 <= endIdx else -1\n            if childTwoIdx != -1 and heap[childTwoIdx] < heap[childOneIdx]:\n                idxToSwap = childTwoIdx\n            else:\n                idxToSwap = childOneIdx\n            if heap[idxToSwap] < heap[currentIdx]:\n                self.swap(currentIdx, idxToSwap, heap)\n                currentIdx = idxToSwap\n                childOneIdx = currentIdx * 2 + 1\n            else:\n                return\n\n    # O(log(n)) time | O(1) space\n    def siftUp(self, currentIdx, heap):\n        parentIdx = (currentIdx - 1) // 2\n        while currentIdx > 0 and heap[currentIdx] < heap[parentIdx]:\n            self.swap(currentIdx, parentIdx, heap)\n            currentIdx = parentIdx\n            parentIdx = (currentIdx - 1) // 2\n\n    # O(1) time | O(1) space\n    def peek(self):\n        return self.heap[0]\n\n    # O(log(n)) time | O(1) space\n    def remove(self):\n        self.swap(0, len(self.heap) - 1, self.heap)\n        valueToRemove = self.heap.pop()\n        self.siftDown(0, len(self.heap) - 1, self.heap)\n        return valueToRemove\n\n    # O(log(n)) time | O(1) space\n    def insert(self, value):\n        self.heap.append(value)\n        self.siftUp(len(self.heap) - 1, self.heap)\n\n    def swap(self, i, j, heap):\n        heap[i], heap[j] = heap[j], heap[i]\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\ndef isMinHeapPropertySatisfied(array):\n    for currentIdx in range(1, len(array)):\n        parentIdx = (currentIdx - 1) // 2\n        if array[parentIdx] > array[currentIdx]:\n            return False\n    return True\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        minHeap = program.MinHeap([48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41])\n        minHeap.insert(76)\n        self.assertTrue(isMinHeapPropertySatisfied(minHeap.heap))\n        self.assertEqual(minHeap.peek(), -5)\n        self.assertEqual(minHeap.remove(), -5)\n        self.assertTrue(isMinHeapPropertySatisfied(minHeap.heap))\n        self.assertEqual(minHeap.peek(), 2)\n        self.assertEqual(minHeap.remove(), 2)\n        self.assertTrue(isMinHeapPropertySatisfied(minHeap.heap))\n        self.assertEqual(minHeap.peek(), 6)\n        minHeap.insert(87)\n        self.assertTrue(isMinHeapPropertySatisfied(minHeap.heap))\n",
      "unitTests": "import program\nimport unittest\n\n\ndef isMinHeapPropertySatisfied(array):\n    for currentIdx in range(1, len(array)):\n        parentIdx = (currentIdx - 1) // 2\n        if array[parentIdx] > array[currentIdx]:\n            return False\n    return True\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        minHeap = program.MinHeap([48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41])\n        minHeap.insert(76)\n        self.assertTrue(isMinHeapPropertySatisfied(minHeap.heap))\n        self.assertEqual(minHeap.peek(), -5)\n        self.assertEqual(minHeap.remove(), -5)\n        self.assertTrue(isMinHeapPropertySatisfied(minHeap.heap))\n        self.assertEqual(minHeap.peek(), 2)\n        self.assertEqual(minHeap.remove(), 2)\n        self.assertTrue(isMinHeapPropertySatisfied(minHeap.heap))\n        self.assertEqual(minHeap.peek(), 6)\n        minHeap.insert(87)\n        self.assertTrue(isMinHeapPropertySatisfied(minHeap.heap))\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  class MinHeap {\n    var heap = [Int]()\n\n    init(array: [Int]) {\n      var array = array\n      heap = buildHeap(array: &array)\n    }\n\n    func buildHeap(array: inout [Int]) -> [Int] {\n      // Write your code here.\n      return []\n    }\n\n    func siftDown(currentIndex: inout Int, endIndex: inout Int, heap: inout [Int]) {\n      // Write your code here.\n    }\n\n    func siftUp(currentIndex: inout Int, heap: inout [Int]) {\n      // Write your code here.\n    }\n\n    func peek() -> Int {\n      // Write your code here.\n      return -1\n    }\n\n    func remove() -> Int {\n      // Write your code here.\n      return -1\n    }\n\n    func insert(value: Int) {\n      // Write your code here.\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class MinHeap {\n    var heap = [Int]()\n\n    init(array: [Int]) {\n      heap = array\n      buildHeap(array: array)\n    }\n\n    // O(n) time | O(1) space\n    func buildHeap(array: [Int]) {\n      var firstParentIndex = Double((array.count - 2) / 2)\n      firstParentIndex = firstParentIndex.rounded(.down)\n\n      for var currentIndex in (0 ... Int(firstParentIndex)).reversed() {\n        var endIndex = array.count - 1\n        siftDown(currentIndex: currentIndex, endIndex: endIndex)\n      }\n    }\n\n    // O(log(n)) time | O(1) space\n    func siftDown(currentIndex: Int, endIndex: Int) {\n      var childOneIdx = currentIndex * 2 + 1\n      var current = currentIndex\n      while childOneIdx <= endIndex {\n        var childTwoIdx = -1\n        if current * 2 + 2 <= endIndex {\n          childTwoIdx = current * 2 + 2\n        }\n        var indexToSwap = childOneIdx\n        if childTwoIdx > -1, heap[childTwoIdx] < heap[childOneIdx] {\n          indexToSwap = childTwoIdx\n        }\n\n        if heap[indexToSwap] < heap[current] {\n          swap(firstIndex: current, secondIndex: indexToSwap)\n          current = indexToSwap\n          childOneIdx = current * 2 + 1\n        } else {\n          return\n        }\n      }\n    }\n\n    // O(log(n)) time | O(1) space\n    func siftUp() {\n      var currentIndex = heap.count - 1\n      var parentIndex = (currentIndex - 1) / 2\n\n      while currentIndex > 0 {\n        var current = heap[currentIndex]\n        var parent = heap[Int(parentIndex)]\n        if current < parent {\n          swap(firstIndex: currentIndex, secondIndex: parentIndex)\n          currentIndex = parentIndex\n          parentIndex = (currentIndex - 1) / 2\n        } else {\n          return\n        }\n      }\n    }\n\n    // O(1) time | O(1) space\n    func peek() -> Int {\n      return heap[0]\n    }\n\n    // O(log(n)) time | O(1) space\n    func remove() -> Int {\n      var l = heap.count\n      swap(firstIndex: 0, secondIndex: l - 1)\n      var peeked = heap[l - 1]\n      heap.removeLast()\n      siftDown(currentIndex: 0, endIndex: l - 2)\n      return peeked\n    }\n\n    // O(log(n)) time | O(1) space\n    func insert(value: Int) {\n      heap.append(value)\n      siftUp()\n    }\n\n    // Generic swap function\n    func swap(firstIndex: Int, secondIndex: Int) {\n      let temp = heap[firstIndex]\n      heap[firstIndex] = heap[secondIndex]\n      heap[secondIndex] = temp\n    }\n\n    func length() -> Int {\n      return heap.count\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws in\n      let minHeap = Program.MinHeap(array: [48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41])\n      minHeap.insert(value: 76)\n      try assert(isMinHeapPropertySatisfied(array: minHeap.heap))\n      try assertEqual(minHeap.peek(), -5)\n      try assertEqual(minHeap.remove(), -5)\n      try assert(isMinHeapPropertySatisfied(array: minHeap.heap))\n      try assertEqual(minHeap.peek(), 2)\n      try assertEqual(minHeap.remove(), 2)\n      try assert(isMinHeapPropertySatisfied(array: minHeap.heap))\n      try assertEqual(minHeap.peek(), 6)\n      minHeap.insert(value: 87)\n      try assert(isMinHeapPropertySatisfied(array: minHeap.heap))\n    }\n  }\n\n  func isMinHeapPropertySatisfied(array: [Int]) -> Bool {\n    for currentIndex in 0 ..< array.count - 1 {\n      var parentIndex = Double((currentIndex - 1) / 2)\n      parentIndex = parentIndex.rounded(.down)\n\n      if parentIndex < 0 {\n        break\n      }\n\n      if array[Int(parentIndex)] > array[currentIndex] {\n        return false\n      }\n    }\n    return true\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws in\n      let minHeap = Program.MinHeap(array: [48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41])\n      minHeap.insert(value: 76)\n      try assert(isMinHeapPropertySatisfied(array: minHeap.heap))\n      try assertEqual(minHeap.peek(), -5)\n      try assertEqual(minHeap.remove(), -5)\n      try assert(isMinHeapPropertySatisfied(array: minHeap.heap))\n      try assertEqual(minHeap.peek(), 2)\n      try assertEqual(minHeap.remove(), 2)\n      try assert(isMinHeapPropertySatisfied(array: minHeap.heap))\n      try assertEqual(minHeap.peek(), 6)\n      minHeap.insert(value: 87)\n      try assert(isMinHeapPropertySatisfied(array: minHeap.heap))\n    }\n  }\n\n  func isMinHeapPropertySatisfied(array: [Int]) -> Bool {\n    for currentIndex in 0 ..< array.count - 1 {\n      var parentIndex = Double((currentIndex - 1) / 2)\n      parentIndex = parentIndex.rounded(.down)\n\n      if parentIndex < 0 {\n        break\n      }\n\n      if array[Int(parentIndex)] > array[currentIndex] {\n        return false\n      }\n    }\n    return true\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// Do not edit the class below except for the buildHeap,\n// siftDown, siftUp, peek, remove, and insert methods.\n// Feel free to add new properties and methods to the class.\nexport class MinHeap {\n  heap: number[];\n\n  constructor(array: number[]) {\n    this.heap = this.buildHeap(array);\n  }\n\n  buildHeap(array: number[]) {\n    // Write your code here.\n    return array;\n  }\n\n  siftDown() {\n    // Write your code here.\n  }\n\n  siftUp() {\n    // Write your code here.\n  }\n\n  peek() {\n    // Write your code here.\n    return -1;\n  }\n\n  remove() {\n    // Write your code here.\n    return -1;\n  }\n\n  insert(value: number) {\n    // Write your code here.\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nexport class MinHeap {\n  heap: number[];\n\n  constructor(array: number[]) {\n    this.heap = this.buildHeap(array);\n  }\n\n  // O(n) time | O(1) space\n  buildHeap(array: number[]) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  // O(log(n)) time | O(1) space\n  siftDown(currentIdx: number, endIdx: number, heap: number[]) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx] < heap[childOneIdx]) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap] < heap[currentIdx]) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  siftUp(currentIdx: number, heap: number[]) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx] < heap[parentIdx]) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  // O(1) time | O(1) space\n  peek() {\n    return this.heap[0];\n  }\n\n  // O(log(n)) time | O(1) space\n  remove() {\n    this.swap(0, this.heap.length - 1, this.heap);\n    const valueToRemove = this.heap.pop();\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return valueToRemove;\n  }\n\n  // O(log(n)) time | O(1) space\n  insert(value: number) {\n    this.heap.push(value);\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i: number, j: number, heap: number[]) {\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nconst isMinHeapPropertySatisfied = (array: number[]) => {\n  for (let currentIdx = 1; currentIdx < array.length; currentIdx++) {\n    const parentIdx = Math.floor((currentIdx - 1) / 2);\n    if (array[parentIdx] > array[currentIdx]) return false;\n  }\n  return true;\n};\n\nit('Test Case #1', function () {\n  const minHeap = new program.MinHeap([48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41]);\n  minHeap.insert(76);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(-5);\n  chai.expect(minHeap.remove()).to.deep.equal(-5);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(2);\n  chai.expect(minHeap.remove()).to.deep.equal(2);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(6);\n  minHeap.insert(87);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nconst isMinHeapPropertySatisfied = (array: number[]) => {\n  for (let currentIdx = 1; currentIdx < array.length; currentIdx++) {\n    const parentIdx = Math.floor((currentIdx - 1) / 2);\n    if (array[parentIdx] > array[currentIdx]) return false;\n  }\n  return true;\n};\n\nit('Test Case #1', function () {\n  const minHeap = new program.MinHeap([48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41]);\n  minHeap.insert(76);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(-5);\n  chai.expect(minHeap.remove()).to.deep.equal(-5);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(2);\n  chai.expect(minHeap.remove()).to.deep.equal(2);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(6);\n  minHeap.insert(87);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "array",
      "example": [
        48,
        12,
        24,
        7,
        8,
        -5,
        24,
        391,
        24,
        56,
        2,
        6,
        8,
        41
      ],
      "schema": {
        "items": {
          "type": "integer"
        },
        "type": "array"
      }
    },
    {
      "name": "classMethodsToCall",
      "example": [
        {
          "arguments": [
            76
          ],
          "method": "insert"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            87
          ],
          "method": "insert"
        }
      ],
      "schema": {
        "description": "These methods will be called in the order that they appear in below\non a <span>MinHeap</span> built from the <span>array</span> and with their respective arguments.\n",
        "items": {
          "properties": {
            "arguments": {
              "maxItems": 1,
              "type": "array"
            },
            "method": {
              "enum": [
                "insert",
                "peek",
                "remove"
              ],
              "type": "string"
            }
          },
          "required": [
            "method",
            "arguments"
          ],
          "type": "object"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "array": [
        48,
        12,
        24,
        7,
        8,
        -5,
        24,
        391,
        24,
        56,
        2,
        6,
        8,
        41
      ],
      "classMethodsToCall": [
        {
          "arguments": [
            76
          ],
          "method": "insert"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            87
          ],
          "method": "insert"
        }
      ]
    },
    {
      "array": [
        2,
        3,
        1
      ],
      "classMethodsToCall": [
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "array": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "classMethodsToCall": [
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "array": [
        -4,
        5,
        10,
        8,
        -10,
        -6,
        -4,
        -2,
        -5,
        3,
        5,
        -4,
        -5,
        -1,
        1,
        6,
        -7,
        -6,
        -7,
        8
      ],
      "classMethodsToCall": [
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "array": [
        -7,
        2,
        3,
        8,
        -10,
        4,
        -6,
        -10,
        -2,
        -7,
        10,
        5,
        2,
        9,
        -9,
        -5,
        3,
        8
      ],
      "classMethodsToCall": [
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            -8
          ],
          "method": "insert"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            8
          ],
          "method": "insert"
        },
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "array": [
        427,
        787,
        222,
        996,
        -359,
        -614,
        246,
        230,
        107,
        -706,
        568,
        9,
        -246,
        12,
        -764,
        -212,
        -484,
        603,
        934,
        -848,
        -646,
        -991,
        661,
        -32,
        -348,
        -474,
        -439,
        -56,
        507,
        736,
        635,
        -171,
        -215,
        564,
        -710,
        710,
        565,
        892,
        970,
        -755,
        55,
        821,
        -3,
        -153,
        240,
        -160,
        -610,
        -583,
        -27,
        131
      ],
      "classMethodsToCall": [
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "array": [
        991,
        -731,
        -882,
        100,
        280,
        -43,
        432,
        771,
        -581,
        180,
        -382,
        -998,
        847,
        80,
        -220,
        680,
        769,
        -75,
        -817,
        366,
        956,
        749,
        471,
        228,
        -435,
        -269,
        652,
        -331,
        -387,
        -657,
        -255,
        382,
        -216,
        -6,
        -163,
        -681,
        980,
        913,
        -169,
        972,
        -523,
        354,
        747,
        805,
        382,
        -827,
        -796,
        372,
        753,
        519,
        906
      ],
      "classMethodsToCall": [
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [
            992
          ],
          "method": "insert"
        }
      ]
    },
    {
      "array": [
        544,
        -578,
        556,
        713,
        -655,
        -359,
        -810,
        -731,
        194,
        -531,
        -685,
        689,
        -279,
        -738,
        886,
        -54,
        -320,
        -500,
        738,
        445,
        -401,
        993,
        -753,
        329,
        -396,
        -924,
        -975,
        376,
        748,
        -356,
        972,
        459,
        399,
        669,
        -488,
        568,
        -702,
        551,
        763,
        -90,
        -249,
        -45,
        452,
        -917,
        394,
        195,
        -877,
        153,
        153,
        788,
        844,
        867,
        266,
        -739,
        904,
        -154,
        -947,
        464,
        343,
        -312,
        150,
        -656,
        528,
        61,
        94,
        -581
      ],
      "classMethodsToCall": [
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "array": [
        -823,
        164,
        48,
        -987,
        323,
        399,
        -293,
        183,
        -908,
        -376,
        14,
        980,
        965,
        842,
        422,
        829,
        59,
        724,
        -415,
        -733,
        356,
        -855,
        -155,
        52,
        328,
        -544,
        -371,
        -160,
        -942,
        -51,
        700,
        -363,
        -353,
        -359,
        238,
        892,
        -730,
        -575,
        892,
        490,
        490,
        995,
        572,
        888,
        -935,
        919,
        -191,
        646,
        -120,
        125,
        -817,
        341,
        -575,
        372,
        -874,
        243,
        610,
        -36,
        -685,
        -337,
        -13,
        295,
        800,
        -950,
        -949,
        -257,
        631,
        -542,
        201,
        -796,
        157,
        950,
        540,
        -846,
        -265,
        746,
        355,
        -578,
        -441,
        -254,
        -941,
        -738,
        -469,
        -167,
        -420,
        -126,
        -410,
        59
      ],
      "classMethodsToCall": [
        {
          "arguments": [
            2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            22
          ],
          "method": "insert"
        },
        {
          "arguments": [
            222
          ],
          "method": "insert"
        },
        {
          "arguments": [
            2222
          ],
          "method": "insert"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "remove"
        }
      ]
    }
  ],
  "jsonTests": [
    {
      "array": [
        48,
        12,
        24,
        7,
        8,
        -5,
        24,
        391,
        24,
        56,
        2,
        6,
        8,
        41
      ],
      "classMethodsToCall": [
        {
          "arguments": [
            76
          ],
          "method": "insert"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            87
          ],
          "method": "insert"
        }
      ]
    },
    {
      "array": [
        2,
        3,
        1
      ],
      "classMethodsToCall": [
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "array": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "classMethodsToCall": [
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "array": [
        -4,
        5,
        10,
        8,
        -10,
        -6,
        -4,
        -2,
        -5,
        3,
        5,
        -4,
        -5,
        -1,
        1,
        6,
        -7,
        -6,
        -7,
        8
      ],
      "classMethodsToCall": [
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "array": [
        -7,
        2,
        3,
        8,
        -10,
        4,
        -6,
        -10,
        -2,
        -7,
        10,
        5,
        2,
        9,
        -9,
        -5,
        3,
        8
      ],
      "classMethodsToCall": [
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            -8
          ],
          "method": "insert"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            8
          ],
          "method": "insert"
        },
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "array": [
        427,
        787,
        222,
        996,
        -359,
        -614,
        246,
        230,
        107,
        -706,
        568,
        9,
        -246,
        12,
        -764,
        -212,
        -484,
        603,
        934,
        -848,
        -646,
        -991,
        661,
        -32,
        -348,
        -474,
        -439,
        -56,
        507,
        736,
        635,
        -171,
        -215,
        564,
        -710,
        710,
        565,
        892,
        970,
        -755,
        55,
        821,
        -3,
        -153,
        240,
        -160,
        -610,
        -583,
        -27,
        131
      ],
      "classMethodsToCall": [
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "array": [
        991,
        -731,
        -882,
        100,
        280,
        -43,
        432,
        771,
        -581,
        180,
        -382,
        -998,
        847,
        80,
        -220,
        680,
        769,
        -75,
        -817,
        366,
        956,
        749,
        471,
        228,
        -435,
        -269,
        652,
        -331,
        -387,
        -657,
        -255,
        382,
        -216,
        -6,
        -163,
        -681,
        980,
        913,
        -169,
        972,
        -523,
        354,
        747,
        805,
        382,
        -827,
        -796,
        372,
        753,
        519,
        906
      ],
      "classMethodsToCall": [
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [
            992
          ],
          "method": "insert"
        }
      ]
    },
    {
      "array": [
        544,
        -578,
        556,
        713,
        -655,
        -359,
        -810,
        -731,
        194,
        -531,
        -685,
        689,
        -279,
        -738,
        886,
        -54,
        -320,
        -500,
        738,
        445,
        -401,
        993,
        -753,
        329,
        -396,
        -924,
        -975,
        376,
        748,
        -356,
        972,
        459,
        399,
        669,
        -488,
        568,
        -702,
        551,
        763,
        -90,
        -249,
        -45,
        452,
        -917,
        394,
        195,
        -877,
        153,
        153,
        788,
        844,
        867,
        266,
        -739,
        904,
        -154,
        -947,
        464,
        343,
        -312,
        150,
        -656,
        528,
        61,
        94,
        -581
      ],
      "classMethodsToCall": [
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "array": [
        -823,
        164,
        48,
        -987,
        323,
        399,
        -293,
        183,
        -908,
        -376,
        14,
        980,
        965,
        842,
        422,
        829,
        59,
        724,
        -415,
        -733,
        356,
        -855,
        -155,
        52,
        328,
        -544,
        -371,
        -160,
        -942,
        -51,
        700,
        -363,
        -353,
        -359,
        238,
        892,
        -730,
        -575,
        892,
        490,
        490,
        995,
        572,
        888,
        -935,
        919,
        -191,
        646,
        -120,
        125,
        -817,
        341,
        -575,
        372,
        -874,
        243,
        610,
        -36,
        -685,
        -337,
        -13,
        295,
        800,
        -950,
        -949,
        -257,
        631,
        -542,
        201,
        -796,
        157,
        950,
        540,
        -846,
        -265,
        746,
        355,
        -578,
        -441,
        -254,
        -941,
        -738,
        -469,
        -167,
        -420,
        -126,
        -410,
        59
      ],
      "classMethodsToCall": [
        {
          "arguments": [
            2
          ],
          "method": "insert"
        },
        {
          "arguments": [
            22
          ],
          "method": "insert"
        },
        {
          "arguments": [
            222
          ],
          "method": "insert"
        },
        {
          "arguments": [
            2222
          ],
          "method": "insert"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "remove"
        },
        {
          "arguments": [],
          "method": "remove"
        }
      ]
    }
  ],
  "changelog": []
}