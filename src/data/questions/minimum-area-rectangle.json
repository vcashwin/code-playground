{
  "uid": "minimum-area-rectangle",
  "testStrategy": "JSON",
  "name": "Minimum Area Rectangle",
  "version": 0,
  "releaseDate": "2021-01-31T00:00:00Z",
  "category": "Arrays",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 4092,
    "failureCount": 1048
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "503733330",
    "duration": 0,
    "annotations": [
      {
        "title": "Typo",
        "content": "(4,5) is in column 2",
        "start": 1323,
        "end": 1329
      }
    ],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 1939
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given an array of points plotted on a 2D graph (the xy-plane). Write a\n  function that returns the minimum area of any rectangle that can be formed\n  using any 4 of these points such that the rectangle's sides are parallel to\n  the x and y axes (i.e., only rectangles with horizontal and vertical sides\n  should be considered--no rectangles with diagonal sides). If no rectangle can\n  be formed, your function should return <span>0</span>.\n</p>\n<p>\n  The input array will contain points represented by arrays of two integers\n  <span>[x, y]</span>. The input array will never contain duplicate points.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">points</span> = \n[\n  [1, 5],\n  [5, 1],\n  [4, 2],\n  [2, 4],\n  [2, 2],\n  [1, 2],\n  [4, 5],\n  [2, 5],\n  [-1, -2],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3\n<span class=\"CodeEditor-promptComment\">// The rectangle with corners [1, 5], [2, 5], [1, 2], and [2, 2]</span>\n<span class=\"CodeEditor-promptComment\">// has the minimum area: 3.</span>\n</pre>\n</div>",
  "hints": [
    "<p>\n  The brute-force approach to this problem is to simply generate all possible\n  combinations of 4 points and to see if they form a rectangle. You can\n  calculate the area of all of these rectangles and then return the minimum area\n  that you find. Is there a better approach than this?\n</p>\n",
    "\n<p>\n  A more optimal approach is to find vertical or horizontal edges that are\n  parallel to the y or x axes, respectively. If you find two parallel edges (two\n  vertical edges, for example) that share a vertical or horizontal coordinate (y\n  values in the case of vertical edges), then those edges form a rectangle.\n</p>\n",
    "\n<p>\n  Another approach is to pick any two points that don't have the same x or y\n  values (i.e., points that could be at opposite ends of a rectangle diagonal)\n  and to see if you can create a rectangle with them and two other points. Given\n  two points where <span>p1 = (x1, y1)</span> and <span>p2 = (x2, y2)</span>, if\n  points <span>p3 = (x1, y2)</span> and <span>p4 = (x2, y1)</span> exist, then\n  these 4 points form a rectangle.\n</p>"
  ],
  "spaceTime": "O(n^2) time | O(n) space - where n is the number of points",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nint minimumAreaRectangle(vector<vector<int>> points) {\n  // Write your code here.\n  return 0;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <limits>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nunordered_map<int, vector<int>> initializeColumns(vector<vector<int>> points);\n\n// O(n^2) time | O(n) space - where n is the number of points\nint minimumAreaRectangle(vector<vector<int>> points) {\n  auto columns = initializeColumns(points);\n  int minimumAreaFound = numeric_limits<int>::max();\n  unordered_map<string, int> edgesParallelToYAxis;\n\n  vector<int> sortedColumns;\n  for (auto it : columns) {\n    sortedColumns.push_back(it.first);\n  }\n  sort(sortedColumns.begin(), sortedColumns.end());\n\n  for (auto x : sortedColumns) {\n    vector<int> yValuesInCurrentColumn = columns[x];\n    sort(yValuesInCurrentColumn.begin(), yValuesInCurrentColumn.end());\n    for (int currentIdx = 0; currentIdx < yValuesInCurrentColumn.size();\n         currentIdx++) {\n      int y2 = yValuesInCurrentColumn[currentIdx];\n      for (int previousIdx = 0; previousIdx < currentIdx; previousIdx++) {\n        int y1 = yValuesInCurrentColumn[previousIdx];\n        string pointString = to_string(y1) + \":\" + to_string(y2);\n\n        if (edgesParallelToYAxis.find(pointString) != edgesParallelToYAxis.end()) {\n          int currentArea = (x - edgesParallelToYAxis[pointString]) * (y2 - y1);\n          minimumAreaFound = min(minimumAreaFound, currentArea);\n        }\n\n        edgesParallelToYAxis[pointString] = x;\n      }\n    }\n  }\n\n  return minimumAreaFound != numeric_limits<int>::max() ? minimumAreaFound : 0;\n}\n\nunordered_map<int, vector<int>> initializeColumns(vector<vector<int>> points) {\n  unordered_map<int, vector<int>> columns;\n\n  for (auto point : points) {\n    int x = point[0];\n    int y = point[1];\n    if (columns.find(x) == columns.end()) {\n      columns[x] = {};\n    }\n    columns[x].push_back(y);\n  }\n\n  return columns;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <cmath>\n#include <limits>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nset<string> createPointSet(vector<vector<int>> points);\nstring convertPointToString(int x, int y);\n\n// O(n^2) time | O(n) space - where n is the number of points\nint minimumAreaRectangle(vector<vector<int>> points) {\n  set<string> pointSet = createPointSet(points);\n  int minimumAreaFound = numeric_limits<int>::max();\n\n  for (int currentIdx = 0; currentIdx < points.size(); currentIdx++) {\n    int p2x = points[currentIdx][0];\n    int p2y = points[currentIdx][1];\n    for (int previousIdx = 0; previousIdx < currentIdx; previousIdx++) {\n      int p1x = points[previousIdx][0];\n      int p1y = points[previousIdx][1];\n      bool pointsShareValue = p1x == p2x || p1y == p2y;\n\n      if (pointsShareValue) continue;\n\n      // If (p1x, p2y) and (p2x, p1y), exist we've found a rectangle.\n      bool point1OnOppositeDiagonalExists =\n        pointSet.find((convertPointToString(p1x, p2y))) != pointSet.end();\n      bool point2OnOppositeDiagonalExists =\n        pointSet.find((convertPointToString(p2x, p1y))) != pointSet.end();\n      bool oppositeDiagonalExists =\n        point1OnOppositeDiagonalExists && point2OnOppositeDiagonalExists;\n\n      if (oppositeDiagonalExists) {\n        int currentArea = abs(p2x - p1x) * abs(p2y - p1y);\n        minimumAreaFound = min(minimumAreaFound, currentArea);\n      }\n    }\n  }\n\n  return minimumAreaFound != numeric_limits<int>::max() ? minimumAreaFound : 0;\n}\n\nset<string> createPointSet(vector<vector<int>> points) {\n  set<string> pointSet;\n\n  for (auto point : points) {\n    int x = point[0];\n    int y = point[1];\n    string pointString = convertPointToString(x, y);\n    pointSet.insert(pointString);\n  }\n\n  return pointSet;\n}\n\nstring convertPointToString(int x, int y) {\n  return to_string(x) + \":\" + to_string(y);\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> input = {\n        {1, 5},\n        {5, 1},\n        {4, 2},\n        {2, 4},\n        {2, 2},\n        {1, 2},\n        {4, 5},\n        {2, 5},\n        {-1, -2}};\n      auto expected = 3;\n      auto actual = minimumAreaRectangle(input);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> input = {\n        {1, 5},\n        {5, 1},\n        {4, 2},\n        {2, 4},\n        {2, 2},\n        {1, 2},\n        {4, 5},\n        {2, 5},\n        {-1, -2}};\n      auto expected = 3;\n      auto actual = minimumAreaRectangle(input);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public int MinimumAreaRectangle(int[][] points) {\n    // Write your code here.\n    return 0;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // O(n^2) time | O(n) space - where n is the number of points\n  public int MinimumAreaRectangle(int[][] points) {\n    Dictionary<int, int[]> columns = initializeColumns(points);\n    int minimumAreaFound = Int32.MaxValue;\n    Dictionary<string, int> edgesParallelToYAxis =\n      new Dictionary<string, int>();\n\n    List<int> sortedColumns = new List<int>(columns.Keys);\n    sortedColumns.Sort();\n\n    foreach (var x in sortedColumns) {\n      int[] yValuesInCurrentColumn = columns[x];\n      Array.Sort(yValuesInCurrentColumn);\n\n      for (int currentIdx = 0; currentIdx < yValuesInCurrentColumn.Length;\n           currentIdx++) {\n        int y2 = yValuesInCurrentColumn[currentIdx];\n        for (int previousIdx = 0; previousIdx < currentIdx; previousIdx++) {\n          int y1 = yValuesInCurrentColumn[previousIdx];\n          string pointstring = y1.ToString() + \":\" + y2.ToString();\n\n          if (edgesParallelToYAxis.ContainsKey(pointstring)) {\n            int currentArea =\n              (x - edgesParallelToYAxis[pointstring]) * (y2 - y1);\n            minimumAreaFound = Math.Min(minimumAreaFound, currentArea);\n          }\n\n          edgesParallelToYAxis[pointstring] = x;\n        }\n      }\n    }\n\n    return (minimumAreaFound != Int32.MaxValue) ? minimumAreaFound : 0;\n  }\n\n  public Dictionary<int, int[]> initializeColumns(int[][] points) {\n    Dictionary<int, int[]> columns = new Dictionary<int, int[]>();\n\n    foreach (var point in points) {\n      int x = point[0];\n      int y = point[1];\n\n      if (!columns.ContainsKey(x)) {\n        columns[x] = new int[] {};\n      }\n\n      int[] column = columns[x];\n      int[] newColumn = new int[column.Length + 1];\n      for (int i = 0; i < column.Length; i++) {\n        newColumn[i] = column[i];\n      }\n      newColumn[column.Length] = y;\n      columns[x] = newColumn;\n    }\n\n    return columns;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(n^2) time | O(n) space - where n is the number of points\n  public int MinimumAreaRectangle(int[][] points) {\n    HashSet<string> pointSet = createPointSet(points);\n    int minimumAreaFound = Int32.MaxValue;\n\n    for (int currentIdx = 0; currentIdx < points.Length; currentIdx++) {\n      int p2x = points[currentIdx][0];\n      int p2y = points[currentIdx][1];\n\n      for (int previousIdx = 0; previousIdx < currentIdx; previousIdx++) {\n        int p1x = points[previousIdx][0];\n        int p1y = points[previousIdx][1];\n        bool pointsShareValue = p1x == p2x || p1y == p2y;\n\n        if (pointsShareValue) continue;\n\n        // If (p1x, p2y) and (p2x, p1y), exist we've found a rectangle.\n        bool point1OnOppositeDiagonalExists =\n          pointSet.Contains(convertPointTostring(p1x, p2y));\n        bool point2OnOppositeDiagonalExists =\n          pointSet.Contains(convertPointTostring(p2x, p1y));\n        bool oppositeDiagonalExists =\n          point1OnOppositeDiagonalExists && point2OnOppositeDiagonalExists;\n\n        if (oppositeDiagonalExists) {\n          int currentArea = Math.Abs(p2x - p1x) * Math.Abs(p2y - p1y);\n          minimumAreaFound = Math.Min(minimumAreaFound, currentArea);\n        }\n      }\n    }\n\n    return (minimumAreaFound != Int32.MaxValue) ? minimumAreaFound : 0;\n  }\n\n  public string convertPointTostring(int x, int y) {\n    return x.ToString() + \":\" + y.ToString();\n  }\n\n  public HashSet<string> createPointSet(int[][] points) {\n    HashSet<string> pointSet = new HashSet<string>();\n    foreach (var point in points) {\n      int x = point[0];\n      int y = point[1];\n      string pointstring = convertPointTostring(x, y);\n      pointSet.Add(pointstring);\n    }\n\n    return pointSet;\n  }\n}"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[][] input = new int[][] {\n      new int[] { 1, 5 },\n      new int[] { 5, 1 },\n      new int[] { 4, 2 },\n      new int[] { 2, 4 },\n      new int[] { 2, 2 },\n      new int[] { 1, 2 },\n      new int[] { 4, 5 },\n      new int[] { 2, 5 },\n      new int[] { -1, -2 }\n    };\n    int expected = 3;\n    var actual = new Program().MinimumAreaRectangle(input);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[][] input = new int[][] {\n      new int[] { 1, 5 },\n      new int[] { 5, 1 },\n      new int[] { 4, 2 },\n      new int[] { 2, 4 },\n      new int[] { 2, 2 },\n      new int[] { 1, 2 },\n      new int[] { 4, 5 },\n      new int[] { 2, 5 },\n      new int[] { -1, -2 }\n    };\n    int expected = 3;\n    var actual = new Program().MinimumAreaRectangle(input);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc MinimumAreaRectangle(points [][]int) int {\n\t// Write your code here.\n\treturn 0\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"sort\"\n)\n\n// O(n^2) time | O(n) space - where n is the number of points\nfunc MinimumAreaRectangle(points [][]int) int {\n\tcolumns := initializeColumns(points)\n\tvar minimumAreaFound = math.MaxInt32\n\tedgesParallelToYAxis := map[string]int{}\n\n\tsortedColumns := make([]int, 0)\n\tfor k := range columns {\n\t\tsortedColumns = append(sortedColumns, k)\n\t}\n\tsort.Ints(sortedColumns)\n\n\tfor _, x := range sortedColumns {\n\t\tyValuesInCurrentColumn := columns[x]\n\t\tsort.Ints(yValuesInCurrentColumn)\n\n\t\tfor currentIdx := range yValuesInCurrentColumn {\n\t\t\ty2 := yValuesInCurrentColumn[currentIdx]\n\t\t\tfor previousIdx := 0; previousIdx < currentIdx; previousIdx++ {\n\t\t\t\ty1 := yValuesInCurrentColumn[previousIdx]\n\t\t\t\tpointString := fmt.Sprintf(\"%d:%d\", y1, y2)\n\n\t\t\t\tif _, found := edgesParallelToYAxis[pointString]; found {\n\t\t\t\t\tcurrentArea := (x - edgesParallelToYAxis[pointString]) * (y2 - y1)\n\t\t\t\t\tminimumAreaFound = min(minimumAreaFound, currentArea)\n\t\t\t\t}\n\n\t\t\t\tedgesParallelToYAxis[pointString] = x\n\t\t\t}\n\t\t}\n\t}\n\n\tif minimumAreaFound != math.MaxInt32 {\n\t\treturn minimumAreaFound\n\t}\n\treturn 0\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc initializeColumns(points [][]int) map[int][]int {\n\tcolumns := map[int][]int{}\n\n\tfor _, point := range points {\n\t\tx, y := point[0], point[1]\n\t\tcolumns[x] = append(columns[x], y)\n\t}\n\n\treturn columns\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// O(n^2) time | O(n) space - where n is the number of points\nfunc MinimumAreaRectangle(points [][]int) int {\n\tpointSet := createPointSet(points)\n\tvar minimumAreaFound = math.MaxInt32\n\n\tfor currentIdx := range points {\n\t\tp2x, p2y := points[currentIdx][0], points[currentIdx][1]\n\t\tfor previousIdx := 0; previousIdx < currentIdx; previousIdx++ {\n\t\t\tp1x, p1y := points[previousIdx][0], points[previousIdx][1]\n\t\t\tpointsShareValue := p1x == p2x || p1y == p2y\n\n\t\t\tif pointsShareValue {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If (p1x, p2y) and (p2x, p1y), exist we've found a rectangle.\n\t\t\tpoint1OnOppositeDiagonalExists := pointSet[convertPointToString(p1x, p2y)]\n\t\t\tpoint2OnOppositeDiagonalExists := pointSet[convertPointToString(p2x, p1y)]\n\t\t\toppositeDiagonalExists := point1OnOppositeDiagonalExists && point2OnOppositeDiagonalExists\n\n\t\t\tif oppositeDiagonalExists {\n\t\t\t\tcurrentArea := abs(p2x-p1x) * abs(p2y-p1y)\n\t\t\t\tminimumAreaFound = min(minimumAreaFound, currentArea)\n\t\t\t}\n\t\t}\n\t}\n\tif minimumAreaFound != math.MaxInt32 {\n\t\treturn minimumAreaFound\n\t}\n\treturn 0\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc abs(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\nfunc createPointSet(points [][]int) map[string]bool {\n\tpointSet := map[string]bool{}\n\n\tfor _, point := range points {\n\t\tx, y := point[0], point[1]\n\t\tpointString := convertPointToString(x, y)\n\t\tpointSet[pointString] = true\n\t}\n\treturn pointSet\n}\n\nfunc convertPointToString(x, y int) string {\n\treturn fmt.Sprintf(\"%d:%d\", x, y)\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{1, 5},\n\t\t{5, 1},\n\t\t{4, 2},\n\t\t{2, 4},\n\t\t{2, 2},\n\t\t{1, 2},\n\t\t{4, 5},\n\t\t{2, 5},\n\t\t{-1, -2},\n\t}\n\texpected := 3\n\tactual := MinimumAreaRectangle(input)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{1, 5},\n\t\t{5, 1},\n\t\t{4, 2},\n\t\t{2, 4},\n\t\t{2, 2},\n\t\t{1, 2},\n\t\t{4, 5},\n\t\t{2, 5},\n\t\t{-1, -2},\n\t}\n\texpected := 3\n\tactual := MinimumAreaRectangle(input)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public int minimumAreaRectangle(int[][] points) {\n    // Write your code here.\n    return 0;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n^2) time | O(n) space - where n is the number of points\n  public int minimumAreaRectangle(int[][] points) {\n    HashMap<Integer, int[]> columns = initializeColumns(points);\n    int minimumAreaFound = Integer.MAX_VALUE;\n    HashMap<String, Integer> edgesParallelToYAxis =\n      new HashMap<String, Integer>();\n\n    ArrayList<Integer> sortedColumns = new ArrayList<Integer>(columns.keySet());\n    Collections.sort(sortedColumns);\n\n    for (Integer x : sortedColumns) {\n      int[] yValuesInCurrentColumn = columns.get(x);\n      Arrays.sort(yValuesInCurrentColumn);\n\n      for (int currentIdx = 0; currentIdx < yValuesInCurrentColumn.length;\n           currentIdx++) {\n        int y2 = yValuesInCurrentColumn[currentIdx];\n        for (int previousIdx = 0; previousIdx < currentIdx; previousIdx++) {\n          int y1 = yValuesInCurrentColumn[previousIdx];\n          String pointString = String.valueOf(y1) + \":\" + String.valueOf(y2);\n\n          if (edgesParallelToYAxis.containsKey(pointString)) {\n            int currentArea =\n              (x - edgesParallelToYAxis.get(pointString)) * (y2 - y1);\n            minimumAreaFound = Math.min(minimumAreaFound, currentArea);\n          }\n\n          edgesParallelToYAxis.put(pointString, x);\n        }\n      }\n    }\n\n    return (minimumAreaFound != Integer.MAX_VALUE) ? minimumAreaFound : 0;\n  }\n\n  public HashMap<Integer, int[]> initializeColumns(int[][] points) {\n    HashMap<Integer, int[]> columns = new HashMap<Integer, int[]>();\n\n    for (int[] point : points) {\n      int x = point[0];\n      int y = point[1];\n\n      if (!columns.containsKey(x)) {\n        columns.put(x, new int[] {});\n      }\n\n      int[] column = columns.get(x);\n      int[] newColumn = new int[column.length + 1];\n      for (int i = 0; i < column.length; i++) {\n        newColumn[i] = column[i];\n      }\n      newColumn[column.length] = y;\n      columns.put(x, newColumn);\n    }\n\n    return columns;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n^2) time | O(n) space - where n is the number of points\n  public int minimumAreaRectangle(int[][] points) {\n    HashSet<String> pointSet = createPointSet(points);\n    int minimumAreaFound = Integer.MAX_VALUE;\n\n    for (int currentIdx = 0; currentIdx < points.length; currentIdx++) {\n      int p2x = points[currentIdx][0];\n      int p2y = points[currentIdx][1];\n\n      for (int previousIdx = 0; previousIdx < currentIdx; previousIdx++) {\n        int p1x = points[previousIdx][0];\n        int p1y = points[previousIdx][1];\n        boolean pointsShareValue = p1x == p2x || p1y == p2y;\n\n        if (pointsShareValue) continue;\n\n        // If (p1x, p2y) and (p2x, p1y), exist we've found a rectangle.\n        boolean point1OnOppositeDiagonalExists =\n          pointSet.contains(convertPointToString(p1x, p2y));\n        boolean point2OnOppositeDiagonalExists =\n          pointSet.contains(convertPointToString(p2x, p1y));\n        boolean oppositeDiagonalExists =\n          point1OnOppositeDiagonalExists && point2OnOppositeDiagonalExists;\n\n        if (oppositeDiagonalExists) {\n          int currentArea = Math.abs(p2x - p1x) * Math.abs(p2y - p1y);\n          minimumAreaFound = Math.min(minimumAreaFound, currentArea);\n        }\n      }\n    }\n\n    return (minimumAreaFound != Integer.MAX_VALUE) ? minimumAreaFound : 0;\n  }\n\n  public String convertPointToString(int x, int y) {\n    return String.valueOf(x) + \":\" + String.valueOf(y);\n  }\n\n  public HashSet<String> createPointSet(int[][] points) {\n    HashSet<String> pointSet = new HashSet<String>();\n    for (int[] point : points) {\n      int x = point[0];\n      int y = point[1];\n      String pointString = convertPointToString(x, y);\n      pointSet.add(pointString);\n    }\n\n    return pointSet;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] input = new int[][] {\n      {1, 5}, {5, 1}, {4, 2}, {2, 4}, {2, 2}, {1, 2}, {4, 5}, {2, 5}, {-1, -2}};\n    int expected = 3;\n    var actual = new Program().minimumAreaRectangle(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] input = new int[][] {\n      {1, 5}, {5, 1}, {4, 2}, {2, 4}, {2, 2}, {1, 2}, {4, 5}, {2, 5}, {-1, -2}};\n    int expected = 3;\n    var actual = new Program().minimumAreaRectangle(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function minimumAreaRectangle(points) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.minimumAreaRectangle = minimumAreaRectangle;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space - where n is the number of points\nfunction minimumAreaRectangle(points) {\n  const columns = initializeColumns(points);\n  let minimumAreaFound = Infinity;\n  const edgesParallelToYAxis = {};\n\n  const sortedColumns = Object.keys(columns)\n    .map(col => parseInt(col))\n    .sort((a, b) => a - b);\n  for (const x of sortedColumns) {\n    const yValuesInCurrentColumn = columns[x].sort((a, b) => a - b);\n\n    for (let currentIdx = 0; currentIdx < yValuesInCurrentColumn.length; currentIdx++) {\n      const y2 = yValuesInCurrentColumn[currentIdx];\n      for (let previousIdx = 0; previousIdx < currentIdx; previousIdx++) {\n        const y1 = yValuesInCurrentColumn[previousIdx];\n        const pointString = y1.toString() + ':' + y2.toString();\n\n        if (pointString in edgesParallelToYAxis) {\n          const currentArea = (x - edgesParallelToYAxis[pointString]) * (y2 - y1);\n          minimumAreaFound = Math.min(minimumAreaFound, currentArea);\n        }\n\n        edgesParallelToYAxis[pointString] = x;\n      }\n    }\n  }\n\n  return minimumAreaFound !== Infinity ? minimumAreaFound : 0;\n}\n\nfunction initializeColumns(points) {\n  const columns = {};\n\n  for (const point of points) {\n    const [x, y] = point;\n    if (!columns[x]) {\n      columns[x] = [];\n    }\n    columns[x].push(y);\n  }\n\n  return columns;\n}\n\n// Do not edit the line below.\nexports.minimumAreaRectangle = minimumAreaRectangle;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space - where n is the number of points\nfunction minimumAreaRectangle(points) {\n  const pointSet = createPointSet(points);\n  let minimumAreaFound = Infinity;\n\n  for (let currentIdx = 0; currentIdx < points.length; currentIdx++) {\n    const [p2x, p2y] = points[currentIdx];\n    for (let previousIdx = 0; previousIdx < currentIdx; previousIdx++) {\n      const [p1x, p1y] = points[previousIdx];\n      const pointsShareValue = p1x === p2x || p1y === p2y;\n\n      if (pointsShareValue) continue;\n\n      // If (p1x, p2y) and (p2x, p1y), exist we've found a rectangle.\n      const point1OnOppositeDiagonalExists = pointSet.has(convertPointToString(p1x, p2y));\n      const point2OnOppositeDiagonalExists = pointSet.has(convertPointToString(p2x, p1y));\n      const oppositeDiagonalExists =\n        point1OnOppositeDiagonalExists && point2OnOppositeDiagonalExists;\n\n      if (oppositeDiagonalExists) {\n        const currentArea = Math.abs(p2x - p1x) * Math.abs(p2y - p1y);\n        minimumAreaFound = Math.min(minimumAreaFound, currentArea);\n      }\n    }\n  }\n\n  return minimumAreaFound !== Infinity ? minimumAreaFound : 0;\n}\n\nfunction createPointSet(points) {\n  const pointSet = new Set();\n\n  for (const point of points) {\n    const [x, y] = point;\n    const pointString = convertPointToString(x, y);\n    pointSet.add(pointString);\n  }\n\n  return pointSet;\n}\n\nfunction convertPointToString(x, y) {\n  return x.toString() + ':' + y.toString();\n}\n\n// Do not edit the line below.\nexports.minimumAreaRectangle = minimumAreaRectangle;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 5],\n    [5, 1],\n    [4, 2],\n    [2, 4],\n    [2, 2],\n    [1, 2],\n    [4, 5],\n    [2, 5],\n    [-1, -2],\n  ];\n  const expected = 3;\n  const actual = program.minimumAreaRectangle(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 5],\n    [5, 1],\n    [4, 2],\n    [2, 4],\n    [2, 2],\n    [1, 2],\n    [4, 5],\n    [2, 5],\n    [-1, -2],\n  ];\n  const expected = 3;\n  const actual = program.minimumAreaRectangle(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun minimumAreaRectangle(points: List<List<Int>>): Int {\n    // Write your code here.\n    return 0\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.min\n\n// O(n^2) time | O(n) space - where n is the number of points\nfun minimumAreaRectangle(points: List<List<Int>>): Int {\n    val columns = initializeColumns(points)\n    var minimumAreaFound = Int.MAX_VALUE\n    val edgesParallelToYAxis = mutableMapOf<String, Int>()\n\n    val sortedColumns = columns.keys.toMutableList()\n    sortedColumns.sort()\n    for (x in sortedColumns) {\n        val yValuesInCurrentColumn = columns[x]!!\n        yValuesInCurrentColumn.sort()\n\n        for (currentIdx in 0 until yValuesInCurrentColumn.size) {\n            val y2 = yValuesInCurrentColumn[currentIdx]\n            for (previousIdx in 0 until currentIdx) {\n                val y1 = yValuesInCurrentColumn[previousIdx]\n                val pointString = y1.toString() + \":\" + y2.toString()\n\n                if (pointString in edgesParallelToYAxis) {\n                    val currentArea = (x - edgesParallelToYAxis[pointString]!!) * (y2 - y1)\n                    minimumAreaFound = min(minimumAreaFound, currentArea)\n                }\n\n                edgesParallelToYAxis[pointString] = x\n            }\n        }\n    }\n\n    return if (minimumAreaFound != Int.MAX_VALUE) minimumAreaFound else 0\n}\n\nfun initializeColumns(points: List<List<Int>>): Map<Int, MutableList<Int>> {\n    val columns = mutableMapOf<Int, MutableList<Int>>()\n\n    for (point in points) {\n        val (x, y) = point\n        if (!(x in columns)) columns[x] = mutableListOf<Int>()\n\n        columns[x]!!.add(y)\n    }\n\n    return columns\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.abs\nimport kotlin.math.min\n\n// O(n^2) time | O(n) space - where n is the number of points\nfun minimumAreaRectangle(points: List<List<Int>>): Int {\n    val pointSet = createPointSet(points)\n    var minimumAreaFound = Int.MAX_VALUE\n\n    for (currentIdx in 0 until points.size) {\n        val (p2x, p2y) = points[currentIdx]\n        for (previousIdx in 0 until currentIdx) {\n            val (p1x, p1y) = points[previousIdx]\n            val pointsShareValue = p1x == p2x || p1y == p2y\n\n            if (pointsShareValue) continue\n\n            // If (p1x, p2y) and (p2x, p1y), exist we've found a rectangle.\n            val point1OnOppositeDiagonalExists = convertPointToString(p1x, p2y) in pointSet\n            val point2OnOppositeDiagonalExists = convertPointToString(p2x, p1y) in pointSet\n            val oppositeDiagonalExists = point1OnOppositeDiagonalExists && point2OnOppositeDiagonalExists\n\n            if (oppositeDiagonalExists) {\n                val currentArea = abs(p2x - p1x) * abs(p2y - p1y)\n                minimumAreaFound = min(minimumAreaFound, currentArea)\n            }\n        }\n    }\n\n    return if (minimumAreaFound != Int.MAX_VALUE) minimumAreaFound else 0\n}\n\nfun createPointSet(points: List<List<Int>>): Set<String> {\n    val pointSet = mutableSetOf<String>()\n\n    for (point in points) {\n        val (x, y) = point\n        val pointString = convertPointToString(x, y)\n        pointSet.add(pointString)\n    }\n\n    return pointSet\n}\n\nfun convertPointToString(x: Int, y: Int): String {\n    return x.toString() + \":\" + y.toString()\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.minimumAreaRectangle\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(\n            listOf(1, 5),\n            listOf(5, 1),\n            listOf(4, 2),\n            listOf(2, 4),\n            listOf(2, 2),\n            listOf(1, 2),\n            listOf(4, 5),\n            listOf(2, 5),\n            listOf(-1, -2),\n        )\n        val expected = 3\n        val output = minimumAreaRectangle(input)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.minimumAreaRectangle\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(\n            listOf(1, 5),\n            listOf(5, 1),\n            listOf(4, 2),\n            listOf(2, 4),\n            listOf(2, 2),\n            listOf(1, 2),\n            listOf(4, 5),\n            listOf(2, 5),\n            listOf(-1, -2),\n        )\n        val expected = 3\n        val output = minimumAreaRectangle(input)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def minimumAreaRectangle(points):\n    # Write your code here.\n    return 0\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n^2) time | O(n) space - where n is the number of points\ndef minimumAreaRectangle(points):\n    columns = initializeColumns(points)\n    minimumAreaFound = float(\"inf\")\n    edgesParallelToYAxis = {}\n\n    sortedColumns = sorted(columns.keys())\n    for x in sortedColumns:\n        yValuesInCurrentColumn = columns[x]\n        yValuesInCurrentColumn.sort()\n\n        for currentIdx, y2 in enumerate(yValuesInCurrentColumn):\n            for previousIdx in range(currentIdx):\n                y1 = yValuesInCurrentColumn[previousIdx]\n                pointString = str(y1) + \":\" + str(y2)\n\n                if pointString in edgesParallelToYAxis:\n                    currentArea = (x - edgesParallelToYAxis[pointString]) * (y2 - y1)\n                    minimumAreaFound = min(minimumAreaFound, currentArea)\n\n                edgesParallelToYAxis[pointString] = x\n\n    return minimumAreaFound if minimumAreaFound != float(\"inf\") else 0\n\n\ndef initializeColumns(points):\n    columns = {}\n\n    for point in points:\n        x, y = point\n        if x not in columns:\n            columns[x] = []\n\n        columns[x].append(y)\n\n    return columns\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n^2) time | O(n) space - where n is the number of points\ndef minimumAreaRectangle(points):\n    pointSet = createPointSet(points)\n    minimumAreaFound = float(\"inf\")\n\n    for currentIdx, p2 in enumerate(points):\n        p2x, p2y = p2\n        for previousIdx in range(currentIdx):\n            p1x, p1y = points[previousIdx]\n            pointsShareValue = p1x == p2x or p1y == p2y\n\n            if pointsShareValue:\n                continue\n\n            # If (p1x, p2y) and (p2x, p1y), exist we've found a rectangle.\n            point1OnOppositeDiagonalExists = convertPointToString(p1x, p2y) in pointSet\n            point2OnOppositeDiagonalExists = convertPointToString(p2x, p1y) in pointSet\n            oppositeDiagonalExists = (\n                point1OnOppositeDiagonalExists and point2OnOppositeDiagonalExists\n            )\n\n            if oppositeDiagonalExists:\n                currentArea = abs(p2x - p1x) * abs(p2y - p1y)\n                minimumAreaFound = min(minimumAreaFound, currentArea)\n\n    return minimumAreaFound if minimumAreaFound != float(\"inf\") else 0\n\n\ndef createPointSet(points):\n    pointSet = set()\n\n    for point in points:\n        x, y = point\n        pointString = convertPointToString(x, y)\n        pointSet.add(pointString)\n\n    return pointSet\n\n\ndef convertPointToString(x, y):\n    return str(x) + \":\" + str(y)\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [[1, 5], [5, 1], [4, 2], [2, 4], [2, 2], [1, 2], [4, 5], [2, 5], [-1, -2]]\n        expected = 3\n        actual = program.minimumAreaRectangle(input)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [[1, 5], [5, 1], [4, 2], [2, 4], [2, 2], [1, 2], [4, 5], [2, 5], [-1, -2]]\n        expected = 3\n        actual = program.minimumAreaRectangle(input)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def minimumAreaRectangle(points)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def minimumAreaRectangle(points)\n    # Write your code here.\n    return -1\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def minimumAreaRectangle(points)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.minimumAreaRectangle\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.minimumAreaRectangle\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func minimumAreaRectangle(_ points: [[Int]]) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^2) time | O(n) space - where n is the number of points\n  func minimumAreaRectangle(_ points: [[Int]]) -> Int {\n    var columns = initializeColumns(points)\n    var minimumAreaFound = Int.max\n    var edgesParallelToYAxis = [String: Int]()\n\n    var sortedColumns = Array(columns.keys).sorted()\n\n    for x in sortedColumns {\n      var yValuesInCurrentColumn = columns[x]!.sorted()\n\n      for currentIdx in 0 ..< yValuesInCurrentColumn.count {\n        let y2 = yValuesInCurrentColumn[currentIdx]\n        for previousIdx in 0 ..< currentIdx {\n          let y1 = yValuesInCurrentColumn[previousIdx]\n          let pointString = String(y1) + \":\" + String(y2)\n\n          if edgesParallelToYAxis[pointString] != nil {\n            let currentArea = (x - edgesParallelToYAxis[pointString]!) * (y2 - y1)\n            minimumAreaFound = min(minimumAreaFound, currentArea)\n          }\n\n          edgesParallelToYAxis[pointString] = x\n        }\n      }\n    }\n\n    if minimumAreaFound != Int.max {\n      return minimumAreaFound\n    }\n    return 0\n  }\n\n  func initializeColumns(_ points: [[Int]]) -> [Int: [Int]] {\n    var columns = [Int: [Int]]()\n    for point in points {\n      let x = point[0]\n      let y = point[1]\n      if columns[x] == nil {\n        columns[x] = [Int]()\n      }\n      columns[x]!.append(y)\n    }\n    return columns\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^2) time | O(n) space - where n is the number of points\n  func minimumAreaRectangle(_ points: [[Int]]) -> Int {\n    let pointSet = createPointSet(points)\n    var minimumAreaFound = Int.max\n\n    for currentIdx in 0 ..< points.count {\n      let p2x = points[currentIdx][0]\n      let p2y = points[currentIdx][1]\n      for previousIdx in 0 ..< currentIdx {\n        let p1x = points[previousIdx][0]\n        let p1y = points[previousIdx][1]\n\n        let pointsShareValue = p1x == p2x || p1y == p2y\n        if pointsShareValue {\n          continue\n        }\n\n        // If (p1x, p2y) and (p2x, p1y), exist we've found a rectangle.\n        let point1OnOppositeDiagonalExists = pointSet.contains(convertPointToString(p1x, p2y))\n        let point2OnOppositeDiagonalExists = pointSet.contains(convertPointToString(p2x, p1y))\n        let oppositeDiagonalExists = point1OnOppositeDiagonalExists && point2OnOppositeDiagonalExists\n\n        if oppositeDiagonalExists {\n          let currentArea = abs(p2x - p1x) * abs(p2y - p1y)\n          minimumAreaFound = min(minimumAreaFound, currentArea)\n        }\n      }\n    }\n    if minimumAreaFound != Int.max {\n      return minimumAreaFound\n    }\n    return 0\n  }\n\n  func createPointSet(_ points: [[Int]]) -> Set<String> {\n    var pointSet: Set<String> = []\n    for point in points {\n      let x = point[0]\n      let y = point[1]\n      let pointString = convertPointToString(x, y)\n      pointSet.insert(pointString)\n    }\n    return pointSet\n  }\n\n  func convertPointToString(_ x: Int, _ y: Int) -> String {\n    return String(x) + \":\" + String(y)\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var input = [\n        [1, 5],\n        [5, 1],\n        [4, 2],\n        [2, 4],\n        [2, 2],\n        [1, 2],\n        [4, 5],\n        [2, 5],\n        [-1, -2],\n      ]\n      var expected = 3\n      var actual = Program().minimumAreaRectangle(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var input = [\n        [1, 5],\n        [5, 1],\n        [4, 2],\n        [2, 4],\n        [2, 2],\n        [1, 2],\n        [4, 5],\n        [2, 5],\n        [-1, -2],\n      ]\n      var expected = 3\n      var actual = Program().minimumAreaRectangle(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function minimumAreaRectangle(points: number[][]) {\n  // Write your code here.\n  return 0;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space - where n is the number of points\nexport function minimumAreaRectangle(points: number[][]) {\n  const columns = initializeColumns(points);\n  let minimumAreaFound = Infinity;\n  const edgesParallelToYAxis: {[edge: string]: number} = {};\n\n  const sortedColumns = Object.keys(columns)\n    .map(col => parseInt(col))\n    .sort((a, b) => a - b);\n  for (const x of sortedColumns) {\n    const yValuesInCurrentColumn = columns[x].sort((a, b) => a - b);\n\n    for (let currentIdx = 0; currentIdx < yValuesInCurrentColumn.length; currentIdx++) {\n      const y2 = yValuesInCurrentColumn[currentIdx];\n      for (let previousIdx = 0; previousIdx < currentIdx; previousIdx++) {\n        const y1 = yValuesInCurrentColumn[previousIdx];\n        const pointString = y1.toString() + ':' + y2.toString();\n\n        if (pointString in edgesParallelToYAxis) {\n          const currentArea = (x - edgesParallelToYAxis[pointString]) * (y2 - y1);\n          minimumAreaFound = Math.min(minimumAreaFound, currentArea);\n        }\n\n        edgesParallelToYAxis[pointString] = x;\n      }\n    }\n  }\n\n  return minimumAreaFound !== Infinity ? minimumAreaFound : 0;\n}\n\nfunction initializeColumns(points: number[][]) {\n  const columns: {[x: number]: number[]} = {};\n\n  for (const point of points) {\n    const [x, y] = point;\n    if (!columns[x]) {\n      columns[x] = [];\n    }\n    columns[x].push(y);\n  }\n\n  return columns;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space - where n is the number of points\nexport function minimumAreaRectangle(points: number[][]) {\n  const pointSet = createPointSet(points);\n  let minimumAreaFound = Infinity;\n\n  for (let currentIdx = 0; currentIdx < points.length; currentIdx++) {\n    const [p2x, p2y] = points[currentIdx];\n    for (let previousIdx = 0; previousIdx < currentIdx; previousIdx++) {\n      const [p1x, p1y] = points[previousIdx];\n      const pointsShareValue = p1x === p2x || p1y === p2y;\n\n      if (pointsShareValue) continue;\n\n      // If (p1x, p2y) and (p2x, p1y), exist we've found a rectangle.\n      const point1OnOppositeDiagonalExists = pointSet.has(convertPointToString(p1x, p2y));\n      const point2OnOppositeDiagonalExists = pointSet.has(convertPointToString(p2x, p1y));\n      const oppositeDiagonalExists =\n        point1OnOppositeDiagonalExists && point2OnOppositeDiagonalExists;\n\n      if (oppositeDiagonalExists) {\n        const currentArea = Math.abs(p2x - p1x) * Math.abs(p2y - p1y);\n        minimumAreaFound = Math.min(minimumAreaFound, currentArea);\n      }\n    }\n  }\n\n  return minimumAreaFound !== Infinity ? minimumAreaFound : 0;\n}\n\nfunction createPointSet(points: number[][]) {\n  const pointSet: Set<String> = new Set();\n\n  for (const point of points) {\n    const [x, y] = point;\n    const pointString = convertPointToString(x, y);\n    pointSet.add(pointString);\n  }\n\n  return pointSet;\n}\n\nfunction convertPointToString(x: number, y: number) {\n  return x.toString() + ':' + y.toString();\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 5],\n    [5, 1],\n    [4, 2],\n    [2, 4],\n    [2, 2],\n    [1, 2],\n    [4, 5],\n    [2, 5],\n    [-1, -2],\n  ];\n  const expected = 3;\n  const actual = program.minimumAreaRectangle(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 5],\n    [5, 1],\n    [4, 2],\n    [2, 4],\n    [2, 2],\n    [1, 2],\n    [4, 5],\n    [2, 5],\n    [-1, -2],\n  ];\n  const expected = 3;\n  const actual = program.minimumAreaRectangle(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "points",
      "example": [
        [
          1,
          5
        ],
        [
          5,
          1
        ],
        [
          4,
          2
        ],
        [
          2,
          4
        ],
        [
          2,
          2
        ],
        [
          1,
          2
        ],
        [
          4,
          5
        ],
        [
          2,
          5
        ],
        [
          -1,
          -2
        ]
      ],
      "schema": {
        "items": {
          "items": {
            "type": "integer"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "points": [
        [
          1,
          5
        ],
        [
          5,
          1
        ],
        [
          4,
          2
        ],
        [
          2,
          4
        ],
        [
          2,
          2
        ],
        [
          1,
          2
        ],
        [
          4,
          5
        ],
        [
          2,
          5
        ],
        [
          -1,
          -2
        ]
      ]
    },
    {
      "points": [
        [
          -4,
          4
        ],
        [
          4,
          4
        ],
        [
          4,
          -2
        ],
        [
          -4,
          -2
        ],
        [
          0,
          -2
        ],
        [
          4,
          2
        ],
        [
          0,
          2
        ]
      ]
    },
    {
      "points": [
        [
          -4,
          4
        ],
        [
          4,
          4
        ],
        [
          4,
          -2
        ],
        [
          -4,
          -2
        ],
        [
          0,
          -2
        ],
        [
          4,
          2
        ],
        [
          0,
          2
        ],
        [
          0,
          4
        ],
        [
          2,
          3
        ],
        [
          0,
          3
        ],
        [
          2,
          4
        ]
      ]
    },
    {
      "points": [
        [
          0,
          0
        ],
        [
          4,
          4
        ],
        [
          8,
          8
        ],
        [
          0,
          8
        ]
      ]
    },
    {
      "points": [
        [
          0,
          0
        ],
        [
          4,
          4
        ],
        [
          8,
          8
        ],
        [
          0,
          8
        ],
        [
          0,
          4
        ],
        [
          6,
          0
        ],
        [
          6,
          4
        ]
      ]
    },
    {
      "points": [
        [
          0,
          0
        ],
        [
          4,
          4
        ],
        [
          8,
          8
        ],
        [
          0,
          8
        ],
        [
          0,
          4
        ],
        [
          6,
          0
        ],
        [
          6,
          4
        ],
        [
          8,
          0
        ],
        [
          8,
          4
        ],
        [
          6,
          2
        ],
        [
          2,
          4
        ],
        [
          2,
          0
        ]
      ]
    },
    {
      "points": [
        [
          0,
          0
        ],
        [
          1,
          1
        ],
        [
          2,
          2
        ],
        [
          -1,
          -1
        ],
        [
          -2,
          -2
        ],
        [
          -1,
          1
        ],
        [
          -2,
          2
        ],
        [
          1,
          -1
        ],
        [
          2,
          -2
        ]
      ]
    },
    {
      "points": [
        [
          0,
          1
        ],
        [
          0,
          0
        ],
        [
          2,
          1
        ],
        [
          2,
          0
        ],
        [
          4,
          0
        ],
        [
          4,
          1
        ],
        [
          0,
          2
        ],
        [
          2,
          2
        ],
        [
          4,
          2
        ],
        [
          6,
          0
        ],
        [
          6,
          1
        ],
        [
          6,
          2
        ],
        [
          7,
          1
        ],
        [
          7,
          0
        ]
      ]
    },
    {
      "points": [
        [
          0,
          1
        ],
        [
          0,
          0
        ],
        [
          2,
          1
        ],
        [
          2,
          0
        ],
        [
          4,
          0
        ],
        [
          4,
          1
        ],
        [
          0,
          2
        ],
        [
          2,
          2
        ],
        [
          4,
          2
        ],
        [
          6,
          0
        ],
        [
          6,
          1
        ],
        [
          6,
          2
        ],
        [
          7,
          1
        ]
      ]
    },
    {
      "points": [
        [
          100,
          100
        ],
        [
          76,
          67
        ],
        [
          -100,
          100
        ],
        [
          65,
          76
        ],
        [
          100,
          -100
        ],
        [
          3,
          4
        ],
        [
          -100,
          -100
        ],
        [
          5,
          6
        ],
        [
          78,
          54
        ],
        [
          -87,
          7
        ],
        [
          1,
          4
        ],
        [
          4,
          1
        ],
        [
          -1,
          5
        ]
      ]
    },
    {
      "points": []
    },
    {
      "points": [
        [
          1,
          2
        ],
        [
          4,
          2
        ]
      ]
    },
    {
      "points": [
        [
          2,
          2
        ],
        [
          3,
          2
        ],
        [
          4,
          2
        ]
      ]
    }
  ],
  "jsonTests": [
    {
      "points": [
        [
          1,
          5
        ],
        [
          5,
          1
        ],
        [
          4,
          2
        ],
        [
          2,
          4
        ],
        [
          2,
          2
        ],
        [
          1,
          2
        ],
        [
          4,
          5
        ],
        [
          2,
          5
        ],
        [
          -1,
          -2
        ]
      ]
    },
    {
      "points": [
        [
          -4,
          4
        ],
        [
          4,
          4
        ],
        [
          4,
          -2
        ],
        [
          -4,
          -2
        ],
        [
          0,
          -2
        ],
        [
          4,
          2
        ],
        [
          0,
          2
        ]
      ]
    },
    {
      "points": [
        [
          -4,
          4
        ],
        [
          4,
          4
        ],
        [
          4,
          -2
        ],
        [
          -4,
          -2
        ],
        [
          0,
          -2
        ],
        [
          4,
          2
        ],
        [
          0,
          2
        ],
        [
          0,
          4
        ],
        [
          2,
          3
        ],
        [
          0,
          3
        ],
        [
          2,
          4
        ]
      ]
    },
    {
      "points": [
        [
          0,
          0
        ],
        [
          4,
          4
        ],
        [
          8,
          8
        ],
        [
          0,
          8
        ]
      ]
    },
    {
      "points": [
        [
          0,
          0
        ],
        [
          4,
          4
        ],
        [
          8,
          8
        ],
        [
          0,
          8
        ],
        [
          0,
          4
        ],
        [
          6,
          0
        ],
        [
          6,
          4
        ]
      ]
    },
    {
      "points": [
        [
          0,
          0
        ],
        [
          4,
          4
        ],
        [
          8,
          8
        ],
        [
          0,
          8
        ],
        [
          0,
          4
        ],
        [
          6,
          0
        ],
        [
          6,
          4
        ],
        [
          8,
          0
        ],
        [
          8,
          4
        ],
        [
          6,
          2
        ],
        [
          2,
          4
        ],
        [
          2,
          0
        ]
      ]
    },
    {
      "points": [
        [
          0,
          0
        ],
        [
          1,
          1
        ],
        [
          2,
          2
        ],
        [
          -1,
          -1
        ],
        [
          -2,
          -2
        ],
        [
          -1,
          1
        ],
        [
          -2,
          2
        ],
        [
          1,
          -1
        ],
        [
          2,
          -2
        ]
      ]
    },
    {
      "points": [
        [
          0,
          1
        ],
        [
          0,
          0
        ],
        [
          2,
          1
        ],
        [
          2,
          0
        ],
        [
          4,
          0
        ],
        [
          4,
          1
        ],
        [
          0,
          2
        ],
        [
          2,
          2
        ],
        [
          4,
          2
        ],
        [
          6,
          0
        ],
        [
          6,
          1
        ],
        [
          6,
          2
        ],
        [
          7,
          1
        ],
        [
          7,
          0
        ]
      ]
    },
    {
      "points": [
        [
          0,
          1
        ],
        [
          0,
          0
        ],
        [
          2,
          1
        ],
        [
          2,
          0
        ],
        [
          4,
          0
        ],
        [
          4,
          1
        ],
        [
          0,
          2
        ],
        [
          2,
          2
        ],
        [
          4,
          2
        ],
        [
          6,
          0
        ],
        [
          6,
          1
        ],
        [
          6,
          2
        ],
        [
          7,
          1
        ]
      ]
    },
    {
      "points": [
        [
          100,
          100
        ],
        [
          76,
          67
        ],
        [
          -100,
          100
        ],
        [
          65,
          76
        ],
        [
          100,
          -100
        ],
        [
          3,
          4
        ],
        [
          -100,
          -100
        ],
        [
          5,
          6
        ],
        [
          78,
          54
        ],
        [
          -87,
          7
        ],
        [
          1,
          4
        ],
        [
          4,
          1
        ],
        [
          -1,
          5
        ]
      ]
    },
    {
      "points": []
    },
    {
      "points": [
        [
          1,
          2
        ],
        [
          4,
          2
        ]
      ]
    },
    {
      "points": [
        [
          2,
          2
        ],
        [
          3,
          2
        ],
        [
          4,
          2
        ]
      ]
    }
  ],
  "changelog": []
}