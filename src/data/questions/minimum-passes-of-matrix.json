{
  "uid": "minimum-passes-of-matrix",
  "testStrategy": "JSON",
  "name": "Minimum Passes Of Matrix",
  "version": 0,
  "releaseDate": "2021-05-17T00:00:00Z",
  "category": "Graphs",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 11885,
    "failureCount": 2542
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "540401191",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 1294
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in an integer matrix of potentially unequal height\n  and width and returns the minimum number of passes required to convert all\n  negative integers in the matrix to positive integers.\n</p>\n<p>\n  A negative integer in the matrix can only be converted to a positive integer\n  if one or more of its adjacent elements is positive. An adjacent element is an\n  element that is to the left, to the right, above, or below the current element\n  in the matrix. Converting a negative to a positive simply involves multiplying\n  it by <span>-1</span>.\n</p>\n<p>\n  Note that the <span>0</span> value is neither positive nor negative, meaning\n  that a <span>0</span> can't convert an adjacent negative to a positive.\n</p>\n<p>\n  A single pass through the matrix involves converting all the negative integers\n  that <i>can</i> be converted at a particular point in time. For example,\n  consider the following input matrix:\n</p>\n<pre>\n[ \n  [0, -2, -1], \n  [-5, 2, 0], \n  [-6, -2, 0],\n]\n</pre>\n<p>After a first pass, only 3 values can be converted to positives:</p>\n<pre>\n[ \n  [0, 2, -1], \n  [5, 2, 0], \n  [-6, 2, 0],\n]\n</pre>\n<p>\n  After a second pass, the remaining negative values can all be converted to\n  positives:\n</p>\n<pre>\n[ \n  [0, 2, 1], \n  [5, 2, 0], \n  [6, 2, 0],\n]\n</pre>\n<p>\n  Note that the input matrix will always contain at least one element. If the\n  negative integers in the input matrix can't all be converted to positives,\n  regardless of how many passes are run, your function should return\n  <span>-1</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">matrix</span> = [\n  [0, -1, -3, 2, 0],\n  [1, -2, -5, -1, -3],\n  [3, 0, 0, -4, -1],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3\n</pre>\n</div>",
  "hints": [
    "<p>\n  The brute-force approach to solving this problem is to simply iterate through\n  the entire matrix, find all positive values, and change their negative\n  neighbors to positive. You then repeat this process until no more negative\n  neighbors exist. This approach works, but it doesn't run in an optimal time\n  complexity; can you think of a another way to solve this?\n</p>\n",
    "\n<p>\n  The approach discussed in Hint #1 has you look at the same elements in the\n  matrix multiple times. How can you ensure that you never process the same\n  element more than once?\n</p>\n",
    "\n<p>\n  Once a positive value has been found and you change its neighbors to\n  positives, this positive value can no longer lead to the conversion of any\n  more negative values. Instead, its neighbors (that you just changed to\n  positives) have the possibility of changing their own neighbors to positives.\n  After you change a negative value to positive, you should store its position\n  so that you can check if it can flip any of its neighbors in the next pass of\n  the matrix. Can something similar to a breadth-first search help you do this?\n</p>\n",
    "\n<p>\n  You can solve this problem in <span>O(w * h)</span> time, where\n  <span>w</span> and <span>h</span> are the width and height of the matrix, by\n  implementing a breadth-first search, starting from all the positive-value\n  positions in the array. Initialize a queue that stores the positions of all\n  positive values, iterate through the queue, dequeue elements out, and consider\n  all of their neighbors. If any of their neighbors are negative, change them to\n  positive, and store their positions in a secondary queue. Once the first queue\n  is empty, increment your number of passes, and iterate through the second\n  queue you created (the one with the positions of negatives that were changed\n  to positives). Repeat this process until no values are converted during a\n  pass.\n</p>\n",
    "\n<p>\n  The approach discussed in Hint #4 can work using either one or two queues. If\n  you decide to use only one queue, you'll need to differentiate the values that\n  were already positive when the current pass started from the values that were\n  changed to positive during the current pass. See the Conceptual Overview\n  section of this question's video explanation for a more in-depth explanation.\n</p>"
  ],
  "spaceTime": "O(w * h) time | O(w * h) space - where w is the width of the matrix and h is the height",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nint minimumPassesOfMatrix(vector<vector<int>> matrix) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nint convertNegatives(vector<vector<int>>& matrix);\nvector<vector<int>> getAllPositivePositions(const vector<vector<int>>& matrix);\nvector<vector<int>> getAdjacentPositions(\n  int row, int col, const vector<vector<int>>& matrix\n);\nbool containsNegative(const vector<vector<int>>& matrix);\n\n// O(w * h) time | O(w * h) space - where w is the\n// width of the matrix and h is the height\nint minimumPassesOfMatrix(vector<vector<int>> matrix) {\n  int passes = convertNegatives(matrix);\n  return !containsNegative(matrix) ? passes - 1 : -1;\n}\n\nint convertNegatives(vector<vector<int>>& matrix) {\n  vector<vector<int>> nextPassQueue = getAllPositivePositions(matrix);\n\n  int passes = 0;\n\n  while (nextPassQueue.size() > 0) {\n    vector<vector<int>> currentPassQueue = nextPassQueue;\n    nextPassQueue = {};\n\n    while (currentPassQueue.size() > 0) {\n      // In C++, removing elements from the start of a vector is an O(n)-time\n      // operation. To make this an O(1)-time operation, we could use a more\n      // legitimate queue structure. For our time complexity analysis, we'll\n      // assume this runs in O(1) time. Also, for this particular solution\n      // (Solution #1), we could actually just turn this queue into a stack and\n      // replace `.erase()` with the constant-time `.pop_back()` operation.\n      auto currentPosition = currentPassQueue.front();\n      currentPassQueue.erase(currentPassQueue.begin());\n      int currentRow = currentPosition[0];\n      int currentCol = currentPosition[1];\n\n      vector<vector<int>> adjacentPositions =\n        getAdjacentPositions(currentRow, currentCol, matrix);\n      for (const auto& position : adjacentPositions) {\n        int row = position[0];\n        int col = position[1];\n\n        int value = matrix[row][col];\n        if (value < 0) {\n          matrix[row][col] *= -1;\n          nextPassQueue.push_back({row, col});\n        }\n      }\n    }\n\n    passes++;\n  }\n\n  return passes;\n}\n\nvector<vector<int>> getAllPositivePositions(const vector<vector<int>>& matrix) {\n  vector<vector<int>> positivePositions;\n\n  for (int row = 0; row < matrix.size(); row++) {\n    for (int col = 0; col < matrix[row].size(); col++) {\n      int value = matrix[row][col];\n      if (value > 0) positivePositions.push_back({row, col});\n    }\n  }\n\n  return positivePositions;\n}\n\nvector<vector<int>> getAdjacentPositions(\n  int row, int col, const vector<vector<int>>& matrix\n) {\n  vector<vector<int>> adjacentPositions;\n\n  if (row > 0) adjacentPositions.push_back({row - 1, col});\n  if (row < matrix.size() - 1) adjacentPositions.push_back({row + 1, col});\n  if (col > 0) adjacentPositions.push_back({row, col - 1});\n  if (col < matrix[0].size() - 1) adjacentPositions.push_back({row, col + 1});\n\n  return adjacentPositions;\n}\n\nbool containsNegative(const vector<vector<int>>& matrix) {\n  for (const auto& row : matrix) {\n    for (const auto& value : row) {\n      if (value < 0) return true;\n    }\n  }\n\n  return false;\n}",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nint convertNegatives(vector<vector<int>>& matrix);\nvector<vector<int>> getAllPositivePositions(const vector<vector<int>>& matrix);\nvector<vector<int>> getAdjacentPositions(\n  int row, int col, const vector<vector<int>>& matrix\n);\nbool containsNegative(const vector<vector<int>>& matrix);\n\n// O(w * h) time | O(w * h) space - where w is the\n// width of the matrix and h is the height\nint minimumPassesOfMatrix(vector<vector<int>> matrix) {\n  int passes = convertNegatives(matrix);\n  return !containsNegative(matrix) ? passes - 1 : -1;\n}\n\nint convertNegatives(vector<vector<int>>& matrix) {\n  vector<vector<int>> queue = getAllPositivePositions(matrix);\n\n  int passes = 0;\n\n  while (queue.size() > 0) {\n    int currentSize = queue.size();\n\n    while (currentSize > 0) {\n      // In C++, removing elements from the start of a vector is an O(n)-time\n      // operation. To make this an O(1)-time operation, we could use a more\n      // legitimate queue structure. For our time complexity analysis, we'll\n      // assume this runs in O(1) time.\n      auto currentPosition = queue.front();\n      queue.erase(queue.begin());\n      int currentRow = currentPosition[0];\n      int currentCol = currentPosition[1];\n\n      vector<vector<int>> adjacentPositions =\n        getAdjacentPositions(currentRow, currentCol, matrix);\n      for (const auto& position : adjacentPositions) {\n        int row = position[0];\n        int col = position[1];\n\n        int value = matrix[row][col];\n        if (value < 0) {\n          matrix[row][col] *= -1;\n          queue.push_back({row, col});\n        }\n      }\n\n      currentSize--;\n    }\n\n    passes++;\n  }\n\n  return passes;\n}\n\nvector<vector<int>> getAllPositivePositions(const vector<vector<int>>& matrix) {\n  vector<vector<int>> positivePositions;\n\n  for (int row = 0; row < matrix.size(); row++) {\n    for (int col = 0; col < matrix[row].size(); col++) {\n      int value = matrix[row][col];\n      if (value > 0) positivePositions.push_back({row, col});\n    }\n  }\n\n  return positivePositions;\n}\n\nvector<vector<int>> getAdjacentPositions(\n  int row, int col, const vector<vector<int>>& matrix\n) {\n  vector<vector<int>> adjacentPositions;\n\n  if (row > 0) adjacentPositions.push_back({row - 1, col});\n  if (row < matrix.size() - 1) adjacentPositions.push_back({row + 1, col});\n  if (col > 0) adjacentPositions.push_back({row, col - 1});\n  if (col < matrix[0].size() - 1) adjacentPositions.push_back({row, col + 1});\n\n  return adjacentPositions;\n}\n\nbool containsNegative(const vector<vector<int>>& matrix) {\n  for (const auto& row : matrix) {\n    for (const auto& value : row) {\n      if (value < 0) return true;\n    }\n  }\n\n  return false;\n}"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> input = {\n        {0, -1, -3, 2, 0}, {1, -2, -5, -1, -3}, {3, 0, 0, -4, -1}};\n      ;\n      auto expected = 3;\n      auto actual = minimumPassesOfMatrix(input);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> input = {\n        {0, -1, -3, 2, 0}, {1, -2, -5, -1, -3}, {3, 0, 0, -4, -1}};\n      ;\n      auto expected = 3;\n      auto actual = minimumPassesOfMatrix(input);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public int MinimumPassesOfMatrix(int[][] matrix) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // O(w * h) time | O(w * h) space - where w is the\n  // width of the matrix and h is the height\n  public int MinimumPassesOfMatrix(int[][] matrix) {\n    int passes = convertNegatives(matrix);\n    return (!containsNegative(matrix)) ? passes - 1 : -1;\n  }\n\n  public int convertNegatives(int[][] matrix) {\n    List<int[]> nextPassQueue = getAllPositivePositions(matrix);\n\n    int passes = 0;\n\n    while (nextPassQueue.Count > 0) {\n      List<int[]> currentPassQueue = nextPassQueue;\n      nextPassQueue = new List<int[]>();\n\n      while (currentPassQueue.Count > 0) {\n        // In C#, removing elements from the start of a list is an O(n)-time\n        // operation. To make this an O(1)-time operation, we could use a more\n        // legitimate queue structure. For our time complexity analysis, we'll\n        // assume this runs in O(1) time. Also, for this particular solution\n        // (Solution #1), we could actually just turn this queue into a stack\n        // and replace `.RemoveAt(0)` with the constant-time `Pop()` operation.\n        int[] vals = currentPassQueue[0];\n        currentPassQueue.RemoveAt(0);\n        int currentRow = vals[0];\n        int currentCol = vals[1];\n\n        List<int[]> adjacentPositions =\n          getAdjacentPositions(currentRow, currentCol, matrix);\n        foreach (var position in adjacentPositions) {\n          int row = position[0];\n          int col = position[1];\n\n          int value = matrix[row][col];\n          if (value < 0) {\n            matrix[row][col] *= -1;\n            nextPassQueue.Add(new int[] { row, col });\n          }\n        }\n      }\n\n      passes += 1;\n    }\n\n    return passes;\n  }\n\n  public List<int[]> getAllPositivePositions(int[][] matrix) {\n    List<int[]> positivePositions = new List<int[]>();\n\n    for (int row = 0; row < matrix.Length; row++) {\n      for (int col = 0; col < matrix[row].Length; col++) {\n        int value = matrix[row][col];\n        if (value > 0) {\n          positivePositions.Add(new int[] { row, col });\n        }\n      }\n    }\n\n    return positivePositions;\n  }\n\n  public List<int[]> getAdjacentPositions(int row, int col, int[][] matrix) {\n    List<int[]> adjacentPositions = new List<int[]>();\n\n    if (row > 0) {\n      adjacentPositions.Add(new int[] { row - 1, col });\n    }\n    if (row < matrix.Length - 1) {\n      adjacentPositions.Add(new int[] { row + 1, col });\n    }\n    if (col > 0) {\n      adjacentPositions.Add(new int[] { row, col - 1 });\n    }\n    if (col < (matrix[0].Length - 1)) {\n      adjacentPositions.Add(new int[] { row, col + 1 });\n    }\n\n    return adjacentPositions;\n  }\n\n  public bool containsNegative(int[][] matrix) {\n    foreach (var row in matrix) {\n      foreach (var value in row) {\n        if (value < 0) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // O(w * h) time | O(w * h) space - where w is the\n  // width of the matrix and h is the height\n  public int MinimumPassesOfMatrix(int[][] matrix) {\n    int passes = convertNegatives(matrix);\n    return (!containsNegative(matrix)) ? passes - 1 : -1;\n  }\n\n  public int convertNegatives(int[][] matrix) {\n    List<int[]> queue = getAllPositivePositions(matrix);\n\n    int passes = 0;\n\n    while (queue.Count > 0) {\n      int currentSize = queue.Count;\n\n      while (currentSize > 0) {\n        // In C#, removing elements from the start of a list is an O(n)-time\n        // operation. To make this an O(1)-time operation, we could use a more\n        // legitimate queue structure. For our time complexity analysis, we'll\n        // assume this runs in O(1) time.\n        int[] vals = queue[0];\n        queue.RemoveAt(0);\n        int currentRow = vals[0];\n        int currentCol = vals[1];\n\n        List<int[]> adjacentPositions =\n          getAdjacentPositions(currentRow, currentCol, matrix);\n        foreach (var position in adjacentPositions) {\n          int row = position[0];\n          int col = position[1];\n\n          int value = matrix[row][col];\n          if (value < 0) {\n            matrix[row][col] *= -1;\n            queue.Add(new int[] { row, col });\n          }\n        }\n\n        currentSize -= 1;\n      }\n\n      passes += 1;\n    }\n\n    return passes;\n  }\n\n  public List<int[]> getAllPositivePositions(int[][] matrix) {\n    List<int[]> positivePositions = new List<int[]>();\n\n    for (int row = 0; row < matrix.Length; row++) {\n      for (int col = 0; col < matrix[row].Length; col++) {\n        int value = matrix[row][col];\n        if (value > 0) {\n          positivePositions.Add(new int[] { row, col });\n        }\n      }\n    }\n\n    return positivePositions;\n  }\n\n  public List<int[]> getAdjacentPositions(int row, int col, int[][] matrix) {\n    List<int[]> adjacentPositions = new List<int[]>();\n\n    if (row > 0) {\n      adjacentPositions.Add(new int[] { row - 1, col });\n    }\n    if (row < matrix.Length - 1) {\n      adjacentPositions.Add(new int[] { row + 1, col });\n    }\n    if (col > 0) {\n      adjacentPositions.Add(new int[] { row, col - 1 });\n    }\n    if (col < (matrix[0].Length - 1)) {\n      adjacentPositions.Add(new int[] { row, col + 1 });\n    }\n\n    return adjacentPositions;\n  }\n\n  public bool containsNegative(int[][] matrix) {\n    foreach (var row in matrix) {\n      foreach (var value in row) {\n        if (value < 0) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\nusing System.Linq;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[][] matrix = new int[][] {\n      new int[] { 0, -1, -3, 2, 0 },\n      new int[] { 1, -2, -5, -1, -3 },\n      new int[] { 3, 0, 0, -4, -1 },\n    };\n    int expected = 3;\n    int actual = new Program().MinimumPassesOfMatrix(matrix);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System;\nusing System.Linq;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[][] matrix = new int[][] {\n      new int[] { 0, -1, -3, 2, 0 },\n      new int[] { 1, -2, -5, -1, -3 },\n      new int[] { 3, 0, 0, -4, -1 },\n    };\n    int expected = 3;\n    int actual = new Program().MinimumPassesOfMatrix(matrix);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc MinimumPassesOfMatrix(matrix [][]int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype IntPair struct {\n\tFirst, Second int\n}\n\n// O(w * h) time | O(w * h) space - where w is the\n// width of the matrix and h is the height\nfunc MinimumPassesOfMatrix(matrix [][]int) int {\n\tpasses := convertNegatives(matrix)\n\tif !containsNegative(matrix) {\n\t\treturn passes - 1\n\t} else {\n\t\treturn -1\n\t}\n}\n\nfunc convertNegatives(matrix [][]int) int {\n\tnextPassQueue := getAllPositivePositions(matrix)\n\n\tvar passes = 0\n\n\tfor len(nextPassQueue) > 0 {\n\t\tcurrentPassQueue := nextPassQueue\n\t\tnextPassQueue = make([]IntPair, 0)\n\n\t\tfor len(currentPassQueue) > 0 {\n\t\t\t// In Go, removing elements from the start of a list is an O(n)-time operation.\n\t\t\t// To make this an O(1)-time operation, we could use a more legitimate queue structure.\n\t\t\t// For our time complexity analysis, we'll assume this runs in O(1) time.\n\t\t\t// Also, for this particular solution (Solution #1), we could actually\n\t\t\t// just turn this queue into a stack and replace the removal of the first element\n\t\t\t// with the removal of the last element.\n\t\t\tfirstElement := currentPassQueue[0]\n\t\t\tcurrentPassQueue = currentPassQueue[1:]\n\t\t\tcurrentRow, currentCol := firstElement.First, firstElement.Second\n\n\t\t\tadjacentPositions := getAdjacentPositions(currentRow, currentCol, matrix)\n\t\t\tfor _, position := range adjacentPositions {\n\t\t\t\trow, col := position.First, position.Second\n\n\t\t\t\tvalue := matrix[row][col]\n\t\t\t\tif value < 0 {\n\t\t\t\t\tmatrix[row][col] *= -1\n\t\t\t\t\tnextPassQueue = append(nextPassQueue, IntPair{row, col})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpasses += 1\n\t}\n\n\treturn passes\n}\n\nfunc getAllPositivePositions(matrix [][]int) []IntPair {\n\tpositivePositions := make([]IntPair, 0)\n\tfor row := range matrix {\n\t\tfor col := range matrix[row] {\n\t\t\tvalue := matrix[row][col]\n\t\t\tif value > 0 {\n\t\t\t\tpositivePositions = append(positivePositions, IntPair{row, col})\n\t\t\t}\n\t\t}\n\t}\n\treturn positivePositions\n}\n\nfunc getAdjacentPositions(row int, col int, matrix [][]int) []IntPair {\n\tadjacentPositions := make([]IntPair, 0)\n\n\tif row > 0 {\n\t\tadjacentPositions = append(adjacentPositions, IntPair{row - 1, col})\n\t}\n\tif row < len(matrix)-1 {\n\t\tadjacentPositions = append(adjacentPositions, IntPair{row + 1, col})\n\t}\n\tif col > 0 {\n\t\tadjacentPositions = append(adjacentPositions, IntPair{row, col - 1})\n\t}\n\tif col < len(matrix[0])-1 {\n\t\tadjacentPositions = append(adjacentPositions, IntPair{row, col + 1})\n\t}\n\n\treturn adjacentPositions\n}\n\nfunc containsNegative(matrix [][]int) bool {\n\tfor _, row := range matrix {\n\t\tfor _, value := range row {\n\t\t\tif value < 0 {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype IntPair struct {\n\tFirst, Second int\n}\n\n// O(w * h) time | O(w * h) space - where w is the\n// width of the matrix and h is the height\nfunc MinimumPassesOfMatrix(matrix [][]int) int {\n\tpasses := convertNegatives(matrix)\n\tif !containsNegative(matrix) {\n\t\treturn passes - 1\n\t} else {\n\t\treturn -1\n\t}\n}\n\nfunc convertNegatives(matrix [][]int) int {\n\tqueue := getAllPositivePositions(matrix)\n\n\tvar passes = 0\n\tfor len(queue) > 0 {\n\t\tvar currentSize = len(queue)\n\n\t\tfor currentSize > 0 {\n\t\t\t// In Go, removing elements from the start of a list is an O(n)-time operation.\n\t\t\t// To make this an O(1)-time operation, we could use a more legitimate queue structure.\n\t\t\t// For our time complexity analysis, we'll assume this runs in O(1) time.\n\t\t\tnextElement := queue[0]\n\t\t\tqueue = queue[1:]\n\t\t\tcurrentRow, currentCol := nextElement.First, nextElement.Second\n\n\t\t\tadjacentPositions := getAdjacentPositions(currentRow, currentCol, matrix)\n\t\t\tfor _, position := range adjacentPositions {\n\t\t\t\trow, col := position.First, position.Second\n\n\t\t\t\tvalue := matrix[row][col]\n\t\t\t\tif value < 0 {\n\t\t\t\t\tmatrix[row][col] *= -1\n\t\t\t\t\tqueue = append(queue, IntPair{row, col})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentSize -= 1\n\t\t}\n\n\t\tpasses += 1\n\t}\n\n\treturn passes\n}\n\nfunc getAllPositivePositions(matrix [][]int) []IntPair {\n\tpositivePositions := make([]IntPair, 0)\n\tfor row := range matrix {\n\t\tfor col := range matrix[row] {\n\t\t\tvalue := matrix[row][col]\n\t\t\tif value > 0 {\n\t\t\t\tpositivePositions = append(positivePositions, IntPair{row, col})\n\t\t\t}\n\t\t}\n\t}\n\treturn positivePositions\n}\n\nfunc getAdjacentPositions(row int, col int, matrix [][]int) []IntPair {\n\tadjacentPositions := make([]IntPair, 0)\n\n\tif row > 0 {\n\t\tadjacentPositions = append(adjacentPositions, IntPair{row - 1, col})\n\t}\n\tif row < len(matrix)-1 {\n\t\tadjacentPositions = append(adjacentPositions, IntPair{row + 1, col})\n\t}\n\tif col > 0 {\n\t\tadjacentPositions = append(adjacentPositions, IntPair{row, col - 1})\n\t}\n\tif col < len(matrix[0])-1 {\n\t\tadjacentPositions = append(adjacentPositions, IntPair{row, col + 1})\n\t}\n\n\treturn adjacentPositions\n}\n\nfunc containsNegative(matrix [][]int) bool {\n\tfor _, row := range matrix {\n\t\tfor _, value := range row {\n\t\t\tif value < 0 {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{0, -1, -3, 2, 0},\n\t\t{1, -2, -5, -1, -3},\n\t\t{3, 0, 0, -4, -1},\n\t}\n\texpected := 3\n\tactual := MinimumPassesOfMatrix(input)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{0, -1, -3, 2, 0},\n\t\t{1, -2, -5, -1, -3},\n\t\t{3, 0, 0, -4, -1},\n\t}\n\texpected := 3\n\tactual := MinimumPassesOfMatrix(input)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public int minimumPassesOfMatrix(int[][] matrix) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(w * h) time | O(w * h) space - where w is the\n  // width of the matrix and h is the height\n  public int minimumPassesOfMatrix(int[][] matrix) {\n    int passes = convertNegatives(matrix);\n    return (!containsNegative(matrix)) ? passes - 1 : -1;\n  }\n\n  public int convertNegatives(int[][] matrix) {\n    ArrayList<int[]> nextPassQueue = getAllPositivePositions(matrix);\n\n    int passes = 0;\n\n    while (nextPassQueue.size() > 0) {\n      ArrayList<int[]> currentPassQueue = nextPassQueue;\n      nextPassQueue = new ArrayList<int[]>();\n\n      while (currentPassQueue.size() > 0) {\n        // In Java, removing elements from the start of a list is an O(n)-time\n        // operation. To make this an O(1)-time operation, we could use a more\n        // legitimate queue structure. For our time complexity analysis, we'll\n        // assume this runs in O(1) time. Also, for this particular solution\n        // (Solution #1), we could actually just turn this queue into a stack\n        // and replace `.remove(0)` with the constant-time `pop()` operation.\n        int[] vals = currentPassQueue.remove(0);\n        int currentRow = vals[0];\n        int currentCol = vals[1];\n\n        ArrayList<int[]> adjacentPositions =\n          getAdjacentPositions(currentRow, currentCol, matrix);\n        for (int[] position : adjacentPositions) {\n          int row = position[0];\n          int col = position[1];\n\n          int value = matrix[row][col];\n          if (value < 0) {\n            matrix[row][col] *= -1;\n            nextPassQueue.add(new int[] {row, col});\n          }\n        }\n      }\n\n      passes += 1;\n    }\n\n    return passes;\n  }\n\n  public ArrayList<int[]> getAllPositivePositions(int[][] matrix) {\n    ArrayList<int[]> positivePositions = new ArrayList<int[]>();\n\n    for (int row = 0; row < matrix.length; row++) {\n      for (int col = 0; col < matrix[row].length; col++) {\n        int value = matrix[row][col];\n        if (value > 0) {\n          positivePositions.add(new int[] {row, col});\n        }\n      }\n    }\n\n    return positivePositions;\n  }\n\n  public ArrayList<int[]> getAdjacentPositions(\n    int row, int col, int[][] matrix\n  ) {\n    ArrayList<int[]> adjacentPositions = new ArrayList<int[]>();\n\n    if (row > 0) {\n      adjacentPositions.add(new int[] {row - 1, col});\n    }\n    if (row < matrix.length - 1) {\n      adjacentPositions.add(new int[] {row + 1, col});\n    }\n    if (col > 0) {\n      adjacentPositions.add(new int[] {row, col - 1});\n    }\n    if (col < (matrix[0].length - 1)) {\n      adjacentPositions.add(new int[] {row, col + 1});\n    }\n\n    return adjacentPositions;\n  }\n\n  public boolean containsNegative(int[][] matrix) {\n    for (int[] row : matrix) {\n      for (int value : row) {\n        if (value < 0) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(w * h) time | O(w * h) space - where w is the\n  // width of the matrix and h is the height\n  public int minimumPassesOfMatrix(int[][] matrix) {\n    int passes = convertNegatives(matrix);\n    return (!containsNegative(matrix)) ? passes - 1 : -1;\n  }\n\n  public int convertNegatives(int[][] matrix) {\n    ArrayList<int[]> queue = getAllPositivePositions(matrix);\n\n    int passes = 0;\n\n    while (queue.size() > 0) {\n      int currentSize = queue.size();\n\n      while (currentSize > 0) {\n        // In Java, removing elements from the start of a list is an O(n)-time\n        // operation. To make this an O(1)-time operation, we could use a more\n        // legitimate queue structure. For our time complexity analysis, we'll\n        // assume this runs in O(1) time.\n        int[] vals = queue.remove(0);\n        int currentRow = vals[0];\n        int currentCol = vals[1];\n\n        ArrayList<int[]> adjacentPositions =\n          getAdjacentPositions(currentRow, currentCol, matrix);\n        for (int[] position : adjacentPositions) {\n          int row = position[0];\n          int col = position[1];\n\n          int value = matrix[row][col];\n          if (value < 0) {\n            matrix[row][col] *= -1;\n            queue.add(new int[] {row, col});\n          }\n        }\n\n        currentSize -= 1;\n      }\n\n      passes += 1;\n    }\n\n    return passes;\n  }\n\n  public ArrayList<int[]> getAllPositivePositions(int[][] matrix) {\n    ArrayList<int[]> positivePositions = new ArrayList<int[]>();\n\n    for (int row = 0; row < matrix.length; row++) {\n      for (int col = 0; col < matrix[row].length; col++) {\n        int value = matrix[row][col];\n        if (value > 0) {\n          positivePositions.add(new int[] {row, col});\n        }\n      }\n    }\n\n    return positivePositions;\n  }\n\n  public ArrayList<int[]> getAdjacentPositions(\n    int row, int col, int[][] matrix\n  ) {\n    ArrayList<int[]> adjacentPositions = new ArrayList<int[]>();\n\n    if (row > 0) {\n      adjacentPositions.add(new int[] {row - 1, col});\n    }\n    if (row < matrix.length - 1) {\n      adjacentPositions.add(new int[] {row + 1, col});\n    }\n    if (col > 0) {\n      adjacentPositions.add(new int[] {row, col - 1});\n    }\n    if (col < (matrix[0].length - 1)) {\n      adjacentPositions.add(new int[] {row, col + 1});\n    }\n\n    return adjacentPositions;\n  }\n\n  public boolean containsNegative(int[][] matrix) {\n    for (int[] row : matrix) {\n      for (int value : row) {\n        if (value < 0) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] matrix =\n      new int[][] {{0, -1, -3, 2, 0}, {1, -2, -5, -1, -3}, {3, 0, 0, -4, -1}};\n    int expected = 3;\n    int actual = new Program().minimumPassesOfMatrix(matrix);\n    assert (expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] matrix =\n      new int[][] {{0, -1, -3, 2, 0}, {1, -2, -5, -1, -3}, {3, 0, 0, -4, -1}};\n    int expected = 3;\n    int actual = new Program().minimumPassesOfMatrix(matrix);\n    assert (expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function minimumPassesOfMatrix(matrix) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.minimumPassesOfMatrix = minimumPassesOfMatrix;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(w * h) time | O(w * h) space - where w is the\n// width of the matrix and h is the height\nfunction minimumPassesOfMatrix(matrix) {\n  const passes = convertNegatives(matrix);\n  return !containsNegative(matrix) ? passes - 1 : -1;\n}\n\nfunction convertNegatives(matrix) {\n  let nextPassQueue = getAllPositivePositions(matrix);\n\n  let passes = 0;\n\n  while (nextPassQueue.length > 0) {\n    const currentPassQueue = nextPassQueue;\n    nextPassQueue = [];\n\n    while (currentPassQueue.length > 0) {\n      // In JavaScript, shifting elements from the start of an array is an O(n)-time operation.\n      // To make this an O(1)-time operation, we could use a more legitimate queue structure.\n      // For our time complexity analysis, we'll assume this runs in O(1) time.\n      // Also, for this particular solution (Solution #1), we could actually\n      // just turn this queue into a stack and replace `.shift()` with the\n      // constant-time `.pop()` operation.\n      const [currentRow, currentCol] = currentPassQueue.shift();\n\n      const adjacentPositions = getAdjacentPositions(currentRow, currentCol, matrix);\n      for (const position of adjacentPositions) {\n        const [row, col] = position;\n\n        const value = matrix[row][col];\n        if (value < 0) {\n          matrix[row][col] *= -1;\n          nextPassQueue.push([row, col]);\n        }\n      }\n    }\n\n    passes++;\n  }\n\n  return passes;\n}\n\nfunction getAllPositivePositions(matrix) {\n  const positivePositions = [];\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      const value = matrix[row][col];\n      if (value > 0) positivePositions.push([row, col]);\n    }\n  }\n\n  return positivePositions;\n}\n\nfunction getAdjacentPositions(row, col, matrix) {\n  const adjacentPositions = [];\n\n  if (row > 0) adjacentPositions.push([row - 1, col]);\n  if (row < matrix.length - 1) adjacentPositions.push([row + 1, col]);\n  if (col > 0) adjacentPositions.push([row, col - 1]);\n  if (col < matrix[0].length - 1) adjacentPositions.push([row, col + 1]);\n\n  return adjacentPositions;\n}\n\nfunction containsNegative(matrix) {\n  for (const row of matrix) {\n    for (const value of row) {\n      if (value < 0) return true;\n    }\n  }\n\n  return false;\n}\n\n// Do not edit the line below.\nexports.minimumPassesOfMatrix = minimumPassesOfMatrix;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(w * h) time | O(w * h) space - where w is the\n// width of the matrix and h is the height\nfunction minimumPassesOfMatrix(matrix) {\n  const passes = convertNegatives(matrix);\n  return !containsNegative(matrix) ? passes - 1 : -1;\n}\n\nfunction convertNegatives(matrix) {\n  const queue = getAllPositivePositions(matrix);\n\n  let passes = 0;\n\n  while (queue.length > 0) {\n    let currentSize = queue.length;\n\n    while (currentSize > 0) {\n      // In JavaScript, shifting elements from the start of an array is an O(n)-time operation.\n      // To make this an O(1)-time operation, we could use a more legitimate queue structure.\n      // For our time complexity analysis, we'll assume this runs in O(1) time.\n      const [currentRow, currentCol] = queue.shift();\n\n      const adjacentPositions = getAdjacentPositions(currentRow, currentCol, matrix);\n      for (const position of adjacentPositions) {\n        const [row, col] = position;\n\n        const value = matrix[row][col];\n        if (value < 0) {\n          matrix[row][col] *= -1;\n          queue.push([row, col]);\n        }\n      }\n\n      currentSize--;\n    }\n\n    passes++;\n  }\n\n  return passes;\n}\n\nfunction getAllPositivePositions(matrix) {\n  const positivePositions = [];\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      const value = matrix[row][col];\n      if (value > 0) positivePositions.push([row, col]);\n    }\n  }\n\n  return positivePositions;\n}\n\nfunction getAdjacentPositions(row, col, matrix) {\n  const adjacentPositions = [];\n\n  if (row > 0) adjacentPositions.push([row - 1, col]);\n  if (row < matrix.length - 1) adjacentPositions.push([row + 1, col]);\n  if (col > 0) adjacentPositions.push([row, col - 1]);\n  if (col < matrix[0].length - 1) adjacentPositions.push([row, col + 1]);\n\n  return adjacentPositions;\n}\n\nfunction containsNegative(matrix) {\n  for (const row of matrix) {\n    for (const value of row) {\n      if (value < 0) return true;\n    }\n  }\n\n  return false;\n}\n\n// Do not edit the line below.\nexports.minimumPassesOfMatrix = minimumPassesOfMatrix;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [0, -1, -3, 2, 0],\n    [1, -2, -5, -1, -3],\n    [3, 0, 0, -4, -1],\n  ];\n  const expected = 3;\n  const actual = program.minimumPassesOfMatrix(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [0, -1, -3, 2, 0],\n    [1, -2, -5, -1, -3],\n    [3, 0, 0, -4, -1],\n  ];\n  const expected = 3;\n  const actual = program.minimumPassesOfMatrix(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun minimumPassesOfMatrix(matrix: MutableList<MutableList<Int>>): Int {\n    // Write your code here.\n    return -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(w * h) time | O(w * h) space - where w is the\n// width of the matrix and h is the height\nfun minimumPassesOfMatrix(matrix: MutableList<MutableList<Int>>): Int {\n    val passes = convertNegatives(matrix)\n    return if (!containsNegative(matrix)) passes - 1 else -1\n}\n\nfun convertNegatives(matrix: MutableList<MutableList<Int>>): Int {\n    var nextPassQueue = getAllPositivePositions(matrix)\n\n    var passes = 0\n\n    while (nextPassQueue.size > 0) {\n        val currentPassQueue = nextPassQueue\n        nextPassQueue = mutableListOf<Pair<Int, Int>>()\n\n        while (currentPassQueue.size > 0) {\n            // In Kotlin, removing elements from the start of a list is an O(n)-time operation.\n            // To make this an O(1)-time operation, we could use a more legitimate queue structure.\n            // For our time complexity analysis, we'll assume this runs in O(1) time.\n            // Also, for this particular solution (Solution #1), we could actually\n            // just turn this queue into a stack and replace `.removeAt(0)` with the\n            // constant-time `.removeAt(currentPassQueue.size - 1)` operation.\n            val (currentRow, currentCol) = currentPassQueue.removeAt(0)\n\n            val adjacentPositions = getAdjacentPositions(\n                currentRow,\n                currentCol,\n                matrix,\n            )\n            for (position in adjacentPositions) {\n                val (row, col) = position\n\n                val value = matrix[row][col]\n                if (value < 0) {\n                    matrix[row][col] *= -1\n                    nextPassQueue.add(Pair(row, col))\n                }\n            }\n        }\n\n        passes += 1\n    }\n\n    return passes\n}\n\nfun getAllPositivePositions(matrix: MutableList<MutableList<Int>>): MutableList<Pair<Int, Int>> {\n    val positivePositions = mutableListOf<Pair<Int, Int>>()\n\n    for (row in 0 until matrix.size) {\n        for (col in 0 until matrix[row].size) {\n            val value = matrix[row][col]\n            if (value > 0) positivePositions.add(Pair(row, col))\n        }\n    }\n\n    return positivePositions\n}\n\nfun getAdjacentPositions(row: Int, col: Int, matrix: MutableList<MutableList<Int>>): List<Pair<Int, Int>> {\n    val adjacentPositions = mutableListOf<Pair<Int, Int>>()\n\n    if (row > 0) adjacentPositions.add(Pair(row - 1, col))\n    if (row < matrix.size - 1) adjacentPositions.add(Pair(row + 1, col))\n    if (col > 0) adjacentPositions.add(Pair(row, col - 1))\n    if (col < matrix[0].size - 1) adjacentPositions.add(Pair(row, col + 1))\n\n    return adjacentPositions\n}\n\nfun containsNegative(matrix: MutableList<MutableList<Int>>): Boolean {\n    for (row in matrix) {\n        for (value in row) {\n            if (value < 0) return true\n        }\n    }\n\n    return false\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(w * h) time | O(w * h) space - where w is the\n// width of the matrix and h is the height\nfun minimumPassesOfMatrix(matrix: MutableList<MutableList<Int>>): Int {\n    val passes = convertNegatives(matrix)\n    return if (!containsNegative(matrix)) passes - 1 else -1\n}\n\nfun convertNegatives(matrix: MutableList<MutableList<Int>>): Int {\n    val queue = getAllPositivePositions(matrix)\n\n    var passes = 0\n\n    while (queue.size > 0) {\n        var currentSize = queue.size\n\n        while (currentSize > 0) {\n            // In Kotlin, removing elements from the start of a list is an O(n)-time operation.\n            // To make this an O(1)-time operation, we could use a more legitimate queue structure.\n            // For our time complexity analysis, we'll assume this runs in O(1) time.\n            val (currentRow, currentCol) = queue.removeAt(0)\n\n            val adjacentPositions = getAdjacentPositions(\n                currentRow,\n                currentCol,\n                matrix,\n            )\n            for (position in adjacentPositions) {\n                val (row, col) = position\n\n                val value = matrix[row][col]\n                if (value < 0) {\n                    matrix[row][col] *= -1\n                    queue.add(Pair(row, col))\n                }\n            }\n\n            currentSize -= 1\n        }\n\n        passes += 1\n    }\n\n    return passes\n}\n\nfun getAllPositivePositions(matrix: MutableList<MutableList<Int>>): MutableList<Pair<Int, Int>> {\n    val positivePositions = mutableListOf<Pair<Int, Int>>()\n\n    for (row in 0 until matrix.size) {\n        for (col in 0 until matrix[row].size) {\n            val value = matrix[row][col]\n            if (value > 0) positivePositions.add(Pair(row, col))\n        }\n    }\n\n    return positivePositions\n}\n\nfun getAdjacentPositions(row: Int, col: Int, matrix: MutableList<MutableList<Int>>): List<Pair<Int, Int>> {\n    val adjacentPositions = mutableListOf<Pair<Int, Int>>()\n\n    if (row > 0) adjacentPositions.add(Pair(row - 1, col))\n    if (row < matrix.size - 1) adjacentPositions.add(Pair(row + 1, col))\n    if (col > 0) adjacentPositions.add(Pair(row, col - 1))\n    if (col < matrix[0].size - 1) adjacentPositions.add(Pair(row, col + 1))\n\n    return adjacentPositions\n}\n\nfun containsNegative(matrix: MutableList<MutableList<Int>>): Boolean {\n    for (row in matrix) {\n        for (value in row) {\n            if (value < 0) return true\n        }\n    }\n\n    return false\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.minimumPassesOfMatrix\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = mutableListOf(\n            mutableListOf(0, -1, -3, 2, 0),\n            mutableListOf(1, -2, -5, -1, -3),\n            mutableListOf(3, 0, 0, -4, -1),\n        )\n        val expected = 3\n        val output = minimumPassesOfMatrix(input)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.minimumPassesOfMatrix\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = mutableListOf(\n            mutableListOf(0, -1, -3, 2, 0),\n            mutableListOf(1, -2, -5, -1, -3),\n            mutableListOf(3, 0, 0, -4, -1),\n        )\n        val expected = 3\n        val output = minimumPassesOfMatrix(input)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def minimumPassesOfMatrix(matrix):\n    # Write your code here.\n    return -1\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(w * h) time | O(w * h) space - where w is the\n# width of the matrix and h is the height\ndef minimumPassesOfMatrix(matrix):\n    passes = convertNegatives(matrix)\n    return passes - 1 if not containsNegative(matrix) else -1\n\n\ndef convertNegatives(matrix):\n    nextPassQueue = getAllPositivePositions(matrix)\n\n    passes = 0\n\n    while len(nextPassQueue) > 0:\n        currentPassQueue = nextPassQueue\n        nextPassQueue = []\n\n        while len(currentPassQueue) > 0:\n            # In Python, popping elements from the start of a list is an O(n)-time operation.\n            # To make this an O(1)-time operation, we could use the `deque` object.\n            # For our time complexity analysis, we'll assume this runs in O(1) time.\n            # Also, for this particular solution (Solution #1), we could actually\n            # just turn this queue into a stack and replace `.pop(0)` with the\n            # constant-time `.pop()` operation.\n            currentRow, currentCol = currentPassQueue.pop(0)\n\n            adjacentPositions = getAdjacentPositions(currentRow, currentCol, matrix)\n            for position in adjacentPositions:\n                row, col = position\n\n                value = matrix[row][col]\n                if value < 0:\n                    matrix[row][col] *= -1\n                    nextPassQueue.append([row, col])\n\n        passes += 1\n\n    return passes\n\n\ndef getAllPositivePositions(matrix):\n    positivePositions = []\n\n    for row in range(len(matrix)):\n        for col in range(len(matrix[row])):\n            value = matrix[row][col]\n            if value > 0:\n                positivePositions.append([row, col])\n\n    return positivePositions\n\n\ndef getAdjacentPositions(row, col, matrix):\n    adjacentPositions = []\n\n    if row > 0:\n        adjacentPositions.append([row - 1, col])\n    if row < len(matrix) - 1:\n        adjacentPositions.append([row + 1, col])\n    if col > 0:\n        adjacentPositions.append([row, col - 1])\n    if col < len(matrix[0]) - 1:\n        adjacentPositions.append([row, col + 1])\n\n    return adjacentPositions\n\n\ndef containsNegative(matrix):\n    for row in matrix:\n        for value in row:\n            if value < 0:\n                return True\n\n    return False\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(w * h) time | O(w * h) space - where w is the\n# width of the matrix and h is the height\ndef minimumPassesOfMatrix(matrix):\n    passes = convertNegatives(matrix)\n    return passes - 1 if not containsNegative(matrix) else -1\n\n\ndef convertNegatives(matrix):\n    queue = getAllPositivePositions(matrix)\n\n    passes = 0\n\n    while len(queue) > 0:\n        currentSize = len(queue)\n\n        while currentSize > 0:\n            # In Python, popping elements from the start of a list is an O(n)-time operation.\n            # To make this an O(1)-time operation, we could use the `deque` object.\n            # For our time complexity analysis, we'll assume this runs in O(1) time.\n            currentRow, currentCol = queue.pop(0)\n\n            adjacentPositions = getAdjacentPositions(currentRow, currentCol, matrix)\n            for position in adjacentPositions:\n                row, col = position\n\n                value = matrix[row][col]\n                if value < 0:\n                    matrix[row][col] *= -1\n                    queue.append([row, col])\n\n            currentSize -= 1\n\n        passes += 1\n\n    return passes\n\n\ndef getAllPositivePositions(matrix):\n    positivePositions = []\n\n    for row in range(len(matrix)):\n        for col in range(len(matrix[row])):\n            value = matrix[row][col]\n            if value > 0:\n                positivePositions.append([row, col])\n\n    return positivePositions\n\n\ndef getAdjacentPositions(row, col, matrix):\n    adjacentPositions = []\n\n    if row > 0:\n        adjacentPositions.append([row - 1, col])\n    if row < len(matrix) - 1:\n        adjacentPositions.append([row + 1, col])\n    if col > 0:\n        adjacentPositions.append([row, col - 1])\n    if col < len(matrix[0]) - 1:\n        adjacentPositions.append([row, col + 1])\n\n    return adjacentPositions\n\n\ndef containsNegative(matrix):\n    for row in matrix:\n        for value in row:\n            if value < 0:\n                return True\n\n    return False\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [\n            [0, -1, -3, 2, 0],\n            [1, -2, -5, -1, -3],\n            [3, 0, 0, -4, -1],\n        ]\n        expected = 3\n        actual = program.minimumPassesOfMatrix(input)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [\n            [0, -1, -3, 2, 0],\n            [1, -2, -5, -1, -3],\n            [3, 0, 0, -4, -1],\n        ]\n        expected = 3\n        actual = program.minimumPassesOfMatrix(input)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "class Program\n  def minimumPassesOfMatrix(matrix)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def minimumPassesOfMatrix(matrix)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.minimumPassesOfMatrix\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.minimumPassesOfMatrix\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func minimumPassesOfMatrix(_ matrix: inout [[Int]]) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(w * h) time | O(w * h) space - where w is the\n  // width of the matrix and h is the height\n  func minimumPassesOfMatrix(_ matrix: inout [[Int]]) -> Int {\n    let passes = convertNegatives(&matrix)\n    if !containsNegative(&matrix) {\n      return passes - 1\n    } else {\n      return -1\n    }\n  }\n\n  func convertNegatives(_ matrix: inout [[Int]]) -> Int {\n    var nextPassQueue = getAllPositivePositions(&matrix)\n\n    var passes = 0\n\n    while nextPassQueue.count > 0 {\n      var currentPassQueue = nextPassQueue\n      nextPassQueue = [(Int, Int)]()\n\n      while currentPassQueue.count > 0 {\n        // In Swift, removing elements from the start of a list is an O(n)-time operation.\n        // To make this an O(1)-time operation, we could use a more legitimate queue structure.\n        // For our time complexity analysis, we'll assume this runs in O(1) time.\n        // Also, for this particular solution (Solution #1), we could actually\n        // just turn this queue into a stack and replace `.removeFirst()` with the\n        // constant-time `removeLast()` operation.\n        let firstElement = currentPassQueue[0]\n        currentPassQueue.removeFirst()\n        let (currentRow, currentCol) = (firstElement.0, firstElement.1)\n\n        let adjacentPositions = getAdjacentPositions(currentRow, currentCol, &matrix)\n        for position in adjacentPositions {\n          let (row, col) = (position.0, position.1)\n\n          let value = matrix[row][col]\n          if value < 0 {\n            matrix[row][col] *= -1\n            nextPassQueue.append((row, col))\n          }\n        }\n      }\n\n      passes += 1\n    }\n\n    return passes\n  }\n\n  func getAllPositivePositions(_ matrix: inout [[Int]]) -> [(Int, Int)] {\n    var positivePositions = [(Int, Int)]()\n    for row in 0 ..< matrix.count {\n      for col in 0 ..< matrix[row].count {\n        let value = matrix[row][col]\n        if value > 0 {\n          positivePositions.append((row, col))\n        }\n      }\n    }\n    return positivePositions\n  }\n\n  func getAdjacentPositions(_ row: Int, _ col: Int, _ matrix: inout [[Int]]) -> [(Int, Int)] {\n    var adjacentPositions = [(Int, Int)]()\n\n    if row > 0 {\n      adjacentPositions.append((row - 1, col))\n    }\n    if row < matrix.count - 1 {\n      adjacentPositions.append((row + 1, col))\n    }\n    if col > 0 {\n      adjacentPositions.append((row, col - 1))\n    }\n    if col < matrix[0].count - 1 {\n      adjacentPositions.append((row, col + 1))\n    }\n\n    return adjacentPositions\n  }\n\n  func containsNegative(_ matrix: inout [[Int]]) -> Bool {\n    for row in matrix {\n      for value in row {\n        if value < 0 {\n          return true\n        }\n      }\n    }\n    return false\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(w * h) time | O(w * h) space - where w is the\n  // width of the matrix and h is the height\n  func minimumPassesOfMatrix(_ matrix: inout [[Int]]) -> Int {\n    let passes = convertNegatives(&matrix)\n    if !containsNegative(&matrix) {\n      return passes - 1\n    } else {\n      return -1\n    }\n  }\n\n  func convertNegatives(_ matrix: inout [[Int]]) -> Int {\n    var queue = getAllPositivePositions(&matrix)\n\n    var passes = 0\n\n    while queue.count > 0 {\n      var currentSize = queue.count\n\n      while currentSize > 0 {\n        // In Swift, removing elements from the start of a list is an O(n)-time operation.\n        // To make this an O(1)-time operation, we could use a more legitimate queue structure.\n        // For our time complexity analysis, we'll assume this runs in O(1) time.\n        let firstElement = queue[0]\n        queue.removeFirst()\n        let (currentRow, currentCol) = (firstElement.0, firstElement.1)\n\n        let adjacentPositions = getAdjacentPositions(currentRow, currentCol, &matrix)\n        for position in adjacentPositions {\n          let (row, col) = (position.0, position.1)\n\n          let value = matrix[row][col]\n          if value < 0 {\n            matrix[row][col] *= -1\n            queue.append((row, col))\n          }\n        }\n\n        currentSize -= 1\n      }\n\n      passes += 1\n    }\n\n    return passes\n  }\n\n  func getAllPositivePositions(_ matrix: inout [[Int]]) -> [(Int, Int)] {\n    var positivePositions = [(Int, Int)]()\n    for row in 0 ..< matrix.count {\n      for col in 0 ..< matrix[row].count {\n        let value = matrix[row][col]\n        if value > 0 {\n          positivePositions.append((row, col))\n        }\n      }\n    }\n    return positivePositions\n  }\n\n  func getAdjacentPositions(_ row: Int, _ col: Int, _ matrix: inout [[Int]]) -> [(Int, Int)] {\n    var adjacentPositions = [(Int, Int)]()\n\n    if row > 0 {\n      adjacentPositions.append((row - 1, col))\n    }\n    if row < matrix.count - 1 {\n      adjacentPositions.append((row + 1, col))\n    }\n    if col > 0 {\n      adjacentPositions.append((row, col - 1))\n    }\n    if col < matrix[0].count - 1 {\n      adjacentPositions.append((row, col + 1))\n    }\n\n    return adjacentPositions\n  }\n\n  func containsNegative(_ matrix: inout [[Int]]) -> Bool {\n    for row in matrix {\n      for value in row {\n        if value < 0 {\n          return true\n        }\n      }\n    }\n    return false\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var input = [\n        [0, -1, -3, 2, 0],\n        [1, -2, -5, -1, -3],\n        [3, 0, 0, -4, -1],\n      ]\n      var expected = 3\n      var actual = Program().minimumPassesOfMatrix(&input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var input = [\n        [0, -1, -3, 2, 0],\n        [1, -2, -5, -1, -3],\n        [3, 0, 0, -4, -1],\n      ]\n      var expected = 3\n      var actual = Program().minimumPassesOfMatrix(&input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function minimumPassesOfMatrix(matrix: number[][]) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(w * h) time | O(w * h) space - where w is the\n// width of the matrix and h is the height\nexport function minimumPassesOfMatrix(matrix: number[][]) {\n  const passes = convertNegatives(matrix);\n  return !containsNegative(matrix) ? passes - 1 : -1;\n}\n\nfunction convertNegatives(matrix: number[][]) {\n  let nextPassQueue = getAllPositivePositions(matrix);\n\n  let passes = 0;\n\n  while (nextPassQueue.length > 0) {\n    const currentPassQueue = nextPassQueue;\n    nextPassQueue = [];\n\n    while (currentPassQueue.length > 0) {\n      // In JavaScript, shifting elements from the start of an array is an O(n)-time operation.\n      // To make this an O(1)-time operation, we could use a more legitimate queue structure.\n      // For our time complexity analysis, we'll assume this runs in O(1) time.\n      // Also, for this particular solution (Solution #1), we could actually\n      // just turn this queue into a stack and replace `.shift()` with the\n      // constant-time `.pop()` operation.\n      const [currentRow, currentCol] = currentPassQueue.shift()!;\n\n      const adjacentPositions = getAdjacentPositions(currentRow, currentCol, matrix);\n      for (const position of adjacentPositions) {\n        const [row, col] = position;\n\n        const value = matrix[row][col];\n        if (value < 0) {\n          matrix[row][col] *= -1;\n          nextPassQueue.push([row, col]);\n        }\n      }\n    }\n\n    passes++;\n  }\n\n  return passes;\n}\n\nfunction getAllPositivePositions(matrix: number[][]) {\n  const positivePositions: [number, number][] = [];\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      const value = matrix[row][col];\n      if (value > 0) positivePositions.push([row, col]);\n    }\n  }\n\n  return positivePositions;\n}\n\nfunction getAdjacentPositions(row: number, col: number, matrix: number[][]) {\n  const adjacentPositions: [number, number][] = [];\n\n  if (row > 0) adjacentPositions.push([row - 1, col]);\n  if (row < matrix.length - 1) adjacentPositions.push([row + 1, col]);\n  if (col > 0) adjacentPositions.push([row, col - 1]);\n  if (col < matrix[0].length - 1) adjacentPositions.push([row, col + 1]);\n\n  return adjacentPositions;\n}\n\nfunction containsNegative(matrix: number[][]) {\n  for (const row of matrix) {\n    for (const value of row) {\n      if (value < 0) return true;\n    }\n  }\n\n  return false;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(w * h) time | O(w * h) space - where w is the\n// width of the matrix and h is the height\nexport function minimumPassesOfMatrix(matrix: number[][]) {\n  const passes = convertNegatives(matrix);\n  return !containsNegative(matrix) ? passes - 1 : -1;\n}\n\nfunction convertNegatives(matrix: number[][]) {\n  const queue = getAllPositivePositions(matrix);\n\n  let passes = 0;\n\n  while (queue.length > 0) {\n    let currentSize = queue.length;\n\n    while (currentSize > 0) {\n      // In JavaScript, shifting elements from the start of an array is an O(n)-time operation.\n      // To make this an O(1)-time operation, we could use a more legitimate queue structure.\n      // For our time complexity analysis, we'll assume this runs in O(1) time.\n      const [currentRow, currentCol] = queue.shift()!;\n\n      const adjacentPositions = getAdjacentPositions(currentRow, currentCol, matrix);\n      for (const position of adjacentPositions) {\n        const [row, col] = position;\n\n        const value = matrix[row][col];\n        if (value < 0) {\n          matrix[row][col] *= -1;\n          queue.push([row, col]);\n        }\n      }\n\n      currentSize--;\n    }\n\n    passes++;\n  }\n\n  return passes;\n}\n\nfunction getAllPositivePositions(matrix: number[][]) {\n  const positivePositions: [number, number][] = [];\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      const value = matrix[row][col];\n      if (value > 0) positivePositions.push([row, col]);\n    }\n  }\n\n  return positivePositions;\n}\n\nfunction getAdjacentPositions(row: number, col: number, matrix: number[][]) {\n  const adjacentPositions: [number, number][] = [];\n\n  if (row > 0) adjacentPositions.push([row - 1, col]);\n  if (row < matrix.length - 1) adjacentPositions.push([row + 1, col]);\n  if (col > 0) adjacentPositions.push([row, col - 1]);\n  if (col < matrix[0].length - 1) adjacentPositions.push([row, col + 1]);\n\n  return adjacentPositions;\n}\n\nfunction containsNegative(matrix: number[][]) {\n  for (const row of matrix) {\n    for (const value of row) {\n      if (value < 0) return true;\n    }\n  }\n\n  return false;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [0, -1, -3, 2, 0],\n    [1, -2, -5, -1, -3],\n    [3, 0, 0, -4, -1],\n  ];\n  const expected = 3;\n  const actual = program.minimumPassesOfMatrix(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [0, -1, -3, 2, 0],\n    [1, -2, -5, -1, -3],\n    [3, 0, 0, -4, -1],\n  ];\n  const expected = 3;\n  const actual = program.minimumPassesOfMatrix(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "matrix",
      "example": [
        [
          0,
          -1,
          -3,
          2,
          0
        ],
        [
          1,
          -2,
          -5,
          -1,
          -3
        ],
        [
          3,
          0,
          0,
          -4,
          -1
        ]
      ],
      "schema": {
        "items": {
          "items": {
            "type": "integer"
          },
          "minItems": 1,
          "type": "array"
        },
        "minItems": 1,
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "matrix": [
        [
          0,
          -1,
          -3,
          2,
          0
        ],
        [
          1,
          -2,
          -5,
          -1,
          -3
        ],
        [
          3,
          0,
          0,
          -4,
          -1
        ]
      ]
    },
    {
      "matrix": [
        [
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          0,
          0,
          -2,
          -3
        ],
        [
          -4,
          -5,
          -6,
          -2,
          -1
        ],
        [
          0,
          0,
          0,
          0,
          -1
        ],
        [
          1,
          2,
          3,
          0,
          -2
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          0,
          0,
          -2,
          -3
        ],
        [
          -4,
          -5,
          -6,
          -2,
          -1
        ],
        [
          0,
          0,
          0,
          0,
          -1
        ],
        [
          1,
          2,
          3,
          0,
          3
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          0,
          0,
          -2,
          -3
        ],
        [
          -4,
          -5,
          -6,
          -2,
          -1
        ],
        [
          0,
          0,
          0,
          0,
          -1
        ],
        [
          -1,
          0,
          3,
          0,
          3
        ]
      ]
    },
    {
      "matrix": [
        [
          -1
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          2,
          3
        ],
        [
          4,
          5,
          6
        ]
      ]
    },
    {
      "matrix": [
        [
          -1,
          -9,
          0,
          -1,
          0
        ],
        [
          -9,
          -4,
          -5,
          4,
          -8
        ],
        [
          2,
          0,
          0,
          -3,
          0
        ],
        [
          0,
          -17,
          -4,
          2,
          -5
        ]
      ]
    },
    {
      "matrix": [
        [
          -2,
          -3,
          -4,
          -1,
          -9
        ],
        [
          -4,
          -3,
          -4,
          -1,
          -2
        ],
        [
          -6,
          -7,
          -2,
          -1,
          -1
        ],
        [
          0,
          0,
          0,
          0,
          -3
        ],
        [
          1,
          -2,
          -3,
          -6,
          -1
        ]
      ]
    },
    {
      "matrix": [
        [
          -1,
          2,
          3
        ],
        [
          4,
          5,
          6
        ]
      ]
    },
    {
      "matrix": [
        [
          -1,
          2,
          3
        ],
        [
          4,
          -5,
          -6
        ]
      ]
    },
    {
      "matrix": [
        [
          -1,
          0,
          3
        ],
        [
          0,
          -5,
          -6
        ]
      ]
    },
    {
      "matrix": [
        [
          -1,
          0,
          3
        ],
        [
          0,
          -5,
          -6
        ]
      ]
    },
    {
      "matrix": [
        [
          0,
          0,
          -1,
          -2
        ],
        [
          -2,
          -3,
          4,
          -1
        ],
        [
          -2,
          -3,
          1,
          -3
        ],
        [
          -14,
          -15,
          2,
          0
        ],
        [
          0,
          0,
          0,
          0
        ],
        [
          1,
          -1,
          -1,
          -1
        ]
      ]
    },
    {
      "matrix": [
        [
          0,
          0,
          -1,
          -2
        ],
        [
          -2,
          -3,
          4,
          -1
        ],
        [
          -2,
          -3,
          1,
          -3
        ],
        [
          -14,
          -15,
          2,
          0
        ],
        [
          0,
          0,
          0,
          0
        ],
        [
          1,
          -1,
          -1,
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          -2,
          0,
          -2,
          1
        ],
        [
          -2,
          -1,
          -1,
          -1
        ]
      ]
    }
  ],
  "jsonTests": [
    {
      "matrix": [
        [
          0,
          -1,
          -3,
          2,
          0
        ],
        [
          1,
          -2,
          -5,
          -1,
          -3
        ],
        [
          3,
          0,
          0,
          -4,
          -1
        ]
      ]
    },
    {
      "matrix": [
        [
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          0,
          0,
          -2,
          -3
        ],
        [
          -4,
          -5,
          -6,
          -2,
          -1
        ],
        [
          0,
          0,
          0,
          0,
          -1
        ],
        [
          1,
          2,
          3,
          0,
          -2
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          0,
          0,
          -2,
          -3
        ],
        [
          -4,
          -5,
          -6,
          -2,
          -1
        ],
        [
          0,
          0,
          0,
          0,
          -1
        ],
        [
          1,
          2,
          3,
          0,
          3
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          0,
          0,
          -2,
          -3
        ],
        [
          -4,
          -5,
          -6,
          -2,
          -1
        ],
        [
          0,
          0,
          0,
          0,
          -1
        ],
        [
          -1,
          0,
          3,
          0,
          3
        ]
      ]
    },
    {
      "matrix": [
        [
          -1
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          2,
          3
        ],
        [
          4,
          5,
          6
        ]
      ]
    },
    {
      "matrix": [
        [
          -1,
          -9,
          0,
          -1,
          0
        ],
        [
          -9,
          -4,
          -5,
          4,
          -8
        ],
        [
          2,
          0,
          0,
          -3,
          0
        ],
        [
          0,
          -17,
          -4,
          2,
          -5
        ]
      ]
    },
    {
      "matrix": [
        [
          -2,
          -3,
          -4,
          -1,
          -9
        ],
        [
          -4,
          -3,
          -4,
          -1,
          -2
        ],
        [
          -6,
          -7,
          -2,
          -1,
          -1
        ],
        [
          0,
          0,
          0,
          0,
          -3
        ],
        [
          1,
          -2,
          -3,
          -6,
          -1
        ]
      ]
    },
    {
      "matrix": [
        [
          -1,
          2,
          3
        ],
        [
          4,
          5,
          6
        ]
      ]
    },
    {
      "matrix": [
        [
          -1,
          2,
          3
        ],
        [
          4,
          -5,
          -6
        ]
      ]
    },
    {
      "matrix": [
        [
          -1,
          0,
          3
        ],
        [
          0,
          -5,
          -6
        ]
      ]
    },
    {
      "matrix": [
        [
          -1,
          0,
          3
        ],
        [
          0,
          -5,
          -6
        ]
      ]
    },
    {
      "matrix": [
        [
          0,
          0,
          -1,
          -2
        ],
        [
          -2,
          -3,
          4,
          -1
        ],
        [
          -2,
          -3,
          1,
          -3
        ],
        [
          -14,
          -15,
          2,
          0
        ],
        [
          0,
          0,
          0,
          0
        ],
        [
          1,
          -1,
          -1,
          -1
        ]
      ]
    },
    {
      "matrix": [
        [
          0,
          0,
          -1,
          -2
        ],
        [
          -2,
          -3,
          4,
          -1
        ],
        [
          -2,
          -3,
          1,
          -3
        ],
        [
          -14,
          -15,
          2,
          0
        ],
        [
          0,
          0,
          0,
          0
        ],
        [
          1,
          -1,
          -1,
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          -2,
          0,
          -2,
          1
        ],
        [
          -2,
          -1,
          -1,
          -1
        ]
      ]
    }
  ],
  "changelog": []
}