{
  "uid": "non-attacking-queens",
  "testStrategy": "JSON",
  "name": "Non-Attacking Queens",
  "version": 0,
  "releaseDate": "2021-04-14T00:00:00Z",
  "category": "Recursion",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 2992,
    "failureCount": 558
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "536135918",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 2537
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in a positive integer <span>n</span> and returns\n  the number of non-attacking placements of <span>n</span> queens on an\n  <span>n x n</span> chessboard.\n</p>\n<p>\n  A non-attacking placement is one where no queen can attack another queen in a\n  single turn. In other words, it's a placement where no queen can move to the\n  same position as another queen in a single turn.\n</p>\n<p>\n  In chess, queens can move any number of squares horizontally, vertically, or\n  diagonally in a single turn.\n</p>\n<pre>\n+--+--+--+--+  \n|  |Q |  |  |\n+--+--+--+--+\n|  |  |  |Q |\n+--+--+--+--+\n|Q |  |  |  |\n+--+--+--+--+\n|  |  |Q |  |\n+--+--+--+--+\n</pre>\n<p>\n  The chessboard above is an example of a non-attacking placement of 4 queens on\n  a 4x4 chessboard. For reference, there are only 2 non-attacking placements of\n  4 queens on a 4x4 chessboard.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">n</span> = 4\n</pre>\n<h3>Sample Output</h3>\n<pre>\n2\n</pre>\n</div>",
  "hints": [
    "<p>\n  As soon as the input gets relatively large, this problem can no longer be\n  solved with a brute-force approach. For example, there are\n  <span>16,777,216</span> possible placements of 8 queens on an 8x8 chessboard.\n  To consider all of these placements and to check if they're non-attacking\n  isn't viable. Can you come up with an approach that limits the number of\n  placements to consider?\n</p>\n",
    "\n<p>\n  In order to generate a placement of <span>n</span> queens, you naturally have\n  to place queens one at a time. Try only placing queens such that they're in a\n  non-attacking position, given where you've previously placed queens. This\n  should drastically limit the total number of placements that you consider. For\n  example, if you place the first queen in the first row and in the first\n  column, then don't consider a placement where any other queen is in the first\n  row, in the first column, or in the down diagonal that starts at the first\n  queen.\n</p>\n",
    "\n<p>\n  When placing a queen in order to generate a full placement of\n  <span>n</span> queens, you'll have to check if the position that you're\n  considering is non-attacking. This can be done in linear time or in constant\n  time, depending on if and how you store what columns and diagonals are blocked\n  by previously placed queens. See the Conceptual Overview section of this\n  question's video explanation for a more in-depth explanation.\n</p>"
  ],
  "spaceTime": "Upper Bound: O(n!) time | O(n) space - where n is the input number",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\nint nonAttackingQueens(int n) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint getNumberOfNonAttackingQueenPlacements(\n  int row, vector<int>& columnPlacements, int boardSize\n);\nbool isNonAttackingPlacement(int row, int col, vector<int> columnPlacements);\n\n// Lower Bound: O(n!) time | O(n) space - where n is the input number\nint nonAttackingQueens(int n) {\n  // Each index of `columnPlacements` represents a row of the chessboard,\n  // and the value at each index is the column (on the relevant row) where\n  // a queen is currently placed.\n  vector<int> columnPlacements(n, 0);\n  return getNumberOfNonAttackingQueenPlacements(0, columnPlacements, n);\n}\n\nint getNumberOfNonAttackingQueenPlacements(\n  int row, vector<int>& columnPlacements, int boardSize\n) {\n  if (row == boardSize) return 1;\n\n  int validPlacements = 0;\n  for (int col = 0; col < boardSize; col++) {\n    if (isNonAttackingPlacement(row, col, columnPlacements)) {\n      columnPlacements[row] = col;\n      validPlacements += getNumberOfNonAttackingQueenPlacements(\n        row + 1, columnPlacements, boardSize\n      );\n    }\n  }\n\n  return validPlacements;\n}\n\n// As `row` tends to `n`, this becomes an O(n)-time operation.\nbool isNonAttackingPlacement(int row, int col, vector<int> columnPlacements) {\n  for (int previousRow = 0; previousRow < row; previousRow++) {\n    int columnToCheck = columnPlacements[previousRow];\n    bool sameColumn = columnToCheck == col;\n    bool onDiagonal = abs(columnToCheck - col) == row - previousRow;\n    if (sameColumn || onDiagonal) return false;\n  }\n\n  return true;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <unordered_set>\nusing namespace std;\n\nint getNumberOfNonAttackingQueenPlacements(\n  int row,\n  unordered_set<int>& blockedColumns,\n  unordered_set<int>& blockedUpDiagonals,\n  unordered_set<int>& blockedDownDiagonals,\n  int boardSize\n);\nbool isNonAttackingPlacement(\n  int row,\n  int col,\n  unordered_set<int>& blockedColumns,\n  unordered_set<int>& blockedUpDiagonals,\n  unordered_set<int>& blockedDownDiagonals\n);\nvoid placeQueen(\n  int row,\n  int col,\n  unordered_set<int>& blockedColumns,\n  unordered_set<int>& blockedUpDiagonals,\n  unordered_set<int>& blockedDownDiagonals\n);\nvoid removeQueen(\n  int row,\n  int col,\n  unordered_set<int>& blockedColumns,\n  unordered_set<int>& blockedUpDiagonals,\n  unordered_set<int>& blockedDownDiagonals\n);\n\n// Upper Bound: O(n!) time | O(n) space - where n is the input number\nint nonAttackingQueens(int n) {\n  unordered_set<int> blockedColumns;\n  unordered_set<int> blockedUpDiagonals;\n  unordered_set<int> blockedDownDiagonals;\n  return getNumberOfNonAttackingQueenPlacements(\n    0, blockedColumns, blockedUpDiagonals, blockedDownDiagonals, n\n  );\n}\n\nint getNumberOfNonAttackingQueenPlacements(\n  int row,\n  unordered_set<int>& blockedColumns,\n  unordered_set<int>& blockedUpDiagonals,\n  unordered_set<int>& blockedDownDiagonals,\n  int boardSize\n) {\n  if (row == boardSize) return 1;\n\n  int validPlacements = 0;\n  for (int col = 0; col < boardSize; col++) {\n    if (isNonAttackingPlacement(\n          row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals\n        )) {\n      placeQueen(\n        row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals\n      );\n      validPlacements += getNumberOfNonAttackingQueenPlacements(\n        row + 1,\n        blockedColumns,\n        blockedUpDiagonals,\n        blockedDownDiagonals,\n        boardSize\n      );\n      removeQueen(\n        row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals\n      );\n    }\n  }\n\n  return validPlacements;\n}\n\n// This is always an O(1)-time operation.\nbool isNonAttackingPlacement(\n  int row,\n  int col,\n  unordered_set<int>& blockedColumns,\n  unordered_set<int>& blockedUpDiagonals,\n  unordered_set<int>& blockedDownDiagonals\n) {\n  if (blockedColumns.find(col) != blockedColumns.end()) return false;\n  if (blockedUpDiagonals.find(row + col) != blockedUpDiagonals.end())\n    return false;\n  if (blockedDownDiagonals.find(row - col) != blockedDownDiagonals.end())\n    return false;\n\n  return true;\n}\n\nvoid placeQueen(\n  int row,\n  int col,\n  unordered_set<int>& blockedColumns,\n  unordered_set<int>& blockedUpDiagonals,\n  unordered_set<int>& blockedDownDiagonals\n) {\n  blockedColumns.insert(col);\n  blockedUpDiagonals.insert(row + col);\n  blockedDownDiagonals.insert(row - col);\n}\n\nvoid removeQueen(\n  int row,\n  int col,\n  unordered_set<int>& blockedColumns,\n  unordered_set<int>& blockedUpDiagonals,\n  unordered_set<int>& blockedDownDiagonals\n) {\n  blockedColumns.erase(col);\n  blockedUpDiagonals.erase(row + col);\n  blockedDownDiagonals.erase(row - col);\n}"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto input = 4;\n      auto expected = 2;\n      auto actual = nonAttackingQueens(input);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto input = 4;\n      auto expected = 2;\n      auto actual = nonAttackingQueens(input);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public int NonAttackingQueens(int n) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // Lower Bound: O(n!) time | O(n) space - where n is the input number\n  public int NonAttackingQueens(int n) {\n    // Each index of `columnPlacements` represents a row of the chessboard,\n    // and the value at each index is the column (on the relevant row) where\n    // a queen is currently placed.\n    int[] columnPlacements = new int[n];\n    return getNumberOfNonAttackingQueenPlacements(0, columnPlacements, n);\n  }\n\n  public int getNumberOfNonAttackingQueenPlacements(\n    int row, int[] columnPlacements, int boardSize\n  ) {\n    if (row == boardSize) return 1;\n\n    int validPlacements = 0;\n    for (int col = 0; col < boardSize; col++) {\n      if (isNonAttackingPlacement(row, col, columnPlacements)) {\n        columnPlacements[row] = col;\n        validPlacements += getNumberOfNonAttackingQueenPlacements(\n          row + 1, columnPlacements, boardSize\n        );\n      }\n    }\n\n    return validPlacements;\n  }\n\n  // As `row` tends to `n`, this becomes an O(n)-time operation.\n  public bool isNonAttackingPlacement(\n    int row, int col, int[] columnPlacements\n  ) {\n    for (int previousRow = 0; previousRow < row; previousRow++) {\n      int columnToCheck = columnPlacements[previousRow];\n      bool sameColumn = (columnToCheck == col);\n      bool onDiagonal = Math.Abs(columnToCheck - col) == (row - previousRow);\n      if (sameColumn || onDiagonal) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program {\n  // Upper Bound: O(n!) time | O(n) space - where n is the input number\n  public int NonAttackingQueens(int n) {\n    HashSet<int> blockedColumns = new HashSet<int>();\n    HashSet<int> blockedUpDiagonals = new HashSet<int>();\n    HashSet<int> blockedDownDiagonals = new HashSet<int>();\n    return getNumberOfNonAttackingQueenPlacements(\n      0, blockedColumns, blockedUpDiagonals, blockedDownDiagonals, n\n    );\n  }\n\n  public int getNumberOfNonAttackingQueenPlacements(\n    int row,\n    HashSet<int> blockedColumns,\n    HashSet<int> blockedUpDiagonals,\n    HashSet<int> blockedDownDiagonals,\n    int boardSize\n  ) {\n    if (row == boardSize) return 1;\n\n    int validPlacements = 0;\n    for (int col = 0; col < boardSize; col++) {\n      if (isNonAttackingPlacement(\n            row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals\n          )) {\n        placeQueen(\n          row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals\n        );\n        validPlacements += getNumberOfNonAttackingQueenPlacements(\n          row + 1,\n          blockedColumns,\n          blockedUpDiagonals,\n          blockedDownDiagonals,\n          boardSize\n        );\n        removeQueen(\n          row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals\n        );\n      }\n    }\n\n    return validPlacements;\n  }\n\n  // This is always an O(1)-time operation.\n  public bool isNonAttackingPlacement(\n    int row,\n    int col,\n    HashSet<int> blockedColumns,\n    HashSet<int> blockedUpDiagonals,\n    HashSet<int> blockedDownDiagonals\n  ) {\n    if (blockedColumns.Contains(col)) {\n      return false;\n    } else if (blockedUpDiagonals.Contains(row + col)) {\n      return false;\n    } else if (blockedDownDiagonals.Contains(row - col)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public void placeQueen(\n    int row,\n    int col,\n    HashSet<int> blockedColumns,\n    HashSet<int> blockedUpDiagonals,\n    HashSet<int> blockedDownDiagonals\n  ) {\n    blockedColumns.Add(col);\n    blockedUpDiagonals.Add(row + col);\n    blockedDownDiagonals.Add(row - col);\n  }\n\n  public void removeQueen(\n    int row,\n    int col,\n    HashSet<int> blockedColumns,\n    HashSet<int> blockedUpDiagonals,\n    HashSet<int> blockedDownDiagonals\n  ) {\n    blockedColumns.Remove(col);\n    blockedUpDiagonals.Remove(row + col);\n    blockedDownDiagonals.Remove(row - col);\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var input = 4;\n    var expected = 2;\n    var actual = new Program().NonAttackingQueens(input);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var input = 4;\n    var expected = 2;\n    var actual = new Program().NonAttackingQueens(input);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc NonAttackingQueens(n int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// Lower Bound: O(n!) time | O(n) space - where n is the input number\nfunc NonAttackingQueens(n int) int {\n\t// Each index of `columnPlacements` represents a row of the chessboard,\n\t// and the value at each index is the column (on the relevant row) where\n\t// a queen is currently placed.\n\tcolumnPlacements := make([]int, n)\n\treturn getNumberOfNonAttackingQueenPlacements(0, columnPlacements, n)\n}\n\nfunc getNumberOfNonAttackingQueenPlacements(\n\trow int, columnPlacements []int, boardSize int) int {\n\tif row == boardSize {\n\t\treturn 1\n\t}\n\n\tvalidPlacements := 0\n\tfor col := 0; col < boardSize; col++ {\n\t\tif isNonAttackingPlacement(row, col, columnPlacements) {\n\t\t\tcolumnPlacements[row] = col\n\t\t\tvalidPlacements += getNumberOfNonAttackingQueenPlacements(row+1,\n\t\t\t\tcolumnPlacements, boardSize)\n\t\t}\n\t}\n\treturn validPlacements\n}\n\n// As `row` tends to `n`, this becomes an O(n)-time operation.\nfunc isNonAttackingPlacement(row, col int, columnPlacements []int) bool {\n\tfor previousRow := 0; previousRow < row; previousRow++ {\n\t\tcolumnToCheck := columnPlacements[previousRow]\n\t\tsameColumn := columnToCheck == col\n\t\tonDiagonal := abs(columnToCheck-col) == row-previousRow\n\t\tif sameColumn || onDiagonal {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc abs(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// Upper Bound: O(n!) time | O(n) space - where n is the input number\nfunc NonAttackingQueens(n int) int {\n\tblockedColumns := map[int]bool{}\n\tblockedUpDiagonals := map[int]bool{}\n\tblockedDownDiagonals := map[int]bool{}\n\treturn getNumberOfNonAttackingQueenPlacements(0, blockedColumns,\n\t\tblockedUpDiagonals, blockedDownDiagonals, n)\n}\n\nfunc getNumberOfNonAttackingQueenPlacements(\n\trow int,\n\tblockedColumns map[int]bool,\n\tblockedUpDiagonals map[int]bool,\n\tblockedDownDiagonals map[int]bool,\n\tboardSize int,\n) int {\n\tif row == boardSize {\n\t\treturn 1\n\t}\n\n\tvalidPlacements := 0\n\tfor col := 0; col < boardSize; col++ {\n\t\tif isNonAttackingPlacement(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals) {\n\t\t\tplaceQueen(row, col, blockedColumns, blockedUpDiagonals,\n\t\t\t\tblockedDownDiagonals)\n\t\t\tvalidPlacements += getNumberOfNonAttackingQueenPlacements(row+1,\n\t\t\t\tblockedColumns, blockedUpDiagonals, blockedDownDiagonals, boardSize)\n\t\t\tremoveQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals)\n\t\t}\n\t}\n\treturn validPlacements\n}\n\n// This is always an O(1)-time operation.\nfunc isNonAttackingPlacement(row, col int,\n\tblockedColumns map[int]bool,\n\tblockedUpDiagonals map[int]bool,\n\tblockedDownDiagonals map[int]bool,\n) bool {\n\tif blockedColumns[col] {\n\t\treturn false\n\t}\n\tif blockedUpDiagonals[row+col] {\n\t\treturn false\n\t}\n\tif blockedDownDiagonals[row-col] {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc placeQueen(row, col int,\n\tblockedColumns map[int]bool,\n\tblockedUpDiagonals map[int]bool,\n\tblockedDownDiagonals map[int]bool,\n) {\n\tblockedColumns[col] = true\n\tblockedUpDiagonals[row+col] = true\n\tblockedDownDiagonals[row-col] = true\n}\n\nfunc removeQueen(row, col int,\n\tblockedColumns map[int]bool,\n\tblockedUpDiagonals map[int]bool,\n\tblockedDownDiagonals map[int]bool,\n) {\n\tblockedColumns[col] = false\n\tblockedUpDiagonals[row+col] = false\n\tblockedDownDiagonals[row-col] = false\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := 4\n\texpected := 2\n\tactual := NonAttackingQueens(input)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := 4\n\texpected := 2\n\tactual := NonAttackingQueens(input)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public int nonAttackingQueens(int n) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // Lower Bound: O(n!) time | O(n) space - where n is the input number\n  public int nonAttackingQueens(int n) {\n    // Each index of `columnPlacements` represents a row of the chessboard,\n    // and the value at each index is the column (on the relevant row) where\n    // a queen is currently placed.\n    int[] columnPlacements = new int[n];\n    return getNumberOfNonAttackingQueenPlacements(0, columnPlacements, n);\n  }\n\n  public int getNumberOfNonAttackingQueenPlacements(\n    int row, int[] columnPlacements, int boardSize\n  ) {\n    if (row == boardSize) return 1;\n\n    int validPlacements = 0;\n    for (int col = 0; col < boardSize; col++) {\n      if (isNonAttackingPlacement(row, col, columnPlacements)) {\n        columnPlacements[row] = col;\n        validPlacements += getNumberOfNonAttackingQueenPlacements(\n          row + 1, columnPlacements, boardSize\n        );\n      }\n    }\n\n    return validPlacements;\n  }\n\n  // As `row` tends to `n`, this becomes an O(n)-time operation.\n  public boolean isNonAttackingPlacement(\n    int row, int col, int[] columnPlacements\n  ) {\n    for (int previousRow = 0; previousRow < row; previousRow++) {\n      int columnToCheck = columnPlacements[previousRow];\n      boolean sameColumn = (columnToCheck == col);\n      boolean onDiagonal = Math.abs(columnToCheck - col) == (row - previousRow);\n      if (sameColumn || onDiagonal) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // Upper Bound: O(n!) time | O(n) space - where n is the input number\n  public int nonAttackingQueens(int n) {\n    HashSet<Integer> blockedColumns = new HashSet<Integer>();\n    HashSet<Integer> blockedUpDiagonals = new HashSet<Integer>();\n    HashSet<Integer> blockedDownDiagonals = new HashSet<Integer>();\n    return getNumberOfNonAttackingQueenPlacements(\n      0, blockedColumns, blockedUpDiagonals, blockedDownDiagonals, n\n    );\n  }\n\n  public int getNumberOfNonAttackingQueenPlacements(\n    int row,\n    HashSet<Integer> blockedColumns,\n    HashSet<Integer> blockedUpDiagonals,\n    HashSet<Integer> blockedDownDiagonals,\n    int boardSize\n  ) {\n    if (row == boardSize) return 1;\n\n    int validPlacements = 0;\n    for (int col = 0; col < boardSize; col++) {\n      if (isNonAttackingPlacement(\n            row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals\n          )) {\n        placeQueen(\n          row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals\n        );\n        validPlacements += getNumberOfNonAttackingQueenPlacements(\n          row + 1,\n          blockedColumns,\n          blockedUpDiagonals,\n          blockedDownDiagonals,\n          boardSize\n        );\n        removeQueen(\n          row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals\n        );\n      }\n    }\n\n    return validPlacements;\n  }\n\n  // This is always an O(1)-time operation.\n  public boolean isNonAttackingPlacement(\n    int row,\n    int col,\n    HashSet<Integer> blockedColumns,\n    HashSet<Integer> blockedUpDiagonals,\n    HashSet<Integer> blockedDownDiagonals\n  ) {\n    if (blockedColumns.contains(col)) {\n      return false;\n    } else if (blockedUpDiagonals.contains(row + col)) {\n      return false;\n    } else if (blockedDownDiagonals.contains(row - col)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public void placeQueen(\n    int row,\n    int col,\n    HashSet<Integer> blockedColumns,\n    HashSet<Integer> blockedUpDiagonals,\n    HashSet<Integer> blockedDownDiagonals\n  ) {\n    blockedColumns.add(col);\n    blockedUpDiagonals.add(row + col);\n    blockedDownDiagonals.add(row - col);\n  }\n\n  public void removeQueen(\n    int row,\n    int col,\n    HashSet<Integer> blockedColumns,\n    HashSet<Integer> blockedUpDiagonals,\n    HashSet<Integer> blockedDownDiagonals\n  ) {\n    blockedColumns.remove(col);\n    blockedUpDiagonals.remove(row + col);\n    blockedDownDiagonals.remove(row - col);\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var input = 4;\n    var expected = 2;\n    var actual = new Program().nonAttackingQueens(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var input = 4;\n    var expected = 2;\n    var actual = new Program().nonAttackingQueens(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function nonAttackingQueens(n) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.nonAttackingQueens = nonAttackingQueens;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// Lower Bound: O(n!) time | O(n) space - where n is the input number\nfunction nonAttackingQueens(n) {\n  // Each index of `columnPlacements` represents a row of the chessboard,\n  // and the value at each index is the column (on the relevant row) where\n  // a queen is currently placed.\n  const columnPlacements = new Array(n).fill(0);\n  return getNumberOfNonAttackingQueenPlacements(0, columnPlacements, n);\n}\n\nfunction getNumberOfNonAttackingQueenPlacements(row, columnPlacements, boardSize) {\n  if (row === boardSize) return 1;\n\n  let validPlacements = 0;\n  for (let col = 0; col < boardSize; col++) {\n    if (isNonAttackingPlacement(row, col, columnPlacements)) {\n      columnPlacements[row] = col;\n      validPlacements += getNumberOfNonAttackingQueenPlacements(\n        row + 1,\n        columnPlacements,\n        boardSize,\n      );\n    }\n  }\n\n  return validPlacements;\n}\n\n// As `row` tends to `n`, this becomes an O(n)-time operation.\nfunction isNonAttackingPlacement(row, col, columnPlacements) {\n  for (let previousRow = 0; previousRow < row; previousRow++) {\n    const columnToCheck = columnPlacements[previousRow];\n    const sameColumn = columnToCheck === col;\n    const onDiagonal = Math.abs(columnToCheck - col) === row - previousRow;\n    if (sameColumn || onDiagonal) return false;\n  }\n\n  return true;\n}\n\n// Do not edit the line below.\nexports.nonAttackingQueens = nonAttackingQueens;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// Upper Bound: O(n!) time | O(n) space - where n is the input number\nfunction nonAttackingQueens(n) {\n  const blockedColumns = new Set();\n  const blockedUpDiagonals = new Set();\n  const blockedDownDiagonals = new Set();\n  return getNumberOfNonAttackingQueenPlacements(\n    0,\n    blockedColumns,\n    blockedUpDiagonals,\n    blockedDownDiagonals,\n    n,\n  );\n}\n\nfunction getNumberOfNonAttackingQueenPlacements(\n  row,\n  blockedColumns,\n  blockedUpDiagonals,\n  blockedDownDiagonals,\n  boardSize,\n) {\n  if (row === boardSize) return 1;\n\n  let validPlacements = 0;\n  for (let col = 0; col < boardSize; col++) {\n    if (\n      isNonAttackingPlacement(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals)\n    ) {\n      placeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals);\n      validPlacements += getNumberOfNonAttackingQueenPlacements(\n        row + 1,\n        blockedColumns,\n        blockedUpDiagonals,\n        blockedDownDiagonals,\n        boardSize,\n      );\n      removeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals);\n    }\n  }\n\n  return validPlacements;\n}\n\n// This is always an O(1)-time operation.\nfunction isNonAttackingPlacement(\n  row,\n  col,\n  blockedColumns,\n  blockedUpDiagonals,\n  blockedDownDiagonals,\n) {\n  if (blockedColumns.has(col)) return false;\n  if (blockedUpDiagonals.has(row + col)) return false;\n  if (blockedDownDiagonals.has(row - col)) return false;\n\n  return true;\n}\n\nfunction placeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals) {\n  blockedColumns.add(col);\n  blockedUpDiagonals.add(row + col);\n  blockedDownDiagonals.add(row - col);\n}\n\nfunction removeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals) {\n  blockedColumns.delete(col);\n  blockedUpDiagonals.delete(row + col);\n  blockedDownDiagonals.delete(row - col);\n}\n\n// Do not edit the line below.\nexports.nonAttackingQueens = nonAttackingQueens;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = 4;\n  const expected = 2;\n  const actual = program.nonAttackingQueens(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = 4;\n  const expected = 2;\n  const actual = program.nonAttackingQueens(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun nonAttackingQueens(n: Int): Int {\n    // Write your code here.\n    return -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.abs\n\n// Lower Bound: O(n!) time | O(n) space - where n is the input number\nfun nonAttackingQueens(n: Int): Int {\n    // Each index of `columnPlacements` represents a row of the chessboard,\n    // and the value at each index is the column (on the relevant row) where\n    // a queen is currently placed.\n    val columnPlacements = MutableList(n) { 0 }\n    return getNumberOfNonAttackingQueenPlacements(0, columnPlacements, n)\n}\n\nfun getNumberOfNonAttackingQueenPlacements(row: Int, columnPlacements: MutableList<Int>, boardSize: Int): Int {\n    if (row == boardSize) return 1\n\n    var validPlacements = 0\n    for (col in 0 until boardSize) {\n        if (isNonAttackingPlacement(row, col, columnPlacements)) {\n            columnPlacements[row] = col\n            validPlacements += getNumberOfNonAttackingQueenPlacements(row + 1, columnPlacements, boardSize)\n        }\n    }\n\n    return validPlacements\n}\n\n// As `row` tends to `n`, this becomes an O(n)-time operation.\nfun isNonAttackingPlacement(row: Int, col: Int, columnPlacements: List<Int>): Boolean {\n    for (previousRow in 0 until row) {\n        val columnToCheck = columnPlacements[previousRow]\n        val sameColumn = columnToCheck == col\n        val onDiagonal = abs(columnToCheck - col) == row - previousRow\n        if (sameColumn || onDiagonal) return false\n    }\n\n    return true\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// Upper Bound: O(n!) time | O(n) space - where n is the input number\nfun nonAttackingQueens(n: Int): Int {\n    val blockedColumns = mutableSetOf<Int>()\n    val blockedUpDiagonals = mutableSetOf<Int>()\n    val blockedDownDiagonals = mutableSetOf<Int>()\n    return getNumberOfNonAttackingQueenPlacements(\n        0,\n        blockedColumns,\n        blockedUpDiagonals,\n        blockedDownDiagonals,\n        n,\n    )\n}\n\nfun getNumberOfNonAttackingQueenPlacements(row: Int, blockedColumns: MutableSet<Int>, blockedUpDiagonals: MutableSet<Int>, blockedDownDiagonals: MutableSet<Int>, boardSize: Int): Int {\n    if (row == boardSize) return 1\n\n    var validPlacements = 0\n    for (col in 0 until boardSize) {\n        if (isNonAttackingPlacement(\n                row,\n                col,\n                blockedColumns,\n                blockedUpDiagonals,\n                blockedDownDiagonals,\n            )\n        ) {\n            placeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals)\n            validPlacements += getNumberOfNonAttackingQueenPlacements(row + 1, blockedColumns, blockedUpDiagonals, blockedDownDiagonals, boardSize)\n            removeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals)\n        }\n    }\n\n    return validPlacements\n}\n\n// This is always an O(1)-time operation.\nfun isNonAttackingPlacement(\n    row: Int,\n    col: Int,\n    blockedColumns: MutableSet<Int>,\n    blockedUpDiagonals: MutableSet<Int>,\n    blockedDownDiagonals: MutableSet<Int>,\n): Boolean {\n    if (col in blockedColumns) return false\n    if (row + col in blockedUpDiagonals) return false\n    if (row - col in blockedDownDiagonals) return false\n\n    return true\n}\n\nfun placeQueen(row: Int, col: Int, blockedColumns: MutableSet<Int>, blockedUpDiagonals: MutableSet<Int>, blockedDownDiagonals: MutableSet<Int>) {\n    blockedColumns.add(col)\n    blockedUpDiagonals.add(row + col)\n    blockedDownDiagonals.add(row - col)\n}\n\nfun removeQueen(row: Int, col: Int, blockedColumns: MutableSet<Int>, blockedUpDiagonals: MutableSet<Int>, blockedDownDiagonals: MutableSet<Int>) {\n    blockedColumns.remove(col)\n    blockedUpDiagonals.remove(row + col)\n    blockedDownDiagonals.remove(row - col)\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.nonAttackingQueens\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = 4\n        val expected = 2\n        val output = nonAttackingQueens(input)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.nonAttackingQueens\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = 4\n        val expected = 2\n        val output = nonAttackingQueens(input)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def nonAttackingQueens(n):\n    # Write your code here.\n    return 0\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# Lower Bound: O(n!) time | O(n) space - where n is the input number\ndef nonAttackingQueens(n):\n    # Each index of `columnPlacements` represents a row of the chessboard,\n    # and the value at each index is the column (on the relevant row) where\n    # a queen is currently placed.\n    columnPlacements = [0] * n\n    return getNumberOfNonAttackingQueenPlacements(0, columnPlacements, n)\n\n\ndef getNumberOfNonAttackingQueenPlacements(row, columnPlacements, boardSize):\n    if row == boardSize:\n        return 1\n\n    validPlacements = 0\n    for col in range(boardSize):\n        if isNonAttackingPlacement(row, col, columnPlacements):\n            columnPlacements[row] = col\n            validPlacements += getNumberOfNonAttackingQueenPlacements(\n                row + 1, columnPlacements, boardSize\n            )\n\n    return validPlacements\n\n\n# As `row` tends to `n`, this becomes an O(n)-time operation.\ndef isNonAttackingPlacement(row, col, columnPlacements):\n    for previousRow in range(row):\n        columnToCheck = columnPlacements[previousRow]\n        sameColumn = columnToCheck == col\n        onDiagonal = abs(columnToCheck - col) == row - previousRow\n        if sameColumn or onDiagonal:\n            return False\n\n    return True\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# Upper Bound: O(n!) time | O(n) space - where n is the input number\ndef nonAttackingQueens(n):\n    blockedColumns = set()\n    blockedUpDiagonals = set()\n    blockedDownDiagonals = set()\n    return getNumberOfNonAttackingQueenPlacements(\n        0, blockedColumns, blockedUpDiagonals, blockedDownDiagonals, n\n    )\n\n\ndef getNumberOfNonAttackingQueenPlacements(\n    row, blockedColumns, blockedUpDiagonals, blockedDownDiagonals, boardSize\n):\n    if row == boardSize:\n        return 1\n\n    validPlacements = 0\n    for col in range(boardSize):\n        if isNonAttackingPlacement(\n            row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals\n        ):\n            placeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals)\n            validPlacements += getNumberOfNonAttackingQueenPlacements(\n                row + 1, blockedColumns, blockedUpDiagonals, blockedDownDiagonals, boardSize\n            )\n            removeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals)\n\n    return validPlacements\n\n\n# This is always an O(1)-time operation.\ndef isNonAttackingPlacement(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals):\n    if col in blockedColumns:\n        return False\n    if row + col in blockedUpDiagonals:\n        return False\n    if row - col in blockedDownDiagonals:\n        return False\n\n    return True\n\n\ndef placeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals):\n    blockedColumns.add(col)\n    blockedUpDiagonals.add(row + col)\n    blockedDownDiagonals.add(row - col)\n\n\ndef removeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals):\n    blockedColumns.remove(col)\n    blockedUpDiagonals.remove(row + col)\n    blockedDownDiagonals.remove(row - col)\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = 4\n        expected = 2\n        actual = program.nonAttackingQueens(input)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = 4\n        expected = 2\n        actual = program.nonAttackingQueens(input)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "class Program\n  def nonAttackingQueens(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def nonAttackingQueens(n)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.nonAttackingQueens\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.nonAttackingQueens\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func nonAttackingQueens(_ n: Int) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Lower Bound: O(n!) time | O(n) space - where n is the input number\n  func nonAttackingQueens(_ n: Int) -> Int {\n    // Each index of `columnPlacements` represents a row of the chessboard,\n    // and the value at each index is the column (on the relevant row) where\n    // a queen is currently placed.\n    var columnPlacements = Array(repeating: 0, count: n)\n    return getNumberOfNonAttackingQueenPlacements(0, &columnPlacements, n)\n  }\n\n  func getNumberOfNonAttackingQueenPlacements(\n    _ row: Int, _ columnPlacements: inout [Int],\n    _ boardSize: Int\n  ) -> Int {\n    if row == boardSize {\n      return 1\n    }\n\n    var validPlacements = 0\n    for col in stride(from: 0, to: boardSize, by: 1) {\n      if isNonAttackingPlacement(row, col, columnPlacements) {\n        columnPlacements[row] = col\n        validPlacements += getNumberOfNonAttackingQueenPlacements(row + 1,\n                                                                  &columnPlacements, boardSize)\n      }\n    }\n    return validPlacements\n  }\n\n  // As `row` tends to `n`, this becomes an O(n)-time operation.\n  func isNonAttackingPlacement(\n    _ row: Int, _ col: Int,\n    _ columnPlacements: [Int]\n  ) -> Bool {\n    for previousRow in stride(from: 0, to: row, by: 1) {\n      let columnToCheck = columnPlacements[previousRow]\n      let sameColumn = columnToCheck == col\n      let onDiagonal = abs(columnToCheck - col) == row - previousRow\n      if sameColumn || onDiagonal {\n        return false\n      }\n    }\n    return true\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Upper Bound: O(n!) time | O(n) space - where n is the input number\n  func nonAttackingQueens(_ n: Int) -> Int {\n    var blockedColumns: Set<Int> = []\n    var blockedUpDiagonals: Set<Int> = []\n    var blockedDownDiagonals: Set<Int> = []\n    return getNumberOfNonAttackingQueenPlacements(0, &blockedColumns,\n                                                  &blockedUpDiagonals, &blockedDownDiagonals, n)\n  }\n\n  func getNumberOfNonAttackingQueenPlacements(\n    _ row: Int,\n    _ blockedColumns: inout Set<Int>,\n    _ blockedUpDiagonals: inout Set<Int>,\n    _ blockedDownDiagonals: inout Set<Int>,\n    _ boardSize: Int\n  ) -> Int {\n    if row == boardSize {\n      return 1\n    }\n\n    var validPlacements = 0\n    for col in stride(from: 0, to: boardSize, by: 1) {\n      if isNonAttackingPlacement(row, col, &blockedColumns, &blockedUpDiagonals, &blockedDownDiagonals) {\n        placeQueen(row, col, &blockedColumns, &blockedUpDiagonals,\n                   &blockedDownDiagonals)\n        validPlacements += getNumberOfNonAttackingQueenPlacements(row + 1,\n                                                                  &blockedColumns, &blockedUpDiagonals, &blockedDownDiagonals, boardSize)\n        removeQueen(row, col, &blockedColumns, &blockedUpDiagonals, &blockedDownDiagonals)\n      }\n    }\n    return validPlacements\n  }\n\n  // This is always an O(1)-time operation.\n  func isNonAttackingPlacement(\n    _ row: Int, _ col: Int,\n    _ blockedColumns: inout Set<Int>,\n    _ blockedUpDiagonals: inout Set<Int>,\n    _ blockedDownDiagonals: inout Set<Int>\n  ) -> Bool {\n    if blockedColumns.contains(col) {\n      return false\n    }\n    if blockedUpDiagonals.contains(row + col) {\n      return false\n    }\n    if blockedDownDiagonals.contains(row - col) {\n      return false\n    }\n    return true\n  }\n\n  func placeQueen(\n    _ row: Int, _ col: Int,\n    _ blockedColumns: inout Set<Int>,\n    _ blockedUpDiagonals: inout Set<Int>,\n    _ blockedDownDiagonals: inout Set<Int>\n  ) {\n    blockedColumns.insert(col)\n    blockedUpDiagonals.insert(row + col)\n    blockedDownDiagonals.insert(row - col)\n  }\n\n  func removeQueen(\n    _ row: Int, _ col: Int,\n    _ blockedColumns: inout Set<Int>,\n    _ blockedUpDiagonals: inout Set<Int>,\n    _ blockedDownDiagonals: inout Set<Int>\n  ) {\n    blockedColumns.remove(col)\n    blockedUpDiagonals.remove(row + col)\n    blockedDownDiagonals.remove(row - col)\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var input = 4\n      var expected = 2\n      var actual = Program().nonAttackingQueens(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var input = 4\n      var expected = 2\n      var actual = Program().nonAttackingQueens(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function nonAttackingQueens(n: number) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// Lower Bound: O(n!) time | O(n) space - where n is the input number\nexport function nonAttackingQueens(n: number) {\n  // Each index of `columnPlacements` represents a row of the chessboard,\n  // and the value at each index is the column (on the relevant row) where\n  // a queen is currently placed.\n  const columnPlacements = new Array(n).fill(0);\n  return getNumberOfNonAttackingQueenPlacements(0, columnPlacements, n);\n}\n\nfunction getNumberOfNonAttackingQueenPlacements(\n  row: number,\n  columnPlacements: number[],\n  boardSize: number,\n) {\n  if (row === boardSize) return 1;\n\n  let validPlacements = 0;\n  for (let col = 0; col < boardSize; col++) {\n    if (isNonAttackingPlacement(row, col, columnPlacements)) {\n      columnPlacements[row] = col;\n      validPlacements += getNumberOfNonAttackingQueenPlacements(\n        row + 1,\n        columnPlacements,\n        boardSize,\n      );\n    }\n  }\n\n  return validPlacements;\n}\n\n// As `row` tends to `n`, this becomes an O(n)-time operation.\nfunction isNonAttackingPlacement(row: number, col: number, columnPlacements: number[]) {\n  for (let previousRow = 0; previousRow < row; previousRow++) {\n    const columnToCheck = columnPlacements[previousRow];\n    const sameColumn = columnToCheck === col;\n    const onDiagonal = Math.abs(columnToCheck - col) === row - previousRow;\n    if (sameColumn || onDiagonal) return false;\n  }\n\n  return true;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// Upper Bound: O(n!) time | O(n) space - where n is the input number\nexport function nonAttackingQueens(n: number) {\n  const blockedColumns = new Set<number>();\n  const blockedUpDiagonals = new Set<number>();\n  const blockedDownDiagonals = new Set<number>();\n  return getNumberOfNonAttackingQueenPlacements(\n    0,\n    blockedColumns,\n    blockedUpDiagonals,\n    blockedDownDiagonals,\n    n,\n  );\n}\n\nfunction getNumberOfNonAttackingQueenPlacements(\n  row: number,\n  blockedColumns: Set<number>,\n  blockedUpDiagonals: Set<number>,\n  blockedDownDiagonals: Set<number>,\n  boardSize: number,\n) {\n  if (row === boardSize) return 1;\n\n  let validPlacements = 0;\n  for (let col = 0; col < boardSize; col++) {\n    if (\n      isNonAttackingPlacement(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals)\n    ) {\n      placeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals);\n      validPlacements += getNumberOfNonAttackingQueenPlacements(\n        row + 1,\n        blockedColumns,\n        blockedUpDiagonals,\n        blockedDownDiagonals,\n        boardSize,\n      );\n      removeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals);\n    }\n  }\n\n  return validPlacements;\n}\n\n// This is always an O(1)-time operation.\nfunction isNonAttackingPlacement(\n  row: number,\n  col: number,\n  blockedColumns: Set<number>,\n  blockedUpDiagonals: Set<number>,\n  blockedDownDiagonals: Set<number>,\n) {\n  if (blockedColumns.has(col)) return false;\n  if (blockedUpDiagonals.has(row + col)) return false;\n  if (blockedDownDiagonals.has(row - col)) return false;\n\n  return true;\n}\n\nfunction placeQueen(\n  row: number,\n  col: number,\n  blockedColumns: Set<number>,\n  blockedUpDiagonals: Set<number>,\n  blockedDownDiagonals: Set<number>,\n) {\n  blockedColumns.add(col);\n  blockedUpDiagonals.add(row + col);\n  blockedDownDiagonals.add(row - col);\n}\n\nfunction removeQueen(\n  row: number,\n  col: number,\n  blockedColumns: Set<number>,\n  blockedUpDiagonals: Set<number>,\n  blockedDownDiagonals: Set<number>,\n) {\n  blockedColumns.delete(col);\n  blockedUpDiagonals.delete(row + col);\n  blockedDownDiagonals.delete(row - col);\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = 4;\n  const expected = 2;\n  const actual = program.nonAttackingQueens(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = 4;\n  const expected = 2;\n  const actual = program.nonAttackingQueens(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "n",
      "example": 4,
      "schema": {
        "minimum": 1,
        "type": "integer"
      }
    }
  ],
  "tests": [
    {
      "n": 4
    },
    {
      "n": 2
    },
    {
      "n": 1
    },
    {
      "n": 3
    },
    {
      "n": 8
    },
    {
      "n": 5
    },
    {
      "n": 6
    },
    {
      "n": 7
    },
    {
      "n": 10
    }
  ],
  "jsonTests": [
    {
      "n": 4
    },
    {
      "n": 2
    },
    {
      "n": 1
    },
    {
      "n": 3
    },
    {
      "n": 8
    },
    {
      "n": 5
    },
    {
      "n": 6
    },
    {
      "n": 7
    },
    {
      "n": 10
    }
  ],
  "changelog": []
}