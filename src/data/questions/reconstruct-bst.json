{
  "uid": "reconstruct-bst",
  "testStrategy": "JSON",
  "name": "Reconstruct BST",
  "version": 0,
  "releaseDate": "2021-02-20T00:00:00Z",
  "category": "Binary Search Trees",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 20041,
    "failureCount": 5662
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "513598635",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 2387
  },
  "prompt": "<div class=\"html\">\n<p>\n  The pre-order traversal of a Binary Tree is a traversal technique that starts\n  at the tree's root node and visits nodes in the following order:\n</p>\n<ol>\n  <li>Current node</li>\n  <li>Left subtree</li>\n  <li>Right subtree</li>\n</ol>\n<p>\n  Given a non-empty array of integers representing the pre-order traversal of a\n  Binary Search Tree (BST), write a function that creates the relevant BST and\n  returns its root node.\n</p>\n<p>\n  The input array will contain the values of BST nodes in the order in which\n  these nodes would be visited with a pre-order traversal.\n</p>\n<p>\n  Each <span>BST</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. A node is\n  said to be a valid <span>BST</span> node if and only if it satisfies the BST\n  property: its <span>value</span> is strictly greater than the values of every\n  node to its left; its <span>value</span> is less than or equal to the values\n  of every node to its right; and its children nodes are either valid\n  <span>BST</span> nodes themselves or <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">preOrderTraversalValues</span> = [10, 4, 2, 1, 5, 17, 19, 18]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n        10 \n      /    \\\n     4      17\n   /   \\      \\\n  2     5     19\n /           /\n1           18 \n</pre>\n</div>",
  "hints": [
    "<p>\n  Think about the properties of a BST. Looking at the pre-order-traversal nodes\n  (values), how can you determine the right child of a particular node?\n</p>\n",
    "\n<p>\n  The right child of any BST node is simply the first node in the pre-order\n  traversal whose value is larger than or equal to the particular node's value.\n  From this, we know that the nodes in the pre-order traversal that come before\n  the right child of a node must be in the left subtree of that node.\n</p>\n",
    "\n<p>\n  Once you determine the right child of any given node, you're able to generate\n  the entire left and right subtrees of that node. You can do so by recursively\n  creating the left and right child nodes of each subsequent node using the fact\n  stated in Hint #2. A node that has no left and right children is naturally a\n  leaf node.\n</p>\n",
    "\n<p>\n  To solve this problem with an optimal time complexity, you need to realize\n  that it's unnecessary to locate the right child of every node. You can simply\n  keep track of the pre-order-traversal position of the current node that needs\n  to be created and try to insert that node as the left or right child of the\n  relevant previously visited node. Since this tree is a BST, every node must\n  satisfy the BST property; by somehow keeping track of lower and upper bounds\n  for node values, you should be able to determine if a node can be inserted as\n  the left or right child of another node. With this approach, you can solve\n  this problem in linear time. See this question's video explanation for a more\n  detailed explanation of this approach.\n</p>"
  ],
  "spaceTime": "O(n) time | O(n) space - where n is the length of the input array",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": "tree"
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is an input class. Do not edit.\nclass BST {\n public:\n  int value;\n  BST* left = nullptr;\n  BST* right = nullptr;\n\n  BST(int value) { this->value = value; }\n};\n\nBST* reconstructBst(vector<int> preOrderTraversalValues) {\n  // Write your code here.\n  return nullptr;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BST {\n public:\n  int value;\n  BST* left = nullptr;\n  BST* right = nullptr;\n\n  BST(int value) { this->value = value; }\n};\n\n// O(n^2) time | O(n) space - where n is the length of the input array\nBST* reconstructBst(vector<int> preOrderTraversalValues) {\n  if (preOrderTraversalValues.size() == 0) return nullptr;\n\n  int currentValue = preOrderTraversalValues[0];\n  int rightSubtreeRootIdx = preOrderTraversalValues.size();\n\n  for (int idx = 1; idx < preOrderTraversalValues.size(); idx++) {\n    int value = preOrderTraversalValues[idx];\n    if (value >= currentValue) {\n      rightSubtreeRootIdx = idx;\n      break;\n    }\n  }\n\n  auto leftSubtree = reconstructBst(vector<int>(\n    preOrderTraversalValues.begin() + 1,\n    preOrderTraversalValues.begin() + rightSubtreeRootIdx\n  ));\n  auto rightSubtree = reconstructBst(vector<int>(\n    preOrderTraversalValues.begin() + rightSubtreeRootIdx,\n    preOrderTraversalValues.end()\n  ));\n\n  auto bst = new BST(currentValue);\n  bst->left = leftSubtree;\n  bst->right = rightSubtree;\n  return bst;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <limits>\n#include <vector>\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BST {\n public:\n  int value;\n  BST* left = nullptr;\n  BST* right = nullptr;\n\n  BST(int value) { this->value = value; }\n};\n\nstruct TreeInfo {\n  int rootIdx;\n};\n\nBST* reconstructBstFromRange(\n  int lowerBound,\n  int upperBound,\n  vector<int>& preOrderTraversalValues,\n  TreeInfo& currentSubtreeInfo\n);\n\n// O(n) time | O(n) space - where n is the length of the input array\nBST* reconstructBst(vector<int> preOrderTraversalValues) {\n  auto treeInfo = TreeInfo{0};\n  return reconstructBstFromRange(\n    numeric_limits<int>::min(),\n    numeric_limits<int>::max(),\n    preOrderTraversalValues,\n    treeInfo\n  );\n}\n\nBST* reconstructBstFromRange(\n  int lowerBound,\n  int upperBound,\n  vector<int>& preOrderTraversalValues,\n  TreeInfo& currentSubtreeInfo\n) {\n  if (currentSubtreeInfo.rootIdx == preOrderTraversalValues.size())\n    return nullptr;\n\n  int rootValue = preOrderTraversalValues[currentSubtreeInfo.rootIdx];\n  if (rootValue < lowerBound || rootValue >= upperBound) return nullptr;\n\n  currentSubtreeInfo.rootIdx++;\n  auto leftSubtree = reconstructBstFromRange(\n    lowerBound, rootValue, preOrderTraversalValues, currentSubtreeInfo\n  );\n  auto rightSubtree = reconstructBstFromRange(\n    rootValue, upperBound, preOrderTraversalValues, currentSubtreeInfo\n  );\n  auto bst = new BST(rootValue);\n  bst->left = leftSubtree;\n  bst->right = rightSubtree;\n  return bst;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nvector<int> getDfsOrder(BST* node, vector<int>& values) {\n  values.push_back(node->value);\n  if (node->left != nullptr) {\n    getDfsOrder(node->left, values);\n  }\n  if (node->right != nullptr) {\n    getDfsOrder(node->right, values);\n  }\n  return values;\n}\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<int> preOrderTraversalValues = {10, 4, 2, 1, 3, 17, 19, 18};\n\n      auto tree = new BST(10);\n      tree->left = new BST(4);\n      tree->left->left = new BST(2);\n      tree->left->left->left = new BST(1);\n      tree->left->right = new BST(3);\n      tree->right = new BST(17);\n      tree->right->right = new BST(19);\n      tree->right->right->left = new BST(18);\n\n      vector<int> v1;\n      auto expected = getDfsOrder(tree, v1);\n\n      auto actual = reconstructBst(preOrderTraversalValues);\n\n      vector<int> v2;\n      auto actualDfsOrder = getDfsOrder(actual, v2);\n\n      assert(expected == actualDfsOrder);\n    });\n  }\n};\n",
      "unitTests": "vector<int> getDfsOrder(BST* node, vector<int>& values) {\n  values.push_back(node->value);\n  if (node->left != nullptr) {\n    getDfsOrder(node->left, values);\n  }\n  if (node->right != nullptr) {\n    getDfsOrder(node->right, values);\n  }\n  return values;\n}\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<int> preOrderTraversalValues = {10, 4, 2, 1, 3, 17, 19, 18};\n\n      auto tree = new BST(10);\n      tree->left = new BST(4);\n      tree->left->left = new BST(2);\n      tree->left->left->left = new BST(1);\n      tree->left->right = new BST(3);\n      tree->right = new BST(17);\n      tree->right->right = new BST(19);\n      tree->right->right->left = new BST(18);\n\n      vector<int> v1;\n      auto expected = getDfsOrder(tree, v1);\n\n      auto actual = reconstructBst(preOrderTraversalValues);\n\n      vector<int> v2;\n      auto actualDfsOrder = getDfsOrder(actual, v2);\n\n      assert(expected == actualDfsOrder);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  public BST ReconstructBst(List<int> preOrderTraversalValues) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n^2) time | O(n) space - where n is the length of the input array\n  public BST ReconstructBst(List<int> preOrderTraversalValues) {\n    if (preOrderTraversalValues.Count == 0) {\n      return null;\n    }\n\n    int currentValue = preOrderTraversalValues[0];\n    int rightSubtreeRootIdx = preOrderTraversalValues.Count;\n\n    for (int idx = 1; idx < preOrderTraversalValues.Count; idx++) {\n      int value = preOrderTraversalValues[idx];\n      if (value >= currentValue) {\n        rightSubtreeRootIdx = idx;\n        break;\n      }\n    }\n\n    BST leftSubtree = ReconstructBst(\n      preOrderTraversalValues.GetRange(1, rightSubtreeRootIdx - 1)\n    );\n    BST rightSubtree = ReconstructBst(preOrderTraversalValues.GetRange(\n      rightSubtreeRootIdx, preOrderTraversalValues.Count - rightSubtreeRootIdx\n    ));\n\n    BST bst = new BST(currentValue);\n    bst.left = leftSubtree;\n    bst.right = rightSubtree;\n\n    return bst;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  public class TreeInfo {\n    public int rootIdx;\n\n    public TreeInfo(int rootIdx) {\n      this.rootIdx = rootIdx;\n    }\n  }\n\n  // O(n) time | O(n) space - where n is the length of the input array\n  public BST ReconstructBst(List<int> preOrderTraversalValues) {\n    TreeInfo treeInfo = new TreeInfo(0);\n    return ReconstructBstFromRange(\n      Int32.MinValue, Int32.MaxValue, preOrderTraversalValues, treeInfo\n    );\n  }\n\n  public BST ReconstructBstFromRange(\n    int lowerBound,\n    int upperBound,\n    List<int> preOrderTraversalValues,\n    TreeInfo currentSubtreeInfo\n  ) {\n    if (currentSubtreeInfo.rootIdx == preOrderTraversalValues.Count) {\n      return null;\n    }\n\n    int rootValue = preOrderTraversalValues[currentSubtreeInfo.rootIdx];\n    if (rootValue < lowerBound || rootValue >= upperBound) {\n      return null;\n    }\n\n    currentSubtreeInfo.rootIdx += 1;\n    BST leftSubtree = ReconstructBstFromRange(\n      lowerBound, rootValue, preOrderTraversalValues, currentSubtreeInfo\n    );\n    BST rightSubtree = ReconstructBstFromRange(\n      rootValue, upperBound, preOrderTraversalValues, currentSubtreeInfo\n    );\n\n    BST bst = new BST(rootValue);\n    bst.left = leftSubtree;\n    bst.right = rightSubtree;\n    return bst;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class ProgramTest {\n  public List<int> getDfsOrder(Program.BST node, List<int> values) {\n    values.Add(node.value);\n    if (node.left != null) {\n      getDfsOrder(node.left, values);\n    }\n    if (node.right != null) {\n      getDfsOrder(node.right, values);\n    }\n    return values;\n  }\n\n  [Test]\n  public void TestCase1() {\n    List<int> preOrderTraversalValues =\n      new List<int> { 10, 4, 2, 1, 3, 17, 19, 18 };\n    Program.BST tree = new Program.BST(10);\n    tree.left = new Program.BST(4);\n    tree.left.left = new Program.BST(2);\n    tree.left.left.left = new Program.BST(1);\n    tree.left.right = new Program.BST(3);\n    tree.right = new Program.BST(17);\n    tree.right.right = new Program.BST(19);\n    tree.right.right.left = new Program.BST(18);\n    List<int> expected = getDfsOrder(tree, new List<int>());\n    var actual = new Program().ReconstructBst(preOrderTraversalValues);\n    List<int> actualValues = getDfsOrder(actual, new List<int>());\n    Utils.AssertTrue(Enumerable.SequenceEqual(expected, actualValues));\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class ProgramTest {\n  public List<int> getDfsOrder(Program.BST node, List<int> values) {\n    values.Add(node.value);\n    if (node.left != null) {\n      getDfsOrder(node.left, values);\n    }\n    if (node.right != null) {\n      getDfsOrder(node.right, values);\n    }\n    return values;\n  }\n\n  [Test]\n  public void TestCase1() {\n    List<int> preOrderTraversalValues =\n      new List<int> { 10, 4, 2, 1, 3, 17, 19, 18 };\n    Program.BST tree = new Program.BST(10);\n    tree.left = new Program.BST(4);\n    tree.left.left = new Program.BST(2);\n    tree.left.left.left = new Program.BST(1);\n    tree.left.right = new Program.BST(3);\n    tree.right = new Program.BST(17);\n    tree.right.right = new Program.BST(19);\n    tree.right.right.left = new Program.BST(18);\n    List<int> expected = getDfsOrder(tree, new List<int>());\n    var actual = new Program().ReconstructBst(preOrderTraversalValues);\n    List<int> actualValues = getDfsOrder(actual, new List<int>());\n    Utils.AssertTrue(Enumerable.SequenceEqual(expected, actualValues));\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is an input class. Do not edit.\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\nfunc ReconstructBst(preOrderTraversalValues []int) *BST {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\n// O(n^2) time | O(n) space - where n is the length of the input array\nfunc ReconstructBst(preOrderTraversalValues []int) *BST {\n\tif len(preOrderTraversalValues) == 0 {\n\t\treturn nil\n\t}\n\n\tcurrentValue := preOrderTraversalValues[0]\n\trightSubtreeRootIdx := len(preOrderTraversalValues)\n\n\tfor idx := 1; idx < len(preOrderTraversalValues); idx++ {\n\t\tvalue := preOrderTraversalValues[idx]\n\t\tif value >= currentValue {\n\t\t\trightSubtreeRootIdx = idx\n\t\t\tbreak\n\t\t}\n\t}\n\n\tleftSubtree := ReconstructBst(preOrderTraversalValues[1:rightSubtreeRootIdx])\n\trightSubtree := ReconstructBst(preOrderTraversalValues[rightSubtreeRootIdx:])\n\treturn &BST{Value: currentValue, Left: leftSubtree, Right: rightSubtree}\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t\"math\"\n)\n\n// This is an input class. Do not edit.\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\ntype treeInfo struct {\n\trootIdx int\n}\n\n// O(n) time | O(n) space - where n is the length of the input array\nfunc ReconstructBst(preOrderTraversalValues []int) *BST {\n\ttreeInfo := &treeInfo{rootIdx: 0}\n\treturn reconstructBstFromRange(\n\t\tmath.MinInt32,\n\t\tmath.MaxInt32,\n\t\tpreOrderTraversalValues,\n\t\ttreeInfo,\n\t)\n}\n\nfunc reconstructBstFromRange(lowerBound, upperBound int, preOrderTraversalValues []int, currentSubtreeInfo *treeInfo) *BST {\n\tif currentSubtreeInfo.rootIdx == len(preOrderTraversalValues) {\n\t\treturn nil\n\t}\n\n\trootValue := preOrderTraversalValues[currentSubtreeInfo.rootIdx]\n\tif rootValue < lowerBound || rootValue >= upperBound {\n\t\treturn nil\n\t}\n\n\tcurrentSubtreeInfo.rootIdx += 1\n\tleftSubtree := reconstructBstFromRange(\n\t\tlowerBound,\n\t\trootValue,\n\t\tpreOrderTraversalValues,\n\t\tcurrentSubtreeInfo,\n\t)\n\trightSubtree := reconstructBstFromRange(\n\t\trootValue,\n\t\tupperBound,\n\t\tpreOrderTraversalValues,\n\t\tcurrentSubtreeInfo,\n\t)\n\treturn &BST{Value: rootValue, Left: leftSubtree, Right: rightSubtree}\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc getDfsOrder(node *BST, values []int) []int {\n\tif node == nil {\n\t\treturn nil\n\t}\n\tvalues = append(values, node.Value)\n\tgetDfsOrder(node.Left, values)\n\tgetDfsOrder(node.Right, values)\n\treturn values\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tpreOrderTraversalValues := []int{10, 4, 2, 1, 3, 17, 19, 18}\n\ttree := &BST{Value: 10}\n\ttree.Left = &BST{Value: 4}\n\ttree.Left.Left = &BST{Value: 2}\n\ttree.Left.Left.Left = &BST{Value: 1}\n\ttree.Left.Right = &BST{Value: 3}\n\ttree.Right = &BST{Value: 17}\n\ttree.Right.Right = &BST{Value: 19}\n\ttree.Right.Right.Left = &BST{Value: 18}\n\texpected := getDfsOrder(tree, nil)\n\tactual := ReconstructBst(preOrderTraversalValues)\n\tactualOrder := getDfsOrder(actual, nil)\n\trequire.Equal(t, expected, actualOrder)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc getDfsOrder(node *BST, values []int) []int {\n\tif node == nil {\n\t\treturn nil\n\t}\n\tvalues = append(values, node.Value)\n\tgetDfsOrder(node.Left, values)\n\tgetDfsOrder(node.Right, values)\n\treturn values\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tpreOrderTraversalValues := []int{10, 4, 2, 1, 3, 17, 19, 18}\n\ttree := &BST{Value: 10}\n\ttree.Left = &BST{Value: 4}\n\ttree.Left.Left = &BST{Value: 2}\n\ttree.Left.Left.Left = &BST{Value: 1}\n\ttree.Left.Right = &BST{Value: 3}\n\ttree.Right = &BST{Value: 17}\n\ttree.Right.Right = &BST{Value: 19}\n\ttree.Right.Right.Left = &BST{Value: 18}\n\texpected := getDfsOrder(tree, nil)\n\tactual := ReconstructBst(preOrderTraversalValues)\n\tactualOrder := getDfsOrder(actual, nil)\n\trequire.Equal(t, expected, actualOrder)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  public BST reconstructBst(ArrayList<Integer> preOrderTraversalValues) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n^2) time | O(n) space - where n is the length of the input array\n  public BST reconstructBst(List<Integer> preOrderTraversalValues) {\n    if (preOrderTraversalValues.size() == 0) {\n      return null;\n    }\n\n    int currentValue = preOrderTraversalValues.get(0);\n    int rightSubtreeRootIdx = preOrderTraversalValues.size();\n\n    for (int idx = 1; idx < preOrderTraversalValues.size(); idx++) {\n      int value = preOrderTraversalValues.get(idx);\n      if (value >= currentValue) {\n        rightSubtreeRootIdx = idx;\n        break;\n      }\n    }\n\n    BST leftSubtree =\n      reconstructBst(preOrderTraversalValues.subList(1, rightSubtreeRootIdx));\n    BST rightSubtree = reconstructBst(preOrderTraversalValues.subList(\n      rightSubtreeRootIdx, preOrderTraversalValues.size()\n    ));\n\n    BST bst = new BST(currentValue);\n    bst.left = leftSubtree;\n    bst.right = rightSubtree;\n\n    return bst;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  static class TreeInfo {\n    public int rootIdx;\n\n    public TreeInfo(int rootIdx) {\n      this.rootIdx = rootIdx;\n    }\n  }\n\n  // O(n) time | O(n) space - where n is the length of the input array\n  public BST reconstructBst(List<Integer> preOrderTraversalValues) {\n    TreeInfo treeInfo = new TreeInfo(0);\n    return reconstructBstFromRange(\n      Integer.MIN_VALUE, Integer.MAX_VALUE, preOrderTraversalValues, treeInfo\n    );\n  }\n\n  public BST reconstructBstFromRange(\n    int lowerBound,\n    int upperBound,\n    List<Integer> preOrderTraversalValues,\n    TreeInfo currentSubtreeInfo\n  ) {\n    if (currentSubtreeInfo.rootIdx == preOrderTraversalValues.size()) {\n      return null;\n    }\n\n    int rootValue = preOrderTraversalValues.get(currentSubtreeInfo.rootIdx);\n    if (rootValue < lowerBound || rootValue >= upperBound) {\n      return null;\n    }\n\n    currentSubtreeInfo.rootIdx += 1;\n    BST leftSubtree = reconstructBstFromRange(\n      lowerBound, rootValue, preOrderTraversalValues, currentSubtreeInfo\n    );\n    BST rightSubtree = reconstructBstFromRange(\n      rootValue, upperBound, preOrderTraversalValues, currentSubtreeInfo\n    );\n\n    BST bst = new BST(rootValue);\n    bst.left = leftSubtree;\n    bst.right = rightSubtree;\n    return bst;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  public List<Integer> getDfsOrder(Program.BST node, List<Integer> values) {\n    values.add(node.value);\n    if (node.left != null) {\n      getDfsOrder(node.left, values);\n    }\n    if (node.right != null) {\n      getDfsOrder(node.right, values);\n    }\n    return values;\n  }\n\n  @Test\n  public void TestCase1() {\n    List<Integer> preOrderTraversalValues =\n      new ArrayList<Integer>(Arrays.asList(10, 4, 2, 1, 3, 17, 19, 18));\n    Program.BST tree = new Program.BST(10);\n    tree.left = new Program.BST(4);\n    tree.left.left = new Program.BST(2);\n    tree.left.left.left = new Program.BST(1);\n    tree.left.right = new Program.BST(3);\n    tree.right = new Program.BST(17);\n    tree.right.right = new Program.BST(19);\n    tree.right.right.left = new Program.BST(18);\n    List<Integer> expected = getDfsOrder(tree, new ArrayList<Integer>());\n    var actual = new Program().reconstructBst(preOrderTraversalValues);\n    List<Integer> actualValues = getDfsOrder(actual, new ArrayList<Integer>());\n    Utils.assertTrue(expected.equals(actualValues));\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  public List<Integer> getDfsOrder(Program.BST node, List<Integer> values) {\n    values.add(node.value);\n    if (node.left != null) {\n      getDfsOrder(node.left, values);\n    }\n    if (node.right != null) {\n      getDfsOrder(node.right, values);\n    }\n    return values;\n  }\n\n  @Test\n  public void TestCase1() {\n    List<Integer> preOrderTraversalValues =\n      new ArrayList<Integer>(Arrays.asList(10, 4, 2, 1, 3, 17, 19, 18));\n    Program.BST tree = new Program.BST(10);\n    tree.left = new Program.BST(4);\n    tree.left.left = new Program.BST(2);\n    tree.left.left.left = new Program.BST(1);\n    tree.left.right = new Program.BST(3);\n    tree.right = new Program.BST(17);\n    tree.right.right = new Program.BST(19);\n    tree.right.right.left = new Program.BST(18);\n    List<Integer> expected = getDfsOrder(tree, new ArrayList<Integer>());\n    var actual = new Program().reconstructBst(preOrderTraversalValues);\n    List<Integer> actualValues = getDfsOrder(actual, new ArrayList<Integer>());\n    Utils.assertTrue(expected.equals(actualValues));\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass BST {\n  constructor(value, left = null, right = null) {\n    this.value = value;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nfunction reconstructBst(preOrderTraversalValues) {\n  // Write your code here.\n  return null;\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.reconstructBst = reconstructBst;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BST {\n  constructor(value, left = null, right = null) {\n    this.value = value;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// O(n^2) time | O(n) space - where n is the length of the input array\nfunction reconstructBst(preOrderTraversalValues) {\n  if (preOrderTraversalValues.length === 0) return null;\n\n  const currentValue = preOrderTraversalValues[0];\n  let rightSubtreeRootIdx = preOrderTraversalValues.length;\n\n  for (let idx = 1; idx < preOrderTraversalValues.length; idx++) {\n    const value = preOrderTraversalValues[idx];\n    if (value >= currentValue) {\n      rightSubtreeRootIdx = idx;\n      break;\n    }\n  }\n\n  const leftSubtree = reconstructBst(preOrderTraversalValues.slice(1, rightSubtreeRootIdx));\n  const rightSubtree = reconstructBst(preOrderTraversalValues.slice(rightSubtreeRootIdx));\n  return new BST(currentValue, leftSubtree, rightSubtree);\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.reconstructBst = reconstructBst;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BST {\n  constructor(value, left = null, right = null) {\n    this.value = value;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nclass TreeInfo {\n  constructor(rootIdx) {\n    this.rootIdx = rootIdx;\n  }\n}\n\n// O(n) time | O(n) space - where n is the length of the input array\nfunction reconstructBst(preOrderTraversalValues) {\n  const treeInfo = new TreeInfo(0);\n  return reconstructBstFromRange(-Infinity, Infinity, preOrderTraversalValues, treeInfo);\n}\n\nfunction reconstructBstFromRange(\n  lowerBound,\n  upperBound,\n  preOrderTraversalValues,\n  currentSubtreeInfo,\n) {\n  if (currentSubtreeInfo.rootIdx === preOrderTraversalValues.length) return null;\n\n  const rootValue = preOrderTraversalValues[currentSubtreeInfo.rootIdx];\n  if (rootValue < lowerBound || rootValue >= upperBound) return null;\n\n  currentSubtreeInfo.rootIdx++;\n  const leftSubtree = reconstructBstFromRange(\n    lowerBound,\n    rootValue,\n    preOrderTraversalValues,\n    currentSubtreeInfo,\n  );\n  const rightSubtree = reconstructBstFromRange(\n    rootValue,\n    upperBound,\n    preOrderTraversalValues,\n    currentSubtreeInfo,\n  );\n  return new BST(rootValue, leftSubtree, rightSubtree);\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.reconstructBst = reconstructBst;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nconst {BST} = program;\n\nfunction getDfsOrder(node, values) {\n  if (node === null) return;\n  values.push(node.value);\n  getDfsOrder(node.left, values);\n  getDfsOrder(node.right, values);\n  return values;\n}\n\nit('Test Case #1', function () {\n  const preOrderTraversalValues = [10, 4, 2, 1, 3, 17, 19, 18];\n  const tree = new BST(10);\n  tree.left = new BST(4);\n  tree.left.left = new BST(2);\n  tree.left.left.left = new BST(1);\n  tree.left.right = new BST(3);\n  tree.right = new BST(17);\n  tree.right.right = new BST(19);\n  tree.right.right.left = new BST(18);\n  const expected = getDfsOrder(tree, []);\n  const actual = program.reconstructBst(preOrderTraversalValues);\n  const actualDfsOrder = getDfsOrder(actual, []);\n  chai.expect(actualDfsOrder).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nconst {BST} = program;\n\nfunction getDfsOrder(node, values) {\n  if (node === null) return;\n  values.push(node.value);\n  getDfsOrder(node.left, values);\n  getDfsOrder(node.right, values);\n  return values;\n}\n\nit('Test Case #1', function () {\n  const preOrderTraversalValues = [10, 4, 2, 1, 3, 17, 19, 18];\n  const tree = new BST(10);\n  tree.left = new BST(4);\n  tree.left.left = new BST(2);\n  tree.left.left.left = new BST(1);\n  tree.left.right = new BST(3);\n  tree.right = new BST(17);\n  tree.right.right = new BST(19);\n  tree.right.right.left = new BST(18);\n  const expected = getDfsOrder(tree, []);\n  const actual = program.reconstructBst(preOrderTraversalValues);\n  const actualDfsOrder = getDfsOrder(actual, []);\n  chai.expect(actualDfsOrder).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BST(value: Int, left: BST? = null, right: BST? = null) {\n    var value = value\n    var left = left\n    var right = right\n}\n\nfun reconstructBst(preOrderTraversalValues: List<Int>): BST? {\n    // Write your code here.\n    return null\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BST(value: Int, left: BST? = null, right: BST? = null) {\n    var value = value\n    var left = left\n    var right = right\n}\n\n// O(n^2) time | O(n) space - where n is the length of the input array\nfun reconstructBst(preOrderTraversalValues: List<Int>): BST? {\n    if (preOrderTraversalValues.size == 0) return null\n\n    val currentValue = preOrderTraversalValues[0]\n    var rightSubtreeRootIdx = preOrderTraversalValues.size\n\n    for (idx in 1 until preOrderTraversalValues.size) {\n        val value = preOrderTraversalValues[idx]\n        if (value >= currentValue) {\n            rightSubtreeRootIdx = idx\n            break\n        }\n    }\n\n    val leftSubtree = reconstructBst(\n        preOrderTraversalValues.subList(1, rightSubtreeRootIdx),\n    )\n    val rightSubtree = reconstructBst(\n        preOrderTraversalValues.subList(rightSubtreeRootIdx, preOrderTraversalValues.size),\n    )\n    return BST(currentValue, leftSubtree, rightSubtree)\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BST(value: Int, left: BST? = null, right: BST? = null) {\n    var value = value\n    var left = left\n    var right = right\n}\n\nopen class TreeInfo(rootIdx: Int) {\n    var rootIdx = rootIdx\n}\n\n// O(n) time | O(n) space - where n is the length of the input array\nfun reconstructBst(preOrderTraversalValues: List<Int>): BST? {\n    val treeInfo = TreeInfo(0)\n    return reconstructBstFromRange(\n        Int.MIN_VALUE,\n        Int.MAX_VALUE,\n        preOrderTraversalValues,\n        treeInfo,\n    )\n}\n\nfun reconstructBstFromRange(\n    lowerBound: Int,\n    upperBound: Int,\n    preOrderTraversalValues: List<Int>,\n    currentSubtreeInfo: TreeInfo,\n): BST? {\n    if (currentSubtreeInfo.rootIdx == preOrderTraversalValues.size) return null\n\n    val rootValue = preOrderTraversalValues[currentSubtreeInfo.rootIdx]\n    if (rootValue < lowerBound || rootValue >= upperBound) return null\n\n    currentSubtreeInfo.rootIdx += 1\n    val leftSubtree = reconstructBstFromRange(\n        lowerBound,\n        rootValue,\n        preOrderTraversalValues,\n        currentSubtreeInfo,\n    )\n    val rightSubtree = reconstructBstFromRange(\n        rootValue,\n        upperBound,\n        preOrderTraversalValues,\n        currentSubtreeInfo,\n    )\n    return BST(rootValue, leftSubtree, rightSubtree)\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.BST\nimport com.algoexpert.program.reconstructBst\n\nfun getDfsOrder(node: BST?, values: MutableList<Int>): List<Int> {\n    if (node == null) return listOf()\n    values.add(node.value)\n    getDfsOrder(node.left, values)\n    getDfsOrder(node.right, values)\n    return values\n}\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val preOrderTraversalValues = listOf(10, 4, 2, 1, 3, 17, 19, 18)\n        val tree = BST(10)\n        tree.left = BST(4)\n        tree.left!!.left = BST(2)\n        tree.left!!.left!!.left = BST(1)\n        tree.left!!.right = BST(3)\n        tree.right = BST(17)\n        tree.right!!.right = BST(19)\n        tree.right!!.right!!.left = BST(18)\n        val expected = getDfsOrder(tree, mutableListOf<Int>())\n        val output = reconstructBst(preOrderTraversalValues)\n        val outputDfsOrder = getDfsOrder(output, mutableListOf<Int>())\n        assert(expected == outputDfsOrder)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.BST\nimport com.algoexpert.program.reconstructBst\n\nfun getDfsOrder(node: BST?, values: MutableList<Int>): List<Int> {\n    if (node == null) return listOf()\n    values.add(node.value)\n    getDfsOrder(node.left, values)\n    getDfsOrder(node.right, values)\n    return values\n}\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val preOrderTraversalValues = listOf(10, 4, 2, 1, 3, 17, 19, 18)\n        val tree = BST(10)\n        tree.left = BST(4)\n        tree.left!!.left = BST(2)\n        tree.left!!.left!!.left = BST(1)\n        tree.left!!.right = BST(3)\n        tree.right = BST(17)\n        tree.right!!.right = BST(19)\n        tree.right!!.right!!.left = BST(18)\n        val expected = getDfsOrder(tree, mutableListOf<Int>())\n        val output = reconstructBst(preOrderTraversalValues)\n        val outputDfsOrder = getDfsOrder(output, mutableListOf<Int>())\n        assert(expected == outputDfsOrder)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass BST:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef reconstructBst(preOrderTraversalValues):\n    # Write your code here.\n    return None\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BST:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# O(n^2) time | O(n) space - where n is the length of the input array\ndef reconstructBst(preOrderTraversalValues):\n    if len(preOrderTraversalValues) == 0:\n        return None\n\n    currentValue = preOrderTraversalValues[0]\n    rightSubtreeRootIdx = len(preOrderTraversalValues)\n\n    for idx in range(1, len(preOrderTraversalValues)):\n        value = preOrderTraversalValues[idx]\n        if value >= currentValue:\n            rightSubtreeRootIdx = idx\n            break\n\n    leftSubtree = reconstructBst(preOrderTraversalValues[1:rightSubtreeRootIdx])\n    rightSubtree = reconstructBst(preOrderTraversalValues[rightSubtreeRootIdx:])\n    return BST(currentValue, leftSubtree, rightSubtree)\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BST:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\nclass TreeInfo:\n    def __init__(self, rootIdx):\n        self.rootIdx = rootIdx\n\n\n# O(n) time | O(n) space - where n is the length of the input array\ndef reconstructBst(preOrderTraversalValues):\n    treeInfo = TreeInfo(0)\n    return reconstructBstFromRange(float(\"-inf\"), float(\"inf\"), preOrderTraversalValues, treeInfo)\n\n\ndef reconstructBstFromRange(lowerBound, upperBound, preOrderTraversalValues, currentSubtreeInfo):\n    if currentSubtreeInfo.rootIdx == len(preOrderTraversalValues):\n        return None\n\n    rootValue = preOrderTraversalValues[currentSubtreeInfo.rootIdx]\n    if rootValue < lowerBound or rootValue >= upperBound:\n        return None\n\n    currentSubtreeInfo.rootIdx += 1\n    leftSubtree = reconstructBstFromRange(\n        lowerBound, rootValue, preOrderTraversalValues, currentSubtreeInfo\n    )\n    rightSubtree = reconstructBstFromRange(\n        rootValue, upperBound, preOrderTraversalValues, currentSubtreeInfo\n    )\n    return BST(rootValue, leftSubtree, rightSubtree)\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nBST = program.BST\n\n\ndef getDfsOrder(node, values):\n    if node is None:\n        return\n    values.append(node.value)\n    getDfsOrder(node.left, values)\n    getDfsOrder(node.right, values)\n    return values\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        preOrderTraversalValues = [10, 4, 2, 1, 3, 17, 19, 18]\n        tree = BST(10)\n        tree.left = BST(4)\n        tree.left.left = BST(2)\n        tree.left.left.left = BST(1)\n        tree.left.right = BST(3)\n        tree.right = BST(17)\n        tree.right.right = BST(19)\n        tree.right.right.left = BST(18)\n        expected = getDfsOrder(tree, [])\n        actual = program.reconstructBst(preOrderTraversalValues)\n        actualDfsOrder = getDfsOrder(actual, [])\n        self.assertEqual(actualDfsOrder, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nBST = program.BST\n\n\ndef getDfsOrder(node, values):\n    if node is None:\n        return\n    values.append(node.value)\n    getDfsOrder(node.left, values)\n    getDfsOrder(node.right, values)\n    return values\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        preOrderTraversalValues = [10, 4, 2, 1, 3, 17, 19, 18]\n        tree = BST(10)\n        tree.left = BST(4)\n        tree.left.left = BST(2)\n        tree.left.left.left = BST(1)\n        tree.left.right = BST(3)\n        tree.right = BST(17)\n        tree.right.right = BST(19)\n        tree.right.right.left = BST(18)\n        expected = getDfsOrder(tree, [])\n        actual = program.reconstructBst(preOrderTraversalValues)\n        actualDfsOrder = getDfsOrder(actual, [])\n        self.assertEqual(actualDfsOrder, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "# This is an input struct. Do not edit.\nclass BST\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def reconstructBst(preOrderTraversalValues)\n    # Write your code here.\n    return nil\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BST\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\n# O(n^2) time | O(n) space - where n is the length of the input array\ndef reconstructBst(preOrderTraversalValues)\n  if preOrderTraversalValues.size == 0\n    return nil\n  end\n\n  currentValue = preOrderTraversalValues[0]\n  rightSubtreeRootIdx = preOrderTraversalValues.count\n\n  1.upto(preOrderTraversalValues.count - 1) do |idx|\n    value = preOrderTraversalValues[idx]\n    if value >= currentValue\n      rightSubtreeRootIdx = idx\n      break\n    end\n  end\n\n  leftSubtree = reconstructBst(preOrderTraversalValues[1..rightSubtreeRootIdx - 1])\n  rightSubtree = reconstructBst(preOrderTraversalValues.drop(rightSubtreeRootIdx))\n  bst = BST.new(currentValue)\n  bst.left = leftSubtree\n  bst.right = rightSubtree\n  return bst\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BST\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\n# O(n^2) time | O(n) space - where n is the length of the input array\ndef reconstructBst(preOrderTraversalValues)\n  return BST.new(-1)\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.reconstructBst\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.reconstructBst\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  func reconstructBst(_ preOrderTraversalValues: [Int]) -> BST {\n    // Write your code here.\n    return BST(value: -1)\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(n^2) time | O(n) space - where n is the length of the input array\n  func reconstructBst(_ preOrderTraversalValues: [Int]) -> BST? {\n    if preOrderTraversalValues.count == 0 {\n      return nil\n    }\n\n    let currentValue = preOrderTraversalValues[0]\n    var rightSubtreeRootIdx = preOrderTraversalValues.count\n\n    for idx in stride(from: 1, to: preOrderTraversalValues.count, by: 1) {\n      let value = preOrderTraversalValues[idx]\n      if value >= currentValue {\n        rightSubtreeRootIdx = idx\n        break\n      }\n    }\n\n    let leftSubtree = reconstructBst(Array(preOrderTraversalValues[1 ..< rightSubtreeRootIdx]))\n    let rightSubtree = reconstructBst(Array(preOrderTraversalValues[rightSubtreeRootIdx...]))\n    var bst = BST(value: currentValue)\n    bst.left = leftSubtree\n    bst.right = rightSubtree\n    return bst\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(n) time | O(n) space - where n is the length of the input array\n  func reconstructBst(_ preOrderTraversalValues: [Int]) -> BST? {\n    var rootIdx = 0\n    return reconstructBstFromRange(\n      Int.min,\n      Int.max,\n      preOrderTraversalValues,\n      &rootIdx\n    )\n  }\n\n  func reconstructBstFromRange(_ lowerBound: Int, _ upperBound: Int, _ preOrderTraversalValues: [Int], _ currentRootIdx: inout Int) -> BST? {\n    if currentRootIdx == preOrderTraversalValues.count {\n      return nil\n    }\n\n    let rootValue = preOrderTraversalValues[currentRootIdx]\n    if rootValue < lowerBound || rootValue >= upperBound {\n      return nil\n    }\n\n    currentRootIdx += 1\n    let leftSubtree = reconstructBstFromRange(\n      lowerBound,\n      rootValue,\n      preOrderTraversalValues,\n      &currentRootIdx\n    )\n    let rightSubtree = reconstructBstFromRange(\n      rootValue,\n      upperBound,\n      preOrderTraversalValues,\n      &currentRootIdx\n    )\n    var bst = BST(value: rootValue)\n    bst.left = leftSubtree\n    bst.right = rightSubtree\n    return bst\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n\nfunc getDfsOrder(_ node: Program.BST?, _ values: inout [Int]) -> [Int] {\n  if node == nil {\n    return [Int]()\n  }\n  values.append(node!.value)\n  getDfsOrder(node!.left, &values)\n  getDfsOrder(node!.right, &values)\n  return values\n}\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let preOrderTraversalValues = [10, 4, 2, 1, 3, 17, 19, 18]\n      var tree = Program.BST(value: 10)\n      tree.left = Program.BST(value: 4)\n      tree.left!.left = Program.BST(value: 2)\n      tree.left!.left!.left = Program.BST(value: 1)\n      tree.left!.right = Program.BST(value: 3)\n      tree.right = Program.BST(value: 17)\n      tree.right!.right = Program.BST(value: 19)\n      tree.right!.right!.left = Program.BST(value: 18)\n      var valuesExpected = [Int]()\n      let expected = getDfsOrder(tree, &valuesExpected)\n      let output = Program().reconstructBst(preOrderTraversalValues)\n      var valuesOutput = [Int]()\n      let outputDfsOrder = getDfsOrder(output, &valuesOutput)\n      try assertEqual(expected, outputDfsOrder)\n    }\n  }\n}\n",
      "unitTests": "\nfunc getDfsOrder(_ node: Program.BST?, _ values: inout [Int]) -> [Int] {\n  if node == nil {\n    return [Int]()\n  }\n  values.append(node!.value)\n  getDfsOrder(node!.left, &values)\n  getDfsOrder(node!.right, &values)\n  return values\n}\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let preOrderTraversalValues = [10, 4, 2, 1, 3, 17, 19, 18]\n      var tree = Program.BST(value: 10)\n      tree.left = Program.BST(value: 4)\n      tree.left!.left = Program.BST(value: 2)\n      tree.left!.left!.left = Program.BST(value: 1)\n      tree.left!.right = Program.BST(value: 3)\n      tree.right = Program.BST(value: 17)\n      tree.right!.right = Program.BST(value: 19)\n      tree.right!.right!.left = Program.BST(value: 18)\n      var valuesExpected = [Int]()\n      let expected = getDfsOrder(tree, &valuesExpected)\n      let output = Program().reconstructBst(preOrderTraversalValues)\n      var valuesOutput = [Int]()\n      let outputDfsOrder = getDfsOrder(output, &valuesOutput)\n      try assertEqual(expected, outputDfsOrder)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number, left: BST | null = null, right: BST | null = null) {\n    this.value = value;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nexport function reconstructBst(preOrderTraversalValues: number[]): BST | null {\n  // Write your code here.\n  return null;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number, left: BST | null = null, right: BST | null = null) {\n    this.value = value;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// O(n^2) time | O(n) space - where n is the length of the input array\nexport function reconstructBst(preOrderTraversalValues: number[]): BST | null {\n  if (preOrderTraversalValues.length === 0) return null;\n\n  const currentValue = preOrderTraversalValues[0];\n  let rightSubtreeRootIdx = preOrderTraversalValues.length;\n\n  for (let idx = 1; idx < preOrderTraversalValues.length; idx++) {\n    const value = preOrderTraversalValues[idx];\n    if (value >= currentValue) {\n      rightSubtreeRootIdx = idx;\n      break;\n    }\n  }\n\n  const leftSubtree = reconstructBst(preOrderTraversalValues.slice(1, rightSubtreeRootIdx));\n  const rightSubtree = reconstructBst(preOrderTraversalValues.slice(rightSubtreeRootIdx));\n  return new BST(currentValue, leftSubtree, rightSubtree);\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number, left: BST | null = null, right: BST | null = null) {\n    this.value = value;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nclass TreeInfo {\n  rootIdx: number;\n\n  constructor(rootIdx: number) {\n    this.rootIdx = rootIdx;\n  }\n}\n\n// O(n) time | O(n) space - where n is the length of the input array\nexport function reconstructBst(preOrderTraversalValues: number[]) {\n  const treeInfo = new TreeInfo(0);\n  return reconstructBstFromRange(-Infinity, Infinity, preOrderTraversalValues, treeInfo);\n}\n\nfunction reconstructBstFromRange(\n  lowerBound: number,\n  upperBound: number,\n  preOrderTraversalValues: number[],\n  currentSubtreeInfo: TreeInfo,\n): BST | null {\n  if (currentSubtreeInfo.rootIdx === preOrderTraversalValues.length) return null;\n\n  const rootValue = preOrderTraversalValues[currentSubtreeInfo.rootIdx];\n  if (rootValue < lowerBound || rootValue >= upperBound) return null;\n\n  currentSubtreeInfo.rootIdx++;\n  const leftSubtree = reconstructBstFromRange(\n    lowerBound,\n    rootValue,\n    preOrderTraversalValues,\n    currentSubtreeInfo,\n  );\n  const rightSubtree = reconstructBstFromRange(\n    rootValue,\n    upperBound,\n    preOrderTraversalValues,\n    currentSubtreeInfo,\n  );\n  return new BST(rootValue, leftSubtree, rightSubtree);\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nconst {BST} = program;\n\nfunction getDfsOrder(node: program.BST | null, values: number[]) {\n  if (node === null) return;\n  values.push(node.value);\n  getDfsOrder(node.left, values);\n  getDfsOrder(node.right, values);\n  return values;\n}\n\nit('Test Case #1', function () {\n  const preOrderTraversalValues = [10, 4, 2, 1, 3, 17, 19, 18];\n  const tree = new BST(10);\n  tree.left = new BST(4);\n  tree.left.left = new BST(2);\n  tree.left.left.left = new BST(1);\n  tree.left.right = new BST(3);\n  tree.right = new BST(17);\n  tree.right.right = new BST(19);\n  tree.right.right.left = new BST(18);\n  const expected = getDfsOrder(tree, []);\n  const actual = program.reconstructBst(preOrderTraversalValues);\n  const actualDfsOrder = getDfsOrder(actual, []);\n  chai.expect(actualDfsOrder).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nconst {BST} = program;\n\nfunction getDfsOrder(node: program.BST | null, values: number[]) {\n  if (node === null) return;\n  values.push(node.value);\n  getDfsOrder(node.left, values);\n  getDfsOrder(node.right, values);\n  return values;\n}\n\nit('Test Case #1', function () {\n  const preOrderTraversalValues = [10, 4, 2, 1, 3, 17, 19, 18];\n  const tree = new BST(10);\n  tree.left = new BST(4);\n  tree.left.left = new BST(2);\n  tree.left.left.left = new BST(1);\n  tree.left.right = new BST(3);\n  tree.right = new BST(17);\n  tree.right.right = new BST(19);\n  tree.right.right.left = new BST(18);\n  const expected = getDfsOrder(tree, []);\n  const actual = program.reconstructBst(preOrderTraversalValues);\n  const actualDfsOrder = getDfsOrder(actual, []);\n  chai.expect(actualDfsOrder).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "preOrderTraversalValues",
      "example": [
        10,
        4,
        2,
        1,
        5,
        17,
        19,
        18
      ],
      "schema": {
        "items": {
          "type": "integer"
        },
        "minItems": 1,
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "preOrderTraversalValues": [
        10,
        4,
        2,
        1,
        5,
        17,
        19,
        18
      ]
    },
    {
      "preOrderTraversalValues": [
        100
      ]
    },
    {
      "preOrderTraversalValues": [
        10,
        9,
        8,
        7,
        6,
        5
      ]
    },
    {
      "preOrderTraversalValues": [
        5,
        6,
        7,
        8
      ]
    },
    {
      "preOrderTraversalValues": [
        5,
        -10,
        -5,
        6,
        9,
        7
      ]
    },
    {
      "preOrderTraversalValues": [
        10,
        4,
        2,
        1,
        3,
        5,
        6,
        9,
        7,
        17,
        19,
        18
      ]
    },
    {
      "preOrderTraversalValues": [
        1,
        0,
        2
      ]
    },
    {
      "preOrderTraversalValues": [
        2,
        0,
        1
      ]
    },
    {
      "preOrderTraversalValues": [
        2,
        0,
        1,
        4,
        3
      ]
    },
    {
      "preOrderTraversalValues": [
        2,
        0,
        1,
        4,
        3,
        3
      ]
    },
    {
      "preOrderTraversalValues": [
        2,
        0,
        1,
        3,
        4,
        3
      ]
    },
    {
      "preOrderTraversalValues": [
        10,
        4,
        2,
        1,
        3,
        5,
        5,
        6,
        5,
        5,
        9,
        7,
        17,
        19,
        18,
        18,
        19
      ]
    }
  ],
  "jsonTests": [
    {
      "preOrderTraversalValues": [
        10,
        4,
        2,
        1,
        5,
        17,
        19,
        18
      ]
    },
    {
      "preOrderTraversalValues": [
        100
      ]
    },
    {
      "preOrderTraversalValues": [
        10,
        9,
        8,
        7,
        6,
        5
      ]
    },
    {
      "preOrderTraversalValues": [
        5,
        6,
        7,
        8
      ]
    },
    {
      "preOrderTraversalValues": [
        5,
        -10,
        -5,
        6,
        9,
        7
      ]
    },
    {
      "preOrderTraversalValues": [
        10,
        4,
        2,
        1,
        3,
        5,
        6,
        9,
        7,
        17,
        19,
        18
      ]
    },
    {
      "preOrderTraversalValues": [
        1,
        0,
        2
      ]
    },
    {
      "preOrderTraversalValues": [
        2,
        0,
        1
      ]
    },
    {
      "preOrderTraversalValues": [
        2,
        0,
        1,
        4,
        3
      ]
    },
    {
      "preOrderTraversalValues": [
        2,
        0,
        1,
        4,
        3,
        3
      ]
    },
    {
      "preOrderTraversalValues": [
        2,
        0,
        1,
        3,
        4,
        3
      ]
    },
    {
      "preOrderTraversalValues": [
        10,
        4,
        2,
        1,
        3,
        5,
        5,
        6,
        5,
        5,
        9,
        7,
        17,
        19,
        18,
        18,
        19
      ]
    }
  ],
  "changelog": []
}