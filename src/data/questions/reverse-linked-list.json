{
  "uid": "reverse-linked-list",
  "testStrategy": "JSON",
  "name": "Reverse Linked List",
  "version": 0,
  "releaseDate": "2019-09-01T00:00:00Z",
  "category": "Linked Lists",
  "difficulty": 3,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 28972,
    "failureCount": 7027
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "347174597",
    "duration": 0,
    "annotations": [
      {
        "title": "Variable Naming",
        "content": "It would be better to name these variables more descriptively.",
        "start": 1280,
        "end": 1286
      }
    ],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1251
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in the head of a Singly Linked List, reverses the\n  list in place (i.e., doesn't create a brand new list), and returns its new head.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it's the tail of the list.\n</p>\n<p>\n  You can assume that the input Linked List will always have at least one node; in other\n  words, the head will never be <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">head</span> = 0 -> 1 -> 2 -> 3 -> 4 -> 5 <span class=\"CodeEditor-promptComment\">// the head node with value 0</span>\n</pre>\n<h3>Sample Output</h3>\n<pre>\n5 -> 4 -> 3 -> 2 -> 1 -> 0 <span class=\"CodeEditor-promptComment\">// the new head node with value 5</span>\n</pre>\n</div>",
  "hints": [
    "<p>\nYou can iterate through the Linked List from head to tail and reverse it in place along the way.\n</p>\n",
    "\n<p>\nYou'll need to manipulate three nodes at once at every step.\n</p>\n",
    "\n<p>\nImagine you have three variables pointing to three consecutive nodes in a Linked List. Start by setting the \"next\" property of the second node to the first node. Then, set the first variable to the second node, and set the second variable to the third node. Finally, set the third variable to the second variable's \"next\" property (at this point, the second variable is the original third node). Repeat this process until you're at the tail of the Linked List.\n</p>"
  ],
  "spaceTime": "O(n) time | O(1) space - where n is the number of nodes in the Linked List",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": "linkedlist",
    "outputType": "linkedlist"
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next;\n\n  LinkedList(int value) {\n    this->value = value;\n    this->next = nullptr;\n  }\n};\n\nLinkedList* reverseLinkedList(LinkedList* head) {\n  // Write your code here.\n  return nullptr;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next;\n\n  LinkedList(int value) {\n    this->value = value;\n    this->next = nullptr;\n  }\n};\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nLinkedList* reverseLinkedList(LinkedList* head) {\n  LinkedList* previousNode = nullptr;\n  LinkedList* currentNode = head;\n  while (currentNode != nullptr) {\n    LinkedList* nextNode = currentNode->next;\n    currentNode->next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include <vector>\n\nLinkedList* newLinkedList(vector<int> values);\nvector<int> toArray(LinkedList* ll);\nbool arraysEqual(vector<int> arr1, vector<int> arr2);\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      LinkedList* test = newLinkedList({0, 1, 2, 3, 4, 5});\n      vector<int> result = toArray(reverseLinkedList(test));\n      vector<int> expected = {5, 4, 3, 2, 1, 0};\n      assert(arraysEqual(result, expected));\n    });\n  }\n};\n\nLinkedList* newLinkedList(vector<int> values) {\n  LinkedList* ll = new LinkedList(values[0]);\n  LinkedList* current = ll;\n  for (int i = 1; i < values.size(); i++) {\n    current->next = new LinkedList(values[i]);\n    current = current->next;\n  }\n  return ll;\n}\n\nvector<int> toArray(LinkedList* ll) {\n  vector<int> arr = {};\n  LinkedList* current = ll;\n  while (current != nullptr) {\n    arr.push_back(current->value);\n    current = current->next;\n  }\n  return arr;\n}\n\nbool arraysEqual(vector<int> arr1, vector<int> arr2) {\n  if (arr1.size() != arr2.size()) return false;\n  for (int i = 0; i < arr1.size(); i++) {\n    if (arr1[i] != arr2[i]) return false;\n  }\n  return true;\n}\n",
      "unitTests": "#include <vector>\n\nLinkedList* newLinkedList(vector<int> values);\nvector<int> toArray(LinkedList* ll);\nbool arraysEqual(vector<int> arr1, vector<int> arr2);\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      LinkedList* test = newLinkedList({0, 1, 2, 3, 4, 5});\n      vector<int> result = toArray(reverseLinkedList(test));\n      vector<int> expected = {5, 4, 3, 2, 1, 0};\n      assert(arraysEqual(result, expected));\n    });\n  }\n};\n\nLinkedList* newLinkedList(vector<int> values) {\n  LinkedList* ll = new LinkedList(values[0]);\n  LinkedList* current = ll;\n  for (int i = 1; i < values.size(); i++) {\n    current->next = new LinkedList(values[i]);\n    current = current->next;\n  }\n  return ll;\n}\n\nvector<int> toArray(LinkedList* ll) {\n  vector<int> arr = {};\n  LinkedList* current = ll;\n  while (current != nullptr) {\n    arr.push_back(current->value);\n    current = current->next;\n  }\n  return arr;\n}\n\nbool arraysEqual(vector<int> arr1, vector<int> arr2) {\n  if (arr1.size() != arr2.size()) return false;\n  for (int i = 0; i < arr1.size(); i++) {\n    if (arr1[i] != arr2[i]) return false;\n  }\n  return true;\n}\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public static LinkedList ReverseLinkedList(LinkedList head) {\n    // Write your code here.\n    return null;\n  }\n\n  public class LinkedList {\n    public int Value;\n    public LinkedList Next = null;\n\n    public LinkedList(int value) {\n      this.Value = value;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n  // O(n) time | O(1) space - where n is the number of nodes in the Linked List\n  public static LinkedList ReverseLinkedList(LinkedList head) {\n    LinkedList previousNode = null;\n    LinkedList currentNode = head;\n    while (currentNode != null) {\n      LinkedList nextNode = currentNode.Next;\n      currentNode.Next = previousNode;\n      previousNode = currentNode;\n      currentNode = nextNode;\n    }\n    return previousNode;\n  }\n\n  public class LinkedList {\n    public int Value;\n    public LinkedList Next = null;\n\n    public LinkedList(int value) {\n      this.Value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.LinkedList test = newLinkedList(new int[] { 0, 1, 2, 3, 4, 5 });\n    List<int> result = toList(Program.ReverseLinkedList(test));\n    int[] expected = new int[] { 5, 4, 3, 2, 1, 0 };\n    Utils.AssertTrue(arraysEqual(result, expected));\n  }\n\n  public Program.LinkedList newLinkedList(int[] values) {\n    Program.LinkedList ll = new Program.LinkedList(values[0]);\n    Program.LinkedList current = ll;\n    for (int i = 1; i < values.Length; i++) {\n      current.Next = new Program.LinkedList(values[i]);\n      current = current.Next;\n    }\n    return ll;\n  }\n\n  public List<int> toList(Program.LinkedList ll) {\n    List<int> arr = new List<int>();\n    Program.LinkedList current = ll;\n    while (current != null) {\n      arr.Add(current.Value);\n      current = current.Next;\n    }\n    return arr;\n  }\n\n  public bool arraysEqual(List<int> arr1, int[] arr2) {\n    if (arr1.Count != arr2.Length) return false;\n    for (int i = 0; i < arr1.Count; i++) {\n      if (arr1[i] != arr2[i]) return false;\n    }\n    return true;\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.LinkedList test = newLinkedList(new int[] { 0, 1, 2, 3, 4, 5 });\n    List<int> result = toList(Program.ReverseLinkedList(test));\n    int[] expected = new int[] { 5, 4, 3, 2, 1, 0 };\n    Utils.AssertTrue(arraysEqual(result, expected));\n  }\n\n  public Program.LinkedList newLinkedList(int[] values) {\n    Program.LinkedList ll = new Program.LinkedList(values[0]);\n    Program.LinkedList current = ll;\n    for (int i = 1; i < values.Length; i++) {\n      current.Next = new Program.LinkedList(values[i]);\n      current = current.Next;\n    }\n    return ll;\n  }\n\n  public List<int> toList(Program.LinkedList ll) {\n    List<int> arr = new List<int>();\n    Program.LinkedList current = ll;\n    while (current != null) {\n      arr.Add(current.Value);\n      current = current.Next;\n    }\n    return arr;\n  }\n\n  public bool arraysEqual(List<int> arr1, int[] arr2) {\n    if (arr1.Count != arr2.Length) return false;\n    for (int i = 0; i < arr1.Count; i++) {\n      if (arr1[i] != arr2[i]) return false;\n    }\n    return true;\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\nfunc ReverseLinkedList(head *LinkedList) *LinkedList {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfunc ReverseLinkedList(head *LinkedList) *LinkedList {\n\tvar previousNode, currentNode *LinkedList = nil, head\n\tfor currentNode != nil {\n\t\tnextNode := currentNode.Next\n\t\tcurrentNode.Next = previousNode\n\t\tpreviousNode = currentNode\n\t\tcurrentNode = nextNode\n\t}\n\treturn previousNode\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc NewLinkedList(val int, others ...int) *LinkedList {\n\tll := &LinkedList{Value: val}\n\tcurrent := ll\n\tfor _, other := range others {\n\t\tcurrent.Next = &LinkedList{Value: other}\n\t\tcurrent = current.Next\n\t}\n\treturn ll\n}\n\nfunc (ll *LinkedList) ToArray() []int {\n\tvals := []int{}\n\tcurrent := ll\n\tfor current != nil {\n\t\tvals = append(vals, current.Value)\n\t\tcurrent = current.Next\n\t}\n\treturn vals\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := NewLinkedList(0, 1, 2, 3, 4, 5)\n\toutput := ReverseLinkedList(input)\n\texpected := []int{5, 4, 3, 2, 1, 0}\n\trequire.NotNil(t, output)\n\trequire.Equal(t, expected, output.ToArray())\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc NewLinkedList(val int, others ...int) *LinkedList {\n\tll := &LinkedList{Value: val}\n\tcurrent := ll\n\tfor _, other := range others {\n\t\tcurrent.Next = &LinkedList{Value: other}\n\t\tcurrent = current.Next\n\t}\n\treturn ll\n}\n\nfunc (ll *LinkedList) ToArray() []int {\n\tvals := []int{}\n\tcurrent := ll\n\tfor current != nil {\n\t\tvals = append(vals, current.Value)\n\t\tcurrent = current.Next\n\t}\n\treturn vals\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := NewLinkedList(0, 1, 2, 3, 4, 5)\n\toutput := ReverseLinkedList(input)\n\texpected := []int{5, 4, 3, 2, 1, 0}\n\trequire.NotNil(t, output)\n\trequire.Equal(t, expected, output.ToArray())\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static LinkedList reverseLinkedList(LinkedList head) {\n    // Write your code here.\n    return null;\n  }\n\n  static class LinkedList {\n    int value;\n    LinkedList next = null;\n\n    public LinkedList(int value) {\n      this.value = value;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space - where n is the number of nodes in the Linked List\n  public static LinkedList reverseLinkedList(LinkedList head) {\n    LinkedList previousNode = null;\n    LinkedList currentNode = head;\n    while (currentNode != null) {\n      LinkedList nextNode = currentNode.next;\n      currentNode.next = previousNode;\n      previousNode = currentNode;\n      currentNode = nextNode;\n    }\n    return previousNode;\n  }\n\n  static class LinkedList {\n    int value;\n    LinkedList next = null;\n\n    public LinkedList(int value) {\n      this.value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.LinkedList test = newLinkedList(new int[] {0, 1, 2, 3, 4, 5});\n    List<Integer> result = toArrayList(Program.reverseLinkedList(test));\n    int[] expected = new int[] {5, 4, 3, 2, 1, 0};\n    Utils.assertTrue(arraysEqual(result, expected));\n  }\n\n  public Program.LinkedList newLinkedList(int[] values) {\n    Program.LinkedList ll = new Program.LinkedList(values[0]);\n    Program.LinkedList current = ll;\n    for (int i = 1; i < values.length; i++) {\n      current.next = new Program.LinkedList(values[i]);\n      current = current.next;\n    }\n    return ll;\n  }\n\n  public List<Integer> toArrayList(Program.LinkedList ll) {\n    List<Integer> arr = new ArrayList<Integer>();\n    Program.LinkedList current = ll;\n    while (current != null) {\n      arr.add(current.value);\n      current = current.next;\n    }\n    return arr;\n  }\n\n  public boolean arraysEqual(List<Integer> arr1, int[] arr2) {\n    if (arr1.size() != arr2.length) return false;\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) return false;\n    }\n    return true;\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.LinkedList test = newLinkedList(new int[] {0, 1, 2, 3, 4, 5});\n    List<Integer> result = toArrayList(Program.reverseLinkedList(test));\n    int[] expected = new int[] {5, 4, 3, 2, 1, 0};\n    Utils.assertTrue(arraysEqual(result, expected));\n  }\n\n  public Program.LinkedList newLinkedList(int[] values) {\n    Program.LinkedList ll = new Program.LinkedList(values[0]);\n    Program.LinkedList current = ll;\n    for (int i = 1; i < values.length; i++) {\n      current.next = new Program.LinkedList(values[i]);\n      current = current.next;\n    }\n    return ll;\n  }\n\n  public List<Integer> toArrayList(Program.LinkedList ll) {\n    List<Integer> arr = new ArrayList<Integer>();\n    Program.LinkedList current = ll;\n    while (current != null) {\n      arr.add(current.value);\n      current = current.next;\n    }\n    return arr;\n  }\n\n  public boolean arraysEqual(List<Integer> arr1, int[] arr2) {\n    if (arr1.size() != arr2.length) return false;\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) return false;\n    }\n    return true;\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction reverseLinkedList(head) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.reverseLinkedList = reverseLinkedList;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfunction reverseLinkedList(head) {\n  let previousNode = null;\n  let currentNode = head;\n  while (currentNode !== null) {\n    const nextNode = currentNode.next;\n    currentNode.next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode;\n}\n\nexports.LinkedList = LinkedList;\nexports.reverseLinkedList = reverseLinkedList;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const test = new LinkedList(0).addMany([1, 2, 3, 4, 5]);\n  const result = program.reverseLinkedList(test).getNodesInArray();\n  const expected = new LinkedList(5).addMany([4, 3, 2, 1, 0]).getNodesInArray();\n  chai.expect(result).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const test = new LinkedList(0).addMany([1, 2, 3, 4, 5]);\n  const result = program.reverseLinkedList(test).getNodesInArray();\n  const expected = new LinkedList(5).addMany([4, 3, 2, 1, 0]).getNodesInArray();\n  chai.expect(result).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\nfun reverseLinkedList(head: LinkedList): LinkedList {\n    // Write your code here.\n    return head\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfun reverseLinkedList(head: LinkedList): LinkedList {\n    var previousNode: LinkedList? = null\n    var currentNode: LinkedList? = head\n    while (currentNode != null) {\n        val nextNode = currentNode.next\n        currentNode.next = previousNode\n        previousNode = currentNode\n        currentNode = nextNode\n    }\n    return previousNode!!\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.LinkedList as LinkedList\nimport com.algoexpert.program.reverseLinkedList as reverseLinkedList\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        var linkedList = LinkedList(0)\n        addAll(linkedList, listOf(1, 2, 3, 4, 5))\n        var reversedLinkedList = LinkedList(5)\n        addAll(reversedLinkedList, listOf(4, 3, 2, 1, 0))\n\n        var result = getNodeValuesInArray(reverseLinkedList(linkedList))\n        var expected = getNodeValuesInArray(reversedLinkedList)\n\n        assert(result == expected)\n    }\n}\n\nfun addAll(ll: LinkedList, values: List<Int>) {\n    var current = ll\n    for (value in values) {\n        val newLL = LinkedList(value)\n        current.next = newLL\n        current = newLL\n    }\n}\n\nfun getNodeValuesInArray(linkedList: LinkedList): List<Int> {\n    var values = mutableListOf<Int>()\n    var current: LinkedList? = linkedList\n    while (current != null) {\n        values.add(current.value)\n        current = current.next\n    }\n    return values\n}\n",
      "unitTests": "import com.algoexpert.program.LinkedList as LinkedList\nimport com.algoexpert.program.reverseLinkedList as reverseLinkedList\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        var linkedList = LinkedList(0)\n        addAll(linkedList, listOf(1, 2, 3, 4, 5))\n        var reversedLinkedList = LinkedList(5)\n        addAll(reversedLinkedList, listOf(4, 3, 2, 1, 0))\n\n        var result = getNodeValuesInArray(reverseLinkedList(linkedList))\n        var expected = getNodeValuesInArray(reversedLinkedList)\n\n        assert(result == expected)\n    }\n}\n\nfun addAll(ll: LinkedList, values: List<Int>) {\n    var current = ll\n    for (value in values) {\n        val newLL = LinkedList(value)\n        current.next = newLL\n        current = newLL\n    }\n}\n\nfun getNodeValuesInArray(linkedList: LinkedList): List<Int> {\n    var values = mutableListOf<Int>()\n    var current: LinkedList? = linkedList\n    while (current != null) {\n        values.add(current.value)\n        current = current.next\n    }\n    return values\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\ndef reverseLinkedList(head):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\n# O(n) time | O(1) space - where n is the number of nodes in the Linked List\ndef reverseLinkedList(head):\n    previousNode, currentNode = None, head\n    while currentNode is not None:\n        nextNode = currentNode.next\n        currentNode.next = previousNode\n        previousNode = currentNode\n        currentNode = nextNode\n    return previousNode\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass LinkedList(program.LinkedList):\n    def addMany(self, values):\n        current = self\n        while current.next is not None:\n            current = current.next\n        for value in values:\n            current.next = LinkedList(value)\n            current = current.next\n        return self\n\n    def getNodesInArray(self):\n        nodes = []\n        current = self\n        while current is not None:\n            nodes.append(current.value)\n            current = current.next\n        return nodes\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        test = LinkedList(0).addMany([1, 2, 3, 4, 5])\n        result = program.reverseLinkedList(test).getNodesInArray()\n        expected = LinkedList(5).addMany([4, 3, 2, 1, 0]).getNodesInArray()\n        self.assertEqual(result, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass LinkedList(program.LinkedList):\n    def addMany(self, values):\n        current = self\n        while current.next is not None:\n            current = current.next\n        for value in values:\n            current.next = LinkedList(value)\n            current = current.next\n        return self\n\n    def getNodesInArray(self):\n        nodes = []\n        current = self\n        while current is not None:\n            nodes.append(current.value)\n            current = current.next\n        return nodes\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        test = LinkedList(0).addMany([1, 2, 3, 4, 5])\n        result = program.reverseLinkedList(test).getNodesInArray()\n        expected = LinkedList(5).addMany([4, 3, 2, 1, 0]).getNodesInArray()\n        self.assertEqual(result, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "# This is an input struct. Do not edit.\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\nclass Program\n  def reverseLinkedList(linkedList)\n    # Write your code here.\n    return nil\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\n# O(n) time | O(1) space - where n is the number of nodes in the Linked List\ndef reverseLinkedList(head)\n  previousNode, currentNode = nil, head\n  while currentNode != nil\n    nextNode = currentNode.next\n    currentNode.next = previousNode\n    previousNode = currentNode\n    currentNode = nextNode\n  end\n  return previousNode\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.reverseLinkedList\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.reverseLinkedList\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class LinkedList {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  func reverseLinkedList(_ head: LinkedList) -> LinkedList {\n    // Write your code here.\n    return head // replace me\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class LinkedList {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  // O(n) time | O(1) space\n  func reverseLinkedList(_ head: LinkedList) -> LinkedList {\n    var previousNode: LinkedList?\n    var currentNode: LinkedList? = head\n\n    while currentNode != nil {\n      let nextPointer = currentNode?.next\n      currentNode?.next = previousNode\n      previousNode = currentNode\n      currentNode = nextPointer\n    }\n\n    return previousNode!\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  let program = Program()\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      try testReverseLinkedList(initialValue: 0, values: [1, 2, 3, 4, 5], reversedInitialValue: 5, reversedValues: [4, 3, 2, 1, 0])\n    }\n  }\n\n  func testReverseLinkedList(initialValue: Int, values: [Int], reversedInitialValue: Int, reversedValues: [Int]) throws {\n    let test = TestLinkedList(value: initialValue).addMany(values: values)\n    let result = program.reverseLinkedList(test) as! TestLinkedList\n    let expected = TestLinkedList(value: reversedInitialValue).addMany(values: reversedValues)\n    try assertEqual(expected.getNodesInArray(), result.getNodesInArray())\n  }\n}\n\nclass TestLinkedList: Program.LinkedList {\n  func addMany(values: [Int]) -> TestLinkedList {\n    var current: Program.LinkedList? = self\n\n    while current?.next != nil {\n      current = current?.next\n    }\n\n    for value in values {\n      current?.next = TestLinkedList(value: value)\n      current = current?.next\n    }\n    return self\n  }\n\n  func getNodesInArray() -> [Int] {\n    var nodes = [Int]()\n    var current: Program.LinkedList? = self\n\n    while current != nil {\n      if let value = current?.value {\n        nodes.append(value)\n      }\n      current = current?.next\n    }\n\n    return nodes\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  let program = Program()\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      try testReverseLinkedList(initialValue: 0, values: [1, 2, 3, 4, 5], reversedInitialValue: 5, reversedValues: [4, 3, 2, 1, 0])\n    }\n  }\n\n  func testReverseLinkedList(initialValue: Int, values: [Int], reversedInitialValue: Int, reversedValues: [Int]) throws {\n    let test = TestLinkedList(value: initialValue).addMany(values: values)\n    let result = program.reverseLinkedList(test) as! TestLinkedList\n    let expected = TestLinkedList(value: reversedInitialValue).addMany(values: reversedValues)\n    try assertEqual(expected.getNodesInArray(), result.getNodesInArray())\n  }\n}\n\nclass TestLinkedList: Program.LinkedList {\n  func addMany(values: [Int]) -> TestLinkedList {\n    var current: Program.LinkedList? = self\n\n    while current?.next != nil {\n      current = current?.next\n    }\n\n    for value in values {\n      current?.next = TestLinkedList(value: value)\n      current = current?.next\n    }\n    return self\n  }\n\n  func getNodesInArray() -> [Int] {\n    var nodes = [Int]()\n    var current: Program.LinkedList? = self\n\n    while current != nil {\n      if let value = current?.value {\n        nodes.append(value)\n      }\n      current = current?.next\n    }\n\n    return nodes\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nexport function reverseLinkedList(head: LinkedList) {\n  // Write your code here.\n  return head;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nexport function reverseLinkedList(head: LinkedList) {\n  let previousNode: LinkedList | null = null;\n  let currentNode: LinkedList | null = head;\n  while (currentNode !== null) {\n    const nextNode: LinkedList | null = currentNode.next;\n    currentNode.next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode!;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\ntype LinkedList = program.LinkedList;\nconst {LinkedList} = program;\n\nit('Test Case #1', function () {\n  const test = addMany(new LinkedList(0), [1, 2, 3, 4, 5]);\n  const result = getNodesInArray(program.reverseLinkedList(test));\n  const expected = getNodesInArray(addMany(new LinkedList(5), [4, 3, 2, 1, 0]));\n  chai.expect(result).to.deep.equal(expected);\n});\n\nfunction addMany(linkedList: LinkedList, values: number[]) {\n  let current = linkedList;\n  while (current.next !== null) {\n    current = current.next;\n  }\n  for (const value of values) {\n    current.next = new LinkedList(value);\n    current = current.next;\n  }\n  return linkedList;\n}\n\nfunction getNodesInArray(linkedList: LinkedList) {\n  const nodes: number[] = [];\n  let current: LinkedList | null = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\ntype LinkedList = program.LinkedList;\nconst {LinkedList} = program;\n\nit('Test Case #1', function () {\n  const test = addMany(new LinkedList(0), [1, 2, 3, 4, 5]);\n  const result = getNodesInArray(program.reverseLinkedList(test));\n  const expected = getNodesInArray(addMany(new LinkedList(5), [4, 3, 2, 1, 0]));\n  chai.expect(result).to.deep.equal(expected);\n});\n\nfunction addMany(linkedList: LinkedList, values: number[]) {\n  let current = linkedList;\n  while (current.next !== null) {\n    current = current.next;\n  }\n  for (const value of values) {\n    current.next = new LinkedList(value);\n    current = current.next;\n  }\n  return linkedList;\n}\n\nfunction getNodesInArray(linkedList: LinkedList) {\n  const nodes: number[] = [];\n  let current: LinkedList | null = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n"
    }
  },
  "customInputVars": [
    {
      "name": "linkedList",
      "example": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": null,
            "value": 5
          }
        ]
      },
      "schema": {
        "description": "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
        "properties": {
          "head": {
            "type": "string"
          },
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "next": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "next"
              ],
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "head",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": null,
            "value": 5
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": null,
            "value": 0
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": null,
            "value": 3
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": null,
            "value": 6
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": "10",
            "value": 9
          },
          {
            "id": "10",
            "next": "11",
            "value": 10
          },
          {
            "id": "11",
            "next": "12",
            "value": 11
          },
          {
            "id": "12",
            "next": null,
            "value": 12
          }
        ]
      }
    }
  ],
  "jsonTests": [
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": null,
            "value": 5
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": null,
            "value": 0
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": null,
            "value": 3
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": null,
            "value": 6
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": "10",
            "value": 9
          },
          {
            "id": "10",
            "next": "11",
            "value": 10
          },
          {
            "id": "11",
            "next": "12",
            "value": 11
          },
          {
            "id": "12",
            "next": null,
            "value": 12
          }
        ]
      }
    }
  ],
  "changelog": []
}