{
  "uid": "right-smaller-than",
  "testStrategy": "JSON",
  "name": "Right Smaller Than",
  "version": 0,
  "releaseDate": "2020-05-11T00:00:00Z",
  "category": "Binary Search Trees",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 7931,
    "failureCount": 2452
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "414980226",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1894
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in an array of integers and returns an array of\n  the same length, where each element in the output array corresponds to the\n  number of integers in the input array that are to the right of the relevant\n  index and that are strictly smaller than the integer at that index.\n</p>\n<p>\n  In other words, the value at <span>output[i]</span> represents the number of\n  integers that are to the right of <span>i</span> and that are strictly smaller\n  than <span>input[i]</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">array</span> = [8, 5, 11, -1, 3, 4, 2]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[5, 4, 4, 0, 1, 1, 0]\n<span class=\"CodeEditor-promptComment\">// There are 5 integers smaller than 8 to the right of it.</span>\n<span class=\"CodeEditor-promptComment\">// There are 4 integers smaller than 5 to the right of it.</span>\n<span class=\"CodeEditor-promptComment\">// There are 4 integers smaller than 11 to the right of it.</span>\n<span class=\"CodeEditor-promptComment\">// Etc..</span>\n</pre>\n</div>",
  "hints": [
    "<p>\nThe naive solution to this problem involves a simple pair of nested for loops and runs in O(n^2) time, where n is the length of the input array. This problem doesn't seem like it can be solved in linear time, so what time complexity could we realistically achieve if we somehow optimized our algorithm?\n</p>\n",
    "\n<p>\nThe only better time complexity than the O(n^2) one of our naive solution that we could realistically achieve would be an O(nlog(n)) complexity. What data structure has log(n) operations, and how could it help for this problem?\n</p>\n",
    "\n<p>\nA Binary Search Tree supports log(n) insertions and has the relevant property of every left-subtree-node having a smaller value than a given node's value; can we construct a BST from the input array in such a way that it leads us to the result array that we're looking for?\n</p>\n",
    "\n<p>\nConstruct a BST by inserting the input array's integers one by one, in reverse order (from right to left). At each insertion, once a new BST node is positioned in the BST, the number of nodes in its parent node's left subtree (plus the parent node itself, if its value is smaller than the inserted node's value) is the number of \"right-smaller-than\" elements for the element being inserted.\n</p>\n",
    "\n<p>\nGoing off of Hint #4, you can construct a special type of BST that stores the size of every node's left subtree. This value can then be used to obtain the right-smaller-than numbers for every element in the array.\n</p>"
  ],
  "spaceTime": "Average case: when the created BST is balanced\nO(nlog(n)) time | O(n) space - where n is the length of the array\n---\nWorst case: when the created BST is like a linked list\nO(n^2) time | O(n) space",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\nvector<int> rightSmallerThan(vector<int> array) {\n  // Write your code here.\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// O(n^2) time | O(n) space - where n is the length of the array\nvector<int> rightSmallerThan(vector<int> array) {\n  vector<int> rightSmallerCounts = {};\n  for (int i = 0; i < array.size(); i++) {\n    int rightSmallerCount = 0;\n    for (int j = i + 1; j < array.size(); j++) {\n      if (array[j] < array[i]) rightSmallerCount++;\n    }\n    rightSmallerCounts.push_back(rightSmallerCount);\n  }\n  return rightSmallerCounts;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\nclass SpecialBST {\n public:\n  int value;\n  int idx;\n  int numSmallerAtInsertTime;\n  int leftSubtreeSize;\n  SpecialBST* left;\n  SpecialBST* right;\n\n  SpecialBST(int value, int idx, int numSmallerAtInsertTime) {\n    this->value = value;\n    this->idx = idx;\n    this->numSmallerAtInsertTime = numSmallerAtInsertTime;\n    leftSubtreeSize = 0;\n    left = nullptr;\n    right = nullptr;\n  }\n\n  void insert(int value, int idx, int numSmallerAtInsertTime = 0) {\n    if (value < this->value) {\n      leftSubtreeSize++;\n      if (left == nullptr) {\n        left = new SpecialBST(value, idx, numSmallerAtInsertTime);\n      } else {\n        left->insert(value, idx, numSmallerAtInsertTime);\n      }\n    } else {\n      numSmallerAtInsertTime += leftSubtreeSize;\n      if (value > this->value) numSmallerAtInsertTime++;\n      if (right == nullptr) {\n        right = new SpecialBST(value, idx, numSmallerAtInsertTime);\n      } else {\n        right->insert(value, idx, numSmallerAtInsertTime);\n      }\n    }\n  }\n};\n\nvoid getRightSmallerCounts(SpecialBST* bst, vector<int>& rightSmallerCounts);\n\n// Average case: when the created BST is balanced\n// O(nlog(n)) time | O(n) space - where n is the length of the array\n// ---\n// Worst case: when the created BST is like a linked list\n// O(n^2) time | O(n) space\nvector<int> rightSmallerThan(vector<int> array) {\n  if (array.size() == 0) return {};\n\n  int lastIdx = array.size() - 1;\n  SpecialBST* bst = new SpecialBST(array[lastIdx], lastIdx, 0);\n  for (int i = array.size() - 2; i >= 0; i--) {\n    bst->insert(array[i], i);\n  }\n\n  vector<int> rightSmallerCounts = array;\n  getRightSmallerCounts(bst, rightSmallerCounts);\n  return rightSmallerCounts;\n}\n\nvoid getRightSmallerCounts(SpecialBST* bst, vector<int>& rightSmallerCounts) {\n  if (bst == nullptr) return;\n  rightSmallerCounts[bst->idx] = bst->numSmallerAtInsertTime;\n  getRightSmallerCounts(bst->left, rightSmallerCounts);\n  getRightSmallerCounts(bst->right, rightSmallerCounts);\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\nclass SpecialBST {\n public:\n  int value;\n  int leftSubtreeSize;\n  SpecialBST* left;\n  SpecialBST* right;\n\n  SpecialBST(int value) {\n    this->value = value;\n    leftSubtreeSize = 0;\n    left = nullptr;\n    right = nullptr;\n  }\n\n  void insert(\n    int value,\n    int idx,\n    vector<int>& rightSmallerCounts,\n    int numSmallerAtInsertTime = 0\n  ) {\n    if (value < this->value) {\n      leftSubtreeSize++;\n      if (left == nullptr) {\n        left = new SpecialBST(value);\n        rightSmallerCounts[idx] = numSmallerAtInsertTime;\n      } else {\n        left->insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime);\n      }\n    } else {\n      numSmallerAtInsertTime += leftSubtreeSize;\n      if (value > this->value) numSmallerAtInsertTime++;\n      if (right == nullptr) {\n        right = new SpecialBST(value);\n        rightSmallerCounts[idx] = numSmallerAtInsertTime;\n      } else {\n        right->insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime);\n      }\n    }\n  }\n};\n\n// Average case: when the created BST is balanced\n// O(nlog(n)) time | O(n) space - where n is the length of the array\n// ---\n// Worst case: when the created BST is like a linked list\n// O(n^2) time | O(n) space\nvector<int> rightSmallerThan(vector<int> array) {\n  if (array.size() == 0) return {};\n\n  vector<int> rightSmallerCounts = array;\n  int lastIdx = array.size() - 1;\n  SpecialBST* bst = new SpecialBST(array[lastIdx]);\n  rightSmallerCounts[lastIdx] = 0;\n  for (int i = array.size() - 2; i >= 0; i--) {\n    bst->insert(array[i], i, rightSmallerCounts);\n  }\n\n  return rightSmallerCounts;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include \"program.cpp\"\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<int> array = {8, 5, 11, -1, 3, 4, 2};\n      vector<int> expected{5, 4, 4, 0, 1, 1, 0};\n      auto actual = rightSmallerThan(array);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "#include \"program.cpp\"\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<int> array = {8, 5, 11, -1, 3, 4, 2};\n      vector<int> expected{5, 4, 4, 0, 1, 1, 0};\n      auto actual = rightSmallerThan(array);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n  public static List<int> RightSmallerThan(List<int> array) {\n    // Write your code here.\n    return new List<int>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(n^2) time | O(n) space - where n is the length of the array\n  public static List<int> RightSmallerThan(List<int> array) {\n    List<int> rightSmallerCounts = new List<int>();\n    for (int i = 0; i < array.Count; i++) {\n      int rightSmallerCount = 0;\n      for (int j = i + 1; j < array.Count; j++) {\n        if (array[j] < array[i]) {\n          rightSmallerCount++;\n        }\n      }\n      rightSmallerCounts.Add(rightSmallerCount);\n    }\n    return rightSmallerCounts;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  // Average case: when the created BST is balanced\n  // O(nlog(n)) time | O(n) space - where n is the length of the array\n  // ---\n  // Worst case: when the created BST is like a linked list\n  // O(n^2) time | O(n) space\n  public static List<int> RightSmallerThan(List<int> array) {\n    if (array.Count == 0) return new List<int>();\n\n    int lastIdx = array.Count - 1;\n    SpecialBST bst = new SpecialBST(array[lastIdx], lastIdx, 0);\n    for (int i = array.Count - 2; i >= 0; i--) {\n      bst.insert(array[i], i);\n    }\n\n    List<int> rightSmallerCounts = new List<int>(array);\n    getRightSmallerCounts(bst, rightSmallerCounts);\n    return rightSmallerCounts;\n  }\n\n  public static void getRightSmallerCounts(\n    SpecialBST bst, List<int> rightSmallerCounts\n  ) {\n    if (bst == null) return;\n    rightSmallerCounts[bst.idx] = bst.numSmallerAtInsertTime;\n    getRightSmallerCounts(bst.left, rightSmallerCounts);\n    getRightSmallerCounts(bst.right, rightSmallerCounts);\n  }\n\n  public class SpecialBST {\n    public int value;\n    public int idx;\n    public int numSmallerAtInsertTime;\n    public int leftSubtreeSize;\n    public SpecialBST left;\n    public SpecialBST right;\n\n    public SpecialBST(int value, int idx, int numSmallerAtInsertTime) {\n      this.value = value;\n      this.idx = idx;\n      this.numSmallerAtInsertTime = numSmallerAtInsertTime;\n      leftSubtreeSize = 0;\n      left = null;\n      right = null;\n    }\n\n    public void insert(int value, int idx) {\n      insertHelper(value, idx, 0);\n    }\n\n    public void insertHelper(int value, int idx, int numSmallerAtInsertTime) {\n      if (value < this.value) {\n        leftSubtreeSize++;\n        if (left == null) {\n          left = new SpecialBST(value, idx, numSmallerAtInsertTime);\n        } else {\n          left.insertHelper(value, idx, numSmallerAtInsertTime);\n        }\n      } else {\n        numSmallerAtInsertTime += leftSubtreeSize;\n        if (value > this.value) numSmallerAtInsertTime++;\n        if (right == null) {\n          right = new SpecialBST(value, idx, numSmallerAtInsertTime);\n        } else {\n          right.insertHelper(value, idx, numSmallerAtInsertTime);\n        }\n      }\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  // Average case: when the created BST is balanced\n  // O(nlog(n)) time | O(n) space - where n is the length of the array\n  // ---\n  // Worst case: when the created BST is like a linked list\n  // O(n^2) time | O(n) space\n  public static List<int> RightSmallerThan(List<int> array) {\n    if (array.Count == 0) return new List<int>();\n\n    List<int> rightSmallerCounts = new List<int>(array);\n    int lastIdx = array.Count - 1;\n    SpecialBST bst = new SpecialBST(array[lastIdx]);\n    rightSmallerCounts[lastIdx] = 0;\n    for (int i = array.Count - 2; i >= 0; i--) {\n      bst.insert(array[i], i, rightSmallerCounts);\n    }\n    return rightSmallerCounts;\n  }\n\n  public class SpecialBST {\n    public int value;\n    public int leftSubtreeSize;\n    public SpecialBST left;\n    public SpecialBST right;\n\n    public SpecialBST(int value) {\n      this.value = value;\n      leftSubtreeSize = 0;\n      left = null;\n      right = null;\n    }\n\n    public void insert(int value, int idx, List<int> rightSmallerCounts) {\n      insertHelper(value, idx, rightSmallerCounts, 0);\n    }\n\n    public void insertHelper(\n      int value,\n      int idx,\n      List<int> rightSmallerCounts,\n      int numSmallerAtInsertTime\n    ) {\n      if (value < this.value) {\n        leftSubtreeSize++;\n        if (left == null) {\n          left = new SpecialBST(value);\n          rightSmallerCounts[idx] = numSmallerAtInsertTime;\n        } else {\n          left.insertHelper(\n            value, idx, rightSmallerCounts, numSmallerAtInsertTime\n          );\n        }\n      } else {\n        numSmallerAtInsertTime += leftSubtreeSize;\n        if (value > this.value) numSmallerAtInsertTime++;\n        if (right == null) {\n          right = new SpecialBST(value);\n          rightSmallerCounts[idx] = numSmallerAtInsertTime;\n        } else {\n          right.insertHelper(\n            value, idx, rightSmallerCounts, numSmallerAtInsertTime\n          );\n        }\n      }\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    List<int> array = new List<int> { 8, 5, 11, -1, 3, 4, 2 };\n    List<int> expected = new List<int> { 5, 4, 4, 0, 1, 1, 0 };\n    var actual = Program.RightSmallerThan(array);\n    Utils.AssertTrue(Enumerable.SequenceEqual(expected, actual));\n  }\n}\n",
      "unitTests": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    List<int> array = new List<int> { 8, 5, 11, -1, 3, 4, 2 };\n    List<int> expected = new List<int> { 5, 4, 4, 0, 1, 1, 0 };\n    var actual = Program.RightSmallerThan(array);\n    Utils.AssertTrue(Enumerable.SequenceEqual(expected, actual));\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc RightSmallerThan(array []int) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n^2) time | O(n) space - where n is the length of the array\nfunc RightSmallerThan(array []int) []int {\n\trightSmallerCounts := []int{}\n\tfor i := 0; i < len(array); i++ {\n\t\trightSmallerCount := 0\n\t\tfor j := i + 1; j < len(array); j++ {\n\t\t\tif array[j] < array[i] {\n\t\t\t\trightSmallerCount += 1\n\t\t\t}\n\t\t}\n\t\trightSmallerCounts = append(rightSmallerCounts, rightSmallerCount)\n\t}\n\treturn rightSmallerCounts\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// Average case: when the created BST is balanced\n// O(nlog(n)) time | O(n) space - where n is the length of the array\n// ---\n// Worst case: when the created BST is like a linked list\n// O(n^2) time | O(n) space\nfunc RightSmallerThan(array []int) []int {\n\tif len(array) == 0 {\n\t\treturn []int{}\n\t}\n\n\tlastIdx := len(array) - 1\n\tbst := NewSpecialBST(array[lastIdx], lastIdx, 0)\n\tfor i := lastIdx - 1; i >= 0; i-- {\n\t\tbst.Insert(array[i], i)\n\t}\n\n\trightSmallerCounts := make([]int, 0, len(array))\n\tfor _, i := range array {\n\t\trightSmallerCounts = append(rightSmallerCounts, i)\n\t}\n\tgetRightSmallerCounts(bst, rightSmallerCounts)\n\treturn rightSmallerCounts\n}\n\nfunc getRightSmallerCounts(bst *SpecialBST, rightSmallerCounts []int) {\n\tif bst == nil {\n\t\treturn\n\t}\n\trightSmallerCounts[bst.Idx] = bst.NumSmallerAtInsertTime\n\tgetRightSmallerCounts(bst.Left, rightSmallerCounts)\n\tgetRightSmallerCounts(bst.Right, rightSmallerCounts)\n}\n\ntype SpecialBST struct {\n\tValue                  int\n\tIdx                    int\n\tNumSmallerAtInsertTime int\n\tLeftSubtreeSize        int\n\n\tLeft  *SpecialBST\n\tRight *SpecialBST\n}\n\nfunc NewSpecialBST(value int, idx int, numSmallerAtInsertTime int) *SpecialBST {\n\treturn &SpecialBST{\n\t\tValue:                  value,\n\t\tIdx:                    idx,\n\t\tNumSmallerAtInsertTime: numSmallerAtInsertTime,\n\t\tLeftSubtreeSize:        0,\n\t\tLeft:                   nil,\n\t\tRight:                  nil,\n\t}\n}\n\nfunc (bst *SpecialBST) Insert(value, idx int) {\n\tbst.insert(value, idx, 0)\n}\n\nfunc (bst *SpecialBST) insert(value, idx, numSmallerAtInsertTime int) {\n\tif value < bst.Value {\n\t\tbst.LeftSubtreeSize += 1\n\t\tif bst.Left == nil {\n\t\t\tbst.Left = NewSpecialBST(value, idx, numSmallerAtInsertTime)\n\t\t} else {\n\t\t\tbst.Left.insert(value, idx, numSmallerAtInsertTime)\n\t\t}\n\t\treturn\n\t}\n\tnumSmallerAtInsertTime += bst.LeftSubtreeSize\n\tif value > bst.Value {\n\t\tnumSmallerAtInsertTime += 1\n\t}\n\n\tif bst.Right == nil {\n\t\tbst.Right = NewSpecialBST(value, idx, numSmallerAtInsertTime)\n\t} else {\n\t\tbst.Right.insert(value, idx, numSmallerAtInsertTime)\n\t}\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// Average case: when the created BST is balanced\n// O(nlog(n)) time | O(n) space - where n is the length of the array\n// ---\n// Worst case: when the created BST is like a linked list\n// O(n^2) time | O(n) space\nfunc RightSmallerThan(array []int) []int {\n\tif len(array) == 0 {\n\t\treturn []int{}\n\t}\n\n\trightSmallerCounts := make([]int, 0, len(array))\n\tfor _, i := range array {\n\t\trightSmallerCounts = append(rightSmallerCounts, i)\n\t}\n\tlastIdx := len(array) - 1\n\tbst := NewSpecialBST(array[lastIdx])\n\trightSmallerCounts[lastIdx] = 0\n\tfor i := lastIdx - 1; i >= 0; i-- {\n\t\tbst.Insert(array[i], i, rightSmallerCounts)\n\t}\n\treturn rightSmallerCounts\n}\n\ntype SpecialBST struct {\n\tValue           int\n\tLeftSubtreeSize int\n\n\tLeft  *SpecialBST\n\tRight *SpecialBST\n}\n\nfunc NewSpecialBST(value int) *SpecialBST {\n\treturn &SpecialBST{\n\t\tValue:           value,\n\t\tLeftSubtreeSize: 0,\n\t\tLeft:            nil,\n\t\tRight:           nil,\n\t}\n}\n\nfunc (bst *SpecialBST) Insert(value, idx int, rightSmallerCounts []int) {\n\tbst.insert(value, idx, rightSmallerCounts, 0)\n}\n\nfunc (bst *SpecialBST) insert(value, idx int, rightSmallerCounts []int, numSmallerAtInsertTime int) {\n\tif value < bst.Value {\n\t\tbst.LeftSubtreeSize += 1\n\t\tif bst.Left == nil {\n\t\t\tbst.Left = NewSpecialBST(value)\n\t\t\trightSmallerCounts[idx] = numSmallerAtInsertTime\n\t\t} else {\n\t\t\tbst.Left.insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime)\n\t\t}\n\t\treturn\n\t}\n\n\tnumSmallerAtInsertTime += bst.LeftSubtreeSize\n\tif value > bst.Value {\n\t\tnumSmallerAtInsertTime += 1\n\t}\n\n\tif bst.Right == nil {\n\t\tbst.Right = NewSpecialBST(value)\n\t\trightSmallerCounts[idx] = numSmallerAtInsertTime\n\t} else {\n\t\tbst.Right.insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime)\n\t}\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tarray := []int{8, 5, 11, -1, 3, 4, 2}\n\texpected := []int{5, 4, 4, 0, 1, 1, 0}\n\tactual := RightSmallerThan(array)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tarray := []int{8, 5, 11, -1, 3, 4, 2}\n\texpected := []int{5, 4, 4, 0, 1, 1, 0}\n\tactual := RightSmallerThan(array)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static List<Integer> rightSmallerThan(List<Integer> array) {\n    // Write your code here.\n    return new ArrayList<Integer>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n^2) time | O(n) space - where n is the length of the array\n  public static List<Integer> rightSmallerThan(List<Integer> array) {\n    List<Integer> rightSmallerCounts = new ArrayList<Integer>();\n    for (int i = 0; i < array.size(); i++) {\n      int rightSmallerCount = 0;\n      for (int j = i + 1; j < array.size(); j++) {\n        if (array.get(j) < array.get(i)) {\n          rightSmallerCount++;\n        }\n      }\n      rightSmallerCounts.add(rightSmallerCount);\n    }\n    return rightSmallerCounts;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // Average case: when the created BST is balanced\n  // O(nlog(n)) time | O(n) space - where n is the length of the array\n  // ---\n  // Worst case: when the created BST is like a linked list\n  // O(n^2) time | O(n) space\n  public static List<Integer> rightSmallerThan(List<Integer> array) {\n    if (array.size() == 0) return new ArrayList<Integer>();\n\n    int lastIdx = array.size() - 1;\n    SpecialBST bst = new SpecialBST(array.get(lastIdx), lastIdx, 0);\n    for (int i = array.size() - 2; i >= 0; i--) {\n      bst.insert(array.get(i), i);\n    }\n\n    List<Integer> rightSmallerCounts = new ArrayList<Integer>(array);\n    getRightSmallerCounts(bst, rightSmallerCounts);\n    return rightSmallerCounts;\n  }\n\n  public static void getRightSmallerCounts(\n    SpecialBST bst, List<Integer> rightSmallerCounts\n  ) {\n    if (bst == null) return;\n    rightSmallerCounts.set(bst.idx, bst.numSmallerAtInsertTime);\n    getRightSmallerCounts(bst.left, rightSmallerCounts);\n    getRightSmallerCounts(bst.right, rightSmallerCounts);\n  }\n\n  static class SpecialBST {\n    public int value;\n    public int idx;\n    public int numSmallerAtInsertTime;\n    public int leftSubtreeSize;\n    public SpecialBST left;\n    public SpecialBST right;\n\n    public SpecialBST(int value, int idx, int numSmallerAtInsertTime) {\n      this.value = value;\n      this.idx = idx;\n      this.numSmallerAtInsertTime = numSmallerAtInsertTime;\n      leftSubtreeSize = 0;\n      left = null;\n      right = null;\n    }\n\n    public void insert(int value, int idx) {\n      insertHelper(value, idx, 0);\n    }\n\n    public void insertHelper(int value, int idx, int numSmallerAtInsertTime) {\n      if (value < this.value) {\n        leftSubtreeSize++;\n        if (left == null) {\n          left = new SpecialBST(value, idx, numSmallerAtInsertTime);\n        } else {\n          left.insertHelper(value, idx, numSmallerAtInsertTime);\n        }\n      } else {\n        numSmallerAtInsertTime += leftSubtreeSize;\n        if (value > this.value) numSmallerAtInsertTime++;\n        if (right == null) {\n          right = new SpecialBST(value, idx, numSmallerAtInsertTime);\n        } else {\n          right.insertHelper(value, idx, numSmallerAtInsertTime);\n        }\n      }\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // Average case: when the created BST is balanced\n  // O(nlog(n)) time | O(n) space - where n is the length of the array\n  // ---\n  // Worst case: when the created BST is like a linked list\n  // O(n^2) time | O(n) space\n  public static List<Integer> rightSmallerThan(List<Integer> array) {\n    if (array.size() == 0) return new ArrayList<Integer>();\n\n    List<Integer> rightSmallerCounts = new ArrayList<Integer>(array);\n    int lastIdx = array.size() - 1;\n    SpecialBST bst = new SpecialBST(array.get(lastIdx));\n    rightSmallerCounts.set(lastIdx, 0);\n    for (int i = array.size() - 2; i >= 0; i--) {\n      bst.insert(array.get(i), i, rightSmallerCounts);\n    }\n    return rightSmallerCounts;\n  }\n\n  static class SpecialBST {\n    public int value;\n    public int leftSubtreeSize;\n    public SpecialBST left;\n    public SpecialBST right;\n\n    public SpecialBST(int value) {\n      this.value = value;\n      leftSubtreeSize = 0;\n      left = null;\n      right = null;\n    }\n\n    public void insert(int value, int idx, List<Integer> rightSmallerCounts) {\n      insertHelper(value, idx, rightSmallerCounts, 0);\n    }\n\n    public void insertHelper(\n      int value,\n      int idx,\n      List<Integer> rightSmallerCounts,\n      int numSmallerAtInsertTime\n    ) {\n      if (value < this.value) {\n        leftSubtreeSize++;\n        if (left == null) {\n          left = new SpecialBST(value);\n          rightSmallerCounts.set(idx, numSmallerAtInsertTime);\n        } else {\n          left.insertHelper(\n            value, idx, rightSmallerCounts, numSmallerAtInsertTime\n          );\n        }\n      } else {\n        numSmallerAtInsertTime += leftSubtreeSize;\n        if (value > this.value) numSmallerAtInsertTime++;\n        if (right == null) {\n          right = new SpecialBST(value);\n          rightSmallerCounts.set(idx, numSmallerAtInsertTime);\n        } else {\n          right.insertHelper(\n            value, idx, rightSmallerCounts, numSmallerAtInsertTime\n          );\n        }\n      }\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var array = Arrays.asList(8, 5, 11, -1, 3, 4, 2);\n    var expected = Arrays.asList(5, 4, 4, 0, 1, 1, 0);\n    var actual = Program.rightSmallerThan(array);\n    Utils.assertTrue(expected.equals(actual));\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var array = Arrays.asList(8, 5, 11, -1, 3, 4, 2);\n    var expected = Arrays.asList(5, 4, 4, 0, 1, 1, 0);\n    var actual = Program.rightSmallerThan(array);\n    Utils.assertTrue(expected.equals(actual));\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function rightSmallerThan(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.rightSmallerThan = rightSmallerThan;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space - where n is the length of the array\nfunction rightSmallerThan(array) {\n  const rightSmallerCounts = [];\n  for (let i = 0; i < array.length; i++) {\n    let rightSmallerCount = 0;\n    for (let j = i + 1; j < array.length; j++) {\n      if (array[j] < array[i]) rightSmallerCount++;\n    }\n    rightSmallerCounts.push(rightSmallerCount);\n  }\n  return rightSmallerCounts;\n}\n\nexports.rightSmallerThan = rightSmallerThan;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// Average case: when the created BST is balanced\n// O(nlog(n)) time | O(n) space - where n is the length of the array\n// ---\n// Worst case: when the created BST is like a linked list\n// O(n^2) time | O(n) space\nfunction rightSmallerThan(array) {\n  if (array.length === 0) return [];\n\n  const lastIdx = array.length - 1;\n  const bst = new SpecialBST(array[lastIdx], lastIdx, 0);\n  for (let i = array.length - 2; i >= 0; i--) {\n    bst.insert(array[i], i);\n  }\n\n  const rightSmallerCounts = array.slice();\n  getRightSmallerCounts(bst, rightSmallerCounts);\n  return rightSmallerCounts;\n}\n\nfunction getRightSmallerCounts(bst, rightSmallerCounts) {\n  if (bst === null) return;\n  rightSmallerCounts[bst.idx] = bst.numSmallerAtInsertTime;\n  getRightSmallerCounts(bst.left, rightSmallerCounts);\n  getRightSmallerCounts(bst.right, rightSmallerCounts);\n}\n\nclass SpecialBST {\n  constructor(value, idx, numSmallerAtInsertTime) {\n    this.value = value;\n    this.idx = idx;\n    this.numSmallerAtInsertTime = numSmallerAtInsertTime;\n    this.leftSubtreeSize = 0;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(value, idx, numSmallerAtInsertTime = 0) {\n    if (value < this.value) {\n      this.leftSubtreeSize++;\n      if (this.left === null) {\n        this.left = new SpecialBST(value, idx, numSmallerAtInsertTime);\n      } else {\n        this.left.insert(value, idx, numSmallerAtInsertTime);\n      }\n    } else {\n      numSmallerAtInsertTime += this.leftSubtreeSize;\n      if (value > this.value) numSmallerAtInsertTime++;\n      if (this.right === null) {\n        this.right = new SpecialBST(value, idx, numSmallerAtInsertTime);\n      } else {\n        this.right.insert(value, idx, numSmallerAtInsertTime);\n      }\n    }\n  }\n}\n\nexports.rightSmallerThan = rightSmallerThan;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// Average case: when the created BST is balanced\n// O(nlog(n)) time | O(n) space - where n is the length of the array\n// ---\n// Worst case: when the created BST is like a linked list\n// O(n^2) time | O(n) space\nfunction rightSmallerThan(array) {\n  if (array.length === 0) return [];\n\n  const rightSmallerCounts = array.slice();\n  const lastIdx = array.length - 1;\n  const bst = new SpecialBST(array[lastIdx]);\n  rightSmallerCounts[lastIdx] = 0;\n  for (let i = array.length - 2; i >= 0; i--) {\n    bst.insert(array[i], i, rightSmallerCounts);\n  }\n\n  return rightSmallerCounts;\n}\n\nclass SpecialBST {\n  constructor(value) {\n    this.value = value;\n    this.leftSubTreeSize = 0;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime = 0) {\n    if (value < this.value) {\n      this.leftSubTreeSize++;\n      if (this.left === null) {\n        this.left = new SpecialBST(value);\n        rightSmallerCounts[idx] = numSmallerAtInsertTime;\n      } else {\n        this.left.insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime);\n      }\n    } else {\n      numSmallerAtInsertTime += this.leftSubTreeSize;\n      if (value > this.value) numSmallerAtInsertTime++;\n      if (this.right === null) {\n        this.right = new SpecialBST(value);\n        rightSmallerCounts[idx] = numSmallerAtInsertTime;\n      } else {\n        this.right.insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime);\n      }\n    }\n  }\n}\n\nexports.rightSmallerThan = rightSmallerThan;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [8, 5, 11, -1, 3, 4, 2];\n  const expected = [5, 4, 4, 0, 1, 1, 0];\n  const actual = program.rightSmallerThan(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [8, 5, 11, -1, 3, 4, 2];\n  const expected = [5, 4, 4, 0, 1, 1, 0];\n  const actual = program.rightSmallerThan(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun rightSmallerThan(array: List<Int>): List<Int> {\n    // Write your code here.\n    return listOf()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n^2) time | O(n) space - where n is the length of the array\nfun rightSmallerThan(array: List<Int>): List<Int> {\n    val rightSmallerCounts = mutableListOf<Int>()\n    for (i in 0 until array.size) {\n        var rightSmallerCount = 0\n        for (j in i + 1 until array.size) {\n            if (array[j] < array[i]) rightSmallerCount++\n        }\n        rightSmallerCounts.add(rightSmallerCount)\n    }\n    return rightSmallerCounts\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// Average case: when the created BST is balanced\n// O(nlog(n)) time | O(n) space - where n is the size of the array\n// ---\n// Worst case: when the created BST is like a linked list\n// O(n^2) time | O(n) space\nfun rightSmallerThan(array: List<Int>): List<Int> {\n    if (array.size == 0) return listOf()\n\n    val lastIdx = array.size - 1\n    val bst = SpecialBST(array[lastIdx], lastIdx, 0)\n    for (i in array.size - 2 downTo 0) {\n        bst.insert(array[i], i)\n    }\n\n    val rightSmallerCounts = array.toMutableList()\n    getRightSmallerCounts(bst, rightSmallerCounts)\n    return rightSmallerCounts\n}\n\nfun getRightSmallerCounts(bst: SpecialBST?, rightSmallerCounts: MutableList<Int>) {\n    if (bst == null) return\n    rightSmallerCounts[bst.idx] = bst.numSmallerAtInsertTime\n    getRightSmallerCounts(bst.left, rightSmallerCounts)\n    getRightSmallerCounts(bst.right, rightSmallerCounts)\n}\n\nopen class SpecialBST(value: Int, idx: Int, numSmallerAtInsertTime: Int) {\n    var value = value\n    var idx = idx\n    var numSmallerAtInsertTime = numSmallerAtInsertTime\n    var leftSubtreeSize = 0\n    var left: SpecialBST? = null\n    var right: SpecialBST? = null\n\n    fun insert(value: Int, idx: Int, numSmallerAtInsertTime: Int = 0) {\n        if (value < this.value) {\n            this.leftSubtreeSize++\n            if (this.left == null) {\n                this.left = SpecialBST(value, idx, numSmallerAtInsertTime)\n            } else {\n                this.left!!.insert(value, idx, numSmallerAtInsertTime)\n            }\n        } else {\n            var newNumSmallerAtInsertTime = numSmallerAtInsertTime + this.leftSubtreeSize\n            if (value > this.value) newNumSmallerAtInsertTime++\n            if (this.right == null) {\n                this.right = SpecialBST(value, idx, newNumSmallerAtInsertTime)\n            } else {\n                this.right!!.insert(value, idx, newNumSmallerAtInsertTime)\n            }\n        }\n    }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// Average case: when the created BST is balanced\n// O(nlog(n)) time | O(n) space - where n is the size of the array\n// ---\n// Worst case: when the created BST is like a linked list\n// O(n^2) time | O(n) space\nfun rightSmallerThan(array: List<Int>): List<Int> {\n    if (array.size == 0) return listOf()\n\n    val rightSmallerCounts = array.toMutableList()\n    val lastIdx = array.size - 1\n    val bst = SpecialBST(array[lastIdx])\n    rightSmallerCounts[lastIdx] = 0\n    for (i in array.size - 2 downTo 0) {\n        bst.insert(array[i], i, rightSmallerCounts)\n    }\n\n    return rightSmallerCounts\n}\n\nopen class SpecialBST(value: Int) {\n    var value = value\n    var leftSubtreeSize = 0\n    var left: SpecialBST? = null\n    var right: SpecialBST? = null\n\n    fun insert(value: Int, idx: Int, rightSmallerCounts: MutableList<Int>, numSmallerAtInsertTime: Int = 0) {\n        if (value < this.value) {\n            this.leftSubtreeSize++\n            if (this.left == null) {\n                this.left = SpecialBST(value)\n                rightSmallerCounts[idx] = numSmallerAtInsertTime\n            } else {\n                this.left!!.insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime)\n            }\n        } else {\n            var newNumSmallerAtInsertTime = numSmallerAtInsertTime + this.leftSubtreeSize\n            if (value > this.value) newNumSmallerAtInsertTime++\n            if (this.right == null) {\n                this.right = SpecialBST(value)\n                rightSmallerCounts[idx] = newNumSmallerAtInsertTime\n            } else {\n                this.right!!.insert(value, idx, rightSmallerCounts, newNumSmallerAtInsertTime)\n            }\n        }\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.rightSmallerThan as rightSmallerThan\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val array = listOf(8, 5, 11, -1, 3, 4, 2)\n        val expected = listOf(5, 4, 4, 0, 1, 1, 0)\n        val actual = rightSmallerThan(array)\n        assert(actual == expected)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.rightSmallerThan as rightSmallerThan\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val array = listOf(8, 5, 11, -1, 3, 4, 2)\n        val expected = listOf(5, 4, 4, 0, 1, 1, 0)\n        val actual = rightSmallerThan(array)\n        assert(actual == expected)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def rightSmallerThan(array):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n^2) time | O(n) space - where n is the length of the array\ndef rightSmallerThan(array):\n    rightSmallerCounts = []\n    for i in range(len(array)):\n        rightSmallerCount = 0\n        for j in range(i + 1, len(array)):\n            if array[j] < array[i]:\n                rightSmallerCount += 1\n        rightSmallerCounts.append(rightSmallerCount)\n    return rightSmallerCounts\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# Average case: when the created BST is balanced\n# O(nlog(n)) time | O(n) space - where n is the length of the array\n# ---\n# Worst case: when the created BST is like a linked list\n# O(n^2) time | O(n) space\ndef rightSmallerThan(array):\n    if len(array) == 0:\n        return []\n\n    lastIdx = len(array) - 1\n    bst = SpecialBST(array[lastIdx], lastIdx, 0)\n    for i in reversed(range(len(array) - 1)):\n        bst.insert(array[i], i)\n\n    rightSmallerCounts = array[:]\n    getRightSmallerCounts(bst, rightSmallerCounts)\n    return rightSmallerCounts\n\n\ndef getRightSmallerCounts(bst, rightSmallerCounts):\n    if bst is None:\n        return\n    rightSmallerCounts[bst.idx] = bst.numSmallerAtInsertTime\n    getRightSmallerCounts(bst.left, rightSmallerCounts)\n    getRightSmallerCounts(bst.right, rightSmallerCounts)\n\n\nclass SpecialBST:\n    def __init__(self, value, idx, numSmallerAtInsertTime):\n        self.value = value\n        self.idx = idx\n        self.numSmallerAtInsertTime = numSmallerAtInsertTime\n        self.leftSubtreeSize = 0\n        self.left = None\n        self.right = None\n\n    def insert(self, value, idx, numSmallerAtInsertTime=0):\n        if value < self.value:\n            self.leftSubtreeSize += 1\n            if self.left is None:\n                self.left = SpecialBST(value, idx, numSmallerAtInsertTime)\n            else:\n                self.left.insert(value, idx, numSmallerAtInsertTime)\n        else:\n            numSmallerAtInsertTime += self.leftSubtreeSize\n            if value > self.value:\n                numSmallerAtInsertTime += 1\n            if self.right is None:\n                self.right = SpecialBST(value, idx, numSmallerAtInsertTime)\n            else:\n                self.right.insert(value, idx, numSmallerAtInsertTime)\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# Average case: when the created BST is balanced\n# O(nlog(n)) time | O(n) space - where n is the length of the array\n# ---\n# Worst case: when the created BST is like a linked list\n# O(n^2) time | O(n) space\ndef rightSmallerThan(array):\n    if len(array) == 0:\n        return []\n\n    rightSmallerCounts = array[:]\n    lastIdx = len(array) - 1\n    bst = SpecialBST(array[lastIdx])\n    rightSmallerCounts[lastIdx] = 0\n    for i in reversed(range(len(array) - 1)):\n        bst.insert(array[i], i, rightSmallerCounts)\n\n    return rightSmallerCounts\n\n\nclass SpecialBST:\n    def __init__(self, value):\n        self.value = value\n        self.leftSubtreeSize = 0\n        self.left = None\n        self.right = None\n\n    def insert(self, value, idx, rightSmallerCounts, numSmallerAtInsertTime=0):\n        if value < self.value:\n            self.leftSubtreeSize += 1\n            if self.left is None:\n                self.left = SpecialBST(value)\n                rightSmallerCounts[idx] = numSmallerAtInsertTime\n            else:\n                self.left.insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime)\n        else:\n            numSmallerAtInsertTime += self.leftSubtreeSize\n            if value > self.value:\n                numSmallerAtInsertTime += 1\n            if self.right is None:\n                self.right = SpecialBST(value)\n                rightSmallerCounts[idx] = numSmallerAtInsertTime\n            else:\n                self.right.insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime)\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        array = [8, 5, 11, -1, 3, 4, 2]\n        expected = [5, 4, 4, 0, 1, 1, 0]\n        actual = program.rightSmallerThan(array)\n        self.assertEqual(expected, actual)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        array = [8, 5, 11, -1, 3, 4, 2]\n        expected = [5, 4, 4, 0, 1, 1, 0]\n        actual = program.rightSmallerThan(array)\n        self.assertEqual(expected, actual)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def rightSmallerThan(array)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def rightSmallerThan(array)\n    # Write your code here.\n    return []\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def rightSmallerThan(array)\n    # Write your code here.\n    return []\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def rightSmallerThan(array)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.rightSmallerThan\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.rightSmallerThan\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  static func rightSmallerThan(_ array: [Int]) -> [Int] {\n    // Write your code here.\n    return [Int]()\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^2) time | O(n) space - where n is the length of the array\n  static func rightSmallerThan(_ array: [Int]) -> [Int] {\n    var rightSmallerCounts = [Int]()\n    for i in 0 ..< array.count {\n      var rightSmallerCount = 0\n      for j in i + 1 ..< array.count {\n        if array[j] < array[i] {\n          rightSmallerCount += 1\n        }\n      }\n      rightSmallerCounts.append(rightSmallerCount)\n    }\n    return rightSmallerCounts\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Average case: when the created BST is balanced\n  // O(nlog(n)) time | O(n) space - where n is the length of the array\n  // ---\n  // Worst case: when the created BST is like a linked list\n  // O(n^2) time | O(n) space\n  static func rightSmallerThan(_ array: [Int]) -> [Int] {\n    if array.count == 0 {\n      return [Int]()\n    }\n\n    let lastIdx = array.count - 1\n    var bst = SpecialBST(array[lastIdx], lastIdx, 0)\n    for i in (0 ..< lastIdx).reversed() {\n      bst.insert(array[i], i)\n    }\n\n    var rightSmallerCounts = [Int]()\n    for i in array {\n      rightSmallerCounts.append(i)\n    }\n    getRightSmallerCounts(bst, &rightSmallerCounts)\n    return rightSmallerCounts\n  }\n\n  static func getRightSmallerCounts(_ bst: SpecialBST?, _ rightSmallerCounts: inout [Int]) {\n    if let tree = bst {\n      rightSmallerCounts[tree.idx] = tree.numSmallerAtInsertTime\n      getRightSmallerCounts(tree.left, &rightSmallerCounts)\n      getRightSmallerCounts(tree.right, &rightSmallerCounts)\n    }\n  }\n\n  class SpecialBST {\n    var value: Int\n    var idx: Int\n    var numSmallerAtInsertTime: Int\n\n    var leftSubtreeSize: Int = 0\n    var left: SpecialBST?\n    var right: SpecialBST?\n\n    init(_ value: Int, _ idx: Int, _ numSmallerAtInsertTime: Int) {\n      self.value = value\n      self.idx = idx\n      self.numSmallerAtInsertTime = numSmallerAtInsertTime\n    }\n\n    func insert(_ value: Int, _ idx: Int, _ numSmallerAtInsertTime: Int = 0) {\n      if value < self.value {\n        leftSubtreeSize += 1\n        if let left = self.left {\n          left.insert(value, idx, numSmallerAtInsertTime)\n        } else {\n          left = SpecialBST(value, idx, numSmallerAtInsertTime)\n        }\n        return\n      }\n\n      var numSmaller = numSmallerAtInsertTime + leftSubtreeSize\n      if value > self.value {\n        numSmaller += 1\n      }\n\n      if let right = self.right {\n        right.insert(value, idx, numSmaller)\n      } else {\n        right = SpecialBST(value, idx, numSmaller)\n      }\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Average case: when the created BST is balanced\n  // O(nlog(n)) time | O(n) space - where n is the length of the array\n  // ---\n  // Worst case: when the created BST is like a linked list\n  // O(n^2) time | O(n) space\n  static func rightSmallerThan(_ array: [Int]) -> [Int] {\n    if array.count == 0 {\n      return [Int]()\n    }\n\n    var rightSmallerCounts = [Int]()\n    for i in array {\n      rightSmallerCounts.append(i)\n    }\n    let lastIdx = array.count - 1\n    var bst = SpecialBST(array[lastIdx])\n    rightSmallerCounts[lastIdx] = 0\n    for i in (0 ..< lastIdx).reversed() {\n      bst.insert(array[i], i, &rightSmallerCounts)\n    }\n    return rightSmallerCounts\n  }\n\n  class SpecialBST {\n    var value: Int\n\n    var leftSubtreeSize: Int = 0\n    var left: SpecialBST?\n    var right: SpecialBST?\n\n    init(_ value: Int) {\n      self.value = value\n    }\n\n    func insert(_ value: Int, _ idx: Int, _ rightSmallerCounts: inout [Int], _ numSmallerAtInsertTime: Int = 0) {\n      if value < self.value {\n        leftSubtreeSize += 1\n        if let left = self.left {\n          left.insert(value, idx, &rightSmallerCounts, numSmallerAtInsertTime)\n        } else {\n          left = SpecialBST(value)\n          rightSmallerCounts[idx] = numSmallerAtInsertTime\n        }\n        return\n      }\n\n      var numSmaller = numSmallerAtInsertTime + leftSubtreeSize\n      if value > self.value {\n        numSmaller += 1\n      }\n\n      if let right = self.right {\n        right.insert(value, idx, &rightSmallerCounts, numSmaller)\n      } else {\n        right = SpecialBST(value)\n        rightSmallerCounts[idx] = numSmaller\n      }\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let array = [8, 5, 11, -1, 3, 4, 2]\n      let expected = [5, 4, 4, 0, 1, 1, 0]\n      let actual = Program.rightSmallerThan(array)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let array = [8, 5, 11, -1, 3, 4, 2]\n      let expected = [5, 4, 4, 0, 1, 1, 0]\n      let actual = Program.rightSmallerThan(array)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function rightSmallerThan(array: number[]) {\n  // Write your code here.\n  return [-1];\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space - where n is the length of the array\nexport function rightSmallerThan(array: number[]) {\n  const rightSmallerCounts: number[] = [];\n  for (let i = 0; i < array.length; i++) {\n    let rightSmallerCount = 0;\n    for (let j = i + 1; j < array.length; j++) {\n      if (array[j] < array[i]) rightSmallerCount++;\n    }\n    rightSmallerCounts.push(rightSmallerCount);\n  }\n  return rightSmallerCounts;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// Average case: when the created BST is balanced\n// O(nlog(n)) time | O(n) space - where n is the length of the array\n// ---\n// Worst case: when the created BST is like a linked list\n// O(n^2) time | O(n) space\nexport function rightSmallerThan(array: number[]) {\n  if (array.length === 0) return [];\n\n  const lastIdx = array.length - 1;\n  const bst = new SpecialBST(array[lastIdx], lastIdx, 0);\n  for (let i = array.length - 2; i >= 0; i--) {\n    bst.insert(array[i], i);\n  }\n\n  const rightSmallerCounts = array.slice();\n  getRightSmallerCounts(bst, rightSmallerCounts);\n  return rightSmallerCounts;\n}\n\nfunction getRightSmallerCounts(bst: SpecialBST | null, rightSmallerCounts: number[]) {\n  if (bst === null) return;\n  rightSmallerCounts[bst.idx] = bst.numSmallerAtInsertTime;\n  getRightSmallerCounts(bst.left, rightSmallerCounts);\n  getRightSmallerCounts(bst.right, rightSmallerCounts);\n}\n\nclass SpecialBST {\n  value: number;\n  idx: number;\n  numSmallerAtInsertTime: number;\n  leftSubtreeSize: number;\n  left: SpecialBST | null;\n  right: SpecialBST | null;\n\n  constructor(value: number, idx: number, numSmallerAtInsertTime: number) {\n    this.value = value;\n    this.idx = idx;\n    this.numSmallerAtInsertTime = numSmallerAtInsertTime;\n    this.leftSubtreeSize = 0;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(value: number, idx: number, numSmallerAtInsertTime = 0) {\n    if (value < this.value) {\n      this.leftSubtreeSize++;\n      if (this.left === null) {\n        this.left = new SpecialBST(value, idx, numSmallerAtInsertTime);\n      } else {\n        this.left.insert(value, idx, numSmallerAtInsertTime);\n      }\n    } else {\n      numSmallerAtInsertTime += this.leftSubtreeSize;\n      if (value > this.value) numSmallerAtInsertTime++;\n      if (this.right === null) {\n        this.right = new SpecialBST(value, idx, numSmallerAtInsertTime);\n      } else {\n        this.right.insert(value, idx, numSmallerAtInsertTime);\n      }\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// Average case: when the created BST is balanced\n// O(nlog(n)) time | O(n) space - where n is the length of the array\n// ---\n// Worst case: when the created BST is like a linked list\n// O(n^2) time | O(n) space\nexport function rightSmallerThan(array: number[]) {\n  if (array.length === 0) return [];\n\n  const rightSmallerCounts = array.slice();\n  const lastIdx = array.length - 1;\n  const bst = new SpecialBST(array[lastIdx]);\n  rightSmallerCounts[lastIdx] = 0;\n  for (let i = array.length - 2; i >= 0; i--) {\n    bst.insert(array[i], i, rightSmallerCounts);\n  }\n\n  return rightSmallerCounts;\n}\n\nclass SpecialBST {\n  value: number;\n  leftSubTreeSize: number;\n  left: SpecialBST | null;\n  right: SpecialBST | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.leftSubTreeSize = 0;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(value: number, idx: number, rightSmallerCounts: number[], numSmallerAtInsertTime = 0) {\n    if (value < this.value) {\n      this.leftSubTreeSize++;\n      if (this.left === null) {\n        this.left = new SpecialBST(value);\n        rightSmallerCounts[idx] = numSmallerAtInsertTime;\n      } else {\n        this.left.insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime);\n      }\n    } else {\n      numSmallerAtInsertTime += this.leftSubTreeSize;\n      if (value > this.value) numSmallerAtInsertTime++;\n      if (this.right === null) {\n        this.right = new SpecialBST(value);\n        rightSmallerCounts[idx] = numSmallerAtInsertTime;\n      } else {\n        this.right.insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime);\n      }\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const array = [8, 5, 11, -1, 3, 4, 2];\n  const expected = [5, 4, 4, 0, 1, 1, 0];\n  const actual = program.rightSmallerThan(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const array = [8, 5, 11, -1, 3, 4, 2];\n  const expected = [5, 4, 4, 0, 1, 1, 0];\n  const actual = program.rightSmallerThan(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "array",
      "example": [
        8,
        5,
        11,
        -1,
        3,
        4,
        2
      ],
      "schema": {
        "items": {
          "type": "integer"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "array": [
        8,
        5,
        11,
        -1,
        3,
        4,
        2
      ]
    },
    {
      "array": []
    },
    {
      "array": [
        1
      ]
    },
    {
      "array": [
        0,
        1,
        1,
        2,
        3,
        5,
        8,
        13
      ]
    },
    {
      "array": [
        13,
        8,
        5,
        3,
        2,
        1,
        1,
        0
      ]
    },
    {
      "array": [
        8,
        5,
        2,
        9,
        5,
        6,
        3
      ]
    },
    {
      "array": [
        991,
        -731,
        -882,
        100,
        280,
        -43,
        432,
        771,
        -581,
        180,
        -382,
        -998,
        847,
        80,
        -220,
        680,
        769,
        -75,
        -817,
        366,
        956,
        749,
        471,
        228,
        -435,
        -269,
        652,
        -331,
        -387,
        -657,
        -255,
        382,
        -216,
        -6,
        -163,
        -681,
        980,
        913,
        -169,
        972,
        -523,
        354,
        747,
        805,
        382,
        -827,
        -796,
        372,
        753,
        519,
        906
      ]
    },
    {
      "array": [
        384,
        -67,
        120,
        759,
        697,
        232,
        -7,
        -557,
        -772,
        -987,
        687,
        397,
        -763,
        -86,
        -491,
        947,
        921,
        421,
        825,
        -679,
        946,
        -562,
        -626,
        -898,
        204,
        776,
        -343,
        393,
        51,
        -796,
        -425,
        31,
        165,
        975,
        -720,
        878,
        -785,
        -367,
        -609,
        662,
        -79,
        -112,
        -313,
        -94,
        187,
        260,
        43,
        85,
        -746,
        612,
        67,
        -389,
        508,
        777,
        624,
        993,
        -581,
        34,
        444,
        -544,
        243,
        -995,
        432,
        -755,
        -978,
        515,
        -68,
        -559,
        489,
        732,
        -19,
        -489,
        737,
        924
      ]
    },
    {
      "array": [
        -823,
        164,
        48,
        -987,
        323,
        399,
        -293,
        183,
        -908,
        -376,
        14,
        980,
        965,
        842,
        422,
        829,
        59,
        724,
        -415,
        -733,
        356,
        -855,
        -155,
        52,
        328,
        -544,
        -371,
        -160,
        -942,
        -51,
        700,
        -363,
        -353,
        -359,
        238,
        892,
        -730,
        -575,
        892,
        490,
        490,
        995,
        572,
        888,
        -935,
        919,
        -191,
        646,
        -120,
        125,
        -817,
        341,
        -575,
        372,
        -874,
        243,
        610,
        -36,
        -685,
        -337,
        -13,
        295,
        800,
        -950,
        -949,
        -257,
        631,
        -542,
        201,
        -796,
        157,
        950,
        540,
        -846,
        -265,
        746,
        355,
        -578,
        -441,
        -254,
        -941,
        -738,
        -469,
        -167,
        -420,
        -126,
        -410,
        59
      ]
    }
  ],
  "jsonTests": [
    {
      "array": [
        8,
        5,
        11,
        -1,
        3,
        4,
        2
      ]
    },
    {
      "array": []
    },
    {
      "array": [
        1
      ]
    },
    {
      "array": [
        0,
        1,
        1,
        2,
        3,
        5,
        8,
        13
      ]
    },
    {
      "array": [
        13,
        8,
        5,
        3,
        2,
        1,
        1,
        0
      ]
    },
    {
      "array": [
        8,
        5,
        2,
        9,
        5,
        6,
        3
      ]
    },
    {
      "array": [
        991,
        -731,
        -882,
        100,
        280,
        -43,
        432,
        771,
        -581,
        180,
        -382,
        -998,
        847,
        80,
        -220,
        680,
        769,
        -75,
        -817,
        366,
        956,
        749,
        471,
        228,
        -435,
        -269,
        652,
        -331,
        -387,
        -657,
        -255,
        382,
        -216,
        -6,
        -163,
        -681,
        980,
        913,
        -169,
        972,
        -523,
        354,
        747,
        805,
        382,
        -827,
        -796,
        372,
        753,
        519,
        906
      ]
    },
    {
      "array": [
        384,
        -67,
        120,
        759,
        697,
        232,
        -7,
        -557,
        -772,
        -987,
        687,
        397,
        -763,
        -86,
        -491,
        947,
        921,
        421,
        825,
        -679,
        946,
        -562,
        -626,
        -898,
        204,
        776,
        -343,
        393,
        51,
        -796,
        -425,
        31,
        165,
        975,
        -720,
        878,
        -785,
        -367,
        -609,
        662,
        -79,
        -112,
        -313,
        -94,
        187,
        260,
        43,
        85,
        -746,
        612,
        67,
        -389,
        508,
        777,
        624,
        993,
        -581,
        34,
        444,
        -544,
        243,
        -995,
        432,
        -755,
        -978,
        515,
        -68,
        -559,
        489,
        732,
        -19,
        -489,
        737,
        924
      ]
    },
    {
      "array": [
        -823,
        164,
        48,
        -987,
        323,
        399,
        -293,
        183,
        -908,
        -376,
        14,
        980,
        965,
        842,
        422,
        829,
        59,
        724,
        -415,
        -733,
        356,
        -855,
        -155,
        52,
        328,
        -544,
        -371,
        -160,
        -942,
        -51,
        700,
        -363,
        -353,
        -359,
        238,
        892,
        -730,
        -575,
        892,
        490,
        490,
        995,
        572,
        888,
        -935,
        919,
        -191,
        646,
        -120,
        125,
        -817,
        341,
        -575,
        372,
        -874,
        243,
        610,
        -36,
        -685,
        -337,
        -13,
        295,
        800,
        -950,
        -949,
        -257,
        631,
        -542,
        201,
        -796,
        157,
        950,
        540,
        -846,
        -265,
        746,
        355,
        -578,
        -441,
        -254,
        -941,
        -738,
        -469,
        -167,
        -420,
        -126,
        -410,
        59
      ]
    }
  ],
  "changelog": []
}