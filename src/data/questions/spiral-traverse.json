{
  "uid": "spiral-traverse",
  "testStrategy": "JSON",
  "name": "Spiral Traverse",
  "version": 0,
  "releaseDate": "2020-03-29T00:00:00Z",
  "category": "Arrays",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 48623,
    "failureCount": 22500
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "401504134",
    "duration": 0,
    "annotations": [
      {
        "title": "Missing Edge Case",
        "content": "`if startRow == endRow: break` (avoid double-counting single row)",
        "start": 1438,
        "end": 1444
      },
      {
        "title": "Missing Edge Case",
        "content": "See Test Case 8 to understand when this edge case occurs.",
        "start": 1445,
        "end": 1451
      },
      {
        "title": "Missing Edge Case",
        "content": "`if startCol == endCol: break` (avoid double-counting single column)",
        "start": 1508,
        "end": 1514
      },
      {
        "title": "Missing Edge Case",
        "content": "See Test Case 9 to understand when this edge case occurs.",
        "start": 1515,
        "end": 1521
      }
    ],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1063
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in an n x m two-dimensional array (that can be\n  square-shaped when n == m) and returns a one-dimensional array of all the\n  array's elements in spiral order.\n</p>\n<p>\n  Spiral order starts at the top left corner of the two-dimensional array, goes\n  to the right, and proceeds in a spiral pattern all the way until every element\n  has been visited.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">array</span> = [\n  [1,   2,  3, 4],\n  [12, 13, 14, 5],\n  [11, 16, 15, 6],\n  [10,  9,  8, 7],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n</pre>\n</div>",
  "hints": [
    "<p>\nYou can think of the spiral that you have to traverse as a set of rectangle perimeters that progressively get smaller (i.e., that progressively move inwards in the two-dimensional array).\n</p>\n",
    "\n<p>\nGoing off of Hint #1, declare four variables: a starting row, a starting column, an ending row, and an ending column. These four variables represent the bounds of the first rectangle perimeter in the spiral that you have to traverse. Traverse that perimeter using those bounds, and then move the bounds inwards. End your algorithm once the starting row passes the ending row or the starting column passes the ending column.\n</p>\n",
    "\n<p>\nYou can solve this problem both iteratively and recursively following very similar logic.\n</p>"
  ],
  "spaceTime": "O(n) time | O(n) space - where n is the total number of elements in the array",
  "notes": "<div class=\"html\">\n<p>\n  In the video explanation, we forget to mention the edge cases where the final\n  \"spiral section\" consists of a single row or a single column. Consider the\n  following two matrices:\n</p>\n<pre>\n[\n  [1,  2,  3,  4],\n  [10, 11, 12, 5],\n  [9,  8,  7,  6],\n]\n</pre>\n<pre>\n[\n  [1,  2,  3],\n  [12, 13, 4],\n  [11, 14, 5],\n  [10, 15, 6],\n  [9,  8,  7],\n]\n</pre>\n<p>\n  In the first matrix, the final section consists of a single row:\n  <span>[11, 12]</span>; in the second matrix, the final section consists of a\n  single column: <span>[13, 14, 15]</span>.\n</p>\n<p>\n  In order to avoid double-counting elements in these sections (i.e., counting\n  11, 12, <b>11</b> instead of just 11, 12 in the first example, and counting\n  13, 14, 15, <b>14</b> instead of just 13, 14, 15 in the second example), we\n  have to add a couple of checks in our code to see if the\n  <span>endRow</span> and <span>endCol</span> are equal to the\n  <span>startRow</span> and <span>startCol</span>, respectively. If either of\n  them are, we make sure to break out of the loop we're in to avoid the\n  double-counting.\n</p>\n</div>",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\nvector<int> spiralTraverse(vector<vector<int>> array) {\n  // Write your code here.\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// O(n) time | O(n) space - where n is the total number of elements in the array\nvector<int> spiralTraverse(vector<vector<int>> array) {\n  if (array.size() == 0) return {};\n\n  vector<int> result = {};\n  int startRow = 0;\n  int endRow = array.size() - 1;\n  int startCol = 0;\n  int endCol = array[0].size() - 1;\n\n  while (startRow <= endRow && startCol <= endCol) {\n    for (int col = startCol; col <= endCol; col++) {\n      result.push_back(array[startRow][col]);\n    }\n\n    for (int row = startRow + 1; row <= endRow; row++) {\n      result.push_back(array[row][endCol]);\n    }\n\n    for (int col = endCol - 1; col >= startCol; col--) {\n      // Handle the edge case when there's a single row\n      // in the middle of the matrix. In this case, we don't\n      // want to double-count the values in this row, which\n      // we've already counted in the first for loop above.\n      // See Test Case 8 for an example of this edge case.\n      if (startRow == endRow) break;\n      result.push_back(array[endRow][col]);\n    }\n\n    for (int row = endRow - 1; row > startRow; row--) {\n      // Handle the edge case when there's a single column\n      // in the middle of the matrix. In this case, we don't\n      // want to double-count the values in this column, which\n      // we've already counted in the second for loop above.\n      // See Test Case 9 for an example of this edge case.\n      if (startCol == endCol) break;\n      result.push_back(array[row][startCol]);\n    }\n\n    startRow++;\n    endRow--;\n    startCol++;\n    endCol--;\n  }\n  return result;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// O(n) time | O(n) space - where n is the total number of elements in the array\nvoid spiralFill(\n  vector<vector<int>>& array,\n  int startRow,\n  int endRow,\n  int startCol,\n  int endCol,\n  vector<int>& result\n) {\n  if (startRow > endRow || startCol > endCol) {\n    return;\n  }\n\n  for (int col = startCol; col <= endCol; col++) {\n    result.push_back(array[startRow][col]);\n  }\n\n  for (int row = startRow + 1; row <= endRow; row++) {\n    result.push_back(array[row][endCol]);\n  }\n\n  for (int col = endCol - 1; col >= startCol; col--) {\n    // Handle the edge case when there's a single row\n    // in the middle of the matrix. In this case, we don't\n    // want to double-count the values in this row, which\n    // we've already counted in the first for loop above.\n    // See Test Case 8 for an example of this edge case.\n    if (startRow == endRow) break;\n    result.push_back(array[endRow][col]);\n  }\n\n  for (int row = endRow - 1; row >= startRow + 1; row--) {\n    // Handle the edge case when there's a single column\n    // in the middle of the matrix. In this case, we don't\n    // want to double-count the values in this column, which\n    // we've already counted in the second for loop above.\n    // See Test Case 9 for an example of this edge case.\n    if (startCol == endCol) break;\n    result.push_back(array[row][startCol]);\n  }\n\n  spiralFill(array, startRow + 1, endRow - 1, startCol + 1, endCol - 1, result);\n}\n\nvector<int> spiralTraverse(vector<vector<int>> array) {\n  if (array.size() == 0) return {};\n\n  vector<int> result = {};\n  spiralFill(array, 0, array.size() - 1, 0, array[0].size() - 1, result);\n  return result;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 4\", []() {\n      vector<vector<int>> input = {\n        {1, 2, 3, 4},\n        {12, 13, 14, 5},\n        {11, 16, 15, 6},\n        {10, 9, 8, 7},\n      };\n      vector<int> expected = {\n        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n      vector<int> actual = spiralTraverse(input);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 4\", []() {\n      vector<vector<int>> input = {\n        {1, 2, 3, 4},\n        {12, 13, 14, 5},\n        {11, 16, 15, 6},\n        {10, 9, 8, 7},\n      };\n      vector<int> expected = {\n        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n      vector<int> actual = spiralTraverse(input);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n  public static List<int> SpiralTraverse(int[,] array) {\n    // Write your code here.\n    return new List<int>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(n) time | O(n) space - where n is the total number of elements in the\n  // array\n  public static List<int> SpiralTraverse(int[,] array) {\n    if (array.GetLength(0) == 0) return new List<int>();\n\n    var result = new List<int>();\n    var startRow = 0;\n    var endRow = array.GetLength(0) - 1;\n    var startCol = 0;\n    var endCol = array.GetLength(1) - 1;\n\n    while (startRow <= endRow && startCol <= endCol) {\n      for (int col = startCol; col <= endCol; col++) {\n        result.Add(array[startRow, col]);\n      }\n\n      for (int row = startRow + 1; row <= endRow; row++) {\n        result.Add(array[row, endCol]);\n      }\n\n      for (int col = endCol - 1; col >= startCol; col--) {\n        // Handle the edge case when there's a single row\n        // in the middle of the matrix. In this case, we don't\n        // want to double-count the values in this row, which\n        // we've already counted in the first for loop above.\n        // See Test Case 8 for an example of this edge case.\n        if (startRow == endRow) break;\n        result.Add(array[endRow, col]);\n      }\n\n      for (int row = endRow - 1; row > startRow; row--) {\n        // Handle the edge case when there's a single column\n        // in the middle of the matrix. In this case, we don't\n        // want to double-count the values in this column, which\n        // we've already counted in the second for loop above.\n        // See Test Case 9 for an example of this edge case.\n        if (startCol == endCol) break;\n        result.Add(array[row, startCol]);\n      }\n\n      startRow++;\n      endRow--;\n      startCol++;\n      endCol--;\n    }\n    return result;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(n) time | O(n) space - where n is the total number of elements in the\n  // array\n  public static List<int> SpiralTraverse(int[,] array) {\n    if (array.Length == 0) return new List<int>();\n\n    var result = new List<int>();\n    spiralFill(\n      array, 0, array.GetLength(0) - 1, 0, array.GetLength(1) - 1, result\n    );\n    return result;\n  }\n\n  public static void spiralFill(\n    int[,] array,\n    int startRow,\n    int endRow,\n    int startCol,\n    int endCol,\n    List<int> result\n  ) {\n    if (startRow > endRow || startCol > endCol) {\n      return;\n    }\n\n    for (int col = startCol; col <= endCol; col++) {\n      result.Add(array[startRow, col]);\n    }\n\n    for (int row = startRow + 1; row <= endRow; row++) {\n      result.Add(array[row, endCol]);\n    }\n\n    for (int col = endCol - 1; col >= startCol; col--) {\n      // Handle the edge case when there's a single row\n      // in the middle of the matrix. In this case, we don't\n      // want to double-count the values in this row, which\n      // we've already counted in the first for loop above.\n      // See Test Case 8 for an example of this edge case.\n      if (startRow == endRow) break;\n      result.Add(array[endRow, col]);\n    }\n\n    for (int row = endRow - 1; row >= startRow + 1; row--) {\n      // Handle the edge case when there's a single column\n      // in the middle of the matrix. In this case, we don't\n      // want to double-count the values in this column, which\n      // we've already counted in the second for loop above.\n      // See Test Case 9 for an example of this edge case.\n      if (startCol == endCol) break;\n      result.Add(array[row, startCol]);\n    }\n    spiralFill(\n      array, startRow + 1, endRow - 1, startCol + 1, endCol - 1, result\n    );\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[,] input = {\n      { 1, 2, 3, 4 },\n      { 12, 13, 14, 5 },\n      { 11, 16, 15, 6 },\n      { 10, 9, 8, 7 },\n    };\n    var expected =\n      new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };\n    var actual = Program.SpiralTraverse(input);\n    Utils.AssertTrue(expected.SequenceEqual(actual));\n  }\n}\n",
      "unitTests": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[,] input = {\n      { 1, 2, 3, 4 },\n      { 12, 13, 14, 5 },\n      { 11, 16, 15, 6 },\n      { 10, 9, 8, 7 },\n    };\n    var expected =\n      new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };\n    var actual = Program.SpiralTraverse(input);\n    Utils.AssertTrue(expected.SequenceEqual(actual));\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc SpiralTraverse(array [][]int) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(n) space - where n is the total number of elements in the array\nfunc SpiralTraverse(array [][]int) []int {\n\tif len(array) == 0 {\n\t\treturn []int{}\n\t}\n\n\tresult := []int{}\n\tstartRow, endRow := 0, len(array)-1\n\tstartCol, endCol := 0, len(array[0])-1\n\n\tfor startRow <= endRow && startCol <= endCol {\n\t\tfor col := startCol; col <= endCol; col++ {\n\t\t\tresult = append(result, array[startRow][col])\n\t\t}\n\n\t\tfor row := startRow + 1; row <= endRow; row++ {\n\t\t\tresult = append(result, array[row][endCol])\n\t\t}\n\n\t\tfor col := endCol - 1; col >= startCol; col-- {\n\t\t\t// Handle the edge case when there's a single row\n\t\t\t// in the middle of the matrix. In this case, we don't\n\t\t\t// want to double-count the values in this row, which\n\t\t\t// we've already counted in the first for loop above.\n\t\t\t// See Test Case 8 for an example of this edge case.\n\t\t\tif startRow == endRow {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tresult = append(result, array[endRow][col])\n\t\t}\n\n\t\tfor row := endRow - 1; row > startRow; row-- {\n\t\t\t// Handle the edge case when there's a single column\n\t\t\t// in the middle of the matrix. In this case, we don't\n\t\t\t// want to double-count the values in this column, which\n\t\t\t// we've already counted in the second for loop above.\n\t\t\t// See Test Case 9 for an example of this edge case.\n\t\t\tif startCol == endCol {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tresult = append(result, array[row][startCol])\n\t\t}\n\n\t\tstartRow++\n\t\tendRow--\n\t\tstartCol++\n\t\tendCol--\n\t}\n\treturn result\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(n) space - where n is the total number of elements in the array\nfunc SpiralTraverse(array [][]int) []int {\n\tif len(array) == 0 {\n\t\treturn []int{}\n\t}\n\tresult := []int{}\n\tspiralFill(array, 0, len(array)-1, 0,\n\t\tlen(array[0])-1, &result)\n\treturn result\n}\n\nfunc spiralFill(array [][]int, startRow, endRow, startCol, endCol int, result *[]int) {\n\tif startRow > endRow || startCol > endCol {\n\t\treturn\n\t}\n\n\tfor col := startCol; col <= endCol; col++ {\n\t\t*result = append(*result, array[startRow][col])\n\t}\n\n\tfor row := startRow + 1; row <= endRow; row++ {\n\t\t*result = append(*result, array[row][endCol])\n\t}\n\n\tfor col := endCol - 1; col >= startCol; col-- {\n\t\t// Handle the edge case when there's a single row\n\t\t// in the middle of the matrix. In this case, we don't\n\t\t// want to double-count the values in this row, which\n\t\t// we've already counted in the first for loop above.\n\t\t// See Test Case 8 for an example of this edge case.\n\t\tif startRow == endRow {\n\t\t\tbreak\n\t\t}\n\t\t*result = append(*result, array[endRow][col])\n\t}\n\n\tfor row := endRow - 1; row >= startRow+1; row-- {\n\t\t// Handle the edge case when there's a single column\n\t\t// in the middle of the matrix. In this case, we don't\n\t\t// want to double-count the values in this column, which\n\t\t// we've already counted in the second for loop above.\n\t\t// See Test Case 9 for an example of this edge case.\n\t\tif startCol == endCol {\n\t\t\tbreak\n\t\t}\n\t\t*result = append(*result, array[row][startCol])\n\t}\n\n\tspiralFill(array, startRow+1, endRow-1,\n\t\tstartCol+1, endCol-1, result)\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tmatrix := [][]int{\n\t\t{1, 2, 3, 4},\n\t\t{12, 13, 14, 5},\n\t\t{11, 16, 15, 6},\n\t\t{10, 9, 8, 7},\n\t}\n\texpected := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n\tactual := SpiralTraverse(matrix)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tmatrix := [][]int{\n\t\t{1, 2, 3, 4},\n\t\t{12, 13, 14, 5},\n\t\t{11, 16, 15, 6},\n\t\t{10, 9, 8, 7},\n\t}\n\texpected := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n\tactual := SpiralTraverse(matrix)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static List<Integer> spiralTraverse(int[][] array) {\n    // Write your code here.\n    return new ArrayList<Integer>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n) time | O(n) space - where n is the total number of elements in the\n  // array\n  public static List<Integer> spiralTraverse(int[][] array) {\n    if (array.length == 0) return new ArrayList<Integer>();\n\n    var result = new ArrayList<Integer>();\n    var startRow = 0;\n    var endRow = array.length - 1;\n    var startCol = 0;\n    var endCol = array[0].length - 1;\n\n    while (startRow <= endRow && startCol <= endCol) {\n      for (int col = startCol; col <= endCol; col++) {\n        result.add(array[startRow][col]);\n      }\n\n      for (int row = startRow + 1; row <= endRow; row++) {\n        result.add(array[row][endCol]);\n      }\n\n      for (int col = endCol - 1; col >= startCol; col--) {\n        // Handle the edge case when there's a single row\n        // in the middle of the matrix. In this case, we don't\n        // want to double-count the values in this row, which\n        // we've already counted in the first for loop above.\n        // See Test Case 8 for an example of this edge case.\n        if (startRow == endRow) break;\n        result.add(array[endRow][col]);\n      }\n\n      for (int row = endRow - 1; row > startRow; row--) {\n        // Handle the edge case when there's a single column\n        // in the middle of the matrix. In this case, we don't\n        // want to double-count the values in this column, which\n        // we've already counted in the second for loop above.\n        // See Test Case 9 for an example of this edge case.\n        if (startCol == endCol) break;\n        result.add(array[row][startCol]);\n      }\n\n      startRow++;\n      endRow--;\n      startCol++;\n      endCol--;\n    }\n    return result;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n) time | O(n) space - where n is the total number of elements in the\n  // array\n  public static List<Integer> spiralTraverse(int[][] array) {\n    if (array.length == 0) return new ArrayList<Integer>();\n\n    var result = new ArrayList<Integer>();\n    spiralFill(array, 0, array.length - 1, 0, array[0].length - 1, result);\n    return result;\n  }\n\n  public static void spiralFill(\n    int[][] array,\n    int startRow,\n    int endRow,\n    int startCol,\n    int endCol,\n    ArrayList<Integer> result\n  ) {\n    if (startRow > endRow || startCol > endCol) {\n      return;\n    }\n\n    for (int col = startCol; col <= endCol; col++) {\n      result.add(array[startRow][col]);\n    }\n\n    for (int row = startRow + 1; row <= endRow; row++) {\n      result.add(array[row][endCol]);\n    }\n\n    for (int col = endCol - 1; col >= startCol; col--) {\n      // Handle the edge case when there's a single row\n      // in the middle of the matrix. In this case, we don't\n      // want to double-count the values in this row, which\n      // we've already counted in the first for loop above.\n      // See Test Case 8 for an example of this edge case.\n      if (startRow == endRow) break;\n      result.add(array[endRow][col]);\n    }\n\n    for (int row = endRow - 1; row >= startRow + 1; row--) {\n      // Handle the edge case when there's a single column\n      // in the middle of the matrix. In this case, we don't\n      // want to double-count the values in this column, which\n      // we've already counted in the second for loop above.\n      // See Test Case 9 for an example of this edge case.\n      if (startCol == endCol) break;\n      result.add(array[row][startCol]);\n    }\n    spiralFill(\n      array, startRow + 1, endRow - 1, startCol + 1, endCol - 1, result\n    );\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var input = new int[][] {\n      {1, 2, 3, 4},\n      {12, 13, 14, 5},\n      {11, 16, 15, 6},\n      {10, 9, 8, 7},\n    };\n    var expected =\n      Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);\n    var actual = Program.spiralTraverse(input);\n    Utils.assertTrue(expected.equals(actual));\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var input = new int[][] {\n      {1, 2, 3, 4},\n      {12, 13, 14, 5},\n      {11, 16, 15, 6},\n      {10, 9, 8, 7},\n    };\n    var expected =\n      Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);\n    var actual = Program.spiralTraverse(input);\n    Utils.assertTrue(expected.equals(actual));\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function spiralTraverse(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.spiralTraverse = spiralTraverse;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the total number of elements in the array\nfunction spiralTraverse(array) {\n  const result = [];\n  let startRow = 0,\n    endRow = array.length - 1;\n  let startCol = 0,\n    endCol = array[0].length - 1;\n\n  while (startRow <= endRow && startCol <= endCol) {\n    for (let col = startCol; col <= endCol; col++) {\n      result.push(array[startRow][col]);\n    }\n\n    for (let row = startRow + 1; row <= endRow; row++) {\n      result.push(array[row][endCol]);\n    }\n\n    for (let col = endCol - 1; col >= startCol; col--) {\n      // Handle the edge case when there's a single row\n      // in the middle of the matrix. In this case, we don't\n      // want to double-count the values in this row, which\n      // we've already counted in the first for loop above.\n      // See Test Case 8 for an example of this edge case.\n      if (startRow === endRow) break;\n      result.push(array[endRow][col]);\n    }\n\n    for (let row = endRow - 1; row > startRow; row--) {\n      // Handle the edge case when there's a single column\n      // in the middle of the matrix. In this case, we don't\n      // want to double-count the values in this column, which\n      // we've already counted in the second for loop above.\n      // See Test Case 9 for an example of this edge case.\n      if (startCol === endCol) break;\n      result.push(array[row][startCol]);\n    }\n\n    startRow++;\n    endRow--;\n    startCol++;\n    endCol--;\n  }\n\n  return result;\n}\n\nexports.spiralTraverse = spiralTraverse;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the total number of elements in the array\nfunction spiralTraverse(array) {\n  const result = [];\n  spiralFill(array, 0, array.length - 1, 0, array[0].length - 1, result);\n  return result;\n}\n\nfunction spiralFill(array, startRow, endRow, startCol, endCol, result) {\n  if (startRow > endRow || startCol > endCol) return;\n\n  for (let col = startCol; col <= endCol; col++) {\n    result.push(array[startRow][col]);\n  }\n\n  for (let row = startRow + 1; row <= endRow; row++) {\n    result.push(array[row][endCol]);\n  }\n\n  for (let col = endCol - 1; col >= startCol; col--) {\n    // Handle the edge case when there's a single row\n    // in the middle of the matrix. In this case, we don't\n    // want to double-count the values in this row, which\n    // we've already counted in the first for loop above.\n    // See Test Case 8 for an example of this edge case.\n    if (startRow === endRow) break;\n    result.push(array[endRow][col]);\n  }\n\n  for (let row = endRow - 1; row >= startRow + 1; row--) {\n    // Handle the edge case when there's a single column\n    // in the middle of the matrix. In this case, we don't\n    // want to double-count the values in this column, which\n    // we've already counted in the second for loop above.\n    // See Test Case 9 for an example of this edge case.\n    if (startCol === endCol) break;\n    result.push(array[row][startCol]);\n  }\n\n  spiralFill(array, startRow + 1, endRow - 1, startCol + 1, endCol - 1, result);\n}\n\nexports.spiralTraverse = spiralTraverse;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const matrix = [\n    [1, 2, 3, 4],\n    [12, 13, 14, 5],\n    [11, 16, 15, 6],\n    [10, 9, 8, 7],\n  ];\n  const expected = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\n  chai.expect(program.spiralTraverse(matrix)).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const matrix = [\n    [1, 2, 3, 4],\n    [12, 13, 14, 5],\n    [11, 16, 15, 6],\n    [10, 9, 8, 7],\n  ];\n  const expected = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\n  chai.expect(program.spiralTraverse(matrix)).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun spiralTraverse(array: List<List<Int>>): List<Int> {\n    // Write your code here.\n    return listOf<Int>()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(n) space - where n is the total number of elements in the array\nfun spiralTraverse(array: List<List<Int>>): List<Int> {\n    val result = mutableListOf<Int>()\n    var startRow = 0\n    var endRow = array.size - 1\n    var startCol = 0\n    var endCol = array[0].size - 1\n\n    while (startRow <= endRow && startCol <= endCol) {\n        for (col in startCol..endCol) {\n            result.add(array[startRow][col])\n        }\n\n        for (row in startRow + 1..endRow) {\n            result.add(array[row][endCol])\n        }\n\n        for (col in endCol - 1 downTo startCol) {\n            // Handle the edge case when there's a single row\n            // in the middle of the matrix. In this case, we don't\n            // want to double-count the values in this row, which\n            // we've already counted in the first for loop above.\n            // See Test Case 8 for an example of this edge case.\n            if (startRow == endRow) break\n            result.add(array[endRow][col])\n        }\n\n        for (row in endRow - 1 downTo startRow + 1) {\n            // Handle the edge case when there's a single column\n            // in the middle of the matrix. In this case, we don't\n            // want to double-count the values in this column, which\n            // we've already counted in the second for loop above.\n            // See Test Case 9 for an example of this edge case.\n            if (startCol == endCol) break\n            result.add(array[row][startCol])\n        }\n\n        startRow++\n        endRow--\n        startCol++\n        endCol--\n    }\n    return result\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(n) space - where n is the total number of elements in the array\nfun spiralTraverse(array: List<List<Int>>): List<Int> {\n    val result = mutableListOf<Int>()\n    spiralFill(array, 0, array.size - 1, 0, array[0].size - 1, result)\n    return result\n}\n\nfun spiralFill(array: List<List<Int>>, startRow: Int, endRow: Int, startCol: Int, endCol: Int, result: MutableList<Int>) {\n    if (startRow > endRow || startCol > endCol) return\n\n    for (col in startCol..endCol) {\n        result.add(array[startRow][col])\n    }\n\n    for (row in startRow + 1..endRow) {\n        result.add(array[row][endCol])\n    }\n\n    for (col in endCol - 1 downTo startCol) {\n        // Handle the edge case when there's a single row\n        // in the middle of the matrix. In this case, we don't\n        // want to double-count the values in this row, which\n        // we've already counted in the first for loop above.\n        // See Test Case 8 for an example of this edge case.\n        if (startRow == endRow) break\n        result.add(array[endRow][col])\n    }\n\n    for (row in endRow - 1 downTo startRow + 1) {\n        // Handle the edge case when there's a single column\n        // in the middle of the matrix. In this case, we don't\n        // want to double-count the values in this column, which\n        // we've already counted in the second for loop above.\n        // See Test Case 9 for an example of this edge case.\n        if (startCol == endCol) break\n        result.add(array[row][startCol])\n    }\n\n    spiralFill(array, startRow + 1, endRow - 1, startCol + 1, endCol - 1, result)\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n\nimport com.algoexpert.program.spiralTraverse as spiralTraverse\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val matrix = listOf(\n            listOf(1, 2, 3, 4),\n            listOf(12, 13, 14, 5),\n            listOf(11, 16, 15, 6),\n            listOf(10, 9, 8, 7),\n        )\n        val expected = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)\n        val output = spiralTraverse(matrix)\n        assert(output.equals(expected))\n    }\n}\n",
      "unitTests": "\nimport com.algoexpert.program.spiralTraverse as spiralTraverse\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val matrix = listOf(\n            listOf(1, 2, 3, 4),\n            listOf(12, 13, 14, 5),\n            listOf(11, 16, 15, 6),\n            listOf(10, 9, 8, 7),\n        )\n        val expected = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)\n        val output = spiralTraverse(matrix)\n        assert(output.equals(expected))\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def spiralTraverse(array):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space - where n is the total number of elements in the array\ndef spiralTraverse(array):\n    result = []\n    startRow, endRow = 0, len(array) - 1\n    startCol, endCol = 0, len(array[0]) - 1\n\n    while startRow <= endRow and startCol <= endCol:\n        for col in range(startCol, endCol + 1):\n            result.append(array[startRow][col])\n\n        for row in range(startRow + 1, endRow + 1):\n            result.append(array[row][endCol])\n\n        for col in reversed(range(startCol, endCol)):\n            # Handle the edge case when there's a single row\n            # in the middle of the matrix. In this case, we don't\n            # want to double-count the values in this row, which\n            # we've already counted in the first for loop above.\n            # See Test Case 8 for an example of this edge case.\n            if startRow == endRow:\n                break\n            result.append(array[endRow][col])\n\n        for row in reversed(range(startRow + 1, endRow)):\n            # Handle the edge case when there's a single column\n            # in the middle of the matrix. In this case, we don't\n            # want to double-count the values in this column, which\n            # we've already counted in the second for loop above.\n            # See Test Case 9 for an example of this edge case.\n            if startCol == endCol:\n                break\n            result.append(array[row][startCol])\n\n        startRow += 1\n        endRow -= 1\n        startCol += 1\n        endCol -= 1\n\n    return result\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space - where n is the total number of elements in the array\ndef spiralTraverse(array):\n    result = []\n    spiralFill(array, 0, len(array) - 1, 0, len(array[0]) - 1, result)\n    return result\n\n\ndef spiralFill(array, startRow, endRow, startCol, endCol, result):\n    if startRow > endRow or startCol > endCol:\n        return\n\n    for col in range(startCol, endCol + 1):\n        result.append(array[startRow][col])\n\n    for row in range(startRow + 1, endRow + 1):\n        result.append(array[row][endCol])\n\n    for col in reversed(range(startCol, endCol)):\n        # Handle the edge case when there's a single row\n        # in the middle of the matrix. In this case, we don't\n        # want to double-count the values in this row, which\n        # we've already counted in the first for loop above.\n        # See Test Case 8 for an example of this edge case.\n        if startRow == endRow:\n            break\n        result.append(array[endRow][col])\n\n    for row in reversed(range(startRow + 1, endRow)):\n        # Handle the edge case when there's a single column\n        # in the middle of the matrix. In this case, we don't\n        # want to double-count the values in this column, which\n        # we've already counted in the second for loop above.\n        # See Test Case 9 for an example of this edge case.\n        if startCol == endCol:\n            break\n        result.append(array[row][startCol])\n\n    spiralFill(array, startRow + 1, endRow - 1, startCol + 1, endCol - 1, result)\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        matrix = [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]\n        expected = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n        self.assertEqual(program.spiralTraverse(matrix), expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        matrix = [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]\n        expected = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n        self.assertEqual(program.spiralTraverse(matrix), expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def spiralTraverse(array)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def spiralTraverse(array)\n    # Write your code here.\n    return []\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def spiralTraverse(array)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.spiralTraverse\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.spiralTraverse\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func spiralTraverse(array: [[Int]]) -> [Int] {\n    // Write your code here.\n    return []\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space - where n is the total number of elements in the array\n  func spiralTraverse(array: [[Int]]) -> [Int] {\n    if array.count == 0 {\n      return []\n    }\n\n    var result = [Int]()\n    var startRow = 0\n    var endRow = array.count - 1\n    var startCol = 0\n    var endCol = array[0].count - 1\n\n    while startRow <= endRow, startCol <= endCol {\n      for col in stride(from: startCol, through: endCol, by: 1) {\n        result.append(array[startRow][col])\n      }\n\n      for row in stride(from: startRow + 1, through: endRow, by: 1) {\n        result.append(array[row][endCol])\n      }\n\n      for col in stride(from: endCol - 1, through: startCol, by: -1) {\n        // Handle the edge case when there's a single row\n        // in the middle of the matrix. In this case, we don't\n        // want to double-count the values in this row, which\n        // we've already counted in the first for loop above.\n        // See Test Case 8 for an example of this edge case.\n        if startRow == endRow {\n          break\n        }\n        result.append(array[endRow][col])\n      }\n\n      for row in stride(from: endRow - 1, through: startRow + 1, by: -1) {\n        // Handle the edge case when there's a single column\n        // in the middle of the matrix. In this case, we don't\n        // want to double-count the values in this column, which\n        // we've already counted in the second for loop above.\n        // See Test Case 9 for an example of this edge case.\n        if startCol == endCol {\n          break\n        }\n        result.append(array[row][startCol])\n      }\n\n      startRow += 1\n      endRow -= 1\n      startCol += 1\n      endCol -= 1\n    }\n    return result\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space - where n is the total number of elements in the array\n  func spiralTraverse(array: [[Int]]) -> [Int] {\n    var result = [Int]()\n    spiralFill(array, 0, array.count - 1, 0, array[0].count - 1, &result)\n    return result\n  }\n\n  func spiralFill(_ array: [[Int]], _ startRow: Int, _ endRow: Int, _ startCol: Int, _ endCol: Int, _ result: inout [Int]) {\n    if startRow > endRow || startCol > endCol {\n      return\n    }\n\n    for col in stride(from: startCol, through: endCol, by: 1) {\n      result.append(array[startRow][col])\n    }\n\n    for row in stride(from: startRow + 1, through: endRow, by: 1) {\n      result.append(array[row][endCol])\n    }\n\n    for col in stride(from: endCol - 1, through: startCol, by: -1) {\n      // Handle the edge case when there's a single row\n      // in the middle of the matrix. In this case, we don't\n      // want to double-count the values in this row, which\n      // we've already counted in the first for loop above.\n      // See Test Case 8 for an example of this edge case.\n      if startRow == endRow {\n        break\n      }\n      result.append(array[endRow][col])\n    }\n\n    for row in stride(from: endRow - 1, through: startRow + 1, by: -1) {\n      // Handle the edge case when there's a single column\n      // in the middle of the matrix. In this case, we don't\n      // want to double-count the values in this column, which\n      // we've already counted in the second for loop above.\n      // See Test Case 9 for an example of this edge case.\n      if startCol == endCol {\n        break\n      }\n      result.append(array[row][startCol])\n    }\n\n    spiralFill(array, startRow + 1, endRow - 1,\n               startCol + 1, endCol - 1, &result)\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let input = [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]\n      let expected = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n      let actual = program.spiralTraverse(array: input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let input = [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]\n      let expected = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n      let actual = program.spiralTraverse(array: input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function spiralTraverse(array: number[][]) {\n  // Write your code here.\n  return [-1];\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the total number of elements in the array\nexport function spiralTraverse(array: number[][]) {\n  const result: number[] = [];\n  let startRow = 0,\n    endRow = array.length - 1;\n  let startCol = 0,\n    endCol = array[0].length - 1;\n\n  while (startRow <= endRow && startCol <= endCol) {\n    for (let col = startCol; col <= endCol; col++) {\n      result.push(array[startRow][col]);\n    }\n\n    for (let row = startRow + 1; row <= endRow; row++) {\n      result.push(array[row][endCol]);\n    }\n\n    for (let col = endCol - 1; col >= startCol; col--) {\n      // Handle the edge case when there's a single row\n      // in the middle of the matrix. In this case, we don't\n      // want to double-count the values in this row, which\n      // we've already counted in the first for loop above.\n      // See Test Case 8 for an example of this edge case.\n      if (startRow === endRow) break;\n      result.push(array[endRow][col]);\n    }\n\n    for (let row = endRow - 1; row > startRow; row--) {\n      // Handle the edge case when there's a single column\n      // in the middle of the matrix. In this case, we don't\n      // want to double-count the values in this column, which\n      // we've already counted in the second for loop above.\n      // See Test Case 9 for an example of this edge case.\n      if (startCol === endCol) break;\n      result.push(array[row][startCol]);\n    }\n\n    startRow++;\n    endRow--;\n    startCol++;\n    endCol--;\n  }\n\n  return result;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the total number of elements in the array\nexport function spiralTraverse(array: number[][]) {\n  const result: number[] = [];\n  spiralFill(array, 0, array.length - 1, 0, array[0].length - 1, result);\n  return result;\n}\n\nexport function spiralFill(\n  array: number[][],\n  startRow: number,\n  endRow: number,\n  startCol: number,\n  endCol: number,\n  result: number[],\n) {\n  if (startRow > endRow || startCol > endCol) return;\n\n  for (let col = startCol; col <= endCol; col++) {\n    result.push(array[startRow][col]);\n  }\n\n  for (let row = startRow + 1; row <= endRow; row++) {\n    result.push(array[row][endCol]);\n  }\n\n  for (let col = endCol - 1; col >= startCol; col--) {\n    // Handle the edge case when there's a single row\n    // in the middle of the matrix. In this case, we don't\n    // want to double-count the values in this row, which\n    // we've already counted in the first for loop above.\n    // See Test Case 8 for an example of this edge case.\n    if (startRow === endRow) break;\n    result.push(array[endRow][col]);\n  }\n\n  for (let row = endRow - 1; row >= startRow + 1; row--) {\n    // Handle the edge case when there's a single column\n    // in the middle of the matrix. In this case, we don't\n    // want to double-count the values in this column, which\n    // we've already counted in the second for loop above.\n    // See Test Case 9 for an example of this edge case.\n    if (startCol === endCol) break;\n    result.push(array[row][startCol]);\n  }\n\n  spiralFill(array, startRow + 1, endRow - 1, startCol + 1, endCol - 1, result);\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const matrix = [\n    [1, 2, 3, 4],\n    [12, 13, 14, 5],\n    [11, 16, 15, 6],\n    [10, 9, 8, 7],\n  ];\n  const expected = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\n  chai.expect(program.spiralTraverse(matrix)).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const matrix = [\n    [1, 2, 3, 4],\n    [12, 13, 14, 5],\n    [11, 16, 15, 6],\n    [10, 9, 8, 7],\n  ];\n  const expected = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\n  chai.expect(program.spiralTraverse(matrix)).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "array",
      "example": [
        [
          1,
          2,
          3,
          4
        ],
        [
          12,
          13,
          14,
          5
        ],
        [
          11,
          16,
          15,
          6
        ],
        [
          10,
          9,
          8,
          7
        ]
      ],
      "schema": {
        "items": {
          "items": {
            "type": "integer"
          },
          "type": "array"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "array": [
        [
          1,
          2,
          3,
          4
        ],
        [
          12,
          13,
          14,
          5
        ],
        [
          11,
          16,
          15,
          6
        ],
        [
          10,
          9,
          8,
          7
        ]
      ]
    },
    {
      "array": [
        [
          1
        ]
      ]
    },
    {
      "array": [
        [
          1,
          2
        ],
        [
          4,
          3
        ]
      ]
    },
    {
      "array": [
        [
          1,
          2,
          3
        ],
        [
          8,
          9,
          4
        ],
        [
          7,
          6,
          5
        ]
      ]
    },
    {
      "array": [
        [
          19,
          32,
          33,
          34,
          25,
          8
        ],
        [
          16,
          15,
          14,
          13,
          12,
          11
        ],
        [
          18,
          31,
          36,
          35,
          26,
          9
        ],
        [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        [
          20,
          21,
          22,
          23,
          24,
          7
        ],
        [
          17,
          30,
          29,
          28,
          27,
          10
        ]
      ]
    },
    {
      "array": [
        [
          4,
          2,
          3,
          6,
          7,
          8,
          1,
          9,
          5,
          10
        ],
        [
          12,
          19,
          15,
          16,
          20,
          18,
          13,
          17,
          11,
          14
        ]
      ]
    },
    {
      "array": [
        [
          27,
          12,
          35,
          26
        ],
        [
          25,
          21,
          94,
          11
        ],
        [
          19,
          96,
          43,
          56
        ],
        [
          55,
          36,
          10,
          18
        ],
        [
          96,
          83,
          31,
          94
        ],
        [
          93,
          11,
          90,
          16
        ]
      ]
    },
    {
      "array": [
        [
          1,
          2,
          3,
          4
        ],
        [
          10,
          11,
          12,
          5
        ],
        [
          9,
          8,
          7,
          6
        ]
      ]
    },
    {
      "array": [
        [
          1,
          2,
          3
        ],
        [
          12,
          13,
          4
        ],
        [
          11,
          14,
          5
        ],
        [
          10,
          15,
          6
        ],
        [
          9,
          8,
          7
        ]
      ]
    },
    {
      "array": [
        [
          1,
          11
        ],
        [
          2,
          12
        ],
        [
          3,
          13
        ],
        [
          4,
          14
        ],
        [
          5,
          15
        ],
        [
          6,
          16
        ],
        [
          7,
          17
        ],
        [
          8,
          18
        ],
        [
          9,
          19
        ],
        [
          10,
          20
        ]
      ]
    },
    {
      "array": [
        [
          1,
          3,
          2,
          5,
          4,
          7,
          6
        ]
      ]
    },
    {
      "array": [
        [
          1
        ],
        [
          3
        ],
        [
          2
        ],
        [
          5
        ],
        [
          4
        ],
        [
          7
        ],
        [
          6
        ]
      ]
    }
  ],
  "jsonTests": [
    {
      "array": [
        [
          1,
          2,
          3,
          4
        ],
        [
          12,
          13,
          14,
          5
        ],
        [
          11,
          16,
          15,
          6
        ],
        [
          10,
          9,
          8,
          7
        ]
      ]
    },
    {
      "array": [
        [
          1
        ]
      ]
    },
    {
      "array": [
        [
          1,
          2
        ],
        [
          4,
          3
        ]
      ]
    },
    {
      "array": [
        [
          1,
          2,
          3
        ],
        [
          8,
          9,
          4
        ],
        [
          7,
          6,
          5
        ]
      ]
    },
    {
      "array": [
        [
          19,
          32,
          33,
          34,
          25,
          8
        ],
        [
          16,
          15,
          14,
          13,
          12,
          11
        ],
        [
          18,
          31,
          36,
          35,
          26,
          9
        ],
        [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        [
          20,
          21,
          22,
          23,
          24,
          7
        ],
        [
          17,
          30,
          29,
          28,
          27,
          10
        ]
      ]
    },
    {
      "array": [
        [
          4,
          2,
          3,
          6,
          7,
          8,
          1,
          9,
          5,
          10
        ],
        [
          12,
          19,
          15,
          16,
          20,
          18,
          13,
          17,
          11,
          14
        ]
      ]
    },
    {
      "array": [
        [
          27,
          12,
          35,
          26
        ],
        [
          25,
          21,
          94,
          11
        ],
        [
          19,
          96,
          43,
          56
        ],
        [
          55,
          36,
          10,
          18
        ],
        [
          96,
          83,
          31,
          94
        ],
        [
          93,
          11,
          90,
          16
        ]
      ]
    },
    {
      "array": [
        [
          1,
          2,
          3,
          4
        ],
        [
          10,
          11,
          12,
          5
        ],
        [
          9,
          8,
          7,
          6
        ]
      ]
    },
    {
      "array": [
        [
          1,
          2,
          3
        ],
        [
          12,
          13,
          4
        ],
        [
          11,
          14,
          5
        ],
        [
          10,
          15,
          6
        ],
        [
          9,
          8,
          7
        ]
      ]
    },
    {
      "array": [
        [
          1,
          11
        ],
        [
          2,
          12
        ],
        [
          3,
          13
        ],
        [
          4,
          14
        ],
        [
          5,
          15
        ],
        [
          6,
          16
        ],
        [
          7,
          17
        ],
        [
          8,
          18
        ],
        [
          9,
          19
        ],
        [
          10,
          20
        ]
      ]
    },
    {
      "array": [
        [
          1,
          3,
          2,
          5,
          4,
          7,
          6
        ]
      ]
    },
    {
      "array": [
        [
          1
        ],
        [
          3
        ],
        [
          2
        ],
        [
          5
        ],
        [
          4
        ],
        [
          7
        ],
        [
          6
        ]
      ]
    }
  ],
  "changelog": []
}