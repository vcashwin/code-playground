{
  "uid": "sum-of-linked-lists",
  "testStrategy": "JSON",
  "name": "Sum of Linked Lists",
  "version": 0,
  "releaseDate": "2021-02-08T00:00:00Z",
  "category": "Linked Lists",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 22742,
    "failureCount": 6099
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "509341782",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 1376
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given two Linked Lists of potentially unequal length. Each Linked List\n  represents a non-negative integer, where each node in the Linked List is a\n  digit of that integer, and the first node in each Linked List always\n  represents the least significant digit of the integer. Write a function that\n  returns the head of a new Linked List that represents the sum of the integers\n  represented by the two input Linked Lists.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it's the tail of the list. The\n  <span>value</span> of each <span>LinkedList</span> node is always in the range\n  of <span>0 - 9</span>.\n</p>\n<p>\n  Note: your function must create and return a new Linked List, and you're not\n  allowed to modify either of the input Linked Lists.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">linkedListOne</span> = 2 -> 4 -> 7 -> 1\n<span class=\"CodeEditor-promptParameter\">linkedListTwo</span> = 9 -> 4 -> 5\n</pre>\n<h3>Sample Output</h3>\n<pre>\n1 -> 9 -> 2 -> 2\n<span class=\"CodeEditor-promptComment\">// linkedListOne represents 1742</span>\n<span class=\"CodeEditor-promptComment\">// linkedListTwo represents 549</span>\n<span class=\"CodeEditor-promptComment\">// 1742 + 549 = 2291</span>\n</pre>\n</div>",
  "hints": [
    "<p>\n  If you can determine the integers that each individual Linked List represents,\n  then all you need to do is add these integers and create a new Linked List\n  that represents the summed value.\n</p>\n",
    "\n<p>\n  If you go with the approach mentioned in Hint #1, you'll need to break down\n  the sum of the two Linked Lists' numbers into its individual digits. Once you\n  know these digits, you can create a new Linked List using them. This approach\n  is <i>fine</i>, but you can solve this problem more elegantly, with a single\n  iteration through the Linked Lists.\n</p>\n",
    "\n<p>\n  Is it necessary to know the entire numbers represented by both Linked Lists in\n  order to calculate their sum? Think back to your elementary-school math class;\n  how did you add two numbers together?\n</p>\n",
    "\n<p>\n  Since each Linked List's digits are ordered from least significant digit to\n  most significant digit, you can simply loop through both Linked Lists,\n  consider the digits with the same significance, and add these digits together\n  while keeping track of any <i>carry</i> that comes out of the addition. At\n  each iteration, when you add the two Linked List digits, also add the carry\n  from the previous iteration. Create a new Linked List node that stores the\n  calculated value, and add that to your new Linked List. Keep iterating until\n  you reach the end of both Linked Lists and have no remaining carry.\n</p>"
  ],
  "spaceTime": "O(max(n, m)) time | O(max(n, m)) space - where n is the length of the first Linked List and m is the length of the second Linked List",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": "linkedlist",
    "outputType": "linkedlist"
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is an input struct. Do not edit.\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next = nullptr;\n\n  LinkedList(int value) { this->value = value; }\n};\n\nLinkedList* sumOfLinkedLists(\n  LinkedList* linkedListOne, LinkedList* linkedListTwo\n) {\n  // Write your code here.\n  return nullptr;\n}",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// This is an input struct. Do not edit.\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next = nullptr;\n\n  LinkedList(int value) { this->value = value; }\n};\n\n// O(max(n, m)) time | O(max(n, m)) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nLinkedList* sumOfLinkedLists(\n  LinkedList* linkedListOne, LinkedList* linkedListTwo\n) {\n  // This variable will store a dummy node whose .next\n  // attribute will point to the head of our new LL.\n  auto newLinkedListHeadPointer = new LinkedList(0);\n  auto currentNode = newLinkedListHeadPointer;\n  int carry = 0;\n\n  auto nodeOne = linkedListOne;\n  auto nodeTwo = linkedListTwo;\n  while (nodeOne != nullptr || nodeTwo != nullptr || carry != 0) {\n    int valueOne = nodeOne != nullptr ? nodeOne->value : 0;\n    int valueTwo = nodeTwo != nullptr ? nodeTwo->value : 0;\n    int sumOfValues = valueOne + valueTwo + carry;\n\n    int newValue = sumOfValues % 10;\n    auto newNode = new LinkedList(newValue);\n    currentNode->next = newNode;\n    currentNode = newNode;\n\n    carry = sumOfValues / 10;\n    nodeOne = nodeOne != nullptr ? nodeOne->next : nullptr;\n    nodeTwo = nodeTwo != nullptr ? nodeTwo->next : nullptr;\n  }\n\n  return newLinkedListHeadPointer->next;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nLinkedList* addMany(LinkedList* linkedList, vector<int> values);\nvector<int> getNodesInArray(LinkedList* linkedList);\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto ll1 = addMany(new LinkedList(2), {4, 7, 1});\n      auto ll2 = addMany(new LinkedList(9), {4, 5});\n      auto expected = addMany(new LinkedList(1), {9, 2, 2});\n      auto actual = sumOfLinkedLists(ll1, ll2);\n      assert(getNodesInArray(actual) == getNodesInArray(expected));\n    });\n  }\n};\n\nLinkedList* addMany(LinkedList* linkedList, vector<int> values) {\n  auto current = linkedList;\n  while (current->next != nullptr) {\n    current = current->next;\n  }\n  for (int value : values) {\n    current->next = new LinkedList(value);\n    current = current->next;\n  }\n  return linkedList;\n}\n\nvector<int> getNodesInArray(LinkedList* linkedList) {\n  vector<int> nodes;\n  auto current = linkedList;\n  while (current != nullptr) {\n    nodes.push_back(current->value);\n    current = current->next;\n  }\n  return nodes;\n}\n",
      "unitTests": "LinkedList* addMany(LinkedList* linkedList, vector<int> values);\nvector<int> getNodesInArray(LinkedList* linkedList);\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto ll1 = addMany(new LinkedList(2), {4, 7, 1});\n      auto ll2 = addMany(new LinkedList(9), {4, 5});\n      auto expected = addMany(new LinkedList(1), {9, 2, 2});\n      auto actual = sumOfLinkedLists(ll1, ll2);\n      assert(getNodesInArray(actual) == getNodesInArray(expected));\n    });\n  }\n};\n\nLinkedList* addMany(LinkedList* linkedList, vector<int> values) {\n  auto current = linkedList;\n  while (current->next != nullptr) {\n    current = current->next;\n  }\n  for (int value : values) {\n    current->next = new LinkedList(value);\n    current = current->next;\n  }\n  return linkedList;\n}\n\nvector<int> getNodesInArray(LinkedList* linkedList) {\n  vector<int> nodes;\n  auto current = linkedList;\n  while (current != nullptr) {\n    nodes.push_back(current->value);\n    current = current->next;\n  }\n  return nodes;\n}\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  public LinkedList SumOfLinkedLists(\n    LinkedList linkedListOne, LinkedList linkedListTwo\n  ) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n  // O(max(n, m)) time | O(max(n, m)) space - where n is the length of the\n  // first Linked List and m is the length of the second Linked List\n  public LinkedList SumOfLinkedLists(\n    LinkedList linkedListOne, LinkedList linkedListTwo\n  ) {\n    // This variable will store a dummy node whose .next\n    // attribute will point to the head of our new LL.\n    LinkedList newLinkedListHeadPointer = new LinkedList(0);\n    LinkedList currentNode = newLinkedListHeadPointer;\n    int carry = 0;\n\n    LinkedList nodeOne = linkedListOne;\n    LinkedList nodeTwo = linkedListTwo;\n\n    while (nodeOne != null || nodeTwo != null || carry != 0) {\n      int valueOne = (nodeOne != null) ? nodeOne.value : 0;\n      int valueTwo = (nodeTwo != null) ? nodeTwo.value : 0;\n      int sumOfValues = valueOne + valueTwo + carry;\n\n      int newValue = sumOfValues % 10;\n      LinkedList newNode = new LinkedList(newValue);\n      currentNode.next = newNode;\n      currentNode = newNode;\n\n      carry = sumOfValues / 10;\n      nodeOne = (nodeOne != null) ? nodeOne.next : null;\n      nodeTwo = (nodeTwo != null) ? nodeTwo.next : null;\n    }\n\n    return newLinkedListHeadPointer.next;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\n// AE_WRAPPER_V2\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.LinkedList ll1 =\n      addMany(new Program.LinkedList(2), new int[] { 4, 7, 1 });\n    Program.LinkedList ll2 =\n      addMany(new Program.LinkedList(9), new int[] { 4, 5 });\n    Program.LinkedList expected =\n      addMany(new Program.LinkedList(1), new int[] { 9, 2, 2 });\n    var actual = new Program().SumOfLinkedLists(ll1, ll2);\n    Utils.AssertTrue(Enumerable.SequenceEqual(\n      getNodesInArray(expected), getNodesInArray(actual)\n    ));\n  }\n\n  public Program\n    .LinkedList addMany(Program.LinkedList linkedList, int[] values) {\n    var current = linkedList;\n    while (current.next != null) {\n      current = current.next;\n    }\n    foreach (var value in values) {\n      current.next = new Program.LinkedList(value);\n      current = current.next;\n    }\n    return linkedList;\n  }\n\n  public List<int> getNodesInArray(Program.LinkedList linkedList) {\n    List<int> nodeValues = new List<int>();\n    Program.LinkedList current = linkedList;\n    while (current != null) {\n      nodeValues.Add(current.value);\n      current = current.next;\n    }\n    return nodeValues;\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\n// AE_WRAPPER_V2\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.LinkedList ll1 =\n      addMany(new Program.LinkedList(2), new int[] { 4, 7, 1 });\n    Program.LinkedList ll2 =\n      addMany(new Program.LinkedList(9), new int[] { 4, 5 });\n    Program.LinkedList expected =\n      addMany(new Program.LinkedList(1), new int[] { 9, 2, 2 });\n    var actual = new Program().SumOfLinkedLists(ll1, ll2);\n    Utils.AssertTrue(Enumerable.SequenceEqual(\n      getNodesInArray(expected), getNodesInArray(actual)\n    ));\n  }\n\n  public Program\n    .LinkedList addMany(Program.LinkedList linkedList, int[] values) {\n    var current = linkedList;\n    while (current.next != null) {\n      current = current.next;\n    }\n    foreach (var value in values) {\n      current.next = new Program.LinkedList(value);\n      current = current.next;\n    }\n    return linkedList;\n  }\n\n  public List<int> getNodesInArray(Program.LinkedList linkedList) {\n    List<int> nodeValues = new List<int>();\n    Program.LinkedList current = linkedList;\n    while (current != null) {\n      nodeValues.Add(current.value);\n      current = current.next;\n    }\n    return nodeValues;\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is an input struct. Do not edit.\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\nfunc SumOfLinkedLists(linkedListOne *LinkedList, linkedListTwo *LinkedList) *LinkedList {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input struct. Do not edit.\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\n// O(max(n, m)) time | O(max(n, m)) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfunc SumOfLinkedLists(linkedListOne *LinkedList, linkedListTwo *LinkedList) *LinkedList {\n\t// This variable will store a dummy node whose .next\n\t// attribute will point to the head of our new LL.\n\tnewLinkedListHeadPointer := &LinkedList{Value: 0}\n\tcurrentNode := newLinkedListHeadPointer\n\tcarry := 0\n\n\tnodeOne := linkedListOne\n\tnodeTwo := linkedListTwo\n\tfor nodeOne != nil || nodeTwo != nil || carry != 0 {\n\t\tvar valueOne, valueTwo int\n\t\tif nodeOne != nil {\n\t\t\tvalueOne = nodeOne.Value\n\t\t}\n\t\tif nodeTwo != nil {\n\t\t\tvalueTwo = nodeTwo.Value\n\t\t}\n\t\tsumOfValues := valueOne + valueTwo + carry\n\n\t\tnewValue := sumOfValues % 10\n\t\tnewNode := &LinkedList{Value: newValue}\n\t\tcurrentNode.Next = newNode\n\t\tcurrentNode = newNode\n\n\t\tcarry = sumOfValues / 10\n\t\tif nodeOne != nil {\n\t\t\tnodeOne = nodeOne.Next\n\t\t}\n\t\tif nodeTwo != nil {\n\t\t\tnodeTwo = nodeTwo.Next\n\t\t}\n\t}\n\n\treturn newLinkedListHeadPointer.Next\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tll1 := addMany(&LinkedList{Value: 2}, []int{4, 7, 1})\n\tll2 := addMany(&LinkedList{Value: 9}, []int{4, 5})\n\texpected := addMany(&LinkedList{Value: 1}, []int{9, 2, 2})\n\tactual := SumOfLinkedLists(ll1, ll2)\n\trequire.Equal(t, expected, actual)\n}\n\nfunc addMany(linkedList *LinkedList, values []int) *LinkedList {\n\tcurrent := linkedList\n\tfor current.Next != nil {\n\t\tcurrent = current.Next\n\t}\n\tfor _, value := range values {\n\t\tcurrent.Next = &LinkedList{Value: value}\n\t\tcurrent = current.Next\n\t}\n\treturn linkedList\n}\n\nfunc getValues(linkedList *LinkedList) []int {\n\tvalues := []int{}\n\tcurrent := linkedList\n\tfor current != nil {\n\t\tvalues = append(values, current.Value)\n\t\tcurrent = current.Next\n\t}\n\treturn values\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tll1 := addMany(&LinkedList{Value: 2}, []int{4, 7, 1})\n\tll2 := addMany(&LinkedList{Value: 9}, []int{4, 5})\n\texpected := addMany(&LinkedList{Value: 1}, []int{9, 2, 2})\n\tactual := SumOfLinkedLists(ll1, ll2)\n\trequire.Equal(t, expected, actual)\n}\n\nfunc addMany(linkedList *LinkedList, values []int) *LinkedList {\n\tcurrent := linkedList\n\tfor current.Next != nil {\n\t\tcurrent = current.Next\n\t}\n\tfor _, value := range values {\n\t\tcurrent.Next = &LinkedList{Value: value}\n\t\tcurrent = current.Next\n\t}\n\treturn linkedList\n}\n\nfunc getValues(linkedList *LinkedList) []int {\n\tvalues := []int{}\n\tcurrent := linkedList\n\tfor current != nil {\n\t\tvalues = append(values, current.Value)\n\t\tcurrent = current.Next\n\t}\n\treturn values\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  public static class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  public LinkedList sumOfLinkedLists(\n    LinkedList linkedListOne, LinkedList linkedListTwo\n  ) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  public static class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n  // O(max(n, m)) time | O(max(n, m)) space - where n is the length of the\n  // first Linked List and m is the length of the second Linked List\n  public LinkedList sumOfLinkedLists(\n    LinkedList linkedListOne, LinkedList linkedListTwo\n  ) {\n    // This variable will store a dummy node whose .next\n    // attribute will point to the head of our new LL.\n    LinkedList newLinkedListHeadPointer = new LinkedList(0);\n    LinkedList currentNode = newLinkedListHeadPointer;\n    int carry = 0;\n\n    LinkedList nodeOne = linkedListOne;\n    LinkedList nodeTwo = linkedListTwo;\n\n    while (nodeOne != null || nodeTwo != null || carry != 0) {\n      int valueOne = (nodeOne != null) ? nodeOne.value : 0;\n      int valueTwo = (nodeTwo != null) ? nodeTwo.value : 0;\n      int sumOfValues = valueOne + valueTwo + carry;\n\n      int newValue = sumOfValues % 10;\n      LinkedList newNode = new LinkedList(newValue);\n      currentNode.next = newNode;\n      currentNode = newNode;\n\n      carry = sumOfValues / 10;\n      nodeOne = (nodeOne != null) ? nodeOne.next : null;\n      nodeTwo = (nodeTwo != null) ? nodeTwo.next : null;\n    }\n\n    return newLinkedListHeadPointer.next;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n// AE_WRAPPER_V2\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.LinkedList ll1 =\n      addMany(new Program.LinkedList(2), new int[] {4, 7, 1});\n    Program.LinkedList ll2 =\n      addMany(new Program.LinkedList(9), new int[] {4, 5});\n    Program.LinkedList expected =\n      addMany(new Program.LinkedList(1), new int[] {9, 2, 2});\n    var actual = new Program().sumOfLinkedLists(ll1, ll2);\n    Utils.assertTrue(getNodesInArray(expected).equals(getNodesInArray(actual)));\n  }\n\n  public Program.LinkedList addMany(\n    Program.LinkedList linkedList, int[] values\n  ) {\n    var current = linkedList;\n    while (current.next != null) {\n      current = current.next;\n    }\n    for (var value : values) {\n      current.next = new Program.LinkedList(value);\n      current = current.next;\n    }\n    return linkedList;\n  }\n\n  public ArrayList<Integer> getNodesInArray(Program.LinkedList linkedList) {\n    ArrayList<Integer> nodeValues = new ArrayList<Integer>();\n    Program.LinkedList current = linkedList;\n    while (current != null) {\n      nodeValues.add(current.value);\n      current = current.next;\n    }\n    return nodeValues;\n  }\n}\n",
      "unitTests": "// AE_WRAPPER_V2\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.LinkedList ll1 =\n      addMany(new Program.LinkedList(2), new int[] {4, 7, 1});\n    Program.LinkedList ll2 =\n      addMany(new Program.LinkedList(9), new int[] {4, 5});\n    Program.LinkedList expected =\n      addMany(new Program.LinkedList(1), new int[] {9, 2, 2});\n    var actual = new Program().sumOfLinkedLists(ll1, ll2);\n    Utils.assertTrue(getNodesInArray(expected).equals(getNodesInArray(actual)));\n  }\n\n  public Program.LinkedList addMany(\n    Program.LinkedList linkedList, int[] values\n  ) {\n    var current = linkedList;\n    while (current.next != null) {\n      current = current.next;\n    }\n    for (var value : values) {\n      current.next = new Program.LinkedList(value);\n      current = current.next;\n    }\n    return linkedList;\n  }\n\n  public ArrayList<Integer> getNodesInArray(Program.LinkedList linkedList) {\n    ArrayList<Integer> nodeValues = new ArrayList<Integer>();\n    Program.LinkedList current = linkedList;\n    while (current != null) {\n      nodeValues.add(current.value);\n      current = current.next;\n    }\n    return nodeValues;\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction sumOfLinkedLists(linkedListOne, linkedListTwo) {\n  // Write your code here.\n  return linkedListOne;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.sumOfLinkedLists = sumOfLinkedLists;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(max(n, m)) time | O(max(n, m)) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfunction sumOfLinkedLists(linkedListOne, linkedListTwo) {\n  // This variable will store a dummy node whose .next\n  // attribute will point to the head of our new LL.\n  const newLinkedListHeadPointer = new LinkedList(0);\n  let currentNode = newLinkedListHeadPointer;\n  let carry = 0;\n\n  let nodeOne = linkedListOne;\n  let nodeTwo = linkedListTwo;\n  while (nodeOne !== null || nodeTwo !== null || carry !== 0) {\n    const valueOne = nodeOne !== null ? nodeOne.value : 0;\n    const valueTwo = nodeTwo !== null ? nodeTwo.value : 0;\n    const sumOfValues = valueOne + valueTwo + carry;\n\n    const newValue = sumOfValues % 10;\n    const newNode = new LinkedList(newValue);\n    currentNode.next = newNode;\n    currentNode = newNode;\n\n    carry = Math.floor(sumOfValues / 10);\n    nodeOne = nodeOne !== null ? nodeOne.next : null;\n    nodeTwo = nodeTwo !== null ? nodeTwo.next : null;\n  }\n\n  return newLinkedListHeadPointer.next;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.sumOfLinkedLists = sumOfLinkedLists;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n}\n\nfunction getNodesInArray(linkedList) {\n  const nodes = [];\n  let current = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n\nit('Test Case #1', function () {\n  const ll1 = new LinkedList(2).addMany([4, 7, 1]);\n  const ll2 = new LinkedList(9).addMany([4, 5]);\n  const expected = new LinkedList(1).addMany([9, 2, 2]);\n  const actual = program.sumOfLinkedLists(ll1, ll2);\n  chai.expect(getNodesInArray(actual)).to.deep.equal(getNodesInArray(expected));\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n}\n\nfunction getNodesInArray(linkedList) {\n  const nodes = [];\n  let current = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n\nit('Test Case #1', function () {\n  const ll1 = new LinkedList(2).addMany([4, 7, 1]);\n  const ll2 = new LinkedList(9).addMany([4, 5]);\n  const expected = new LinkedList(1).addMany([9, 2, 2]);\n  const actual = program.sumOfLinkedLists(ll1, ll2);\n  chai.expect(getNodesInArray(actual)).to.deep.equal(getNodesInArray(expected));\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\nfun sumOfLinkedLists(linkedListOne: LinkedList, linkedListTwo: LinkedList): LinkedList {\n    // Write your code here.\n    return linkedListOne\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\n// O(max(n, m)) time | O(max(n, m)) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfun sumOfLinkedLists(linkedListOne: LinkedList, linkedListTwo: LinkedList): LinkedList {\n    // This variable will store a dummy node whose .next\n    // attribute will point to the head of our new LL.\n    val newLinkedListHeadPointer = LinkedList(0)\n    var currentNode = newLinkedListHeadPointer\n    var carry = 0\n\n    var nodeOne: LinkedList? = linkedListOne\n    var nodeTwo: LinkedList? = linkedListTwo\n    while (nodeOne != null || nodeTwo != null || carry != 0) {\n        val valueOne = if (nodeOne != null) nodeOne.value else 0\n        val valueTwo = if (nodeTwo != null) nodeTwo.value else 0\n        val sumOfValues = valueOne + valueTwo + carry\n\n        val newValue = sumOfValues % 10\n        val newNode = LinkedList(newValue)\n        currentNode.next = newNode\n        currentNode = newNode\n\n        carry = sumOfValues / 10\n        nodeOne = if (nodeOne != null) nodeOne.next else null\n        nodeTwo = if (nodeTwo != null) nodeTwo.next else null\n    }\n\n    return newLinkedListHeadPointer.next!!\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.LinkedList\nimport com.algoexpert.program.sumOfLinkedLists\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val ll1 = addMany(LinkedList(2), listOf(4, 7, 1))\n        val ll2 = addMany(LinkedList(9), listOf(4, 5))\n        val expected = addMany(LinkedList(1), listOf(9, 2, 2))\n        val output = sumOfLinkedLists(ll1, ll2)\n        assert(getNodesInArray(expected) == getNodesInArray(output))\n    }\n}\n\nfun addMany(linkedList: LinkedList, values: List<Int>): LinkedList {\n    var current = linkedList\n    while (current.next != null) {\n        current = current.next!!\n    }\n    for (value in values) {\n        current.next = LinkedList(value)\n        current = current.next!!\n    }\n    return linkedList\n}\n\nfun getNodesInArray(linkedList: LinkedList?): List<Int> {\n    val nodes = mutableListOf<Int>()\n    var current: LinkedList? = linkedList\n    while (current != null) {\n        nodes.add(current.value)\n        current = current.next\n    }\n    return nodes\n}\n",
      "unitTests": "import com.algoexpert.program.LinkedList\nimport com.algoexpert.program.sumOfLinkedLists\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val ll1 = addMany(LinkedList(2), listOf(4, 7, 1))\n        val ll2 = addMany(LinkedList(9), listOf(4, 5))\n        val expected = addMany(LinkedList(1), listOf(9, 2, 2))\n        val output = sumOfLinkedLists(ll1, ll2)\n        assert(getNodesInArray(expected) == getNodesInArray(output))\n    }\n}\n\nfun addMany(linkedList: LinkedList, values: List<Int>): LinkedList {\n    var current = linkedList\n    while (current.next != null) {\n        current = current.next!!\n    }\n    for (value in values) {\n        current.next = LinkedList(value)\n        current = current.next!!\n    }\n    return linkedList\n}\n\nfun getNodesInArray(linkedList: LinkedList?): List<Int> {\n    val nodes = mutableListOf<Int>()\n    var current: LinkedList? = linkedList\n    while (current != null) {\n        nodes.add(current.value)\n        current = current.next\n    }\n    return nodes\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\ndef sumOfLinkedLists(linkedListOne, linkedListTwo):\n    # Write your code here.\n    return linkedListOne\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\n# O(max(n, m)) time | O(max(n, m)) space - where n is the length of the\n# first Linked List and m is the length of the second Linked List\ndef sumOfLinkedLists(linkedListOne, linkedListTwo):\n    # This variable will store a dummy node whose .next\n    # attribute will point to the head of our new LL.\n    newLinkedListHeadPointer = LinkedList(0)\n    currentNode = newLinkedListHeadPointer\n    carry = 0\n\n    nodeOne = linkedListOne\n    nodeTwo = linkedListTwo\n    while nodeOne is not None or nodeTwo is not None or carry != 0:\n        valueOne = nodeOne.value if nodeOne is not None else 0\n        valueTwo = nodeTwo.value if nodeTwo is not None else 0\n        sumOfValues = valueOne + valueTwo + carry\n\n        newValue = sumOfValues % 10\n        newNode = LinkedList(newValue)\n        currentNode.next = newNode\n        currentNode = newNode\n\n        carry = sumOfValues // 10\n        nodeOne = nodeOne.next if nodeOne is not None else None\n        nodeTwo = nodeTwo.next if nodeTwo is not None else None\n\n    return newLinkedListHeadPointer.next\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass LinkedList(program.LinkedList):\n    def addMany(self, values):\n        current = self\n        while current.next is not None:\n            current = current.next\n        for value in values:\n            current.next = LinkedList(value)\n            current = current.next\n        return self\n\n\ndef getNodesInArray(output):\n    nodes = []\n    current = output\n    while current is not None:\n        nodes.append(current.value)\n        current = current.next\n    return nodes\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        ll1 = LinkedList(2).addMany([4, 7, 1])\n        ll2 = LinkedList(9).addMany([4, 5])\n        expected = LinkedList(1).addMany([9, 2, 2])\n        actual = program.sumOfLinkedLists(ll1, ll2)\n        self.assertEqual(getNodesInArray(actual), getNodesInArray(expected))\n",
      "unitTests": "import program\nimport unittest\n\n\nclass LinkedList(program.LinkedList):\n    def addMany(self, values):\n        current = self\n        while current.next is not None:\n            current = current.next\n        for value in values:\n            current.next = LinkedList(value)\n            current = current.next\n        return self\n\n\ndef getNodesInArray(output):\n    nodes = []\n    current = output\n    while current is not None:\n        nodes.append(current.value)\n        current = current.next\n    return nodes\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        ll1 = LinkedList(2).addMany([4, 7, 1])\n        ll2 = LinkedList(9).addMany([4, 5])\n        expected = LinkedList(1).addMany([9, 2, 2])\n        actual = program.sumOfLinkedLists(ll1, ll2)\n        self.assertEqual(getNodesInArray(actual), getNodesInArray(expected))\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "# This is an input struct. Do not edit.\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\nclass Program\n  def sumOfLinkedLists(linkedListOne, linkedListTwo)\n    # Write your code here.\n    return nil\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\nclass Program\n  def sumOfLinkedLists(linkedListOne, linkedListTwo)\n    # Write your code here.\n    return nil\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.sumOfLinkedLists\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.sumOfLinkedLists\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class LinkedList {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  func sumOfLinkedLists(_ linkedListOne: LinkedList, _ linkedListTwo: LinkedList) -> LinkedList? {\n    // Write your code here.\n    return nil\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class LinkedList {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  // O(max(n, m)) time | O(max(n, m)) space - where n is the length of the\n  // first Linked List and m is the length of the second Linked List\n  func sumOfLinkedLists(_ linkedListOne: LinkedList, _ linkedListTwo: LinkedList) -> LinkedList {\n    // This variable will store a dummy node whose .next\n    // attribute will point to the head of our new LL.\n    var newLinkedListHeadPointer = LinkedList(value: 0)\n    var currentNode = newLinkedListHeadPointer\n    var carry = 0\n\n    var nodeOne: LinkedList? = linkedListOne\n    var nodeTwo: LinkedList? = linkedListTwo\n    while nodeOne != nil || nodeTwo != nil || carry != 0 {\n      var valueOne = 0\n      var valueTwo = 0\n      if nodeOne != nil {\n        valueOne = nodeOne!.value\n      }\n      if nodeTwo != nil {\n        valueTwo = nodeTwo!.value\n      }\n      let sumOfValues = valueOne + valueTwo + carry\n\n      let newValue = sumOfValues % 10\n      let newNode = LinkedList(value: newValue)\n      currentNode.next = newNode\n      currentNode = newNode\n\n      carry = sumOfValues / 10\n      if nodeOne != nil {\n        nodeOne = nodeOne!.next\n      }\n      if nodeTwo != nil {\n        nodeTwo = nodeTwo!.next\n      }\n    }\n\n    return newLinkedListHeadPointer.next!\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var ll1 = addMany(Program.LinkedList(value: 2), [4, 7, 1])\n      var ll2 = addMany(Program.LinkedList(value: 9), [4, 5])\n      var expected = addMany(Program.LinkedList(value: 1), [9, 2, 2])\n      var actual = Program().sumOfLinkedLists(ll1, ll2)\n      try assertEqual(getValues(expected), getValues(actual))\n    }\n  }\n\n  func addMany(_ linkedList: Program.LinkedList, _ values: [Int]) -> Program.LinkedList {\n    var current: Program.LinkedList = linkedList\n    while current.next != nil {\n      current = current.next!\n    }\n    for value in values {\n      current.next = Program.LinkedList(value: value)\n      current = current.next!\n    }\n    return linkedList\n  }\n\n  func getValues(_ linkedList: Program.LinkedList) -> [Int] {\n    var values = [Int]()\n    var current: Program.LinkedList? = linkedList\n    while current != nil {\n      values.append(current!.value)\n      current = current!.next\n    }\n    return values\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var ll1 = addMany(Program.LinkedList(value: 2), [4, 7, 1])\n      var ll2 = addMany(Program.LinkedList(value: 9), [4, 5])\n      var expected = addMany(Program.LinkedList(value: 1), [9, 2, 2])\n      var actual = Program().sumOfLinkedLists(ll1, ll2)\n      try assertEqual(getValues(expected), getValues(actual))\n    }\n  }\n\n  func addMany(_ linkedList: Program.LinkedList, _ values: [Int]) -> Program.LinkedList {\n    var current: Program.LinkedList = linkedList\n    while current.next != nil {\n      current = current.next!\n    }\n    for value in values {\n      current.next = Program.LinkedList(value: value)\n      current = current.next!\n    }\n    return linkedList\n  }\n\n  func getValues(_ linkedList: Program.LinkedList) -> [Int] {\n    var values = [Int]()\n    var current: Program.LinkedList? = linkedList\n    while current != nil {\n      values.append(current!.value)\n      current = current!.next\n    }\n    return values\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nexport function sumOfLinkedLists(linkedListOne: LinkedList, linkedListTwo: LinkedList) {\n  // Write your code here.\n  return linkedListOne;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(max(n, m)) time | O(max(n, m)) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nexport function sumOfLinkedLists(linkedListOne: LinkedList, linkedListTwo: LinkedList) {\n  // This variable will store a dummy node whose .next\n  // attribute will point to the head of our new LL.\n  const newLinkedListHeadPointer = new LinkedList(0);\n  let currentNode = newLinkedListHeadPointer;\n  let carry = 0;\n\n  let nodeOne: LinkedList | null = linkedListOne;\n  let nodeTwo: LinkedList | null = linkedListTwo;\n  while (nodeOne !== null || nodeTwo !== null || carry !== 0) {\n    const valueOne = nodeOne !== null ? nodeOne.value : 0;\n    const valueTwo = nodeTwo !== null ? nodeTwo.value : 0;\n    const sumOfValues = valueOne + valueTwo + carry;\n\n    const newValue = sumOfValues % 10;\n    const newNode = new LinkedList(newValue);\n    currentNode.next = newNode;\n    currentNode = newNode;\n\n    carry = Math.floor(sumOfValues / 10);\n    nodeOne = nodeOne !== null ? nodeOne.next : null;\n    nodeTwo = nodeTwo !== null ? nodeTwo.next : null;\n  }\n\n  return newLinkedListHeadPointer.next;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const ll1 = addMany(new program.LinkedList(2), [4, 7, 1]);\n  const ll2 = addMany(new program.LinkedList(9), [4, 5]);\n  const expected = addMany(new program.LinkedList(1), [9, 2, 2]);\n  const actual = program.sumOfLinkedLists(ll1, ll2);\n  chai.expect(getNodesInArray(actual)).to.deep.equal(getNodesInArray(expected));\n});\n\nfunction addMany(linkedList: program.LinkedList, values: number[]) {\n  let current = linkedList;\n  while (current.next !== null) {\n    current = current.next;\n  }\n  for (const value of values) {\n    current.next = new program.LinkedList(value);\n    current = current.next;\n  }\n  return linkedList;\n}\n\nfunction getNodesInArray(linkedList: program.LinkedList | null) {\n  const nodes: number[] = [];\n  let current: program.LinkedList | null = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const ll1 = addMany(new program.LinkedList(2), [4, 7, 1]);\n  const ll2 = addMany(new program.LinkedList(9), [4, 5]);\n  const expected = addMany(new program.LinkedList(1), [9, 2, 2]);\n  const actual = program.sumOfLinkedLists(ll1, ll2);\n  chai.expect(getNodesInArray(actual)).to.deep.equal(getNodesInArray(expected));\n});\n\nfunction addMany(linkedList: program.LinkedList, values: number[]) {\n  let current = linkedList;\n  while (current.next !== null) {\n    current = current.next;\n  }\n  for (const value of values) {\n    current.next = new program.LinkedList(value);\n    current = current.next;\n  }\n  return linkedList;\n}\n\nfunction getNodesInArray(linkedList: program.LinkedList | null) {\n  const nodes: number[] = [];\n  let current: program.LinkedList | null = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n"
    }
  },
  "customInputVars": [
    {
      "name": "linkedListOne",
      "example": {
        "head": "2",
        "nodes": [
          {
            "id": "2",
            "next": "4",
            "value": 2
          },
          {
            "id": "4",
            "next": "7",
            "value": 4
          },
          {
            "id": "7",
            "next": "1",
            "value": 7
          },
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      },
      "schema": {
        "description": "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
        "properties": {
          "head": {
            "type": "string"
          },
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "next": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "next"
              ],
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "head",
          "nodes"
        ],
        "type": "object"
      }
    },
    {
      "name": "linkedListTwo",
      "example": {
        "head": "9",
        "nodes": [
          {
            "id": "9",
            "next": "4",
            "value": 9
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": null,
            "value": 5
          }
        ]
      },
      "schema": {
        "description": "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
        "properties": {
          "head": {
            "type": "string"
          },
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "next": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "next"
              ],
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "head",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "linkedListOne": {
        "head": "2",
        "nodes": [
          {
            "id": "2",
            "next": "4",
            "value": 2
          },
          {
            "id": "4",
            "next": "7",
            "value": 4
          },
          {
            "id": "7",
            "next": "1",
            "value": 7
          },
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      },
      "linkedListTwo": {
        "head": "9",
        "nodes": [
          {
            "id": "9",
            "next": "4",
            "value": 9
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": null,
            "value": 5
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "2",
        "nodes": [
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      },
      "linkedListTwo": {
        "head": "9",
        "nodes": [
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "0-2",
            "value": 0
          },
          {
            "id": "0-2",
            "next": "0-3",
            "value": 0
          },
          {
            "id": "0-3",
            "next": "5",
            "value": 0
          },
          {
            "id": "5",
            "next": null,
            "value": 5
          }
        ]
      },
      "linkedListTwo": {
        "head": "9",
        "nodes": [
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "1-2",
            "value": 1
          },
          {
            "id": "1-2",
            "next": "1-3",
            "value": 1
          },
          {
            "id": "1-3",
            "next": null,
            "value": 1
          }
        ]
      },
      "linkedListTwo": {
        "head": "9",
        "nodes": [
          {
            "id": "9",
            "next": "9-2",
            "value": 9
          },
          {
            "id": "9-2",
            "next": "9-3",
            "value": 9
          },
          {
            "id": "9-3",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": null,
            "value": 3
          }
        ]
      },
      "linkedListTwo": {
        "head": "6",
        "nodes": [
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "9",
            "value": 7
          },
          {
            "id": "9",
            "next": "1",
            "value": 9
          },
          {
            "id": "1",
            "next": "8",
            "value": 1
          },
          {
            "id": "8",
            "next": null,
            "value": 8
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": null,
            "value": 0
          }
        ]
      },
      "linkedListTwo": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": null,
            "value": 0
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": null,
            "value": 0
          }
        ]
      },
      "linkedListTwo": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "0-2",
            "value": 0
          },
          {
            "id": "0-2",
            "next": "0-3",
            "value": 0
          },
          {
            "id": "0-3",
            "next": "0-4",
            "value": 0
          },
          {
            "id": "0-4",
            "next": "0-5",
            "value": 0
          },
          {
            "id": "0-5",
            "next": "8",
            "value": 0
          },
          {
            "id": "8",
            "next": null,
            "value": 8
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "4",
        "nodes": [
          {
            "id": "4",
            "next": "6",
            "value": 4
          },
          {
            "id": "6",
            "next": "9",
            "value": 6
          },
          {
            "id": "9",
            "next": "3",
            "value": 9
          },
          {
            "id": "3",
            "next": "1",
            "value": 3
          },
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      },
      "linkedListTwo": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "0-2",
            "value": 0
          },
          {
            "id": "0-2",
            "next": "0-3",
            "value": 0
          },
          {
            "id": "0-3",
            "next": "0-4",
            "value": 0
          },
          {
            "id": "0-4",
            "next": "2",
            "value": 0
          },
          {
            "id": "2",
            "next": "7",
            "value": 2
          },
          {
            "id": "7",
            "next": null,
            "value": 7
          }
        ]
      }
    }
  ],
  "jsonTests": [
    {
      "linkedListOne": {
        "head": "2",
        "nodes": [
          {
            "id": "2",
            "next": "4",
            "value": 2
          },
          {
            "id": "4",
            "next": "7",
            "value": 4
          },
          {
            "id": "7",
            "next": "1",
            "value": 7
          },
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      },
      "linkedListTwo": {
        "head": "9",
        "nodes": [
          {
            "id": "9",
            "next": "4",
            "value": 9
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": null,
            "value": 5
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "2",
        "nodes": [
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      },
      "linkedListTwo": {
        "head": "9",
        "nodes": [
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "0-2",
            "value": 0
          },
          {
            "id": "0-2",
            "next": "0-3",
            "value": 0
          },
          {
            "id": "0-3",
            "next": "5",
            "value": 0
          },
          {
            "id": "5",
            "next": null,
            "value": 5
          }
        ]
      },
      "linkedListTwo": {
        "head": "9",
        "nodes": [
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "1-2",
            "value": 1
          },
          {
            "id": "1-2",
            "next": "1-3",
            "value": 1
          },
          {
            "id": "1-3",
            "next": null,
            "value": 1
          }
        ]
      },
      "linkedListTwo": {
        "head": "9",
        "nodes": [
          {
            "id": "9",
            "next": "9-2",
            "value": 9
          },
          {
            "id": "9-2",
            "next": "9-3",
            "value": 9
          },
          {
            "id": "9-3",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": null,
            "value": 3
          }
        ]
      },
      "linkedListTwo": {
        "head": "6",
        "nodes": [
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "9",
            "value": 7
          },
          {
            "id": "9",
            "next": "1",
            "value": 9
          },
          {
            "id": "1",
            "next": "8",
            "value": 1
          },
          {
            "id": "8",
            "next": null,
            "value": 8
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": null,
            "value": 0
          }
        ]
      },
      "linkedListTwo": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": null,
            "value": 0
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": null,
            "value": 0
          }
        ]
      },
      "linkedListTwo": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "0-2",
            "value": 0
          },
          {
            "id": "0-2",
            "next": "0-3",
            "value": 0
          },
          {
            "id": "0-3",
            "next": "0-4",
            "value": 0
          },
          {
            "id": "0-4",
            "next": "0-5",
            "value": 0
          },
          {
            "id": "0-5",
            "next": "8",
            "value": 0
          },
          {
            "id": "8",
            "next": null,
            "value": 8
          }
        ]
      }
    },
    {
      "linkedListOne": {
        "head": "4",
        "nodes": [
          {
            "id": "4",
            "next": "6",
            "value": 4
          },
          {
            "id": "6",
            "next": "9",
            "value": 6
          },
          {
            "id": "9",
            "next": "3",
            "value": 9
          },
          {
            "id": "3",
            "next": "1",
            "value": 3
          },
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      },
      "linkedListTwo": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "0-2",
            "value": 0
          },
          {
            "id": "0-2",
            "next": "0-3",
            "value": 0
          },
          {
            "id": "0-3",
            "next": "0-4",
            "value": 0
          },
          {
            "id": "0-4",
            "next": "2",
            "value": 0
          },
          {
            "id": "2",
            "next": "7",
            "value": 2
          },
          {
            "id": "7",
            "next": null,
            "value": 7
          }
        ]
      }
    }
  ],
  "changelog": []
}