{
  "uid": "union-find",
  "testStrategy": "JSON",
  "name": "Union Find",
  "version": 0,
  "releaseDate": "2022-12-15T00:00:00Z",
  "category": "Famous Algorithms",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 2476,
    "failureCount": 326
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "775578872",
    "duration": 0,
    "annotations": [],
    "instructor": "Conner Ardman",
    "overviewTime": 0,
    "codeWalkthroughTime": 1495
  },
  "prompt": "<div class=\"html\">\n<p>\n  The union-find data structure is similar to a traditional set data structure\n  in that it contains a collection of unique values. However, these values are\n  spread out amongst a variety of distinct disjoint sets, meaning that no set\n  can have duplicate values, and no two sets can contain the same value.\n</p>\n\n<p>\n  Write a <span>UnionFind</span> class that implements the union-find (also\n  called a disjoint set) data structure. This class should support three methods:\n</p>\n\n<ul>\n  <li>\n    <span>createSet(value)</span>: Adds a given value in a new set containing\n    only that value.\n  </li>\n  <li>\n    <span>union(valueOne, valueTwo)</span>: Takes in two values and determines\n    which sets they are in. If they are in different sets, the sets are combined\n    into a single set. If either value is not in a set or they are in the same\n    set, the function should have no effect.\n  </li>\n  <li>\n    <span>find(value)</span>: Returns the \"representative\" value of the set for\n    which a value belongs to. This can be any value in the set, but it should\n    always be the same value, regardless of which value in the set\n    <span>find</span> is passed. If the value is not in a set, the function\n    should return <span>null</span> / <span>None</span>. Note that after a set\n    is part of a union, its representative can potentially change.\n  </li>\n</ul>\n<p>\n  You can assume <span>createSet</span> will never be called with the same\n  value twice.\n</p>\n\n<p>\n  If you're unfamiliar with Union Find, we recommend watching the Conceptual\n  Overview section of this question's video explanation before starting to code.\n</p>\n\n<h3>Sample Usage</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">createSet</span>(5): null\n<span class=\"CodeEditor-promptParameter\">createSet</span>(10): null\n<span class=\"CodeEditor-promptParameter\">find</span>(5): 5\n<span class=\"CodeEditor-promptParameter\">find</span>(10): 10\n<span class=\"CodeEditor-promptParameter\">union</span>(5, 10): null\n<span class=\"CodeEditor-promptParameter\">find</span>(5): 5\n<span class=\"CodeEditor-promptParameter\">find</span>(10): 5\n<span class=\"CodeEditor-promptParameter\">createSet</span>(20): null\n<span class=\"CodeEditor-promptParameter\">find</span>(20): 20\n<span class=\"CodeEditor-promptParameter\">union</span>(20, 10): null\n<span class=\"CodeEditor-promptParameter\">find</span>(5): 5\n<span class=\"CodeEditor-promptParameter\">find</span>(10): 5\n<span class=\"CodeEditor-promptParameter\">find</span>(20): 5\n</pre>\n</div>",
  "hints": [
    "<p>\n  Disjoint sets traditionally use a tree-like data structure for each set, with\n  the root node being the \"representative\" node returned by <span>find</span>.\n</p>\n",
    "\n<p>\n  When combining two trees with <span>union</span>, make sure to keep the height\n  of the combined tree as small as possible in order to keep a logarithmic\n  time complexity.\n</p>\n",
    "\n<p>\n  The larger the tree is, the slower the time complexity will be. This can\n  be improved by making all nodes in the trees point directly to the root,\n  keeping a minimal height. A good time to make these updates is while running\n  the <span>find</span> method. This is known as path compression.\n</p>"
  ],
  "spaceTime": "createSet method: O(1) time | O(1) space\nunion and find methods: O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space - where n is the total number of values",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <optional>\nusing namespace std;\n\n// Do not edit the class below except for\n// the constructor, push, pop, peek, and\n// isEmpty methods. Feel free to add new\n// properties and methods to the class.\nclass UnionFind {\n public:\n  void createSet(int value) {\n    // Write your code here.\n  }\n\n  optional<int> find(int value) {\n    // Write your code here.\n    return -1;\n  }\n\n  void createUnion(int valueOne, int valueTwo) {\n    // Write your code here.\n  }\n};\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <optional>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nclass UnionFind {\n public:\n  unordered_map<int, int> parents;\n\n  // O(1) time | O(1) space\n  void createSet(int value) { parents[value] = value; }\n\n  // O(n) time | O(1) space - where n is the total number of values\n  optional<int> find(int value) {\n    if (parents.find(value) == parents.end()) {\n      return nullopt;\n    }\n\n    int currentParent = value;\n    while (currentParent != parents[currentParent]) {\n      currentParent = parents[currentParent];\n    }\n\n    return currentParent;\n  }\n\n  // O(n) time | O(1) space - where n is the total number of values\n  // This function is renamed to `createUnion` because `union` is a reserved\n  // keyword in C++.\n  void createUnion(int valueOne, int valueTwo) {\n    if (parents.find(valueOne) == parents.end() ||\n        parents.find(valueTwo) == parents.end()) {\n      return;\n    }\n\n    int valueOneRoot = *find(valueOne);\n    int valueTwoRoot = *find(valueTwo);\n    parents[valueTwoRoot] = valueOneRoot;\n  }\n};\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <optional>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nclass UnionFind {\n public:\n  unordered_map<int, int> parents;\n  unordered_map<int, int> ranks;\n\n  // O(1) time | O(1) space\n  void createSet(int value) {\n    parents[value] = value;\n    ranks[value] = 0;\n  }\n\n  // O(log(n)) time | O(1) space - where n is the total number of values\n  optional<int> find(int value) {\n    if (parents.find(value) == parents.end()) {\n      return nullopt;\n    }\n\n    int currentParent = value;\n    while (currentParent != parents[currentParent]) {\n      currentParent = parents[currentParent];\n    }\n\n    return currentParent;\n  }\n\n  // O(log(n)) time | O(1) space - where n is the total number of values\n  // This function is renamed to `createUnion` because `union` is a reserved\n  // keyword in C++.\n  void createUnion(int valueOne, int valueTwo) {\n    if (parents.find(valueOne) == parents.end() ||\n        parents.find(valueTwo) == parents.end()) {\n      return;\n    }\n\n    int valueOneRoot = *find(valueOne);\n    int valueTwoRoot = *find(valueTwo);\n    if (ranks[valueOneRoot] < ranks[valueTwoRoot]) {\n      parents[valueOneRoot] = valueTwoRoot;\n    } else if (ranks[valueOneRoot] > ranks[valueTwoRoot]) {\n      parents[valueTwoRoot] = valueOneRoot;\n    } else {\n      parents[valueTwoRoot] = valueOneRoot;\n      ranks[valueOneRoot] = ranks[valueOneRoot] + 1;\n    }\n  }\n};\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <optional>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nclass UnionFind {\n public:\n  unordered_map<int, int> parents;\n  unordered_map<int, int> ranks;\n\n  // O(1) time | O(1) space\n  void createSet(int value) {\n    parents[value] = value;\n    ranks[value] = 0;\n  }\n\n  // O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space -\n  // where n is the total number of values\n  optional<int> find(int value) {\n    if (parents.find(value) == parents.end()) {\n      return nullopt;\n    }\n\n    if (value != parents[value]) {\n      parents[value] = *find(parents[value]);\n    }\n\n    return parents[value];\n  }\n\n  // O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space -\n  // where n is the total number of values This function is renamed to\n  // `createUnion` because `union` is a reserved keyword in C++.\n  void createUnion(int valueOne, int valueTwo) {\n    if (parents.find(valueOne) == parents.end() ||\n        parents.find(valueTwo) == parents.end()) {\n      return;\n    }\n\n    int valueOneRoot = *find(valueOne);\n    int valueTwoRoot = *find(valueTwo);\n    if (ranks[valueOneRoot] < ranks[valueTwoRoot]) {\n      parents[valueOneRoot] = valueTwoRoot;\n    } else if (ranks[valueOneRoot] > ranks[valueTwoRoot]) {\n      parents[valueTwoRoot] = valueOneRoot;\n    } else {\n      parents[valueTwoRoot] = valueOneRoot;\n      ranks[valueOneRoot] = ranks[valueOneRoot] + 1;\n    }\n  }\n};\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto unionFind = new UnionFind();\n      auto findResult = unionFind->find(1);\n      assert(!findResult);\n\n      unionFind->createSet(1);\n      findResult = unionFind->find(1);\n      assert(findResult && *findResult == 1);\n\n      unionFind->createSet(5);\n      findResult = unionFind->find(1);\n      assert(findResult && *findResult == 1);\n\n      findResult = unionFind->find(5);\n      assert(findResult && *findResult == 5);\n\n      unionFind->createUnion(5, 1);\n      findResult = unionFind->find(5);\n      auto findResult2 = unionFind->find(1);\n      assert(findResult && findResult2 && *findResult == *findResult2);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto unionFind = new UnionFind();\n      auto findResult = unionFind->find(1);\n      assert(!findResult);\n\n      unionFind->createSet(1);\n      findResult = unionFind->find(1);\n      assert(findResult && *findResult == 1);\n\n      unionFind->createSet(5);\n      findResult = unionFind->find(1);\n      assert(findResult && *findResult == 1);\n\n      findResult = unionFind->find(5);\n      assert(findResult && *findResult == 5);\n\n      unionFind->createUnion(5, 1);\n      findResult = unionFind->find(5);\n      auto findResult2 = unionFind->find(1);\n      assert(findResult && findResult2 && *findResult == *findResult2);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\n// Do not edit the public class below except for\n// the constructor, push, pop, peek, and\n// isEmpty methods. Feel free to add new\n// properties and methods to the class.\npublic class Program {\n  public class UnionFind {\n    // Write your code here.\n\n    public void CreateSet(int value) {\n      // Write your code here.\n    }\n\n    public int? Find(int value) {\n      // Write your code here.\n      return null;\n    }\n\n    public void Union(int valueOne, int valueTwo) {\n      // Write your code here.\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  public class UnionFind {\n    private Dictionary<int, int> parents = new Dictionary<int, int>();\n\n    // O(1) time | O(1) space\n    public void CreateSet(int value) {\n      parents[value] = value;\n    }\n\n    // O(n) time | O(1) space - where n is the total number of values\n    public int? Find(int value) {\n      if (!parents.ContainsKey(value)) {\n        return null;\n      }\n\n      int currentParent = value;\n      while (currentParent != parents[currentParent]) {\n        currentParent = parents[currentParent];\n      }\n      return currentParent;\n    }\n\n    // O(n) time | O(1) space - where n is the total number of values\n    public void Union(int valueOne, int valueTwo) {\n      if (!parents.ContainsKey(valueOne) || !parents.ContainsKey(valueTwo)) {\n        return;\n      }\n\n      int valueOneRoot = (int)Find(valueOne);\n      int valueTwoRoot = (int)Find(valueTwo);\n      parents[valueTwoRoot] = valueOneRoot;\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  public class UnionFind {\n    private Dictionary<int, int> parents = new Dictionary<int, int>();\n    private Dictionary<int, int> ranks = new Dictionary<int, int>();\n\n    // O(1) time | O(1) space\n    public void CreateSet(int value) {\n      parents[value] = value;\n      ranks[value] = 0;\n    }\n\n    // O(log(n)) time | O(1) space - where n is the total number of values\n    public int? Find(int value) {\n      if (!parents.ContainsKey(value)) {\n        return null;\n      }\n\n      int currentParent = value;\n      while (currentParent != parents[currentParent]) {\n        currentParent = parents[currentParent];\n      }\n      return currentParent;\n    }\n\n    // O(log(n)) time | O(1) space - where n is the total number of values\n    public void Union(int valueOne, int valueTwo) {\n      if (!parents.ContainsKey(valueOne) || !parents.ContainsKey(valueTwo)) {\n        return;\n      }\n\n      int valueOneRoot = (int)Find(valueOne);\n      int valueTwoRoot = (int)Find(valueTwo);\n      if (ranks[valueOneRoot] < ranks[valueTwoRoot]) {\n        parents[valueOneRoot] = valueTwoRoot;\n      } else if (ranks[valueOneRoot] > ranks[valueTwoRoot]) {\n        parents[valueTwoRoot] = valueOneRoot;\n      } else {\n        parents[valueTwoRoot] = valueOneRoot;\n        ranks[valueOneRoot] = ranks[valueOneRoot] + 1;\n      }\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  public class UnionFind {\n    private Dictionary<int, int> parents = new Dictionary<int, int>();\n    private Dictionary<int, int> ranks = new Dictionary<int, int>();\n\n    // O(1) time | O(1) space\n    public void CreateSet(int value) {\n      parents[value] = value;\n      ranks[value] = 0;\n    }\n\n    // O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space -\n    // where n is the total number of values\n    public int? Find(int value) {\n      if (!parents.ContainsKey(value)) {\n        return null;\n      }\n\n      if (value != parents[value]) {\n        parents[value] = (int)Find(parents[value]);\n      }\n\n      return parents[value];\n    }\n\n    // O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space -\n    // where n is the total number of values\n    public void Union(int valueOne, int valueTwo) {\n      if (!parents.ContainsKey(valueOne) || !parents.ContainsKey(valueTwo)) {\n        return;\n      }\n\n      int valueOneRoot = (int)Find(valueOne);\n      int valueTwoRoot = (int)Find(valueTwo);\n      if (ranks[valueOneRoot] < ranks[valueTwoRoot]) {\n        parents[valueOneRoot] = valueTwoRoot;\n      } else if (ranks[valueOneRoot] > ranks[valueTwoRoot]) {\n        parents[valueTwoRoot] = valueOneRoot;\n      } else {\n        parents[valueTwoRoot] = valueOneRoot;\n        ranks[valueOneRoot] = ranks[valueOneRoot] + 1;\n      }\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var unionFind = new Program.UnionFind();\n    Utils.AssertTrue(unionFind.Find(1) == null);\n    unionFind.CreateSet(1);\n    Utils.AssertTrue(unionFind.Find(1) == 1);\n    unionFind.CreateSet(5);\n    Utils.AssertTrue(unionFind.Find(1) == 1);\n    Utils.AssertTrue(unionFind.Find(5) == 5);\n    unionFind.Union(5, 1);\n    Utils.AssertTrue(unionFind.Find(5) == unionFind.Find(1));\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var unionFind = new Program.UnionFind();\n    Utils.AssertTrue(unionFind.Find(1) == null);\n    unionFind.CreateSet(1);\n    Utils.AssertTrue(unionFind.Find(1) == 1);\n    unionFind.CreateSet(5);\n    Utils.AssertTrue(unionFind.Find(1) == 1);\n    Utils.AssertTrue(unionFind.Find(5) == 5);\n    unionFind.Union(5, 1);\n    Utils.AssertTrue(unionFind.Find(5) == unionFind.Find(1));\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\ntype UnionFind struct {\n\t// Write your code here.\n}\n\nfunc NewUnionFind() *UnionFind {\n\t// Write your code here.\n\treturn &UnionFind{\n\t\t// Write your code here.\n\t}\n}\n\nfunc (union *UnionFind) CreateSet(value int) {\n\t// Write your code here.\n}\n\nfunc (union *UnionFind) Find(value int) *int {\n\t// Write your code here.\n\treturn nil\n}\n\nfunc (union *UnionFind) Union(valueOne, valueTwo int) {\n\t// Write your code here.\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype UnionFind struct {\n\tparents map[int]int\n}\n\nfunc NewUnionFind() *UnionFind {\n\treturn &UnionFind{\n\t\tparents: map[int]int{},\n\t}\n}\n\n// O(1) time | O(1) space\nfunc (union *UnionFind) CreateSet(value int) {\n\tunion.parents[value] = value\n}\n\n// O(n) time | O(1) space - where n is the total number of values\nfunc (union *UnionFind) Find(value int) *int {\n\tif _, found := union.parents[value]; !found {\n\t\treturn nil\n\t}\n\n\tcurrentParent := value\n\tfor currentParent != union.parents[currentParent] {\n\t\tcurrentParent = union.parents[currentParent]\n\t}\n\treturn &currentParent\n}\n\n// O(n) time | O(1) space - where n is the total number of values\nfunc (union *UnionFind) Union(valueOne, valueTwo int) {\n\t_, parentsContainOne := union.parents[valueOne]\n\t_, parentsContainTwo := union.parents[valueTwo]\n\tif !parentsContainOne || !parentsContainTwo {\n\t\treturn\n\t}\n\n\tvalueOneRoot := *union.Find(valueOne)\n\tvalueTwoRoot := *union.Find(valueTwo)\n\tunion.parents[valueTwoRoot] = valueOneRoot\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype UnionFind struct {\n\tparents map[int]int\n\tranks   map[int]int\n}\n\nfunc NewUnionFind() *UnionFind {\n\treturn &UnionFind{\n\t\tparents: map[int]int{},\n\t\tranks:   map[int]int{},\n\t}\n}\n\n// O(1) time | O(1) space\nfunc (union *UnionFind) CreateSet(value int) {\n\tunion.parents[value] = value\n\tunion.ranks[value] = 0\n}\n\n// O(log(n)) time | O(1) space - where n is the total number of values\nfunc (union *UnionFind) Find(value int) *int {\n\tif _, found := union.parents[value]; !found {\n\t\treturn nil\n\t}\n\n\tcurrentParent := value\n\tfor currentParent != union.parents[currentParent] {\n\t\tcurrentParent = union.parents[currentParent]\n\t}\n\treturn &currentParent\n}\n\n// O(log(n)) time | O(1) space - where n is the total number of values\nfunc (union *UnionFind) Union(valueOne, valueTwo int) {\n\t_, parentsContainOne := union.parents[valueOne]\n\t_, parentsContainTwo := union.parents[valueTwo]\n\tif !parentsContainOne || !parentsContainTwo {\n\t\treturn\n\t}\n\n\tvalueOneRoot := *union.Find(valueOne)\n\tvalueTwoRoot := *union.Find(valueTwo)\n\n\tif union.ranks[valueOneRoot] < union.ranks[valueTwoRoot] {\n\t\tunion.parents[valueOneRoot] = valueTwoRoot\n\t} else if union.ranks[valueOneRoot] > union.ranks[valueTwoRoot] {\n\t\tunion.parents[valueTwoRoot] = valueOneRoot\n\t} else {\n\t\tunion.parents[valueTwoRoot] = valueOneRoot\n\t\tunion.ranks[valueOneRoot] = union.ranks[valueOneRoot] + 1\n\t}\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype UnionFind struct {\n\tparents map[int]int\n\tranks   map[int]int\n}\n\nfunc NewUnionFind() *UnionFind {\n\treturn &UnionFind{\n\t\tparents: map[int]int{},\n\t\tranks:   map[int]int{},\n\t}\n}\n\n// O(1) time | O(1) space\nfunc (union *UnionFind) CreateSet(value int) {\n\tunion.parents[value] = value\n\tunion.ranks[value] = 0\n}\n\n// O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space - where n is the total number of values\nfunc (union *UnionFind) Find(value int) *int {\n\tif _, found := union.parents[value]; !found {\n\t\treturn nil\n\t}\n\n\tif value != union.parents[value] {\n\t\tparentsValue := union.Find(union.parents[value])\n\t\tunion.parents[value] = *parentsValue\n\t}\n\tresult := union.parents[value]\n\treturn &result\n}\n\n// O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space - where n is the total number of values\nfunc (union *UnionFind) Union(valueOne, valueTwo int) {\n\t_, parentsContainOne := union.parents[valueOne]\n\t_, parentsContainTwo := union.parents[valueTwo]\n\tif !parentsContainOne || !parentsContainTwo {\n\t\treturn\n\t}\n\n\tvalueOneRoot := *union.Find(valueOne)\n\tvalueTwoRoot := *union.Find(valueTwo)\n\n\tif union.ranks[valueOneRoot] < union.ranks[valueTwoRoot] {\n\t\tunion.parents[valueOneRoot] = valueTwoRoot\n\t} else if union.ranks[valueOneRoot] > union.ranks[valueTwoRoot] {\n\t\tunion.parents[valueTwoRoot] = valueOneRoot\n\t} else {\n\t\tunion.parents[valueTwoRoot] = valueOneRoot\n\t\tunion.ranks[valueOneRoot] = union.ranks[valueOneRoot] + 1\n\t}\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tunionFind := NewUnionFind()\n\trequire.Nil(t, unionFind.Find(1))\n\tunionFind.CreateSet(1)\n\trequire.Equal(t, 1, *unionFind.Find(1))\n\tunionFind.CreateSet(5)\n\trequire.Equal(t, 1, *unionFind.Find(1))\n\trequire.Equal(t, 5, *unionFind.Find(5))\n\tunionFind.Union(5, 1)\n\trequire.Equal(t, *unionFind.Find(5), *unionFind.Find(1))\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tunionFind := NewUnionFind()\n\trequire.Nil(t, unionFind.Find(1))\n\tunionFind.CreateSet(1)\n\trequire.Equal(t, 1, *unionFind.Find(1))\n\tunionFind.CreateSet(5)\n\trequire.Equal(t, 1, *unionFind.Find(1))\n\trequire.Equal(t, 5, *unionFind.Find(5))\n\tunionFind.Union(5, 1)\n\trequire.Equal(t, *unionFind.Find(5), *unionFind.Find(1))\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\n// Do not edit the class below except for\n// the constructor and the createSet, find,\n// and union methods. Feel free to add new\n// properties and methods to the class.\nclass Program {\n  static class UnionFind {\n    // Write your code here.\n\n    public void createSet(int value) {\n      // Write your code here.\n    }\n\n    public Integer find(int value) {\n      // Write your code here.\n      return null;\n    }\n\n    public void union(int valueOne, int valueTwo) {\n      // Write your code here.\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  static class UnionFind {\n    private HashMap<Integer, Integer> parents = new HashMap<Integer, Integer>();\n\n    // O(1) time | O(1) space\n    public void createSet(int value) {\n      parents.put(value, value);\n    }\n\n    // O(n) time | O(1) space - where n is the total number of values\n    public Integer find(int value) {\n      if (!parents.containsKey(value)) {\n        return null;\n      }\n\n      int currentParent = value;\n      while (currentParent != parents.get(currentParent)) {\n        currentParent = parents.get(currentParent);\n      }\n      return currentParent;\n    }\n\n    // O(n) time | O(1) space - where n is the total number of values\n    public void union(int valueOne, int valueTwo) {\n      if (!parents.containsKey(valueOne) || !parents.containsKey(valueTwo)) {\n        return;\n      }\n\n      int valueOneRoot = find(valueOne);\n      int valueTwoRoot = find(valueTwo);\n      parents.put(valueTwoRoot, valueOneRoot);\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  static class UnionFind {\n    private HashMap<Integer, Integer> parents = new HashMap<Integer, Integer>();\n    private HashMap<Integer, Integer> ranks = new HashMap<Integer, Integer>();\n\n    // O(1) time | O(1) space\n    public void createSet(int value) {\n      parents.put(value, value);\n      ranks.put(value, 0);\n    }\n\n    // O(log(n)) time | O(1) space - where n is the total number of values\n    public Integer find(int value) {\n      if (!parents.containsKey(value)) {\n        return null;\n      }\n\n      int currentParent = value;\n      while (currentParent != parents.get(currentParent)) {\n        currentParent = parents.get(currentParent);\n      }\n      return currentParent;\n    }\n\n    // O(log(n)) time | O(1) space - where n is the total number of values\n    public void union(int valueOne, int valueTwo) {\n      if (!parents.containsKey(valueOne) || !parents.containsKey(valueTwo)) {\n        return;\n      }\n\n      int valueOneRoot = find(valueOne);\n      int valueTwoRoot = find(valueTwo);\n      if (ranks.get(valueOneRoot) < ranks.get(valueTwoRoot)) {\n        parents.put(valueOneRoot, valueTwoRoot);\n      } else if (ranks.get(valueOneRoot) > ranks.get(valueTwoRoot)) {\n        parents.put(valueTwoRoot, valueOneRoot);\n      } else {\n        parents.put(valueTwoRoot, valueOneRoot);\n        ranks.put(valueOneRoot, ranks.get(valueOneRoot) + 1);\n      }\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  static class UnionFind {\n    private HashMap<Integer, Integer> parents = new HashMap<Integer, Integer>();\n    private HashMap<Integer, Integer> ranks = new HashMap<Integer, Integer>();\n\n    // O(1) time | O(1) space\n    public void createSet(int value) {\n      parents.put(value, value);\n      ranks.put(value, 0);\n    }\n\n    // O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space -\n    // where n is the total number of values\n    public Integer find(int value) {\n      if (!parents.containsKey(value)) {\n        return null;\n      }\n\n      if (value != parents.get(value)) {\n        parents.put(value, find(parents.get(value)));\n      }\n\n      return parents.get(value);\n    }\n\n    // O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space -\n    // where n is the total number of values\n    public void union(int valueOne, int valueTwo) {\n      if (!parents.containsKey(valueOne) || !parents.containsKey(valueTwo)) {\n        return;\n      }\n\n      int valueOneRoot = find(valueOne);\n      int valueTwoRoot = find(valueTwo);\n      if (ranks.get(valueOneRoot) < ranks.get(valueTwoRoot)) {\n        parents.put(valueOneRoot, valueTwoRoot);\n      } else if (ranks.get(valueOneRoot) > ranks.get(valueTwoRoot)) {\n        parents.put(valueTwoRoot, valueOneRoot);\n      } else {\n        parents.put(valueTwoRoot, valueOneRoot);\n        ranks.put(valueOneRoot, ranks.get(valueOneRoot) + 1);\n      }\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var unionFind = new Program.UnionFind();\n    Utils.assertTrue(unionFind.find(1) == null);\n    unionFind.createSet(1);\n    Utils.assertTrue(unionFind.find(1) == 1);\n    unionFind.createSet(5);\n    Utils.assertTrue(unionFind.find(1) == 1);\n    Utils.assertTrue(unionFind.find(5) == 5);\n    unionFind.union(5, 1);\n    Utils.assertTrue(unionFind.find(5) == unionFind.find(1));\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var unionFind = new Program.UnionFind();\n    Utils.assertTrue(unionFind.find(1) == null);\n    unionFind.createSet(1);\n    Utils.assertTrue(unionFind.find(1) == 1);\n    unionFind.createSet(5);\n    Utils.assertTrue(unionFind.find(1) == 1);\n    Utils.assertTrue(unionFind.find(5) == 5);\n    unionFind.union(5, 1);\n    Utils.assertTrue(unionFind.find(5) == unionFind.find(1));\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// Do not edit the class below except for\n// the constructor and the createSet, find,\n// and union methods. Feel free to add new\n// properties and methods to the class.\nclass UnionFind {\n  constructor() {\n    // Write your code here.\n  }\n\n  createSet(value) {\n    // Write your code here.\n  }\n\n  find(value) {\n    // Write your code here.\n  }\n\n  union(valueOne, valueTwo) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.UnionFind = UnionFind;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass UnionFind {\n  constructor() {\n    this.parents = {};\n  }\n\n  // O(1) time | O(1) space\n  createSet(value) {\n    this.parents[value] = value;\n  }\n\n  // O(n) time | O(1) space - where n is the total number of values\n  find(value) {\n    if (!(value in this.parents)) return null;\n\n    let currentParent = value;\n    while (currentParent !== this.parents[currentParent]) {\n      currentParent = this.parents[currentParent];\n    }\n    return currentParent;\n  }\n\n  // O(n) time | O(1) space - where n is the total number of values\n  union(valueOne, valueTwo) {\n    if (!(valueOne in this.parents) || !(valueTwo in this.parents)) return;\n\n    const valueOneRoot = this.find(valueOne);\n    const valueTwoRoot = this.find(valueTwo);\n    this.parents[valueTwoRoot] = valueOneRoot;\n  }\n}\n\nexports.UnionFind = UnionFind;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass UnionFind {\n  constructor() {\n    this.parents = {};\n    this.ranks = {};\n  }\n\n  // O(1) time | O(1) space\n  createSet(value) {\n    this.parents[value] = value;\n    this.ranks[value] = 0;\n  }\n\n  // O(log(n)) time | O(1) space - where n is the total number of values\n  find(value) {\n    if (!(value in this.parents)) return null;\n\n    let currentParent = value;\n    while (currentParent !== this.parents[currentParent]) {\n      currentParent = this.parents[currentParent];\n    }\n    return currentParent;\n  }\n\n  // O(log(n)) time | O(1) space - where n is the total number of values\n  union(valueOne, valueTwo) {\n    if (!(valueOne in this.parents) || !(valueTwo in this.parents)) return;\n\n    const valueOneRoot = this.find(valueOne);\n    const valueTwoRoot = this.find(valueTwo);\n    if (this.ranks[valueOneRoot] < this.ranks[valueTwoRoot]) {\n      this.parents[valueOneRoot] = valueTwoRoot;\n    } else if (this.ranks[valueOneRoot] > this.ranks[valueTwoRoot]) {\n      this.parents[valueTwoRoot] = valueOneRoot;\n    } else {\n      this.parents[valueTwoRoot] = valueOneRoot;\n      this.ranks[valueOneRoot] += 1;\n    }\n  }\n}\n\nexports.UnionFind = UnionFind;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass UnionFind {\n  constructor() {\n    this.parents = {};\n    this.ranks = {};\n  }\n\n  // O(1) time | O(1) space\n  createSet(value) {\n    this.parents[value] = value;\n    this.ranks[value] = 0;\n  }\n\n  // O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space - where n is the total number of values\n  find(value) {\n    if (!(value in this.parents)) return null;\n\n    if (value !== this.parents[value]) {\n      this.parents[value] = this.find(this.parents[value]);\n    }\n\n    return this.parents[value];\n  }\n\n  // O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space - where n is the total number of values\n  union(valueOne, valueTwo) {\n    if (!(valueOne in this.parents) || !(valueTwo in this.parents)) return;\n\n    const valueOneRoot = this.find(valueOne);\n    const valueTwoRoot = this.find(valueTwo);\n    if (this.ranks[valueOneRoot] < this.ranks[valueTwoRoot]) {\n      this.parents[valueOneRoot] = valueTwoRoot;\n    } else if (this.ranks[valueOneRoot] > this.ranks[valueTwoRoot]) {\n      this.parents[valueTwoRoot] = valueOneRoot;\n    } else {\n      this.parents[valueTwoRoot] = valueOneRoot;\n      this.ranks[valueOneRoot] += 1;\n    }\n  }\n}\n\nexports.UnionFind = UnionFind;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const unionFind = new program.UnionFind();\n  chai.expect(unionFind.find(1)).to.deep.equal(null);\n  unionFind.createSet(1);\n  chai.expect(unionFind.find(1)).to.deep.equal(1);\n  unionFind.createSet(5);\n  chai.expect(unionFind.find(1)).to.deep.equal(1);\n  chai.expect(unionFind.find(5)).to.deep.equal(5);\n  unionFind.union(5, 1);\n  chai.expect(unionFind.find(5)).to.deep.equal(unionFind.find(1));\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const unionFind = new program.UnionFind();\n  chai.expect(unionFind.find(1)).to.deep.equal(null);\n  unionFind.createSet(1);\n  chai.expect(unionFind.find(1)).to.deep.equal(1);\n  unionFind.createSet(5);\n  chai.expect(unionFind.find(1)).to.deep.equal(1);\n  chai.expect(unionFind.find(5)).to.deep.equal(5);\n  unionFind.union(5, 1);\n  chai.expect(unionFind.find(5)).to.deep.equal(unionFind.find(1));\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// Do not edit the class below except for\n// the constructor and the createSet, find,\n// and union methods. Feel free to add new\n// properties and methods to the class.\nopen class UnionFind() {\n    // Write your code here.\n\n    fun createSet(value: Int) {\n        // Write your code here.\n    }\n\n    fun find(value: Int): Int? {\n        // Write your code here.\n        return null\n    }\n\n    fun union(valueOne: Int, valueTwo: Int) {\n        // Write your code here.\n    }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class UnionFind() {\n    val parents = mutableMapOf<Int, Int>()\n\n    // O(1) time | O(1) space\n    fun createSet(value: Int) {\n        this.parents[value] = value\n    }\n\n    // O(n) time | O(1) space - where n is the total number of values\n    fun find(value: Int): Int? {\n        if (!(value in this.parents)) return null\n\n        var currentParent = value\n        while (currentParent != this.parents[currentParent]) {\n            currentParent = this.parents[currentParent]!!\n        }\n        return currentParent\n    }\n\n    // O(n) time | O(1) space - where n is the total number of values\n    fun union(valueOne: Int, valueTwo: Int) {\n        if (!(valueOne in this.parents) || !(valueTwo in this.parents)) return\n\n        val valueOneRoot = this.find(valueOne)!!\n        val valueTwoRoot = this.find(valueTwo)!!\n        this.parents[valueTwoRoot] = valueOneRoot\n    }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class UnionFind() {\n    val parents = mutableMapOf<Int, Int>()\n    val ranks = mutableMapOf<Int, Int>()\n\n    // O(1) time | O(1) space\n    fun createSet(value: Int) {\n        this.parents[value] = value\n        this.ranks[value] = 0\n    }\n\n    // O(log(n)) time | O(1) space - where n is the total number of values\n    fun find(value: Int): Int? {\n        if (!(value in this.parents)) return null\n\n        var currentParent = value\n        while (currentParent != this.parents[currentParent]) {\n            currentParent = this.parents[currentParent]!!\n        }\n        return currentParent\n    }\n\n    // O(log(n)) time | O(1) space - where n is the total number of values\n    fun union(valueOne: Int, valueTwo: Int) {\n        if (!(valueOne in this.parents) || !(valueTwo in this.parents)) return\n\n        val valueOneRoot = this.find(valueOne)!!\n        val valueTwoRoot = this.find(valueTwo)!!\n        if (this.ranks[valueOneRoot]!! < this.ranks[valueTwoRoot]!!) {\n            this.parents[valueOneRoot] = valueTwoRoot\n        } else if (this.ranks[valueOneRoot]!! > this.ranks[valueTwoRoot]!!) {\n            this.parents[valueTwoRoot] = valueOneRoot\n        } else {\n            this.parents[valueTwoRoot] = valueOneRoot\n            this.ranks[valueOneRoot] = this.ranks[valueOneRoot]!! + 1\n        }\n    }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class UnionFind() {\n    val parents = mutableMapOf<Int, Int>()\n    val ranks = mutableMapOf<Int, Int>()\n\n    // O(1) time | O(1) space\n    fun createSet(value: Int) {\n        this.parents[value] = value\n        this.ranks[value] = 0\n    }\n\n    // O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space - where n is the total number of values\n    fun find(value: Int): Int? {\n        if (!(value in this.parents)) return null\n\n        if (value != this.parents[value]) {\n            this.parents[value] = this.find(this.parents[value]!!)!!\n        }\n\n        return this.parents[value]\n    }\n\n    // O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space - where n is the total number of values\n    fun union(valueOne: Int, valueTwo: Int) {\n        if (!(valueOne in this.parents) || !(valueTwo in this.parents)) return\n\n        val valueOneRoot = this.find(valueOne)!!\n        val valueTwoRoot = this.find(valueTwo)!!\n        if (this.ranks[valueOneRoot]!! < this.ranks[valueTwoRoot]!!) {\n            this.parents[valueOneRoot] = valueTwoRoot\n        } else if (this.ranks[valueOneRoot]!! > this.ranks[valueTwoRoot]!!) {\n            this.parents[valueTwoRoot] = valueOneRoot\n        } else {\n            this.parents[valueTwoRoot] = valueOneRoot\n            this.ranks[valueOneRoot] = this.ranks[valueOneRoot]!! + 1\n        }\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.UnionFind as UnionFind\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val unionFind = UnionFind()\n        assert(unionFind.find(1) == null)\n        unionFind.createSet(1)\n        assert(unionFind.find(1) == 1)\n        unionFind.createSet(5)\n        assert(unionFind.find(1) == 1)\n        assert(unionFind.find(5) == 5)\n        unionFind.union(5, 1)\n        assert(unionFind.find(5) == unionFind.find(1))\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.UnionFind as UnionFind\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val unionFind = UnionFind()\n        assert(unionFind.find(1) == null)\n        unionFind.createSet(1)\n        assert(unionFind.find(1) == 1)\n        unionFind.createSet(5)\n        assert(unionFind.find(1) == 1)\n        assert(unionFind.find(5) == 5)\n        unionFind.union(5, 1)\n        assert(unionFind.find(5) == unionFind.find(1))\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# Do not edit the class below except for\n# the constructor and the createSet, find,\n# and union methods. Feel free to add new\n# properties and methods to the class.\nclass UnionFind:\n    def __init__(self):\n        # Write your code here\n        pass\n\n    def createSet(self, value):\n        # Write your code here\n        pass\n\n    def find(self, value):\n        # Write your code here\n        pass\n\n    def union(self, valueOne, valueTwo):\n        # Write your code here\n        pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass UnionFind:\n    def __init__(self):\n        self.parents = {}\n\n    # O(1) time | O(1) space\n    def createSet(self, value):\n        self.parents[value] = value\n\n    # O(n) time | O(1) space - where n is the total number of values\n    def find(self, value):\n        if value not in self.parents:\n            return None\n\n        currentParent = value\n        while currentParent != self.parents[currentParent]:\n            currentParent = self.parents[currentParent]\n        return currentParent\n\n    # O(n) time | O(1) space - where n is the total number of values\n    def union(self, valueOne, valueTwo):\n        if valueOne not in self.parents or valueTwo not in self.parents:\n            return\n\n        valueOneRoot = self.find(valueOne)\n        valueTwoRoot = self.find(valueTwo)\n        self.parents[valueTwoRoot] = valueOneRoot\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass UnionFind:\n    def __init__(self):\n        self.parents = {}\n        self.ranks = {}\n\n    # O(1) time | O(1) space\n    def createSet(self, value):\n        self.parents[value] = value\n        self.ranks[value] = 0\n\n    # O(log(n)) time | O(1) space - where n is the total number of values\n    def find(self, value):\n        if value not in self.parents:\n            return None\n\n        currentParent = value\n        while currentParent != self.parents[currentParent]:\n            currentParent = self.parents[currentParent]\n        return currentParent\n\n    # O(log(n)) time | O(1) space - where n is the total number of values\n    def union(self, valueOne, valueTwo):\n        if valueOne not in self.parents or valueTwo not in self.parents:\n            return\n\n        valueOneRoot = self.find(valueOne)\n        valueTwoRoot = self.find(valueTwo)\n        if self.ranks[valueOneRoot] < self.ranks[valueTwoRoot]:\n            self.parents[valueOneRoot] = valueTwoRoot\n        elif self.ranks[valueOneRoot] > self.ranks[valueTwoRoot]:\n            self.parents[valueTwoRoot] = valueOneRoot\n        else:\n            self.parents[valueTwoRoot] = valueOneRoot\n            self.ranks[valueOneRoot] += 1\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass UnionFind:\n    def __init__(self):\n        self.parents = {}\n        self.ranks = {}\n\n    # O(1) time | O(1) space\n    def createSet(self, value):\n        self.parents[value] = value\n        self.ranks[value] = 0\n\n    # O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space - where n is the total number of values\n    def find(self, value):\n        if value not in self.parents:\n            return None\n\n        if value != self.parents[value]:\n            self.parents[value] = self.find(self.parents[value])\n\n        return self.parents[value]\n\n    # O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space - where n is the total number of values\n    def union(self, valueOne, valueTwo):\n        if valueOne not in self.parents or valueTwo not in self.parents:\n            return\n\n        valueOneRoot = self.find(valueOne)\n        valueTwoRoot = self.find(valueTwo)\n        if self.ranks[valueOneRoot] < self.ranks[valueTwoRoot]:\n            self.parents[valueOneRoot] = valueTwoRoot\n        elif self.ranks[valueOneRoot] > self.ranks[valueTwoRoot]:\n            self.parents[valueTwoRoot] = valueOneRoot\n        else:\n            self.parents[valueTwoRoot] = valueOneRoot\n            self.ranks[valueOneRoot] += 1\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nUnionFind = program.UnionFind\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        unionFind = UnionFind()\n        self.assertTrue(unionFind.find(1) == None)\n        unionFind.createSet(1)\n        self.assertTrue(unionFind.find(1) == 1)\n        unionFind.createSet(5)\n        self.assertTrue(unionFind.find(1) == 1)\n        self.assertTrue(unionFind.find(5) == 5)\n        unionFind.union(5, 1)\n        self.assertTrue(unionFind.find(5) == unionFind.find(1))\n",
      "unitTests": "import program\nimport unittest\n\n\nUnionFind = program.UnionFind\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        unionFind = UnionFind()\n        self.assertTrue(unionFind.find(1) == None)\n        unionFind.createSet(1)\n        self.assertTrue(unionFind.find(1) == 1)\n        unionFind.createSet(5)\n        self.assertTrue(unionFind.find(1) == 1)\n        self.assertTrue(unionFind.find(5) == 5)\n        unionFind.union(5, 1)\n        self.assertTrue(unionFind.find(5) == unionFind.find(1))\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "# Do not edit the class below except for\n# the constructor, push, pop, peek, and\n# isEmpty methods. Feel free to add new\n# properties and methods to the class.\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "// Feel free to add new properties and methods\n// to the class.\nclass Program {\n  class UnionFind {\n    // Write your code here.\n\n    init() {\n      // Write your code here.\n    }\n\n    func createSet(_ value: Int) {\n      // Write your code here.\n    }\n\n    func find(_ value: Int) -> Int? {\n      // Write your code here.\n      return nil\n    }\n\n    func union(_ valueOne: Int, _ valueTwo: Int) {\n      // Write your code here.\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class UnionFind {\n    var parents = [Int: Int]()\n\n    // O(1) time | O(1) space\n    func createSet(_ value: Int) {\n      parents[value] = value\n    }\n\n    // O(n) time | O(1) space - where n is the total number of values\n    func find(_ value: Int) -> Int? {\n      if parents[value] == nil {\n        return nil\n      }\n\n      var currentParent = value\n      while currentParent != parents[currentParent] {\n        currentParent = parents[currentParent]!\n      }\n      return currentParent\n    }\n\n    // O(n) time | O(1) space - where n is the total number of values\n    func union(_ valueOne: Int, _ valueTwo: Int) {\n      if let valueOneRoot = find(valueOne), let valueTwoRoot = find(valueTwo) {\n        parents[valueTwoRoot] = valueOneRoot\n      }\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class UnionFind {\n    var parents = [Int: Int]()\n    var ranks = [Int: Int]()\n\n    // O(1) time | O(1) space\n    func createSet(_ value: Int) {\n      parents[value] = value\n      ranks[value] = 0\n    }\n\n    // O(log(n)) time | O(1) space - where n is the total number of values\n    func find(_ value: Int) -> Int? {\n      if parents[value] == nil {\n        return nil\n      }\n\n      var currentParent = value\n      while currentParent != parents[currentParent] {\n        currentParent = parents[currentParent]!\n      }\n      return currentParent\n    }\n\n    // O(log(n)) time | O(1) space - where n is the total number of values\n    func union(_ valueOne: Int, _ valueTwo: Int) {\n      if parents[valueOne] == nil || parents[valueTwo] == nil {\n        return\n      }\n\n      let valueOneRoot = find(valueOne)!\n      let valueTwoRoot = find(valueTwo)!\n\n      if ranks[valueOneRoot]! < ranks[valueTwoRoot]! {\n        parents[valueOneRoot] = valueTwoRoot\n      } else if ranks[valueOneRoot]! > ranks[valueTwoRoot]! {\n        parents[valueTwoRoot] = valueOneRoot\n      } else {\n        parents[valueTwoRoot] = valueOneRoot\n        ranks[valueOneRoot] = ranks[valueOneRoot]! + 1\n      }\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class UnionFind {\n    var parents = [Int: Int]()\n    var ranks = [Int: Int]()\n\n    // O(1) time | O(1) space\n    func createSet(_ value: Int) {\n      parents[value] = value\n      ranks[value] = 0\n    }\n\n    // O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space - where n is the total number of values\n    func find(_ value: Int) -> Int? {\n      if parents[value] == nil {\n        return nil\n      }\n\n      if value != parents[value]! {\n        parents[value] = find(parents[value]!)!\n      }\n      return parents[value]\n    }\n\n    // O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space - where n is the total number of values\n    func union(_ valueOne: Int, _ valueTwo: Int) {\n      if parents[valueOne] == nil || parents[valueTwo] == nil {\n        return\n      }\n\n      let valueOneRoot = find(valueOne)!\n      let valueTwoRoot = find(valueTwo)!\n\n      if ranks[valueOneRoot]! < ranks[valueTwoRoot]! {\n        parents[valueOneRoot] = valueTwoRoot\n      } else if ranks[valueOneRoot]! > ranks[valueTwoRoot]! {\n        parents[valueTwoRoot] = valueOneRoot\n      } else {\n        parents[valueTwoRoot] = valueOneRoot\n        ranks[valueOneRoot] = ranks[valueOneRoot]! + 1\n      }\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      var unionFind = Program.UnionFind()\n      try assertEqual(nil, unionFind.find(1))\n      unionFind.createSet(1)\n      try assertEqual(1, unionFind.find(1))\n      unionFind.createSet(5)\n      try assertEqual(1, unionFind.find(1))\n      try assertEqual(5, unionFind.find(5))\n      unionFind.union(5, 1)\n      try assertEqual(unionFind.find(1), unionFind.find(5))\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      var unionFind = Program.UnionFind()\n      try assertEqual(nil, unionFind.find(1))\n      unionFind.createSet(1)\n      try assertEqual(1, unionFind.find(1))\n      unionFind.createSet(5)\n      try assertEqual(1, unionFind.find(1))\n      try assertEqual(5, unionFind.find(5))\n      unionFind.union(5, 1)\n      try assertEqual(unionFind.find(1), unionFind.find(5))\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// Do not edit the class below except for\n// the constructor and the createSet, find,\n// and union methods. Feel free to add new\n// properties and methods to the class.\nexport class UnionFind {\n  constructor() {\n    // Write your code here.\n  }\n\n  createSet(value: number) {\n    // Write your code here.\n  }\n\n  find(value: number) {\n    // Write your code here.\n  }\n\n  union(valueOne: number, valueTwo: number) {\n    // Write your code here.\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nexport class UnionFind {\n  parents: Record<number, number>;\n\n  constructor() {\n    this.parents = {};\n  }\n\n  // O(1) time | O(1) space\n  createSet(value: number) {\n    this.parents[value] = value;\n  }\n\n  // O(n) time | O(1) space - where n is the total number of values\n  find(value: number) {\n    if (!(value in this.parents)) return null;\n\n    let currentParent = value;\n    while (currentParent !== this.parents[currentParent]) {\n      currentParent = this.parents[currentParent];\n    }\n    return currentParent;\n  }\n\n  // O(n) time | O(1) space - where n is the total number of values\n  union(valueOne: number, valueTwo: number) {\n    if (!(valueOne in this.parents) || !(valueTwo in this.parents)) return;\n\n    const valueOneRoot = this.find(valueOne)!;\n    const valueTwoRoot = this.find(valueTwo)!;\n    this.parents[valueTwoRoot] = valueOneRoot;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nexport class UnionFind {\n  parents: Record<number, number>;\n  ranks: Record<number, number>;\n\n  constructor() {\n    this.parents = {};\n    this.ranks = {};\n  }\n\n  // O(1) time | O(1) space\n  createSet(value: number) {\n    this.parents[value] = value;\n    this.ranks[value] = 0;\n  }\n\n  // O(log(n)) time | O(1) space - where n is the total number of values\n  find(value: number) {\n    if (!(value in this.parents)) return null;\n\n    let currentParent = value;\n    while (currentParent !== this.parents[currentParent]) {\n      currentParent = this.parents[currentParent];\n    }\n    return currentParent;\n  }\n\n  // O(log(n)) time | O(1) space - where n is the total number of values\n  union(valueOne: number, valueTwo: number) {\n    if (!(valueOne in this.parents) || !(valueTwo in this.parents)) return;\n\n    const valueOneRoot = this.find(valueOne)!;\n    const valueTwoRoot = this.find(valueTwo)!;\n    if (this.ranks[valueOneRoot] < this.ranks[valueTwoRoot]) {\n      this.parents[valueOneRoot] = valueTwoRoot;\n    } else if (this.ranks[valueOneRoot] > this.ranks[valueTwoRoot]) {\n      this.parents[valueTwoRoot] = valueOneRoot;\n    } else {\n      this.parents[valueTwoRoot] = valueOneRoot;\n      this.ranks[valueOneRoot] += 1;\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nexport class UnionFind {\n  parents: Record<number, number>;\n  ranks: Record<number, number>;\n\n  constructor() {\n    this.parents = {};\n    this.ranks = {};\n  }\n\n  // O(1) time | O(1) space\n  createSet(value: number) {\n    this.parents[value] = value;\n    this.ranks[value] = 0;\n  }\n\n  // O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space - where n is the total number of values\n  find(value: number) {\n    if (!(value in this.parents)) return null;\n\n    if (value !== this.parents[value]) {\n      this.parents[value] = this.find(this.parents[value])!;\n    }\n\n    return this.parents[value];\n  }\n\n  // O(α(n)), approximately O(1) time | O(α(n)), approximately O(1) space - where n is the total number of values\n  union(valueOne: number, valueTwo: number) {\n    if (!(valueOne in this.parents) || !(valueTwo in this.parents)) return;\n\n    const valueOneRoot = this.find(valueOne)!;\n    const valueTwoRoot = this.find(valueTwo)!;\n    if (this.ranks[valueOneRoot] < this.ranks[valueTwoRoot]) {\n      this.parents[valueOneRoot] = valueTwoRoot;\n    } else if (this.ranks[valueOneRoot] > this.ranks[valueTwoRoot]) {\n      this.parents[valueTwoRoot] = valueOneRoot;\n    } else {\n      this.parents[valueTwoRoot] = valueOneRoot;\n      this.ranks[valueOneRoot] += 1;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const unionFind = new program.UnionFind();\n  chai.expect(unionFind.find(1)).to.deep.equal(null);\n  unionFind.createSet(1);\n  chai.expect(unionFind.find(1)).to.deep.equal(1);\n  unionFind.createSet(5);\n  chai.expect(unionFind.find(1)).to.deep.equal(1);\n  chai.expect(unionFind.find(5)).to.deep.equal(5);\n  unionFind.union(5, 1);\n  chai.expect(unionFind.find(5)).to.deep.equal(unionFind.find(1));\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const unionFind = new program.UnionFind();\n  chai.expect(unionFind.find(1)).to.deep.equal(null);\n  unionFind.createSet(1);\n  chai.expect(unionFind.find(1)).to.deep.equal(1);\n  unionFind.createSet(5);\n  chai.expect(unionFind.find(1)).to.deep.equal(1);\n  chai.expect(unionFind.find(5)).to.deep.equal(5);\n  unionFind.union(5, 1);\n  chai.expect(unionFind.find(5)).to.deep.equal(unionFind.find(1));\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "classMethodsToCall",
      "example": [
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        }
      ],
      "schema": {
        "description": "These methods will be called on an instantiated UnionFind.\n",
        "items": {
          "properties": {
            "arguments": {
              "items": {
                "type": "integer"
              },
              "maxItems": 2,
              "minItems": 0,
              "type": "array"
            },
            "method": {
              "enum": [
                "createSet",
                "union",
                "find"
              ],
              "type": "string"
            }
          },
          "required": [
            "method",
            "arguments"
          ],
          "type": "object"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            0,
            1
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            10
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            5
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            10
          ],
          "method": "find"
        },
        {
          "arguments": [
            5
          ],
          "method": "find"
        },
        {
          "arguments": [
            10,
            5
          ],
          "method": "union"
        },
        {
          "arguments": [
            10
          ],
          "method": "find"
        },
        {
          "arguments": [
            5
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            2
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            3
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            0,
            2
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            2
          ],
          "method": "find"
        },
        {
          "arguments": [
            3
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            2
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            0,
            2
          ],
          "method": "union"
        },
        {
          "arguments": [
            3
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1,
            3
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            2
          ],
          "method": "find"
        },
        {
          "arguments": [
            3
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            2
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            0,
            2
          ],
          "method": "union"
        },
        {
          "arguments": [
            3
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1,
            3
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            2
          ],
          "method": "find"
        },
        {
          "arguments": [
            3
          ],
          "method": "find"
        },
        {
          "arguments": [
            3,
            0
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            2
          ],
          "method": "find"
        },
        {
          "arguments": [
            3
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            0,
            2
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            0,
            1
          ],
          "method": "union"
        },
        {
          "arguments": [
            1,
            0
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            3
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            12
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            5
          ],
          "method": "find"
        },
        {
          "arguments": [
            2
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1000
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1000,
            2
          ],
          "method": "union"
        },
        {
          "arguments": [
            1000,
            5
          ],
          "method": "union"
        },
        {
          "arguments": [
            1,
            12
          ],
          "method": "union"
        },
        {
          "arguments": [
            7
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            3,
            5
          ],
          "method": "union"
        },
        {
          "arguments": [
            7,
            3
          ],
          "method": "union"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            3
          ],
          "method": "find"
        },
        {
          "arguments": [
            12
          ],
          "method": "find"
        },
        {
          "arguments": [
            5
          ],
          "method": "find"
        },
        {
          "arguments": [
            2
          ],
          "method": "find"
        },
        {
          "arguments": [
            1000
          ],
          "method": "find"
        },
        {
          "arguments": [
            7
          ],
          "method": "find"
        },
        {
          "arguments": [
            3,
            12
          ],
          "method": "union"
        },
        {
          "arguments": [
            12
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            2
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            2,
            0
          ],
          "method": "union"
        },
        {
          "arguments": [
            3
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            3,
            0
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            2
          ],
          "method": "find"
        }
      ]
    }
  ],
  "jsonTests": [
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            0,
            1
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            10
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            5
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            10
          ],
          "method": "find"
        },
        {
          "arguments": [
            5
          ],
          "method": "find"
        },
        {
          "arguments": [
            10,
            5
          ],
          "method": "union"
        },
        {
          "arguments": [
            10
          ],
          "method": "find"
        },
        {
          "arguments": [
            5
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            2
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            3
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            0,
            2
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            2
          ],
          "method": "find"
        },
        {
          "arguments": [
            3
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            2
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            0,
            2
          ],
          "method": "union"
        },
        {
          "arguments": [
            3
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1,
            3
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            2
          ],
          "method": "find"
        },
        {
          "arguments": [
            3
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            2
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            0,
            2
          ],
          "method": "union"
        },
        {
          "arguments": [
            3
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1,
            3
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            2
          ],
          "method": "find"
        },
        {
          "arguments": [
            3
          ],
          "method": "find"
        },
        {
          "arguments": [
            3,
            0
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            2
          ],
          "method": "find"
        },
        {
          "arguments": [
            3
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            0,
            2
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            0,
            1
          ],
          "method": "union"
        },
        {
          "arguments": [
            1,
            0
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            3
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            12
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            5
          ],
          "method": "find"
        },
        {
          "arguments": [
            2
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1000
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            1000,
            2
          ],
          "method": "union"
        },
        {
          "arguments": [
            1000,
            5
          ],
          "method": "union"
        },
        {
          "arguments": [
            1,
            12
          ],
          "method": "union"
        },
        {
          "arguments": [
            7
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            3,
            5
          ],
          "method": "union"
        },
        {
          "arguments": [
            7,
            3
          ],
          "method": "union"
        },
        {
          "arguments": [
            1
          ],
          "method": "find"
        },
        {
          "arguments": [
            3
          ],
          "method": "find"
        },
        {
          "arguments": [
            12
          ],
          "method": "find"
        },
        {
          "arguments": [
            5
          ],
          "method": "find"
        },
        {
          "arguments": [
            2
          ],
          "method": "find"
        },
        {
          "arguments": [
            1000
          ],
          "method": "find"
        },
        {
          "arguments": [
            7
          ],
          "method": "find"
        },
        {
          "arguments": [
            3,
            12
          ],
          "method": "union"
        },
        {
          "arguments": [
            12
          ],
          "method": "find"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            0
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            2
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            2,
            0
          ],
          "method": "union"
        },
        {
          "arguments": [
            3
          ],
          "method": "createSet"
        },
        {
          "arguments": [
            3,
            0
          ],
          "method": "union"
        },
        {
          "arguments": [
            0
          ],
          "method": "find"
        },
        {
          "arguments": [
            2
          ],
          "method": "find"
        }
      ]
    }
  ],
  "changelog": []
}