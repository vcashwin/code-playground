{
  "uid": "zip-linked-list",
  "testStrategy": "JSON",
  "name": "Zip Linked List",
  "version": 0,
  "releaseDate": "2021-03-02T00:00:00Z",
  "category": "Linked Lists",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 3853,
    "failureCount": 949
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "516496077",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 1224
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given the head of a Singly Linked List of arbitrary length\n  <span>k</span>. Write a function that zips the Linked List in place (i.e.,\n  doesn't create a brand new list) and returns its head.\n</p>\n<p>\n  A Linked List is zipped if its nodes are in the following order, where\n  <span>k</span> is the length of the Linked List:\n</p>\n<pre>\n1st node -> kth node -> 2nd node -> (k - 1)th node -> 3rd node -> (k - 2)th node -> ...\n</pre>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it's the tail of the list.\n</p>\n<p>\n  You can assume that the input Linked List will always have at least one node;\n  in other words, the head will never be <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">linkedList</span> = 1 -> 2 -> 3 -> 4 -> 5 -> 6 <span class=\"CodeEditor-promptComment\">// the head node with value 1 </span>\n</pre>\n<h3>Sample Output</h3>\n<pre>\n1 -> 6 -> 2 -> 5 -> 3 -> 4 <span class=\"CodeEditor-promptComment\">// the head node with value 1</span>\n</pre>\n</div>",
  "hints": [
    "<p>\n  Try to imagine how you would solve this problem if you were given two distinct\n  linked lists. For example, how would you zip the list\n  <span>1 -> 2 -> 3</span> with the list <span>4 -> 5</span> to get\n  <span>1 -> 5 -> 2 -> 4 -> 3</span>?\n</p>\n",
    "\n<p>\n  One of the most straightforward ways to solve this problem is to split the\n  original linked list into two linked lists and to reverse the second linked\n  list before interweaving it with the first one. Ultimately, you want the first\n  node, then the kth node, then the second node, etc., so reversing the second\n  linked list before interweaving it with the first one makes things simple.\n</p>\n",
    "\n<p>\n  After you split the linked list into two halves and reverse the second half,\n  you'll have something like <span>1 -> 2 -> 3</span> and <span>5 -> 4</span>;\n  at this point, you can simply add the first node of the reversed second half\n  into the first half between <span>1</span> and <span>2</span> as in\n  <span>1 -> 5 -> 2...</span>. Simply continue this process until you've\n  inserted all of the nodes from the reversed second half into the first.\n</p>"
  ],
  "spaceTime": "O(n) time | O(1) space - where n is the length of the input Linked List",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": "linkedList",
    "outputType": "linkedList"
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is an input struct. Do not edit.\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next = nullptr;\n\n  LinkedList(int value) { this->value = value; }\n};\n\nLinkedList* zipLinkedList(LinkedList* linkedList) {\n  // Write your code here.\n  return nullptr;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// This is an input struct. Do not edit.\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next = nullptr;\n\n  LinkedList(int value) { this->value = value; }\n};\n\nLinkedList* splitLinkedList(LinkedList* linkedList);\nLinkedList* interweaveLinkedLists(\n  LinkedList* linkedList1, LinkedList* linkedList2\n);\nLinkedList* reverseLinkedList(LinkedList* head);\n\n// O(n) time | O(1) space - where n is the length of the Linked List\nLinkedList* zipLinkedList(LinkedList* linkedList) {\n  if (linkedList->next == nullptr || linkedList->next->next == nullptr)\n    return linkedList;\n\n  LinkedList* firstHalfHead = linkedList;\n  LinkedList* secondHalfHead = splitLinkedList(linkedList);\n\n  LinkedList* reversedSecondHalfHead = reverseLinkedList(secondHalfHead);\n\n  return interweaveLinkedLists(firstHalfHead, reversedSecondHalfHead);\n}\n\nLinkedList* splitLinkedList(LinkedList* linkedList) {\n  LinkedList* slowIterator = linkedList;\n  LinkedList* fastIterator = linkedList;\n  while (fastIterator != nullptr && fastIterator->next != nullptr) {\n    slowIterator = slowIterator->next;\n    fastIterator = fastIterator->next->next;\n  }\n\n  LinkedList* secondHalfHead = slowIterator->next;\n  slowIterator->next = nullptr;\n  return secondHalfHead;\n}\n\nLinkedList* interweaveLinkedLists(\n  LinkedList* linkedList1, LinkedList* linkedList2\n) {\n  LinkedList* linkedList1Iterator = linkedList1;\n  LinkedList* linkedList2Iterator = linkedList2;\n  while (linkedList1Iterator != nullptr && linkedList2Iterator != nullptr) {\n    LinkedList* linkedList1IteratorNext = linkedList1Iterator->next;\n    LinkedList* linkedList2IteratorNext = linkedList2Iterator->next;\n\n    linkedList1Iterator->next = linkedList2Iterator;\n    linkedList2Iterator->next = linkedList1IteratorNext;\n\n    linkedList1Iterator = linkedList1IteratorNext;\n    linkedList2Iterator = linkedList2IteratorNext;\n  }\n\n  return linkedList1;\n}\n\nLinkedList* reverseLinkedList(LinkedList* head) {\n  LinkedList* previousNode = nullptr;\n  LinkedList* currentNode = head;\n  while (currentNode != nullptr) {\n    LinkedList* nextNode = currentNode->next;\n    currentNode->next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nLinkedList* addMany(LinkedList* linkedList, vector<int> values);\nvector<int> getNodesInArray(LinkedList* linkedList);\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      LinkedList* head = addMany(new LinkedList(1), vector<int>{2, 3, 4, 5, 6});\n      vector<int> expected = {1, 6, 2, 5, 3, 4};\n      auto actual = getNodesInArray(zipLinkedList(head));\n      assert(expected == actual);\n    });\n  }\n};\n\nLinkedList* addMany(LinkedList* linkedList, vector<int> values) {\n  LinkedList* current = linkedList;\n  while (current->next != nullptr) {\n    current = current->next;\n  }\n  for (auto value : values) {\n    current->next = new LinkedList(value);\n    current = current->next;\n  }\n  return linkedList;\n}\n\nvector<int> getNodesInArray(LinkedList* linkedList) {\n  vector<int> nodes;\n  LinkedList* current = linkedList;\n  while (current != nullptr) {\n    nodes.push_back(current->value);\n    current = current->next;\n  }\n  return nodes;\n}",
      "unitTests": "LinkedList* addMany(LinkedList* linkedList, vector<int> values);\nvector<int> getNodesInArray(LinkedList* linkedList);\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      LinkedList* head = addMany(new LinkedList(1), vector<int>{2, 3, 4, 5, 6});\n      vector<int> expected = {1, 6, 2, 5, 3, 4};\n      auto actual = getNodesInArray(zipLinkedList(head));\n      assert(expected == actual);\n    });\n  }\n};\n\nLinkedList* addMany(LinkedList* linkedList, vector<int> values) {\n  LinkedList* current = linkedList;\n  while (current->next != nullptr) {\n    current = current->next;\n  }\n  for (auto value : values) {\n    current->next = new LinkedList(value);\n    current = current->next;\n  }\n  return linkedList;\n}\n\nvector<int> getNodesInArray(LinkedList* linkedList) {\n  vector<int> nodes;\n  LinkedList* current = linkedList;\n  while (current != nullptr) {\n    nodes.push_back(current->value);\n    current = current->next;\n  }\n  return nodes;\n}"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  public LinkedList ZipLinkedList(LinkedList linkedList) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  // O(n) time | O(1) space - where n is the length of the Linked List\n  public LinkedList ZipLinkedList(LinkedList linkedList) {\n    if (linkedList.next == null || linkedList.next.next == null) {\n      return linkedList;\n    }\n\n    LinkedList firstHalfHead = linkedList;\n    LinkedList secondHalfHead = splitLinkedList(linkedList);\n\n    LinkedList reversedSecondHalfHead = reverseLinkedList(secondHalfHead);\n\n    return interweaveLinkedLists(firstHalfHead, reversedSecondHalfHead);\n  }\n\n  public LinkedList splitLinkedList(LinkedList linkedList) {\n    LinkedList slowIterator = linkedList;\n    LinkedList fastIterator = linkedList;\n\n    while (fastIterator != null && fastIterator.next != null) {\n      slowIterator = slowIterator.next;\n      fastIterator = fastIterator.next.next;\n    }\n\n    LinkedList secondHalfHead = slowIterator.next;\n    slowIterator.next = null;\n    return secondHalfHead;\n  }\n\n  public LinkedList interweaveLinkedLists(\n    LinkedList linkedList1, LinkedList linkedList2\n  ) {\n    LinkedList linkedList1Iterator = linkedList1;\n    LinkedList linkedList2Iterator = linkedList2;\n\n    while (linkedList1Iterator != null && linkedList2Iterator != null) {\n      LinkedList firstHalfIteratorNext = linkedList1Iterator.next;\n      LinkedList secondHalfIteratorNext = linkedList2Iterator.next;\n\n      linkedList1Iterator.next = linkedList2Iterator;\n      linkedList2Iterator.next = firstHalfIteratorNext;\n\n      linkedList1Iterator = firstHalfIteratorNext;\n      linkedList2Iterator = secondHalfIteratorNext;\n    }\n\n    return linkedList1;\n  }\n\n  public LinkedList reverseLinkedList(LinkedList linkedList) {\n    LinkedList previousNode = null;\n    LinkedList currentNode = linkedList;\n    while (currentNode != null) {\n      LinkedList nextNode = currentNode.next;\n      currentNode.next = previousNode;\n      previousNode = currentNode;\n      currentNode = nextNode;\n    }\n    return previousNode;\n  }\n}"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var head = new Program.LinkedList(1);\n    addMany(head, new int[] { 2, 3, 4, 5, 6 });\n    List<int> expected = new List<int> { 1, 6, 2, 5, 3, 4 };\n    var actual = getNodesInArray(new Program().ZipLinkedList(head));\n    Utils.AssertTrue(Enumerable.SequenceEqual(expected, actual));\n  }\n\n  public List<int> getNodesInArray(Program.LinkedList linkedList) {\n    var nodes = new List<int>();\n    var current = linkedList;\n    while (current != null) {\n      nodes.Add(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n\n  public void addMany(Program.LinkedList head, int[] values) {\n    Program.LinkedList current = head;\n    while (current.next != null) {\n      current = current.next;\n    }\n    foreach (var value in values) {\n      current.next = new Program.LinkedList(value);\n      current = current.next;\n    }\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var head = new Program.LinkedList(1);\n    addMany(head, new int[] { 2, 3, 4, 5, 6 });\n    List<int> expected = new List<int> { 1, 6, 2, 5, 3, 4 };\n    var actual = getNodesInArray(new Program().ZipLinkedList(head));\n    Utils.AssertTrue(Enumerable.SequenceEqual(expected, actual));\n  }\n\n  public List<int> getNodesInArray(Program.LinkedList linkedList) {\n    var nodes = new List<int>();\n    var current = linkedList;\n    while (current != null) {\n      nodes.Add(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n\n  public void addMany(Program.LinkedList head, int[] values) {\n    Program.LinkedList current = head;\n    while (current.next != null) {\n      current = current.next;\n    }\n    foreach (var value in values) {\n      current.next = new Program.LinkedList(value);\n      current = current.next;\n    }\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is an input struct. Do not edit.\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\nfunc ZipLinkedList(linkedList *LinkedList) *LinkedList {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input struct. Do not edit.\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\n// O(n) time | O(1) space - where n is the length of the Linked List\nfunc ZipLinkedList(linkedList *LinkedList) *LinkedList {\n\tif linkedList.Next == nil || linkedList.Next.Next == nil {\n\t\treturn linkedList\n\t}\n\n\tfirstHalfHead := linkedList\n\tsecondHalfHead := splitLinkedList(linkedList)\n\n\treversedSecondHalfHead := reverseLinkedList(secondHalfHead)\n\n\treturn interweaveLinkedLists(firstHalfHead, reversedSecondHalfHead)\n}\n\nfunc splitLinkedList(linkedList *LinkedList) *LinkedList {\n\tslowIterator := linkedList\n\tfastIterator := linkedList\n\tfor fastIterator != nil && fastIterator.Next != nil {\n\t\tslowIterator = slowIterator.Next\n\t\tfastIterator = fastIterator.Next.Next\n\t}\n\n\tsecondHalfHead := slowIterator.Next\n\tslowIterator.Next = nil\n\treturn secondHalfHead\n}\n\nfunc interweaveLinkedLists(linkedList1 *LinkedList, linkedList2 *LinkedList) *LinkedList {\n\tlinkedList1Iterator := linkedList1\n\tlinkedList2Iterator := linkedList2\n\tfor linkedList1Iterator != nil && linkedList2Iterator != nil {\n\t\tlinkedList1IteratorNext := linkedList1Iterator.Next\n\t\tlinkedList2IteratorNext := linkedList2Iterator.Next\n\n\t\tlinkedList1Iterator.Next = linkedList2Iterator\n\t\tlinkedList2Iterator.Next = linkedList1IteratorNext\n\n\t\tlinkedList1Iterator = linkedList1IteratorNext\n\t\tlinkedList2Iterator = linkedList2IteratorNext\n\t}\n\n\treturn linkedList1\n}\n\nfunc reverseLinkedList(head *LinkedList) *LinkedList {\n\tvar previousNode *LinkedList\n\tcurrentNode := head\n\tfor currentNode != nil {\n\t\tnextNode := currentNode.Next\n\t\tcurrentNode.Next = previousNode\n\t\tpreviousNode = currentNode\n\t\tcurrentNode = nextNode\n\t}\n\treturn previousNode\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := addMany(&LinkedList{Value: 1}, []int{2, 3, 4, 5, 6})\n\texpected := []int{1, 6, 2, 5, 3, 4}\n\tactual := ZipLinkedList(input)\n\tresult := getValues(actual)\n\trequire.Equal(t, expected, result)\n}\n\nfunc addMany(linkedList *LinkedList, values []int) *LinkedList {\n\tcurrent := linkedList\n\tfor current.Next != nil {\n\t\tcurrent = current.Next\n\t}\n\tfor _, value := range values {\n\t\tcurrent.Next = &LinkedList{Value: value}\n\t\tcurrent = current.Next\n\t}\n\treturn linkedList\n}\n\nfunc getValues(linkedList *LinkedList) []int {\n\tvalues := []int{}\n\tcurrent := linkedList\n\tfor current != nil {\n\t\tvalues = append(values, current.Value)\n\t\tcurrent = current.Next\n\t}\n\treturn values\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := addMany(&LinkedList{Value: 1}, []int{2, 3, 4, 5, 6})\n\texpected := []int{1, 6, 2, 5, 3, 4}\n\tactual := ZipLinkedList(input)\n\tresult := getValues(actual)\n\trequire.Equal(t, expected, result)\n}\n\nfunc addMany(linkedList *LinkedList, values []int) *LinkedList {\n\tcurrent := linkedList\n\tfor current.Next != nil {\n\t\tcurrent = current.Next\n\t}\n\tfor _, value := range values {\n\t\tcurrent.Next = &LinkedList{Value: value}\n\t\tcurrent = current.Next\n\t}\n\treturn linkedList\n}\n\nfunc getValues(linkedList *LinkedList) []int {\n\tvalues := []int{}\n\tcurrent := linkedList\n\tfor current != nil {\n\t\tvalues = append(values, current.Value)\n\t\tcurrent = current.Next\n\t}\n\treturn values\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  public static class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  public LinkedList zipLinkedList(LinkedList linkedList) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  public static class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  // O(n) time | O(1) space - where n is the length of the Linked List\n  public LinkedList zipLinkedList(LinkedList linkedList) {\n    if (linkedList.next == null || linkedList.next.next == null) {\n      return linkedList;\n    }\n\n    LinkedList firstHalfHead = linkedList;\n    LinkedList secondHalfHead = splitLinkedList(linkedList);\n\n    LinkedList reversedSecondHalfHead = reverseLinkedList(secondHalfHead);\n\n    return interweaveLinkedLists(firstHalfHead, reversedSecondHalfHead);\n  }\n\n  public LinkedList splitLinkedList(LinkedList linkedList) {\n    LinkedList slowIterator = linkedList;\n    LinkedList fastIterator = linkedList;\n\n    while (fastIterator != null && fastIterator.next != null) {\n      slowIterator = slowIterator.next;\n      fastIterator = fastIterator.next.next;\n    }\n\n    LinkedList secondHalfHead = slowIterator.next;\n    slowIterator.next = null;\n    return secondHalfHead;\n  }\n\n  public LinkedList interweaveLinkedLists(\n    LinkedList linkedList1, LinkedList linkedList2\n  ) {\n    LinkedList linkedList1Iterator = linkedList1;\n    LinkedList linkedList2Iterator = linkedList2;\n\n    while (linkedList1Iterator != null && linkedList2Iterator != null) {\n      LinkedList firstHalfIteratorNext = linkedList1Iterator.next;\n      LinkedList secondHalfIteratorNext = linkedList2Iterator.next;\n\n      linkedList1Iterator.next = linkedList2Iterator;\n      linkedList2Iterator.next = firstHalfIteratorNext;\n\n      linkedList1Iterator = firstHalfIteratorNext;\n      linkedList2Iterator = secondHalfIteratorNext;\n    }\n\n    return linkedList1;\n  }\n\n  public LinkedList reverseLinkedList(LinkedList linkedList) {\n    LinkedList previousNode = null;\n    LinkedList currentNode = linkedList;\n    while (currentNode != null) {\n      LinkedList nextNode = currentNode.next;\n      currentNode.next = previousNode;\n      previousNode = currentNode;\n      currentNode = nextNode;\n    }\n    return previousNode;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    TestLinkedList head = new TestLinkedList(1);\n    head.addMany(new int[] {2, 3, 4, 5, 6});\n    List<Integer> expected =\n      new ArrayList<Integer>(Arrays.asList(1, 6, 2, 5, 3, 4));\n    var actual = getNodesInArray(new Program().zipLinkedList(head));\n    Utils.assertTrue(expected.equals(actual));\n  }\n\n  public List<Integer> getNodesInArray(Program.LinkedList linkedList) {\n    var nodes = new ArrayList<Integer>();\n    var current = linkedList;\n    while (current != null) {\n      nodes.add(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n\n  class TestLinkedList extends Program.LinkedList {\n    public TestLinkedList(int value) {\n      super(value);\n    }\n\n    public void addMany(int[] values) {\n      Program.LinkedList current = this;\n      while (current.next != null) {\n        current = current.next;\n      }\n      for (int value : values) {\n        current.next = new Program.LinkedList(value);\n        current = current.next;\n      }\n    }\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    TestLinkedList head = new TestLinkedList(1);\n    head.addMany(new int[] {2, 3, 4, 5, 6});\n    List<Integer> expected =\n      new ArrayList<Integer>(Arrays.asList(1, 6, 2, 5, 3, 4));\n    var actual = getNodesInArray(new Program().zipLinkedList(head));\n    Utils.assertTrue(expected.equals(actual));\n  }\n\n  public List<Integer> getNodesInArray(Program.LinkedList linkedList) {\n    var nodes = new ArrayList<Integer>();\n    var current = linkedList;\n    while (current != null) {\n      nodes.add(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n\n  class TestLinkedList extends Program.LinkedList {\n    public TestLinkedList(int value) {\n      super(value);\n    }\n\n    public void addMany(int[] values) {\n      Program.LinkedList current = this;\n      while (current.next != null) {\n        current = current.next;\n      }\n      for (int value : values) {\n        current.next = new Program.LinkedList(value);\n        current = current.next;\n      }\n    }\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction zipLinkedList(linkedList) {\n  // Write your code here.\n  return linkedList;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.zipLinkedList = zipLinkedList;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the length of the Linked List\nfunction zipLinkedList(linkedList) {\n  if (linkedList.next === null || linkedList.next.next === null) return linkedList;\n\n  const firstHalfHead = linkedList;\n  const secondHalfHead = splitLinkedList(linkedList);\n\n  const reversedSecondHalfHead = reverseLinkedList(secondHalfHead);\n\n  return interweaveLinkedLists(firstHalfHead, reversedSecondHalfHead);\n}\n\nfunction splitLinkedList(linkedList) {\n  let slowIterator = linkedList;\n  let fastIterator = linkedList;\n  while (fastIterator !== null && fastIterator.next !== null) {\n    slowIterator = slowIterator.next;\n    fastIterator = fastIterator.next.next;\n  }\n\n  const secondHalfHead = slowIterator.next;\n  slowIterator.next = null;\n  return secondHalfHead;\n}\n\nfunction interweaveLinkedLists(linkedList1, linkedList2) {\n  let linkedList1Iterator = linkedList1;\n  let linkedList2Iterator = linkedList2;\n  while (linkedList1Iterator !== null && linkedList2Iterator !== null) {\n    const linkedList1IteratorNext = linkedList1Iterator.next;\n    const linkedList2IteratorNext = linkedList2Iterator.next;\n\n    linkedList1Iterator.next = linkedList2Iterator;\n    linkedList2Iterator.next = linkedList1IteratorNext;\n\n    linkedList1Iterator = linkedList1IteratorNext;\n    linkedList2Iterator = linkedList2IteratorNext;\n  }\n\n  return linkedList1;\n}\n\nfunction reverseLinkedList(head) {\n  let previousNode = null;\n  let currentNode = head;\n  while (currentNode !== null) {\n    const nextNode = currentNode.next;\n    currentNode.next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.zipLinkedList = zipLinkedList;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const head = new LinkedList(1).addMany([2, 3, 4, 5, 6]);\n  const expected = [1, 6, 2, 5, 3, 4];\n  const actual = program.zipLinkedList(head).getNodesInArray();\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const head = new LinkedList(1).addMany([2, 3, 4, 5, 6]);\n  const expected = [1, 6, 2, 5, 3, 4];\n  const actual = program.zipLinkedList(head).getNodesInArray();\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\nfun zipLinkedList(linkedList: LinkedList): LinkedList {\n    // Write your code here.\n    return LinkedList(-1)\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\n// O(n) time | O(1) space - where n is the length of the Linked List\nfun zipLinkedList(linkedList: LinkedList): LinkedList {\n    if (linkedList.next == null || linkedList.next!!.next == null) {\n        return linkedList\n    }\n\n    val firstHalfHead = linkedList\n    val secondHalfHead = splitLinkedList(linkedList)\n\n    val reversedSecondHalfHead = reverseLinkedList(secondHalfHead)\n\n    return interweaveLinkedLists(firstHalfHead, reversedSecondHalfHead)\n}\n\nfun splitLinkedList(linkedList: LinkedList): LinkedList {\n    var slowIterator = linkedList\n    var fastIterator: LinkedList? = linkedList\n    while (fastIterator != null && fastIterator.next != null) {\n        slowIterator = slowIterator.next!!\n        fastIterator = fastIterator.next!!.next\n    }\n\n    val secondHalfHead = slowIterator.next!!\n    slowIterator.next = null\n    return secondHalfHead\n}\n\nfun interweaveLinkedLists(linkedList1: LinkedList, linkedList2: LinkedList): LinkedList {\n    var linkedList1Iterator: LinkedList? = linkedList1\n    var linkedList2Iterator: LinkedList? = linkedList2\n    while (linkedList1Iterator != null && linkedList2Iterator != null) {\n        val linkedList1IteratorNext = linkedList1Iterator.next\n        val linkedList2IteratorNext = linkedList2Iterator.next\n\n        linkedList1Iterator.next = linkedList2Iterator\n        linkedList2Iterator.next = linkedList1IteratorNext\n\n        linkedList1Iterator = linkedList1IteratorNext\n        linkedList2Iterator = linkedList2IteratorNext\n    }\n\n    return linkedList1\n}\n\nfun reverseLinkedList(head: LinkedList): LinkedList {\n    var previousNode: LinkedList? = null\n    var currentNode: LinkedList? = head\n    while (currentNode != null) {\n        val nextNode: LinkedList? = currentNode.next\n        currentNode.next = previousNode\n        previousNode = currentNode\n        currentNode = nextNode\n    }\n    return previousNode!!\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.LinkedList\nimport com.algoexpert.program.zipLinkedList\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val test = addMany(LinkedList(1), listOf(2, 3, 4, 5, 6))\n        val result = getNodesInArray(zipLinkedList(test))\n        val expected = listOf(1, 6, 2, 5, 3, 4)\n        assert(result.equals(expected))\n    }\n}\n\nfun addMany(linkedList: LinkedList, values: List<Int>): LinkedList {\n    var current = linkedList\n    while (current.next != null) {\n        current = current.next!!\n    }\n    for (value in values) {\n        current.next = LinkedList(value)\n        current = current.next!!\n    }\n    return linkedList\n}\n\nfun getNodesInArray(linkedList: LinkedList?): List<Int> {\n    val nodes = mutableListOf<Int>()\n    var current: LinkedList? = linkedList\n    while (current != null) {\n        nodes.add(current.value)\n        current = current.next\n    }\n    return nodes\n}\n",
      "unitTests": "import com.algoexpert.program.LinkedList\nimport com.algoexpert.program.zipLinkedList\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val test = addMany(LinkedList(1), listOf(2, 3, 4, 5, 6))\n        val result = getNodesInArray(zipLinkedList(test))\n        val expected = listOf(1, 6, 2, 5, 3, 4)\n        assert(result.equals(expected))\n    }\n}\n\nfun addMany(linkedList: LinkedList, values: List<Int>): LinkedList {\n    var current = linkedList\n    while (current.next != null) {\n        current = current.next!!\n    }\n    for (value in values) {\n        current.next = LinkedList(value)\n        current = current.next!!\n    }\n    return linkedList\n}\n\nfun getNodesInArray(linkedList: LinkedList?): List<Int> {\n    val nodes = mutableListOf<Int>()\n    var current: LinkedList? = linkedList\n    while (current != null) {\n        nodes.add(current.value)\n        current = current.next\n    }\n    return nodes\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\ndef zipLinkedList(linkedList):\n    # Write your code here.\n    return None\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\n# O(n) time | O(1) space - where n is the length of the Linked List\ndef zipLinkedList(linkedList):\n    if linkedList.next is None or linkedList.next.next is None:\n        return linkedList\n\n    firstHalfHead = linkedList\n    secondHalfHead = splitLinkedList(linkedList)\n\n    reversedSecondHalfHead = reverseLinkedList(secondHalfHead)\n\n    return interweaveLinkedLists(firstHalfHead, reversedSecondHalfHead)\n\n\ndef splitLinkedList(linkedList):\n    slowIterator = linkedList\n    fastIterator = linkedList\n    while fastIterator is not None and fastIterator.next is not None:\n        slowIterator = slowIterator.next\n        fastIterator = fastIterator.next.next\n\n    secondHalfHead = slowIterator.next\n    slowIterator.next = None\n    return secondHalfHead\n\n\ndef interweaveLinkedLists(linkedList1, linkedList2):\n    linkedList1Iterator = linkedList1\n    linkedList2Iterator = linkedList2\n    while linkedList1Iterator is not None and linkedList2Iterator is not None:\n        linkedList1IteratorNext = linkedList1Iterator.next\n        linkedList2IteratorNext = linkedList2Iterator.next\n\n        linkedList1Iterator.next = linkedList2Iterator\n        linkedList2Iterator.next = linkedList1IteratorNext\n\n        linkedList1Iterator = linkedList1IteratorNext\n        linkedList2Iterator = linkedList2IteratorNext\n\n    return linkedList1\n\n\ndef reverseLinkedList(linkedList):\n    previousNode, currentNode = None, linkedList\n    while currentNode is not None:\n        nextNode = currentNode.next\n        currentNode.next = previousNode\n        previousNode = currentNode\n        currentNode = nextNode\n    return previousNode\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass LinkedList(program.LinkedList):\n    def addMany(self, values):\n        current = self\n        while current.next is not None:\n            current = current.next\n        for value in values:\n            current.next = LinkedList(value)\n            current = current.next\n        return self\n\n    def getNodesInArray(self):\n        nodes = []\n        current = self\n        while current is not None:\n            nodes.append(current.value)\n            current = current.next\n        return nodes\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        head = LinkedList(1).addMany([2, 3, 4, 5, 6])\n        expected = [1, 6, 2, 5, 3, 4]\n        actual = program.zipLinkedList(head).getNodesInArray()\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass LinkedList(program.LinkedList):\n    def addMany(self, values):\n        current = self\n        while current.next is not None:\n            current = current.next\n        for value in values:\n            current.next = LinkedList(value)\n            current = current.next\n        return self\n\n    def getNodesInArray(self):\n        nodes = []\n        current = self\n        while current is not None:\n            nodes.append(current.value)\n            current = current.next\n        return nodes\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        head = LinkedList(1).addMany([2, 3, 4, 5, 6])\n        expected = [1, 6, 2, 5, 3, 4]\n        actual = program.zipLinkedList(head).getNodesInArray()\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "# This is an input struct. Do not edit.\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\nclass Program\n  def zipLinkedList(linkedList)\n    # Write your code here.\n    return nil\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\nclass Program\n  def zipLinkedList(linkedList)\n    # Write your code here.\n    return nil\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.zipLinkedList\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.zipLinkedList\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class LinkedList {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  func zipLinkedList(_ linkedList: LinkedList) -> LinkedList {\n    // Write your code here.\n    return LinkedList(value: -1)\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class LinkedList {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  // O(n) time | O(1) space - where n is the length of the Linked List\n  func zipLinkedList(_ linkedList: LinkedList) -> LinkedList {\n    if linkedList.next == nil || linkedList.next!.next == nil {\n      return linkedList\n    }\n\n    let firstHalfHead = linkedList\n    let secondHalfHead = splitLinkedList(linkedList)\n\n    let reversedSecondHalfHead = reverseLinkedList(secondHalfHead)\n\n    return interweaveLinkedLists(firstHalfHead, reversedSecondHalfHead)!\n  }\n\n  func splitLinkedList(_ linkedList: LinkedList?) -> LinkedList? {\n    var slowIterator = linkedList\n    var fastIterator = linkedList\n    while fastIterator != nil, fastIterator!.next != nil {\n      slowIterator = slowIterator!.next\n      fastIterator = fastIterator!.next!.next\n    }\n\n    let secondHalfHead = slowIterator!.next\n    slowIterator!.next = nil\n    return secondHalfHead\n  }\n\n  func interweaveLinkedLists(_ linkedList1: LinkedList?, _ linkedList2: LinkedList?) -> LinkedList? {\n    var linkedList1Iterator = linkedList1\n    var linkedList2Iterator = linkedList2\n    while linkedList1Iterator != nil, linkedList2Iterator != nil {\n      let linkedList1IteratorNext = linkedList1Iterator!.next\n      let linkedList2IteratorNext = linkedList2Iterator!.next\n\n      linkedList1Iterator!.next = linkedList2Iterator\n      linkedList2Iterator!.next = linkedList1IteratorNext\n\n      linkedList1Iterator = linkedList1IteratorNext\n      linkedList2Iterator = linkedList2IteratorNext\n    }\n\n    return linkedList1\n  }\n\n  func reverseLinkedList(_ head: LinkedList?) -> LinkedList? {\n    var previousNode: LinkedList?\n    var currentNode = head\n    while currentNode != nil {\n      let nextNode = currentNode!.next\n      currentNode!.next = previousNode\n      previousNode = currentNode\n      currentNode = nextNode\n    }\n    return previousNode\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let input = addMany(Program.LinkedList(value: 1), [2, 3, 4, 5, 6])\n      let expected = [1, 6, 2, 5, 3, 4]\n      var actual = Program().zipLinkedList(input)\n      let result = getValues(actual)\n      try assertEqual(expected, result)\n    }\n  }\n\n  func addMany(_ linkedList: Program.LinkedList, _ values: [Int]) -> Program.LinkedList {\n    var current: Program.LinkedList = linkedList\n    while current.next != nil {\n      current = current.next!\n    }\n    for value in values {\n      current.next = Program.LinkedList(value: value)\n      current = current.next!\n    }\n    return linkedList\n  }\n\n  func getValues(_ linkedList: Program.LinkedList) -> [Int] {\n    var values = [Int]()\n    var current: Program.LinkedList? = linkedList\n    while current != nil {\n      values.append(current!.value)\n      current = current!.next\n    }\n    return values\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let input = addMany(Program.LinkedList(value: 1), [2, 3, 4, 5, 6])\n      let expected = [1, 6, 2, 5, 3, 4]\n      var actual = Program().zipLinkedList(input)\n      let result = getValues(actual)\n      try assertEqual(expected, result)\n    }\n  }\n\n  func addMany(_ linkedList: Program.LinkedList, _ values: [Int]) -> Program.LinkedList {\n    var current: Program.LinkedList = linkedList\n    while current.next != nil {\n      current = current.next!\n    }\n    for value in values {\n      current.next = Program.LinkedList(value: value)\n      current = current.next!\n    }\n    return linkedList\n  }\n\n  func getValues(_ linkedList: Program.LinkedList) -> [Int] {\n    var values = [Int]()\n    var current: Program.LinkedList? = linkedList\n    while current != nil {\n      values.append(current!.value)\n      current = current!.next\n    }\n    return values\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nexport function zipLinkedList(linkedList: LinkedList) {\n  // Write your code here.\n  return linkedList;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the length of the Linked List\nexport function zipLinkedList(linkedList: LinkedList) {\n  if (linkedList.next === null || linkedList.next.next === null) return linkedList;\n\n  const firstHalfHead = linkedList;\n  const secondHalfHead = splitLinkedList(linkedList);\n\n  const reversedSecondHalfHead = reverseLinkedList(secondHalfHead);\n\n  return interweaveLinkedLists(firstHalfHead, reversedSecondHalfHead);\n}\n\nfunction splitLinkedList(linkedList: LinkedList) {\n  let slowIterator = linkedList;\n  let fastIterator: LinkedList | null = linkedList;\n  while (fastIterator !== null && fastIterator.next !== null) {\n    slowIterator = slowIterator.next!;\n    fastIterator = fastIterator.next.next;\n  }\n\n  const secondHalfHead = slowIterator.next!;\n  slowIterator.next = null;\n  return secondHalfHead;\n}\n\nfunction interweaveLinkedLists(linkedList1: LinkedList, linkedList2: LinkedList) {\n  let linkedList1Iterator: LinkedList | null = linkedList1;\n  let linkedList2Iterator: LinkedList | null = linkedList2;\n  while (linkedList1Iterator !== null && linkedList2Iterator !== null) {\n    const linkedList1IteratorNext: LinkedList | null = linkedList1Iterator.next;\n    const linkedList2IteratorNext: LinkedList | null = linkedList2Iterator.next;\n\n    linkedList1Iterator.next = linkedList2Iterator;\n    linkedList2Iterator.next = linkedList1IteratorNext;\n\n    linkedList1Iterator = linkedList1IteratorNext;\n    linkedList2Iterator = linkedList2IteratorNext;\n  }\n\n  return linkedList1;\n}\n\nfunction reverseLinkedList(head: LinkedList) {\n  let previousNode: LinkedList | null = null;\n  let currentNode: LinkedList | null = head;\n  while (currentNode !== null) {\n    const nextNode: LinkedList | null = currentNode.next;\n    currentNode.next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode!;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const head = addMany(new program.LinkedList(1), [2, 3, 4, 5, 6]);\n  const expected = [1, 6, 2, 5, 3, 4];\n  const actual = getNodesInArray(program.zipLinkedList(head));\n  chai.expect(actual).to.deep.equal(expected);\n});\n\nfunction addMany(linkedList: program.LinkedList, values: number[]) {\n  let current = linkedList;\n  while (current.next !== null) {\n    current = current.next;\n  }\n  for (const value of values) {\n    current.next = new program.LinkedList(value);\n    current = current.next;\n  }\n  return linkedList;\n}\n\nfunction getNodesInArray(linkedList: program.LinkedList) {\n  const nodes: number[] = [];\n  let current: program.LinkedList | null = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const head = addMany(new program.LinkedList(1), [2, 3, 4, 5, 6]);\n  const expected = [1, 6, 2, 5, 3, 4];\n  const actual = getNodesInArray(program.zipLinkedList(head));\n  chai.expect(actual).to.deep.equal(expected);\n});\n\nfunction addMany(linkedList: program.LinkedList, values: number[]) {\n  let current = linkedList;\n  while (current.next !== null) {\n    current = current.next;\n  }\n  for (const value of values) {\n    current.next = new program.LinkedList(value);\n    current = current.next;\n  }\n  return linkedList;\n}\n\nfunction getNodesInArray(linkedList: program.LinkedList) {\n  const nodes: number[] = [];\n  let current: program.LinkedList | null = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n"
    }
  },
  "customInputVars": [
    {
      "name": "linkedList",
      "example": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": null,
            "value": 6
          }
        ]
      },
      "schema": {
        "description": "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
        "properties": {
          "head": {
            "type": "string"
          },
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "next": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "next"
              ],
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "head",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": null,
            "value": 6
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": null,
            "value": 7
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": null,
            "value": 3
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": "10",
            "value": 9
          },
          {
            "id": "10",
            "next": null,
            "value": 10
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": "10",
            "value": 9
          },
          {
            "id": "10",
            "next": "11",
            "value": 10
          },
          {
            "id": "11",
            "next": null,
            "value": 11
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "-6",
            "value": 1
          },
          {
            "id": "-6",
            "next": "8",
            "value": -6
          },
          {
            "id": "8",
            "next": "5",
            "value": 8
          },
          {
            "id": "5",
            "next": "10",
            "value": 5
          },
          {
            "id": "10",
            "next": "-1",
            "value": 10
          },
          {
            "id": "-1",
            "next": "0",
            "value": -1
          },
          {
            "id": "0",
            "next": "2",
            "value": 0
          },
          {
            "id": "2",
            "next": "11",
            "value": 2
          },
          {
            "id": "11",
            "next": "-100",
            "value": 11
          },
          {
            "id": "-100",
            "next": "99",
            "value": -100
          },
          {
            "id": "99",
            "next": null,
            "value": 99
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "-6",
            "value": 1
          },
          {
            "id": "-6",
            "next": "8",
            "value": -6
          },
          {
            "id": "8",
            "next": "5",
            "value": 8
          },
          {
            "id": "5",
            "next": "10",
            "value": 5
          },
          {
            "id": "10",
            "next": "-1",
            "value": 10
          },
          {
            "id": "-1",
            "next": "0",
            "value": -1
          },
          {
            "id": "0",
            "next": "2",
            "value": 0
          },
          {
            "id": "2",
            "next": "11",
            "value": 2
          },
          {
            "id": "11",
            "next": "-100",
            "value": 11
          },
          {
            "id": "-100",
            "next": "99",
            "value": -100
          },
          {
            "id": "99",
            "next": "50",
            "value": 99
          },
          {
            "id": "50",
            "next": null,
            "value": 50
          }
        ]
      }
    }
  ],
  "jsonTests": [
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": null,
            "value": 6
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": null,
            "value": 7
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": null,
            "value": 3
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": null,
            "value": 2
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": "10",
            "value": 9
          },
          {
            "id": "10",
            "next": null,
            "value": 10
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": "10",
            "value": 9
          },
          {
            "id": "10",
            "next": "11",
            "value": 10
          },
          {
            "id": "11",
            "next": null,
            "value": 11
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "-6",
            "value": 1
          },
          {
            "id": "-6",
            "next": "8",
            "value": -6
          },
          {
            "id": "8",
            "next": "5",
            "value": 8
          },
          {
            "id": "5",
            "next": "10",
            "value": 5
          },
          {
            "id": "10",
            "next": "-1",
            "value": 10
          },
          {
            "id": "-1",
            "next": "0",
            "value": -1
          },
          {
            "id": "0",
            "next": "2",
            "value": 0
          },
          {
            "id": "2",
            "next": "11",
            "value": 2
          },
          {
            "id": "11",
            "next": "-100",
            "value": 11
          },
          {
            "id": "-100",
            "next": "99",
            "value": -100
          },
          {
            "id": "99",
            "next": null,
            "value": 99
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "-6",
            "value": 1
          },
          {
            "id": "-6",
            "next": "8",
            "value": -6
          },
          {
            "id": "8",
            "next": "5",
            "value": 8
          },
          {
            "id": "5",
            "next": "10",
            "value": 5
          },
          {
            "id": "10",
            "next": "-1",
            "value": 10
          },
          {
            "id": "-1",
            "next": "0",
            "value": -1
          },
          {
            "id": "0",
            "next": "2",
            "value": 0
          },
          {
            "id": "2",
            "next": "11",
            "value": 2
          },
          {
            "id": "11",
            "next": "-100",
            "value": 11
          },
          {
            "id": "-100",
            "next": "99",
            "value": -100
          },
          {
            "id": "99",
            "next": "50",
            "value": 99
          },
          {
            "id": "50",
            "next": null,
            "value": 50
          }
        ]
      }
    }
  ],
  "changelog": []
}