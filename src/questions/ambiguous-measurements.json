{
  "uid": "ambiguous-measurements",
  "testStrategy": "JSON",
  "name": "Ambiguous Measurements",
  "version": 0,
  "releaseDate": "2021-04-01T00:00:00Z",
  "category": "Recursion",
  "difficulty": 3,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 3431,
    "failureCount": 875
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "524804264",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 2117
  },
  "prompt": "<div class=\"html\">\n<p>\n  This problem deals with measuring cups that are missing important measuring\n  labels. Specifically, a measuring cup only has two measuring lines, a Low (L)\n  line and a High (H) line. This means that these cups can't precisely measure\n  and can only guarantee that the substance poured into them will be between the\n  L and H line. For example, you might have a measuring cup that has a Low line\n  at <span>400ml</span> and a high line at <span>435ml</span>. This means that\n  when you use this measuring cup, you can only be sure that what you're\n  measuring is between <span>400ml</span> and <span>435ml</span>.\n</p>\n<p>\n  You're given a list of measuring cups containing their low and high lines as\n  well as one <span>low</span> integer and one <span>high</span> integer\n  representing a range for a target measurement. Write a function that returns a\n  boolean representing whether you can use the cups to accurately measure a\n  volume in the specified <span>[low, high]</span> range (the range is\n  inclusive).\n</p>\n<p>Note that:</p>\n<ul>\n  <li>\n    Each measuring cup will be represented by a pair of positive integers\n    <span>[L, H]</span>, where <span>0 &lt;= L &lt;= H</span>.\n  </li>\n  <li>\n    You'll always be given at least one measuring cup, and the\n    <span>low</span> and <span>high</span> input parameters will always satisfy\n    the following constraint: <span>0 &lt;= low &lt;= high</span>.\n  </li>\n  <li>\n    Once you've measured some liquid, it will immediately be transferred to a\n    larger bowl that will eventually (possibly) contain the target measurement.\n  </li>\n  <li>You can't pour the contents of one measuring cup into another cup.</li>\n</ul>\n<p></p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">measuringCups</span> = [\n  [200, 210],\n  [450, 465],\n  [800, 850],\n] \n<span class=\"CodeEditor-promptParameter\">low</span> = 2100\n<span class=\"CodeEditor-promptParameter\">high</span> = 2300\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n<span class=\"CodeEditor-promptComment\">// We use cup [450, 465] to measure four volumes:</span>\n<span class=\"CodeEditor-promptComment\">// First measurement: Low = 450, High = 465</span>\n<span class=\"CodeEditor-promptComment\">// Second measurement: Low = 450 + 450 = 900, High = 465 + 465 = 930</span>\n<span class=\"CodeEditor-promptComment\">// Third measurement: Low = 900 + 450 = 1350, High = 930 + 465 = 1395</span>\n<span class=\"CodeEditor-promptComment\">// Fourth measurement: Low = 1350 + 450 = 1800, High = 1395 + 465 = 1860</span>\n\n<span class=\"CodeEditor-promptComment\">// Then we use cup [200, 210] to measure two volumes:</span>\n<span class=\"CodeEditor-promptComment\">// Fifth measurement: Low = 1800 + 200 = 2000, High = 1860 + 210 = 2070</span>\n<span class=\"CodeEditor-promptComment\">// Sixth measurement: Low = 2000 + 200 = 2200, High = 2070 + 210 = 2280</span>\n\n<span class=\"CodeEditor-promptComment\">// We've measured a volume in the range [2200, 2280].</span>\n<span class=\"CodeEditor-promptComment\">// This is within our target range, so we return `true`.</span>\n\n<span class=\"CodeEditor-promptComment\">// Note: there are other ways to measure a volume in the target range.</span>\n</pre>\n</div>",
  "hints": [
    "<p>\n  Start by considering the last cup that you'll use in your sequence of\n  measurements. If it isn't possible to use any of the cups as the last cup,\n  then you can't measure the desired volume.\n</p>\n",
    "\n<p>\n  If the cup that you're going to use last has a measuring range of\n  <span>[100, 110]</span> and you want to measure in the range of\n  <span>[500, 550]</span>, then after you pick this cup as the last cup, you\n  need to measure a range of <span>[400, 440]</span>. Now, you can simply pick\n  the last cup you'll use to measure this new range. If you continue these\n  steps, you'll eventually know if you're able to measure the entire range or\n  not.\n</p>\n",
    "\n<p>\n  Hint #2 should give you an idea of how to solve this problem recursively. Try\n  every cup as the last cup for the starting range, then recursively try to\n  measure the new ranges created after using the selected last cups. If you ever\n  reach a point where one cup can measure the entire range, then you're finished\n  and you can measure the target range. Try to think of a way to optimize this\n  recursive approach, since it might involve a lot of repeated calculations.\n</p>"
  ],
  "spaceTime": "O(low * high * n) time | O(low * high) space - where n is the number of measuring cups",
  "notes": "<div class=\"html\">\n<p>\n  As we recursively call our <span>canMeasureInRange</span> function, we might\n  realize that if the input <span>low</span> is ever less than or equal to\n  <span>0</span>, the outcome for that <span>low</span> is always the same.\n</p>\n<p>\n  In other words, checking if we can measure in the range\n  <span>[-10, 10]</span> is equivalent to checking if we can measure in the\n  range <span>[-5, 10]</span>, which itself is equivalent to checking if we can\n  measure in the range <span>[0, 10]</span>.\n</p>\n<p>The same logic applies to the <span>high</span> value.</p>\n<p>\n  Thus, we can optimize the solution described in the video explanation by\n  capping the <span>low</span> and <span>high</span> values that we pass to our\n  <span>canMeasureInRange</span> function to <span>0</span>. This reduces the\n  number of keys in our cache and maximizes cache hits, thereby optimizing our\n  solution in practice (though not from a time-complexity point of view).\n</p>\n<p>\n  The two comments in the code snippet below highlight the changes that we've\n  made to the code covered in the video explanation.\n</p>\n<pre>\n<span class=\"CodeEditor-promptComment\">// Change `<` to `<=`.</span>\nif low <= 0 and high <= 0:\n    return False\n\ncanMeasure = False\nfor cup in measuringCups:\n    cupLow, cupHigh = cup\n    if low <= cupLow and cupHigh <= high:\n        canMeasure = True\n        break\n\n    <span class=\"CodeEditor-promptComment\">// Cap the `newLow` and `newHigh` to 0.</span>\n    newLow = max(0, low - cupLow)\n    newHigh = max(0, high - cupHigh)\n    canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization)\n    if canMeasure:\n        break\n</pre>\n</div>",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nbool ambiguousMeasurements(\n  vector<vector<int>> measuringCups, int low, int high\n) {\n  // Write your code here.\n  return false;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nbool canMeasureInRange(\n  vector<vector<int>>& measuringCups,\n  int low,\n  int high,\n  unordered_map<string, bool>& memoization\n);\nstring createHashableKey(int low, int high);\n\n// O(low * high * n) time | O(low * high) space - where n is the number of\n// measuring cups\nbool ambiguousMeasurements(\n  vector<vector<int>> measuringCups, int low, int high\n) {\n  unordered_map<string, bool> memoization;\n  return canMeasureInRange(measuringCups, low, high, memoization);\n}\n\nbool canMeasureInRange(\n  vector<vector<int>>& measuringCups,\n  int low,\n  int high,\n  unordered_map<string, bool>& memoization\n) {\n  string memoizeKey = createHashableKey(low, high);\n  if (memoization.find(memoizeKey) != memoization.end()) {\n    return memoization[memoizeKey];\n  }\n\n  if (low <= 0 && high <= 0) {\n    return false;\n  }\n\n  bool canMeasure = false;\n  for (auto cup : measuringCups) {\n    int cupLow = cup[0];\n    int cupHigh = cup[1];\n    if (low <= cupLow && cupHigh <= high) {\n      canMeasure = true;\n      break;\n    }\n\n    int newLow = max(0, low - cupLow);\n    int newHigh = max(0, high - cupHigh);\n    canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization);\n    if (canMeasure) break;\n  }\n\n  memoization[memoizeKey] = canMeasure;\n  return canMeasure;\n}\n\nstring createHashableKey(int low, int high) {\n  return to_string(low) + \":\" + to_string(high);\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> cups = {{200, 210}, {450, 465}, {800, 850}};\n      int low = 2100;\n      int high = 2300;\n      auto expected = true;\n      auto actual = ambiguousMeasurements(cups, low, high);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> cups = {{200, 210}, {450, 465}, {800, 850}};\n      int low = 2100;\n      int high = 2300;\n      auto expected = true;\n      auto actual = ambiguousMeasurements(cups, low, high);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public bool AmbiguousMeasurements(int[][] measuringCups, int low, int high) {\n    // Write your code here.\n    return false;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // O(low * high * n) time | O(low * high) space - where n is the number of\n  // measuring cups\n  public bool AmbiguousMeasurements(int[][] measuringCups, int low, int high) {\n    Dictionary<string, bool> memoization = new Dictionary<string, bool>();\n    return canMeasureInRange(measuringCups, low, high, memoization);\n  }\n\n  public bool canMeasureInRange(\n    int[][] measuringCups,\n    int low,\n    int high,\n    Dictionary<string, bool> memoization\n  ) {\n    string memoizeKey = createHashableKey(low, high);\n    if (memoization.ContainsKey(memoizeKey)) {\n      return memoization[memoizeKey];\n    }\n\n    if (low <= 0 && high <= 0) {\n      return false;\n    }\n\n    bool canMeasure = false;\n    foreach (var cup in measuringCups) {\n      int cupLow = cup[0];\n      int cupHigh = cup[1];\n      if (low <= cupLow && cupHigh <= high) {\n        canMeasure = true;\n        break;\n      }\n\n      int newLow = Math.Max(0, low - cupLow);\n      int newHigh = Math.Max(0, high - cupHigh);\n      canMeasure =\n        canMeasureInRange(measuringCups, newLow, newHigh, memoization);\n      if (canMeasure) break;\n    }\n\n    memoization[memoizeKey] = canMeasure;\n    return canMeasure;\n  }\n\n  public string createHashableKey(int low, int high) {\n    return low.ToString() + \":\" + high.ToString();\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[][] cups = new int[][] {\n      new int[] { 200, 210 }, new int[] { 450, 465 }, new int[] { 800, 850 }\n    };\n    int low = 2100;\n    int high = 2300;\n    bool expected = true;\n    var actual = new Program().AmbiguousMeasurements(cups, low, high);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[][] cups = new int[][] {\n      new int[] { 200, 210 }, new int[] { 450, 465 }, new int[] { 800, 850 }\n    };\n    int low = 2100;\n    int high = 2300;\n    bool expected = true;\n    var actual = new Program().AmbiguousMeasurements(cups, low, high);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc AmbiguousMeasurements(measuringCups [][]int, low int, high int) bool {\n\t// Write your code here.\n\treturn false\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// O(low * high * n) time | O(low * high) space - where n is the number of measuring cups\nfunc AmbiguousMeasurements(measuringCups [][]int, low int, high int) bool {\n\tmemoization := map[string]bool{}\n\treturn canMeasureInRange(measuringCups, low, high, memoization)\n}\n\nfunc canMeasureInRange(measuringCups [][]int, low, high int, memoization map[string]bool) bool {\n\tmemoizeKey := createHashtableKey(low, high)\n\tif val, found := memoization[memoizeKey]; found {\n\t\treturn val\n\t}\n\n\tif low <= 0 && high <= 0 {\n\t\treturn false\n\t}\n\n\tcanMeasure := false\n\tfor _, cup := range measuringCups {\n\t\tcupLow, cupHigh := cup[0], cup[1]\n\t\tif low <= cupLow && cupHigh <= high {\n\t\t\tcanMeasure = true\n\t\t\tbreak\n\t\t}\n\n\t\tnewLow := max(0, low-cupLow)\n\t\tnewHigh := max(0, high-cupHigh)\n\t\tcanMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization)\n\t\tif canMeasure {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tmemoization[memoizeKey] = canMeasure\n\treturn canMeasure\n}\n\nfunc createHashtableKey(low, high int) string {\n\treturn fmt.Sprintf(\"%d:%d\", low, high)\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tcups := [][]int{\n\t\t{200, 210},\n\t\t{450, 465},\n\t\t{800, 850},\n\t}\n\tlow := 2100\n\thigh := 2300\n\texpected := true\n\tactual := AmbiguousMeasurements(cups, low, high)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tcups := [][]int{\n\t\t{200, 210},\n\t\t{450, 465},\n\t\t{800, 850},\n\t}\n\tlow := 2100\n\thigh := 2300\n\texpected := true\n\tactual := AmbiguousMeasurements(cups, low, high)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public boolean ambiguousMeasurements(\n    int[][] measuringCups, int low, int high\n  ) {\n    // Write your code here.\n    return false;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(low * high * n) time | O(low * high) space - where n is the number of\n  // measuring cups\n  public boolean ambiguousMeasurements(\n    int[][] measuringCups, int low, int high\n  ) {\n    HashMap<String, Boolean> memoization = new HashMap<String, Boolean>();\n    return canMeasureInRange(measuringCups, low, high, memoization);\n  }\n\n  public boolean canMeasureInRange(\n    int[][] measuringCups,\n    int low,\n    int high,\n    HashMap<String, Boolean> memoization\n  ) {\n    String memoizeKey = createHashableKey(low, high);\n    if (memoization.containsKey(memoizeKey)) {\n      return memoization.get(memoizeKey);\n    }\n\n    if (low <= 0 && high <= 0) {\n      return false;\n    }\n\n    boolean canMeasure = false;\n    for (int[] cup : measuringCups) {\n      int cupLow = cup[0];\n      int cupHigh = cup[1];\n      if (low <= cupLow && cupHigh <= high) {\n        canMeasure = true;\n        break;\n      }\n\n      int newLow = Math.max(0, low - cupLow);\n      int newHigh = Math.max(0, high - cupHigh);\n      canMeasure =\n        canMeasureInRange(measuringCups, newLow, newHigh, memoization);\n      if (canMeasure) break;\n    }\n\n    memoization.put(memoizeKey, canMeasure);\n    return canMeasure;\n  }\n\n  public String createHashableKey(int low, int high) {\n    return String.valueOf(low) + \":\" + String.valueOf(high);\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] cups = new int[][] {{200, 210}, {450, 465}, {800, 850}};\n    int low = 2100;\n    int high = 2300;\n    boolean expected = true;\n    var actual = new Program().ambiguousMeasurements(cups, low, high);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] cups = new int[][] {{200, 210}, {450, 465}, {800, 850}};\n    int low = 2100;\n    int high = 2300;\n    boolean expected = true;\n    var actual = new Program().ambiguousMeasurements(cups, low, high);\n    Utils.assertTrue(expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function ambiguousMeasurements(measuringCups, low, high) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.ambiguousMeasurements = ambiguousMeasurements;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(low * high * n) time | O(low * high) space - where n is\n// the number of measuring cups\nfunction ambiguousMeasurements(measuringCups, low, high) {\n  const memoization = {};\n  return canMeasureInRange(measuringCups, low, high, memoization);\n}\n\nfunction canMeasureInRange(measuringCups, low, high, memoization) {\n  const memoizeKey = createHashableKey(low, high);\n  if (memoizeKey in memoization) return memoization[memoizeKey];\n\n  if (low <= 0 && high <= 0) return false;\n\n  let canMeasure = false;\n  for (const cup of measuringCups) {\n    const [cupLow, cupHigh] = cup;\n    if (low <= cupLow && cupHigh <= high) {\n      canMeasure = true;\n      break;\n    }\n\n    const newLow = Math.max(0, low - cupLow);\n    const newHigh = Math.max(0, high - cupHigh);\n    canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization);\n    if (canMeasure) break;\n  }\n\n  memoization[memoizeKey] = canMeasure;\n  return canMeasure;\n}\n\nfunction createHashableKey(low, high) {\n  return low.toString() + ':' + high.toString();\n}\n\n// Do not edit the line below.\nexports.ambiguousMeasurements = ambiguousMeasurements;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const cups = [\n    [200, 210],\n    [450, 465],\n    [800, 850],\n  ];\n  const low = 2100;\n  const high = 2300;\n  const expected = true;\n  const actual = program.ambiguousMeasurements(cups, low, high);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const cups = [\n    [200, 210],\n    [450, 465],\n    [800, 850],\n  ];\n  const low = 2100;\n  const high = 2300;\n  const expected = true;\n  const actual = program.ambiguousMeasurements(cups, low, high);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun ambiguousMeasurements(measuringCups: List<List<Int>>, low: Int, high: Int): Boolean {\n    // Write your code here.\n    return false\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(low * high * n) time | O(low * high) space - where n is the number of measuring cups\nfun ambiguousMeasurements(measuringCups: List<List<Int>>, low: Int, high: Int): Boolean {\n    val memoization = mutableMapOf<String, Boolean>()\n    return canMeasureInRange(measuringCups, low, high, memoization)\n}\n\nfun canMeasureInRange(measuringCups: List<List<Int>>, low: Int, high: Int, memoization: MutableMap<String, Boolean>): Boolean {\n    val memoizeKey = createHashableKey(low, high)\n    if (memoizeKey in memoization) return memoization[memoizeKey]!!\n\n    if (low <= 0 && high <= 0) return false\n\n    var canMeasure = false\n    for (cup in measuringCups) {\n        val (cupLow, cupHigh) = cup\n        if (low <= cupLow && cupHigh <= high) {\n            canMeasure = true\n            break\n        }\n\n        val newLow = Math.max(0, low - cupLow)\n        val newHigh = Math.max(0, high - cupHigh)\n        canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization)\n        if (canMeasure) break\n    }\n\n    memoization[memoizeKey] = canMeasure\n    return canMeasure\n}\n\nfun createHashableKey(low: Int, high: Int): String {\n    return low.toString() + \":\" + high.toString()\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.ambiguousMeasurements\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val cups = listOf(\n            listOf(200, 210),\n            listOf(450, 465),\n            listOf(800, 850),\n        )\n        val low = 2100\n        val high = 2300\n        val expected = true\n        val output = ambiguousMeasurements(cups, low, high)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.ambiguousMeasurements\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val cups = listOf(\n            listOf(200, 210),\n            listOf(450, 465),\n            listOf(800, 850),\n        )\n        val low = 2100\n        val high = 2300\n        val expected = true\n        val output = ambiguousMeasurements(cups, low, high)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def ambiguousMeasurements(measuringCups, low, high):\n    # Write your code here.\n    return False\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(low * high * n) time | O(low * high) space - where n is the number of measuring cups\ndef ambiguousMeasurements(measuringCups, low, high):\n    memoization = {}\n    return canMeasureInRange(measuringCups, low, high, memoization)\n\n\ndef canMeasureInRange(measuringCups, low, high, memoization):\n    memoizeKey = createHashableKey(low, high)\n    if memoizeKey in memoization:\n        return memoization[memoizeKey]\n\n    if low <= 0 and high <= 0:\n        return False\n\n    canMeasure = False\n    for cup in measuringCups:\n        cupLow, cupHigh = cup\n        if low <= cupLow and cupHigh <= high:\n            canMeasure = True\n            break\n\n        newLow = max(0, low - cupLow)\n        newHigh = max(0, high - cupHigh)\n        canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization)\n        if canMeasure:\n            break\n\n    memoization[memoizeKey] = canMeasure\n    return canMeasure\n\n\ndef createHashableKey(low, high):\n    return str(low) + \":\" + str(high)\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        cups = [[200, 210], [450, 465], [800, 850]]\n        low = 2100\n        high = 2300\n        expected = True\n        actual = program.ambiguousMeasurements(cups, low, high)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        cups = [[200, 210], [450, 465], [800, 850]]\n        low = 2100\n        high = 2300\n        expected = True\n        actual = program.ambiguousMeasurements(cups, low, high)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "class Program\n  def ambiguousMeasurements(measuringCups, low, high)\n    # Write your code here.\n    return false\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def ambiguousMeasurements(measuringCups, low, high)\n    # Write your code here.\n    return false\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.ambiguousMeasurements\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.ambiguousMeasurements\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func ambiguousMeasurements(_ measuringCups: [[Int]], _ low: Int, _ high: Int) -> Bool {\n    // Write your code here.\n    return false\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(low * high * n) time | O(low * high) space - where n is the number of measuring cups\n  func ambiguousMeasurements(_ measuringCups: [[Int]], _ low: Int, _ high: Int) -> Bool {\n    var memoization = [String: Bool]()\n    return canMeasureInRange(measuringCups, low, high, &memoization)\n  }\n\n  func canMeasureInRange(_ measuringCups: [[Int]], _ low: Int, _ high: Int, _ memoization: inout [String: Bool]) -> Bool {\n    let memoizeKey = createHashtableKey(low, high)\n    if memoization[memoizeKey] != nil {\n      return memoization[memoizeKey]!\n    }\n\n    if low <= 0, high <= 0 {\n      return false\n    }\n\n    var canMeasure = false\n    for cup in measuringCups {\n      let (cupLow, cupHigh) = (cup[0], cup[1])\n      if low <= cupLow, cupHigh <= high {\n        canMeasure = true\n        break\n      }\n\n      let newLow = max(0, low - cupLow)\n      let newHigh = max(0, high - cupHigh)\n      canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, &memoization)\n      if canMeasure {\n        break\n      }\n    }\n\n    memoization[memoizeKey] = canMeasure\n    return canMeasure\n  }\n\n  func createHashtableKey(_ low: Int, _ high: Int) -> String {\n    return String(low) + \":\" + String(high)\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let cups = [\n        [200, 210],\n        [450, 465],\n        [800, 850],\n      ]\n      let low = 2100\n      let high = 2300\n      let expected = true\n      var actual = Program().ambiguousMeasurements(cups, low, high)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let cups = [\n        [200, 210],\n        [450, 465],\n        [800, 850],\n      ]\n      let low = 2100\n      let high = 2300\n      let expected = true\n      var actual = Program().ambiguousMeasurements(cups, low, high)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function ambiguousMeasurements(measuringCups: number[][], low: number, high: number) {\n  // Write your code here.\n  return false;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(low * high * n) time | O(low * high) space - where n is\n// the number of measuring cups\nexport function ambiguousMeasurements(measuringCups: number[][], low: number, high: number) {\n  const memoization: {[key: string]: boolean} = {};\n  return canMeasureInRange(measuringCups, low, high, memoization);\n}\n\nfunction canMeasureInRange(\n  measuringCups: number[][],\n  low: number,\n  high: number,\n  memoization: {[key: string]: boolean},\n): boolean {\n  const memoizeKey = createHashableKey(low, high);\n  if (memoizeKey in memoization) return memoization[memoizeKey];\n\n  if (low <= 0 && high <= 0) return false;\n\n  let canMeasure = false;\n  for (const cup of measuringCups) {\n    const [cupLow, cupHigh] = cup;\n    if (low <= cupLow && cupHigh <= high) {\n      canMeasure = true;\n      break;\n    }\n\n    const newLow = Math.max(0, low - cupLow);\n    const newHigh = Math.max(0, high - cupHigh);\n    canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization);\n    if (canMeasure) break;\n  }\n\n  memoization[memoizeKey] = canMeasure;\n  return canMeasure;\n}\n\nfunction createHashableKey(low: number, high: number) {\n  return low.toString() + ':' + high.toString();\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const cups = [\n    [200, 210],\n    [450, 465],\n    [800, 850],\n  ];\n  const low = 2100;\n  const high = 2300;\n  const expected = true;\n  const actual = program.ambiguousMeasurements(cups, low, high);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const cups = [\n    [200, 210],\n    [450, 465],\n    [800, 850],\n  ];\n  const low = 2100;\n  const high = 2300;\n  const expected = true;\n  const actual = program.ambiguousMeasurements(cups, low, high);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "measuringCups",
      "example": [
        [
          200,
          210
        ],
        [
          450,
          465
        ],
        [
          800,
          850
        ]
      ],
      "schema": {
        "items": {
          "items": {
            "minimum": 0,
            "type": "integer"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        "type": "array"
      }
    },
    {
      "name": "low",
      "example": 2100,
      "schema": {
        "minimum": 0,
        "type": "integer"
      }
    },
    {
      "name": "high",
      "example": 2300,
      "schema": {
        "minimum": 0,
        "type": "integer"
      }
    }
  ],
  "tests": [
    {
      "high": 2300,
      "low": 2100,
      "measuringCups": [
        [
          200,
          210
        ],
        [
          450,
          465
        ],
        [
          800,
          850
        ]
      ]
    },
    {
      "high": 20,
      "low": 10,
      "measuringCups": [
        [
          200,
          210
        ]
      ]
    },
    {
      "high": 2300,
      "low": 2100,
      "measuringCups": [
        [
          230,
          240
        ],
        [
          290,
          310
        ],
        [
          500,
          515
        ]
      ]
    },
    {
      "high": 101,
      "low": 100,
      "measuringCups": [
        [
          1,
          3
        ],
        [
          2,
          4
        ],
        [
          5,
          6
        ]
      ]
    },
    {
      "high": 120,
      "low": 100,
      "measuringCups": [
        [
          1,
          3
        ],
        [
          2,
          4
        ],
        [
          5,
          6
        ]
      ]
    },
    {
      "high": 12,
      "low": 10,
      "measuringCups": [
        [
          1,
          3
        ],
        [
          2,
          4
        ],
        [
          5,
          6
        ],
        [
          10,
          20
        ]
      ]
    },
    {
      "high": 12,
      "low": 10,
      "measuringCups": [
        [
          1,
          3
        ],
        [
          2,
          4
        ],
        [
          5,
          7
        ],
        [
          10,
          20
        ]
      ]
    },
    {
      "high": 1050,
      "low": 1000,
      "measuringCups": [
        [
          50,
          60
        ],
        [
          100,
          120
        ],
        [
          20,
          40
        ],
        [
          10,
          15
        ],
        [
          400,
          500
        ]
      ]
    },
    {
      "high": 1200,
      "low": 1000,
      "measuringCups": [
        [
          50,
          65
        ],
        [
          100,
          120
        ],
        [
          20,
          40
        ],
        [
          10,
          15
        ],
        [
          400,
          500
        ]
      ]
    },
    {
      "high": 3300,
      "low": 3000,
      "measuringCups": [
        [
          50,
          65
        ],
        [
          100,
          120
        ],
        [
          20,
          40
        ],
        [
          10,
          15
        ],
        [
          400,
          500
        ],
        [
          300,
          350
        ],
        [
          10,
          25
        ]
      ]
    },
    {
      "high": 1050,
      "low": 1000,
      "measuringCups": [
        [
          50,
          60
        ],
        [
          100,
          120
        ],
        [
          20,
          40
        ],
        [
          400,
          500
        ]
      ]
    },
    {
      "high": 200,
      "low": 200,
      "measuringCups": [
        [
          50,
          65
        ]
      ]
    },
    {
      "high": 200,
      "low": 200,
      "measuringCups": [
        [
          50,
          50
        ]
      ]
    },
    {
      "high": 200,
      "low": 200,
      "measuringCups": [
        [
          50,
          50
        ],
        [
          50,
          51
        ]
      ]
    },
    {
      "high": 1000,
      "low": 0,
      "measuringCups": [
        [
          100,
          150
        ],
        [
          1000,
          2000
        ]
      ]
    },
    {
      "high": 20,
      "low": 10,
      "measuringCups": [
        [
          10,
          20
        ]
      ]
    },
    {
      "high": 20,
      "low": 10,
      "measuringCups": [
        [
          15,
          18
        ]
      ]
    },
    {
      "high": 20,
      "low": 10,
      "measuringCups": [
        [
          15,
          22
        ]
      ]
    }
  ],
  "jsonTests": [
    {
      "high": 2300,
      "low": 2100,
      "measuringCups": [
        [
          200,
          210
        ],
        [
          450,
          465
        ],
        [
          800,
          850
        ]
      ]
    },
    {
      "high": 20,
      "low": 10,
      "measuringCups": [
        [
          200,
          210
        ]
      ]
    },
    {
      "high": 2300,
      "low": 2100,
      "measuringCups": [
        [
          230,
          240
        ],
        [
          290,
          310
        ],
        [
          500,
          515
        ]
      ]
    },
    {
      "high": 101,
      "low": 100,
      "measuringCups": [
        [
          1,
          3
        ],
        [
          2,
          4
        ],
        [
          5,
          6
        ]
      ]
    },
    {
      "high": 120,
      "low": 100,
      "measuringCups": [
        [
          1,
          3
        ],
        [
          2,
          4
        ],
        [
          5,
          6
        ]
      ]
    },
    {
      "high": 12,
      "low": 10,
      "measuringCups": [
        [
          1,
          3
        ],
        [
          2,
          4
        ],
        [
          5,
          6
        ],
        [
          10,
          20
        ]
      ]
    },
    {
      "high": 12,
      "low": 10,
      "measuringCups": [
        [
          1,
          3
        ],
        [
          2,
          4
        ],
        [
          5,
          7
        ],
        [
          10,
          20
        ]
      ]
    },
    {
      "high": 1050,
      "low": 1000,
      "measuringCups": [
        [
          50,
          60
        ],
        [
          100,
          120
        ],
        [
          20,
          40
        ],
        [
          10,
          15
        ],
        [
          400,
          500
        ]
      ]
    },
    {
      "high": 1200,
      "low": 1000,
      "measuringCups": [
        [
          50,
          65
        ],
        [
          100,
          120
        ],
        [
          20,
          40
        ],
        [
          10,
          15
        ],
        [
          400,
          500
        ]
      ]
    },
    {
      "high": 3300,
      "low": 3000,
      "measuringCups": [
        [
          50,
          65
        ],
        [
          100,
          120
        ],
        [
          20,
          40
        ],
        [
          10,
          15
        ],
        [
          400,
          500
        ],
        [
          300,
          350
        ],
        [
          10,
          25
        ]
      ]
    },
    {
      "high": 1050,
      "low": 1000,
      "measuringCups": [
        [
          50,
          60
        ],
        [
          100,
          120
        ],
        [
          20,
          40
        ],
        [
          400,
          500
        ]
      ]
    },
    {
      "high": 200,
      "low": 200,
      "measuringCups": [
        [
          50,
          65
        ]
      ]
    },
    {
      "high": 200,
      "low": 200,
      "measuringCups": [
        [
          50,
          50
        ]
      ]
    },
    {
      "high": 200,
      "low": 200,
      "measuringCups": [
        [
          50,
          50
        ],
        [
          50,
          51
        ]
      ]
    },
    {
      "high": 1000,
      "low": 0,
      "measuringCups": [
        [
          100,
          150
        ],
        [
          1000,
          2000
        ]
      ]
    },
    {
      "high": 20,
      "low": 10,
      "measuringCups": [
        [
          10,
          20
        ]
      ]
    },
    {
      "high": 20,
      "low": 10,
      "measuringCups": [
        [
          15,
          18
        ]
      ]
    },
    {
      "high": 20,
      "low": 10,
      "measuringCups": [
        [
          15,
          22
        ]
      ]
    }
  ],
  "changelog": []
}