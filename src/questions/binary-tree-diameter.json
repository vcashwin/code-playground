{
  "uid": "binary-tree-diameter",
  "testStrategy": "JSON",
  "name": "Binary Tree Diameter",
  "version": 0,
  "releaseDate": "2020-11-16T00:00:00Z",
  "category": "Binary Trees",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 26566,
    "failureCount": 8042
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "557855845",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 1053
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in a Binary Tree and returns its diameter. The\n  diameter of a binary tree is defined as the length of its longest path, even\n  if that path doesn't pass through the root of the tree.\n</p>\n<p>\n  A path is a collection of connected nodes in a tree, where no node is\n  connected to more than two other nodes. The length of a path is the number of\n  edges between the path's first node and its last node.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">tree</span> =        1\n            /   \\\n           3     2\n         /   \\ \n        7     4\n       /       \\\n      8         5\n     /           \\\n    9             6\n</pre>\n<h3>Sample Output</h3>\n<pre>\n6 <span class=\"CodeEditor-promptComment\">// 9 -> 8 -> 7 -> 3 -> 4 -> 5 -> 6</span>\n<span class=\"CodeEditor-promptComment\">// There are 6 edges between the</span>\n<span class=\"CodeEditor-promptComment\">// first node and the last node</span>\n<span class=\"CodeEditor-promptComment\">// of this tree's longest path.</span>\n</pre>\n</div>",
  "hints": [
    "<p>\nHow can you use the height of a binary tree and the heights of its subtrees to calculate its diameter?\n</p>\n",
    "\n<p>\nThe length of the longest path that goes through the root of a binary tree is the sum of the heights of its left and right subtrees (left subtree height + right subtree height). The diameter of a binary tree can be calculated by taking the maximum of: 1) the maximum subtree diameter (max(left subtree diameter, right subtree diameter)); and 2) the length of the longest path that goes through the root (left subtree height + right subtree height).\n</p>\n",
    "\n<p>\nImplement a variation of depth-first search that recursively keeps track of both the diameter and the height of a each subtree in the input binary tree. Follow Hint #2 to continuously compute these diameters.\n</p>"
  ],
  "spaceTime": "Average case: when the tree is balanced\nO(n) time | O(h) space - where n is the number of nodes in the Binary Tree and h is the height of the Binary Tree",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": "tree",
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left;\n  BinaryTree* right;\n\n  BinaryTree(int value) {\n    this->value = value;\n    left = nullptr;\n    right = nullptr;\n  }\n};\n\nint binaryTreeDiameter(BinaryTree* tree) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left;\n  BinaryTree* right;\n\n  BinaryTree(int value) {\n    this->value = value;\n    left = nullptr;\n    right = nullptr;\n  }\n};\n\nstruct TreeInfo {\n  int diameter;\n  int height;\n};\n\nTreeInfo getTreeInfo(BinaryTree* tree);\n\n// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nint binaryTreeDiameter(BinaryTree* tree) { return getTreeInfo(tree).diameter; }\n\nTreeInfo getTreeInfo(BinaryTree* tree) {\n  if (tree == nullptr) {\n    return TreeInfo{0, 0};\n  }\n\n  TreeInfo leftTreeInfo = getTreeInfo(tree->left);\n  TreeInfo rightTreeInfo = getTreeInfo(tree->right);\n\n  int longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height;\n  int maxDiameterSoFar = max(leftTreeInfo.diameter, rightTreeInfo.diameter);\n  int currentDiameter = max(longestPathThroughRoot, maxDiameterSoFar);\n  int currentHeight = 1 + max(leftTreeInfo.height, rightTreeInfo.height);\n\n  return TreeInfo{currentDiameter, currentHeight};\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree* root = new BinaryTree(1);\n      root->left = new BinaryTree(3);\n      root->left->left = new BinaryTree(7);\n      root->left->left->left = new BinaryTree(8);\n      root->left->left->left->left = new BinaryTree(9);\n      root->left->right = new BinaryTree(4);\n      root->left->right->right = new BinaryTree(5);\n      root->left->right->right->right = new BinaryTree(6);\n      root->right = new BinaryTree(2);\n      int expected = 6;\n      int actual = binaryTreeDiameter(root);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree* root = new BinaryTree(1);\n      root->left = new BinaryTree(3);\n      root->left->left = new BinaryTree(7);\n      root->left->left->left = new BinaryTree(8);\n      root->left->left->left->left = new BinaryTree(9);\n      root->left->right = new BinaryTree(4);\n      root->left->right->right = new BinaryTree(5);\n      root->left->right->right->right = new BinaryTree(6);\n      root->right = new BinaryTree(2);\n      int expected = 6;\n      int actual = binaryTreeDiameter(root);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public int BinaryTreeDiameter(BinaryTree tree) {\n    // Write your code here.\n    return -1;\n  }\n\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // Average case: when the tree is balanced\n  // O(n) time | O(h) space - where n is the number of nodes in\n  // the Binary Tree and h is the height of the Binary Tree\n  public int BinaryTreeDiameter(BinaryTree tree) {\n    return getTreeInfo(tree).diameter;\n  }\n\n  public TreeInfo getTreeInfo(BinaryTree tree) {\n    if (tree == null) {\n      return new TreeInfo(0, 0);\n    }\n\n    TreeInfo leftTreeInfo = getTreeInfo(tree.left);\n    TreeInfo rightTreeInfo = getTreeInfo(tree.right);\n\n    int longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height;\n    int maxDiameterSoFar =\n      Math.Max(leftTreeInfo.diameter, rightTreeInfo.diameter);\n    int currentDiameter = Math.Max(longestPathThroughRoot, maxDiameterSoFar);\n    int currentHeight = 1 + Math.Max(leftTreeInfo.height, rightTreeInfo.height);\n\n    return new TreeInfo(currentDiameter, currentHeight);\n  }\n\n  public class TreeInfo {\n    public int diameter;\n    public int height;\n    public TreeInfo(int diameter, int height) {\n      this.diameter = diameter;\n      this.height = height;\n    }\n  }\n\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var root = new Program.BinaryTree(1);\n    root.left = new Program.BinaryTree(3);\n    root.left.left = new Program.BinaryTree(7);\n    root.left.left.left = new Program.BinaryTree(8);\n    root.left.left.left.left = new Program.BinaryTree(9);\n    root.left.right = new Program.BinaryTree(4);\n    root.left.right.right = new Program.BinaryTree(5);\n    root.left.right.right.right = new Program.BinaryTree(6);\n    root.right = new Program.BinaryTree(2);\n    var expected = 6;\n    var actual = new Program().BinaryTreeDiameter(root);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var root = new Program.BinaryTree(1);\n    root.left = new Program.BinaryTree(3);\n    root.left.left = new Program.BinaryTree(7);\n    root.left.left.left = new Program.BinaryTree(8);\n    root.left.left.left.left = new Program.BinaryTree(9);\n    root.left.right = new Program.BinaryTree(4);\n    root.left.right.right = new Program.BinaryTree(5);\n    root.left.right.right.right = new Program.BinaryTree(6);\n    root.right = new Program.BinaryTree(2);\n    var expected = 6;\n    var actual = new Program().BinaryTreeDiameter(root);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\nfunc BinaryTreeDiameter(tree *BinaryTree) int {\n\t// Write your code here.\n\treturn -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\ntype TreeInfo struct {\n\tdiameter int\n\theight   int\n}\n\n// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nfunc BinaryTreeDiameter(tree *BinaryTree) int {\n\treturn getTreeInfo(tree).diameter\n}\n\nfunc getTreeInfo(tree *BinaryTree) TreeInfo {\n\tif tree == nil {\n\t\treturn TreeInfo{0, 0}\n\t}\n\n\tleftTreeInfo := getTreeInfo(tree.Left)\n\trightTreeInfo := getTreeInfo(tree.Right)\n\n\tlongestPathThroughRoot := leftTreeInfo.height + rightTreeInfo.height\n\tmaxDiameterSoFar := max(leftTreeInfo.diameter, rightTreeInfo.diameter)\n\tcurrentDiameter := max(longestPathThroughRoot, maxDiameterSoFar)\n\tcurrentHeight := 1 + max(leftTreeInfo.height, rightTreeInfo.height)\n\n\treturn TreeInfo{currentDiameter, currentHeight}\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\troot := &BinaryTree{Value: 1}\n\troot.Left = &BinaryTree{Value: 3}\n\troot.Left.Left = &BinaryTree{Value: 7}\n\troot.Left.Left.Left = &BinaryTree{Value: 8}\n\troot.Left.Left.Left.Left = &BinaryTree{Value: 9}\n\troot.Left.Right = &BinaryTree{Value: 4}\n\troot.Left.Right.Right = &BinaryTree{Value: 5}\n\troot.Left.Right.Right.Right = &BinaryTree{Value: 6}\n\troot.Right = &BinaryTree{Value: 2}\n\texpected := 6\n\tactual := BinaryTreeDiameter(root)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\troot := &BinaryTree{Value: 1}\n\troot.Left = &BinaryTree{Value: 3}\n\troot.Left.Left = &BinaryTree{Value: 7}\n\troot.Left.Left.Left = &BinaryTree{Value: 8}\n\troot.Left.Left.Left.Left = &BinaryTree{Value: 9}\n\troot.Left.Right = &BinaryTree{Value: 4}\n\troot.Left.Right.Right = &BinaryTree{Value: 5}\n\troot.Left.Right.Right.Right = &BinaryTree{Value: 6}\n\troot.Right = &BinaryTree{Value: 2}\n\texpected := 6\n\tactual := BinaryTreeDiameter(root)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  public int binaryTreeDiameter(BinaryTree tree) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // Average case: when the tree is balanced\n  // O(n) time | O(h) space - where n is the number of nodes in\n  // the Binary Tree and h is the height of the Binary Tree\n  public int binaryTreeDiameter(BinaryTree tree) {\n    return getTreeInfo(tree).diameter;\n  }\n\n  public TreeInfo getTreeInfo(BinaryTree tree) {\n    if (tree == null) {\n      return new TreeInfo(0, 0);\n    }\n\n    TreeInfo leftTreeInfo = getTreeInfo(tree.left);\n    TreeInfo rightTreeInfo = getTreeInfo(tree.right);\n\n    int longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height;\n    int maxDiameterSoFar =\n      Math.max(leftTreeInfo.diameter, rightTreeInfo.diameter);\n    int currentDiameter = Math.max(longestPathThroughRoot, maxDiameterSoFar);\n    int currentHeight = 1 + Math.max(leftTreeInfo.height, rightTreeInfo.height);\n\n    return new TreeInfo(currentDiameter, currentHeight);\n  }\n\n  static class TreeInfo {\n    public int diameter;\n    public int height;\n\n    public TreeInfo(int diameter, int height) {\n      this.diameter = diameter;\n      this.height = height;\n    }\n  }\n\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    TestBinaryTree input = new TestBinaryTree(1);\n    input.insert(new int[] {2, 3, 4, 5, 6, 7}, 0);\n    var expected = 4;\n    var actual = new Program().binaryTreeDiameter(input);\n    Utils.assertTrue(expected == actual);\n  }\n\n  class TestBinaryTree extends Program.BinaryTree {\n    public TestBinaryTree(int value) {\n      super(value);\n    }\n\n    public void insert(int[] values, int i) {\n      if (i >= values.length) {\n        return;\n      }\n      ArrayDeque<Program.BinaryTree> queue =\n        new ArrayDeque<Program.BinaryTree>();\n      queue.addLast(this);\n      while (queue.size() > 0) {\n        Program.BinaryTree current = queue.pollFirst();\n        if (current.left == null) {\n          current.left = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.left);\n        if (current.right == null) {\n          current.right = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.right);\n      }\n      insert(values, i + 1);\n    }\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    TestBinaryTree input = new TestBinaryTree(1);\n    input.insert(new int[] {2, 3, 4, 5, 6, 7}, 0);\n    var expected = 4;\n    var actual = new Program().binaryTreeDiameter(input);\n    Utils.assertTrue(expected == actual);\n  }\n\n  class TestBinaryTree extends Program.BinaryTree {\n    public TestBinaryTree(int value) {\n      super(value);\n    }\n\n    public void insert(int[] values, int i) {\n      if (i >= values.length) {\n        return;\n      }\n      ArrayDeque<Program.BinaryTree> queue =\n        new ArrayDeque<Program.BinaryTree>();\n      queue.addLast(this);\n      while (queue.size() > 0) {\n        Program.BinaryTree current = queue.pollFirst();\n        if (current.left == null) {\n          current.left = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.left);\n        if (current.right == null) {\n          current.right = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.right);\n      }\n      insert(values, i + 1);\n    }\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction binaryTreeDiameter(tree) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.binaryTreeDiameter = binaryTreeDiameter;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nfunction binaryTreeDiameter(tree) {\n  return getTreeInfo(tree).diameter;\n}\n\nfunction getTreeInfo(tree) {\n  if (tree === null) {\n    return new TreeInfo(0, 0);\n  }\n\n  const leftTreeInfo = getTreeInfo(tree.left);\n  const rightTreeInfo = getTreeInfo(tree.right);\n\n  const longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height;\n  const maxDiameterSoFar = Math.max(leftTreeInfo.diameter, rightTreeInfo.diameter);\n  const currentDiameter = Math.max(longestPathThroughRoot, maxDiameterSoFar);\n  const currentHeight = 1 + Math.max(leftTreeInfo.height, rightTreeInfo.height);\n\n  return new TreeInfo(currentDiameter, currentHeight);\n}\n\nclass TreeInfo {\n  constructor(diameter, height) {\n    this.diameter = diameter;\n    this.height = height;\n  }\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.binaryTreeDiameter = binaryTreeDiameter;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(3);\n  root.left.left = new program.BinaryTree(7);\n  root.left.left.left = new program.BinaryTree(8);\n  root.left.left.left.left = new program.BinaryTree(9);\n  root.left.right = new program.BinaryTree(4);\n  root.left.right.right = new program.BinaryTree(5);\n  root.left.right.right.right = new program.BinaryTree(6);\n  root.right = new program.BinaryTree(2);\n  const expected = 6;\n  const actual = program.binaryTreeDiameter(root);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(3);\n  root.left.left = new program.BinaryTree(7);\n  root.left.left.left = new program.BinaryTree(8);\n  root.left.left.left.left = new program.BinaryTree(9);\n  root.left.right = new program.BinaryTree(4);\n  root.left.right.right = new program.BinaryTree(5);\n  root.left.right.right.right = new program.BinaryTree(6);\n  root.right = new program.BinaryTree(2);\n  const expected = 6;\n  const actual = program.binaryTreeDiameter(root);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\nfun binaryTreeDiameter(tree: BinaryTree?): Int {\n    // Write your code here.\n    return -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.max\n\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\nopen class TreeInfo(diameter: Int, height: Int) {\n    val diameter = diameter\n    val height = height\n}\n\n// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nfun binaryTreeDiameter(tree: BinaryTree): Int {\n    return getTreeInfo(tree).diameter\n}\n\nfun getTreeInfo(tree: BinaryTree?): TreeInfo {\n    if (tree == null) return TreeInfo(0, 0)\n\n    val leftTreeInfo = getTreeInfo(tree.left)\n    val rightTreeInfo = getTreeInfo(tree.right)\n\n    val longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height\n    val maxDiameterSoFar = max(leftTreeInfo.diameter, rightTreeInfo.diameter)\n    val currentDiameter = max(longestPathThroughRoot, maxDiameterSoFar)\n    val currentHeight = 1 + max(leftTreeInfo.height, rightTreeInfo.height)\n\n    return TreeInfo(currentDiameter, currentHeight)\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.BinaryTree\nimport com.algoexpert.program.binaryTreeDiameter\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val root = BinaryTree(1)\n        root.left = BinaryTree(3)\n        root.left!!.left = BinaryTree(7)\n        root.left!!.left!!.left = BinaryTree(8)\n        root.left!!.left!!.left!!.left = BinaryTree(9)\n        root.left!!.right = BinaryTree(4)\n        root.left!!.right!!.right = BinaryTree(5)\n        root.left!!.right!!.right!!.right = BinaryTree(6)\n        root.right = BinaryTree(2)\n        val expected = 6\n        var output = binaryTreeDiameter(root)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.BinaryTree\nimport com.algoexpert.program.binaryTreeDiameter\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val root = BinaryTree(1)\n        root.left = BinaryTree(3)\n        root.left!!.left = BinaryTree(7)\n        root.left!!.left!!.left = BinaryTree(8)\n        root.left!!.left!!.left!!.left = BinaryTree(9)\n        root.left!!.right = BinaryTree(4)\n        root.left!!.right!!.right = BinaryTree(5)\n        root.left!!.right!!.right!!.right = BinaryTree(6)\n        root.right = BinaryTree(2)\n        val expected = 6\n        var output = binaryTreeDiameter(root)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef binaryTreeDiameter(tree):\n    # Write your code here.\n    return -1\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# Average case: when the tree is balanced\n# O(n) time | O(h) space - where n is the number of nodes in\n# the Binary Tree and h is the height of the Binary Tree\ndef binaryTreeDiameter(tree):\n    return getTreeInfo(tree).diameter\n\n\ndef getTreeInfo(tree):\n    if tree is None:\n        return TreeInfo(0, 0)\n\n    leftTreeInfo = getTreeInfo(tree.left)\n    rightTreeInfo = getTreeInfo(tree.right)\n\n    longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height\n    maxDiameterSoFar = max(leftTreeInfo.diameter, rightTreeInfo.diameter)\n    currentDiameter = max(longestPathThroughRoot, maxDiameterSoFar)\n    currentHeight = 1 + max(leftTreeInfo.height, rightTreeInfo.height)\n\n    return TreeInfo(currentDiameter, currentHeight)\n\n\nclass TreeInfo:\n    def __init__(self, diameter, height):\n        self.diameter = diameter\n        self.height = height\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = program.BinaryTree(1)\n        root.left = program.BinaryTree(3)\n        root.left.left = program.BinaryTree(7)\n        root.left.left.left = program.BinaryTree(8)\n        root.left.left.left.left = program.BinaryTree(9)\n        root.left.right = program.BinaryTree(4)\n        root.left.right.right = program.BinaryTree(5)\n        root.left.right.right.right = program.BinaryTree(6)\n        root.right = program.BinaryTree(2)\n        expected = 6\n        actual = program.binaryTreeDiameter(root)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = program.BinaryTree(1)\n        root.left = program.BinaryTree(3)\n        root.left.left = program.BinaryTree(7)\n        root.left.left.left = program.BinaryTree(8)\n        root.left.left.left.left = program.BinaryTree(9)\n        root.left.right = program.BinaryTree(4)\n        root.left.right.right = program.BinaryTree(5)\n        root.left.right.right.right = program.BinaryTree(6)\n        root.right = program.BinaryTree(2)\n        expected = 6\n        actual = program.binaryTreeDiameter(root)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def binaryTreeDiameter(tree)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def binaryTreeDiameter(tree)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.binaryTreeDiameter\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.binaryTreeDiameter\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  func binaryTreeDiameter(_ tree: BinaryTree) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  class TreeInfo {\n    var diameter: Int\n    var height: Int\n\n    init(_ diameter: Int, _ height: Int) {\n      self.diameter = diameter\n      self.height = height\n    }\n  }\n\n  // Average case: when the tree is balanced\n  // O(n) time | O(h) space - where n is the number of nodes in\n  // the Binary Tree and h is the height of the Binary Tree\n  func binaryTreeDiameter(_ tree: BinaryTree) -> Int {\n    return getTreeInfo(tree).diameter\n  }\n\n  func getTreeInfo(_ tree: BinaryTree?) -> TreeInfo {\n    if tree == nil {\n      return TreeInfo(0, 0)\n    }\n\n    let leftTreeInfo = getTreeInfo(tree!.left)\n    let rightTreeInfo = getTreeInfo(tree!.right)\n\n    let longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height\n    let maxDiameterSoFar = max(leftTreeInfo.diameter, rightTreeInfo.diameter)\n    let currentDiameter = max(longestPathThroughRoot, maxDiameterSoFar)\n    let currentHeight = 1 + max(leftTreeInfo.height, rightTreeInfo.height)\n\n    return TreeInfo(currentDiameter, currentHeight)\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let root = Program.BinaryTree(value: 1)\n      root.left = Program.BinaryTree(value: 3)\n      root.left!.left = Program.BinaryTree(value: 7)\n      root.left!.left!.left = Program.BinaryTree(value: 8)\n      root.left!.left!.left!.left = Program.BinaryTree(value: 9)\n      root.left!.right = Program.BinaryTree(value: 4)\n      root.left!.right!.right = Program.BinaryTree(value: 5)\n      root.left!.right!.right!.right = Program.BinaryTree(value: 6)\n      root.right = Program.BinaryTree(value: 2)\n      let expected = 6\n      var actual = Program().binaryTreeDiameter(root)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let root = Program.BinaryTree(value: 1)\n      root.left = Program.BinaryTree(value: 3)\n      root.left!.left = Program.BinaryTree(value: 7)\n      root.left!.left!.left = Program.BinaryTree(value: 8)\n      root.left!.left!.left!.left = Program.BinaryTree(value: 9)\n      root.left!.right = Program.BinaryTree(value: 4)\n      root.left!.right!.right = Program.BinaryTree(value: 5)\n      root.left!.right!.right!.right = Program.BinaryTree(value: 6)\n      root.right = Program.BinaryTree(value: 2)\n      let expected = 6\n      var actual = Program().binaryTreeDiameter(root)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport function binaryTreeDiameter(tree: BinaryTree) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nexport function binaryTreeDiameter(tree: BinaryTree) {\n  return getTreeInfo(tree).diameter;\n}\n\nfunction getTreeInfo(tree: BinaryTree | null): TreeInfo {\n  if (tree === null) {\n    return new TreeInfo(0, 0);\n  }\n\n  const leftTreeInfo = getTreeInfo(tree.left);\n  const rightTreeInfo = getTreeInfo(tree.right);\n\n  const longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height;\n  const maxDiameterSoFar = Math.max(leftTreeInfo.diameter, rightTreeInfo.diameter);\n  const currentDiameter = Math.max(longestPathThroughRoot, maxDiameterSoFar);\n  const currentHeight = 1 + Math.max(leftTreeInfo.height, rightTreeInfo.height);\n\n  return new TreeInfo(currentDiameter, currentHeight);\n}\n\nclass TreeInfo {\n  diameter: number;\n  height: number;\n\n  constructor(diameter: number, height: number) {\n    this.diameter = diameter;\n    this.height = height;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(3);\n  root.left.left = new program.BinaryTree(7);\n  root.left.left.left = new program.BinaryTree(8);\n  root.left.left.left.left = new program.BinaryTree(9);\n  root.left.right = new program.BinaryTree(4);\n  root.left.right.right = new program.BinaryTree(5);\n  root.left.right.right.right = new program.BinaryTree(6);\n  root.right = new program.BinaryTree(2);\n  const expected = 6;\n  const actual = program.binaryTreeDiameter(root);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(3);\n  root.left.left = new program.BinaryTree(7);\n  root.left.left.left = new program.BinaryTree(8);\n  root.left.left.left.left = new program.BinaryTree(9);\n  root.left.right = new program.BinaryTree(4);\n  root.left.right.right = new program.BinaryTree(5);\n  root.left.right.right.right = new program.BinaryTree(6);\n  root.right = new program.BinaryTree(2);\n  const expected = 6;\n  const actual = program.binaryTreeDiameter(root);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "tree",
      "example": {
        "nodes": [
          {
            "id": "1",
            "left": "3",
            "right": "2",
            "value": 1
          },
          {
            "id": "3",
            "left": "7",
            "right": "4",
            "value": 3
          },
          {
            "id": "7",
            "left": "8",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "9",
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "4",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      },
      "schema": {
        "description": "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "left": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "right": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "left",
                "right"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "root": {
            "type": "string"
          }
        },
        "required": [
          "root",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "3",
            "right": "2",
            "value": 1
          },
          {
            "id": "3",
            "left": "7",
            "right": "4",
            "value": 3
          },
          {
            "id": "7",
            "left": "8",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "9",
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "4",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "-1",
            "value": 1
          },
          {
            "id": "-1",
            "left": null,
            "right": null,
            "value": -1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "-5",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "-5",
            "left": "6",
            "right": null,
            "value": -5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "3",
            "right": "9",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "9",
            "left": "14",
            "right": "10",
            "value": 9
          },
          {
            "id": "10",
            "left": null,
            "right": "11",
            "value": 10
          },
          {
            "id": "11",
            "left": null,
            "right": "12",
            "value": 11
          },
          {
            "id": "12",
            "left": null,
            "right": "17",
            "value": 12
          },
          {
            "id": "17",
            "left": null,
            "right": null,
            "value": 17
          },
          {
            "id": "14",
            "left": null,
            "right": "19",
            "value": 14
          },
          {
            "id": "19",
            "left": "25",
            "right": null,
            "value": 19
          },
          {
            "id": "25",
            "left": null,
            "right": null,
            "value": 25
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "3",
            "right": "5",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "5",
            "right": null,
            "value": 1
          },
          {
            "id": "5",
            "left": "7",
            "right": "9",
            "value": 5
          },
          {
            "id": "9",
            "left": null,
            "right": "12",
            "value": 9
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "7",
            "left": "8",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "4",
            "left": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "4"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "4",
            "left": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "4"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "4",
            "left": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "1",
            "left": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "19",
            "right": null,
            "value": 3
          },
          {
            "id": "19",
            "left": null,
            "right": null,
            "value": 19
          }
        ],
        "root": "4"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "6",
            "left": null,
            "right": "1",
            "value": 6
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "6"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "3",
            "left": null,
            "right": "10",
            "value": 3
          },
          {
            "id": "10",
            "left": "1",
            "right": null,
            "value": 10
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "3"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "1",
            "left": "3",
            "right": null,
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": "5",
            "value": 3
          },
          {
            "id": "5",
            "left": null,
            "right": "10",
            "value": 5
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          }
        ],
        "root": "2"
      }
    }
  ],
  "jsonTests": [
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "3",
            "right": "2",
            "value": 1
          },
          {
            "id": "3",
            "left": "7",
            "right": "4",
            "value": 3
          },
          {
            "id": "7",
            "left": "8",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "9",
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "4",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "-1",
            "value": 1
          },
          {
            "id": "-1",
            "left": null,
            "right": null,
            "value": -1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "-5",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "-5",
            "left": "6",
            "right": null,
            "value": -5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "3",
            "right": "9",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "9",
            "left": "14",
            "right": "10",
            "value": 9
          },
          {
            "id": "10",
            "left": null,
            "right": "11",
            "value": 10
          },
          {
            "id": "11",
            "left": null,
            "right": "12",
            "value": 11
          },
          {
            "id": "12",
            "left": null,
            "right": "17",
            "value": 12
          },
          {
            "id": "17",
            "left": null,
            "right": null,
            "value": 17
          },
          {
            "id": "14",
            "left": null,
            "right": "19",
            "value": 14
          },
          {
            "id": "19",
            "left": "25",
            "right": null,
            "value": 19
          },
          {
            "id": "25",
            "left": null,
            "right": null,
            "value": 25
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "3",
            "right": "5",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "5",
            "right": null,
            "value": 1
          },
          {
            "id": "5",
            "left": "7",
            "right": "9",
            "value": 5
          },
          {
            "id": "9",
            "left": null,
            "right": "12",
            "value": 9
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "7",
            "left": "8",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "4",
            "left": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "4"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "4",
            "left": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "4"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "4",
            "left": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "1",
            "left": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "19",
            "right": null,
            "value": 3
          },
          {
            "id": "19",
            "left": null,
            "right": null,
            "value": 19
          }
        ],
        "root": "4"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "6",
            "left": null,
            "right": "1",
            "value": 6
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "6"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "3",
            "left": null,
            "right": "10",
            "value": 3
          },
          {
            "id": "10",
            "left": "1",
            "right": null,
            "value": 10
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "3"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "1",
            "left": "3",
            "right": null,
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": "5",
            "value": 3
          },
          {
            "id": "5",
            "left": null,
            "right": "10",
            "value": 5
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          }
        ],
        "root": "2"
      }
    }
  ],
  "changelog": []
}