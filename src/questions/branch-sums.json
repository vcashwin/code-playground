{
  "uid": "branch-sums",
  "testStrategy": "JSON",
  "name": "Branch Sums",
  "version": 0,
  "releaseDate": "2019-11-21T00:00:00Z",
  "category": "Binary Trees",
  "difficulty": 1,
  "acl": {
    "isFree": false,
    "isFreeForStudents": true,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 77553,
    "failureCount": 26984
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "373949304",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1045
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in a Binary Tree and returns a list of its branch\n  sums ordered from leftmost branch sum to rightmost branch sum.\n</p>\n<p>\n  A branch sum is the sum of all values in a Binary Tree branch. A Binary Tree\n  branch is a path of nodes in a tree that starts at the root node and ends at\n  any leaf node.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">tree</span> =     1\n        /     \\\n       2       3\n     /   \\    /  \\\n    4     5  6    7\n  /   \\  /\n 8    9 10\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[15, 16, 18, 10, 11]\n<span class=\"CodeEditor-promptComment\">// 15 == 1 + 2 + 4 + 8</span>\n<span class=\"CodeEditor-promptComment\">// 16 == 1 + 2 + 4 + 9</span>\n<span class=\"CodeEditor-promptComment\">// 18 == 1 + 2 + 5 + 10</span>\n<span class=\"CodeEditor-promptComment\">// 10 == 1 + 3 + 6</span>\n<span class=\"CodeEditor-promptComment\">// 11 == 1 + 3 + 7</span>\n</pre>\n</div>",
  "hints": [
    "<p>\nTry traversing the Binary Tree in a depth-first-search-like fashion.\n</p>\n",
    "\n<p>\nRecursively traverse the Binary Tree in a depth-first-search-like fashion, and pass a running sum of the values of every previously-visited node to each node that you're traversing.\n</p>\n",
    "\n<p>\nAs you recursively traverse the tree, if you reach a leaf node (a node with no \"left\" or \"right\" Binary Tree nodes), add the relevant running sum that you've calculated to a list of sums (which you'll also have to pass to the recursive function). If you reach a node that isn't a leaf node, keep recursively traversing its children nodes, passing the correctly updated running sum to them.\n</p>"
  ],
  "spaceTime": "O(n) time | O(n) space - where n is the number of nodes in the Binary Tree",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": "tree",
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is the class of the input root. Do not edit it.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left;\n  BinaryTree* right;\n\n  BinaryTree(int value) {\n    this->value = value;\n    left = nullptr;\n    right = nullptr;\n  }\n};\n\nvector<int> branchSums(BinaryTree* root) {\n  // Write your code here.\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n\nusing namespace std;\n\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left;\n  BinaryTree* right;\n\n  BinaryTree(int value) {\n    this->value = value;\n    left = nullptr;\n    right = nullptr;\n  }\n};\n\nvoid calculateBranchSums(BinaryTree* node, int runningSum, vector<int>& sums);\n\n// O(n) time | O(n) space - where n is the number of nodes in the Binary Tree\nvector<int> branchSums(BinaryTree* root) {\n  vector<int> sums;\n  calculateBranchSums(root, 0, sums);\n  return sums;\n}\n\nvoid calculateBranchSums(BinaryTree* node, int runningSum, vector<int>& sums) {\n  if (node == nullptr) return;\n\n  int newRunningSum = runningSum + node->value;\n  if (node->left == nullptr && node->right == nullptr) {\n    sums.push_back(newRunningSum);\n    return;\n  }\n\n  calculateBranchSums(node->left, newRunningSum, sums);\n  calculateBranchSums(node->right, newRunningSum, sums);\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass TestBinaryTree : public BinaryTree {\n public:\n  TestBinaryTree(int value) : BinaryTree(value){};\n\n  BinaryTree* insert(vector<int> values, int i = 0) {\n    if (i >= values.size()) return nullptr;\n    vector<BinaryTree*> queue = {this};\n    while (queue.size() > 0) {\n      BinaryTree* current = queue[0];\n      queue.erase(queue.begin());\n      if (current->left == nullptr) {\n        current->left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push_back(current->left);\n      if (current->right == nullptr) {\n        current->right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push_back(current->right);\n    }\n    insert(values, i + 1);\n    return this;\n  }\n};\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      TestBinaryTree* tree = new TestBinaryTree(1);\n      tree->insert({2, 3, 4, 5, 6, 7, 8, 9, 10});\n      vector<int> expected = {15, 16, 18, 10, 11};\n      assert(branchSums(tree) == expected);\n    });\n  }\n};\n",
      "unitTests": "class TestBinaryTree : public BinaryTree {\n public:\n  TestBinaryTree(int value) : BinaryTree(value){};\n\n  BinaryTree* insert(vector<int> values, int i = 0) {\n    if (i >= values.size()) return nullptr;\n    vector<BinaryTree*> queue = {this};\n    while (queue.size() > 0) {\n      BinaryTree* current = queue[0];\n      queue.erase(queue.begin());\n      if (current->left == nullptr) {\n        current->left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push_back(current->left);\n      if (current->right == nullptr) {\n        current->right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push_back(current->right);\n    }\n    insert(values, i + 1);\n    return this;\n  }\n};\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      TestBinaryTree* tree = new TestBinaryTree(1);\n      tree->insert({2, 3, 4, 5, 6, 7, 8, 9, 10});\n      vector<int> expected = {15, 16, 18, 10, 11};\n      assert(branchSums(tree) == expected);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n  // This is the class of the input root. Do not edit it.\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n\n    public BinaryTree(int value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n    }\n  }\n\n  public static List<int> BranchSums(BinaryTree root) {\n    // Write your code here.\n    return new List<int>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n\n    public BinaryTree(int value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n    }\n  }\n\n  // O(n) time | O(n) space - where n is the number of nodes in the Binary Tree\n  public static List<int> BranchSums(BinaryTree root) {\n    List<int> sums = new List<int>();\n    calculateBranchSums(root, 0, sums);\n    return sums;\n  }\n\n  public static void calculateBranchSums(\n    BinaryTree node, int runningSum, List<int> sums\n  ) {\n    if (node == null) return;\n\n    int newRunningSum = runningSum + node.value;\n    if (node.left == null && node.right == null) {\n      sums.Add(newRunningSum);\n      return;\n    }\n\n    calculateBranchSums(node.left, newRunningSum, sums);\n    calculateBranchSums(node.right, newRunningSum, sums);\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  public class TestBinaryTree : Program.BinaryTree {\n    public TestBinaryTree(int value) : base(value) {}\n\n    public TestBinaryTree Insert(List<int> values) {\n      return Insert(values, 0);\n    }\n\n    public TestBinaryTree Insert(List<int> values, int i) {\n      if (i >= values.Count) return null;\n\n      List<TestBinaryTree> queue = new List<TestBinaryTree>();\n      queue.Add(this);\n      while (queue.Count > 0) {\n        TestBinaryTree current = queue[0];\n        queue.RemoveAt(0);\n        if (current.left == null) {\n          current.left = new TestBinaryTree(values[i]);\n          break;\n        }\n        queue.Add((TestBinaryTree)current.left);\n        if (current.right == null) {\n          current.right = new TestBinaryTree(values[i]);\n          break;\n        }\n        queue.Add((TestBinaryTree)current.right);\n      }\n      Insert(values, i + 1);\n      return this;\n    }\n  }\n\n  [Test]\n  public void TestCase1() {\n    TestBinaryTree tree = new TestBinaryTree(1).Insert(new List<int>(\n    ) { 2, 3, 4, 5, 6, 7, 8, 9, 10 });\n    List<int> expected = new List<int>() { 15, 16, 18, 10, 11 };\n    Utils.AssertTrue(Program.BranchSums(tree).SequenceEqual(expected));\n  }\n}\n",
      "unitTests": "using System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  public class TestBinaryTree : Program.BinaryTree {\n    public TestBinaryTree(int value) : base(value) {}\n\n    public TestBinaryTree Insert(List<int> values) {\n      return Insert(values, 0);\n    }\n\n    public TestBinaryTree Insert(List<int> values, int i) {\n      if (i >= values.Count) return null;\n\n      List<TestBinaryTree> queue = new List<TestBinaryTree>();\n      queue.Add(this);\n      while (queue.Count > 0) {\n        TestBinaryTree current = queue[0];\n        queue.RemoveAt(0);\n        if (current.left == null) {\n          current.left = new TestBinaryTree(values[i]);\n          break;\n        }\n        queue.Add((TestBinaryTree)current.left);\n        if (current.right == null) {\n          current.right = new TestBinaryTree(values[i]);\n          break;\n        }\n        queue.Add((TestBinaryTree)current.right);\n      }\n      Insert(values, i + 1);\n      return this;\n    }\n  }\n\n  [Test]\n  public void TestCase1() {\n    TestBinaryTree tree = new TestBinaryTree(1).Insert(new List<int>(\n    ) { 2, 3, 4, 5, 6, 7, 8, 9, 10 });\n    List<int> expected = new List<int>() { 15, 16, 18, 10, 11 };\n    Utils.AssertTrue(Program.BranchSums(tree).SequenceEqual(expected));\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is the struct of the input root. Do not edit it.\ntype BinaryTree struct {\n\tValue int\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\nfunc BranchSums(root *BinaryTree) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype BinaryTree struct {\n\tValue int\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the Binary Tree\nfunc BranchSums(root *BinaryTree) []int {\n\tsums := []int{}\n\tcalculateBranchSums(root, 0, &sums)\n\treturn sums\n}\n\nfunc calculateBranchSums(node *BinaryTree,\n\trunningSum int, sums *[]int) {\n\tif node == nil {\n\t\treturn\n\t}\n\n\trunningSum += node.Value\n\tif node.Left == nil && node.Right == nil {\n\t\t*sums = append(*sums, runningSum)\n\t\treturn\n\t}\n\n\tcalculateBranchSums(node.Left, runningSum, sums)\n\tcalculateBranchSums(node.Right, runningSum, sums)\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\ttree := NewBinaryTree(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\texpected := []int{15, 16, 18, 10, 11}\n\toutput := BranchSums(tree)\n\trequire.Equal(t, expected, output)\n}\n\nfunc NewBinaryTree(root int, values ...int) *BinaryTree {\n\ttree := &BinaryTree{Value: root}\n\ttree.Insert(values, 0)\n\treturn tree\n}\n\nfunc (tree *BinaryTree) Insert(values []int, i int) *BinaryTree {\n\tif i >= len(values) {\n\t\treturn tree\n\t}\n\tval := values[i]\n\n\tqueue := []*BinaryTree{tree}\n\tfor len(queue) > 0 {\n\t\tvar current *BinaryTree\n\t\tcurrent, queue = queue[0], queue[1:]\n\t\tif current.Left == nil {\n\t\t\tcurrent.Left = &BinaryTree{Value: val}\n\t\t\tbreak\n\t\t}\n\t\tqueue = append(queue, current.Left)\n\n\t\tif current.Right == nil {\n\t\t\tcurrent.Right = &BinaryTree{Value: val}\n\t\t\tbreak\n\t\t}\n\t\tqueue = append(queue, current.Right)\n\t}\n\n\ttree.Insert(values, i+1)\n\treturn tree\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\ttree := NewBinaryTree(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\texpected := []int{15, 16, 18, 10, 11}\n\toutput := BranchSums(tree)\n\trequire.Equal(t, expected, output)\n}\n\nfunc NewBinaryTree(root int, values ...int) *BinaryTree {\n\ttree := &BinaryTree{Value: root}\n\ttree.Insert(values, 0)\n\treturn tree\n}\n\nfunc (tree *BinaryTree) Insert(values []int, i int) *BinaryTree {\n\tif i >= len(values) {\n\t\treturn tree\n\t}\n\tval := values[i]\n\n\tqueue := []*BinaryTree{tree}\n\tfor len(queue) > 0 {\n\t\tvar current *BinaryTree\n\t\tcurrent, queue = queue[0], queue[1:]\n\t\tif current.Left == nil {\n\t\t\tcurrent.Left = &BinaryTree{Value: val}\n\t\t\tbreak\n\t\t}\n\t\tqueue = append(queue, current.Left)\n\n\t\tif current.Right == nil {\n\t\t\tcurrent.Right = &BinaryTree{Value: val}\n\t\t\tbreak\n\t\t}\n\t\tqueue = append(queue, current.Right)\n\t}\n\n\ttree.Insert(values, i+1)\n\treturn tree\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is the class of the input root. Do not edit it.\n  public static class BinaryTree {\n    int value;\n    BinaryTree left;\n    BinaryTree right;\n\n    BinaryTree(int value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n    }\n  }\n\n  public static List<Integer> branchSums(BinaryTree root) {\n    // Write your code here.\n    return new ArrayList<Integer>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  public static class BinaryTree {\n    int value;\n    BinaryTree left;\n    BinaryTree right;\n\n    BinaryTree(int value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n    }\n  }\n\n  // O(n) time | O(n) space - where n is the number of nodes in the Binary Tree\n  public static List<Integer> branchSums(BinaryTree root) {\n    List<Integer> sums = new ArrayList<Integer>();\n    calculateBranchSums(root, 0, sums);\n    return sums;\n  }\n\n  public static void calculateBranchSums(\n    BinaryTree node, int runningSum, List<Integer> sums\n  ) {\n    if (node == null) return;\n\n    int newRunningSum = runningSum + node.value;\n    if (node.left == null && node.right == null) {\n      sums.add(newRunningSum);\n      return;\n    }\n\n    calculateBranchSums(node.left, newRunningSum, sums);\n    calculateBranchSums(node.right, newRunningSum, sums);\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  public class TestBinaryTree extends Program.BinaryTree {\n    TestBinaryTree(int value) {\n      super(value);\n    }\n\n    TestBinaryTree insert(List<Integer> values) {\n      return insert(values, 0);\n    }\n\n    TestBinaryTree insert(List<Integer> values, int i) {\n      if (i >= values.size()) return null;\n\n      List<TestBinaryTree> queue = new ArrayList<TestBinaryTree>();\n      queue.add(this);\n      while (queue.size() > 0) {\n        TestBinaryTree current = queue.get(0);\n        queue.remove(0);\n        if (current.left == null) {\n          current.left = new TestBinaryTree(values.get(i));\n          break;\n        }\n        queue.add((TestBinaryTree) current.left);\n        if (current.right == null) {\n          current.right = new TestBinaryTree(values.get(i));\n          break;\n        }\n        queue.add((TestBinaryTree) current.right);\n      }\n      insert(values, i + 1);\n      return this;\n    }\n  }\n\n  @Test\n  public void TestCase1() {\n    TestBinaryTree tree =\n      new TestBinaryTree(1).insert(Arrays.asList(2, 3, 4, 5, 6, 7, 8, 9, 10));\n    List<Integer> expected =\n      new ArrayList<Integer>(Arrays.asList(15, 16, 18, 10, 11));\n    Utils.assertTrue(Program.branchSums(tree).equals(expected));\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  public class TestBinaryTree extends Program.BinaryTree {\n    TestBinaryTree(int value) {\n      super(value);\n    }\n\n    TestBinaryTree insert(List<Integer> values) {\n      return insert(values, 0);\n    }\n\n    TestBinaryTree insert(List<Integer> values, int i) {\n      if (i >= values.size()) return null;\n\n      List<TestBinaryTree> queue = new ArrayList<TestBinaryTree>();\n      queue.add(this);\n      while (queue.size() > 0) {\n        TestBinaryTree current = queue.get(0);\n        queue.remove(0);\n        if (current.left == null) {\n          current.left = new TestBinaryTree(values.get(i));\n          break;\n        }\n        queue.add((TestBinaryTree) current.left);\n        if (current.right == null) {\n          current.right = new TestBinaryTree(values.get(i));\n          break;\n        }\n        queue.add((TestBinaryTree) current.right);\n      }\n      insert(values, i + 1);\n      return this;\n    }\n  }\n\n  @Test\n  public void TestCase1() {\n    TestBinaryTree tree =\n      new TestBinaryTree(1).insert(Arrays.asList(2, 3, 4, 5, 6, 7, 8, 9, 10));\n    List<Integer> expected =\n      new ArrayList<Integer>(Arrays.asList(15, 16, 18, 10, 11));\n    Utils.assertTrue(Program.branchSums(tree).equals(expected));\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is the class of the input root.\n// Do not edit it.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction branchSums(root) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.branchSums = branchSums;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the Binary Tree\nfunction branchSums(root) {\n  const sums = [];\n  calculateBranchSums(root, 0, sums);\n  return sums;\n}\n\nfunction calculateBranchSums(node, runningSum, sums) {\n  if (!node) return;\n\n  const newRunningSum = runningSum + node.value;\n  if (!node.left && !node.right) {\n    sums.push(newRunningSum);\n    return;\n  }\n\n  calculateBranchSums(node.left, newRunningSum, sums);\n  calculateBranchSums(node.right, newRunningSum, sums);\n}\n\nexports.BinaryTree = BinaryTree;\nexports.branchSums = branchSums;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9, 10]);\n  chai.expect(program.branchSums(tree)).to.deep.equal([15, 16, 18, 10, 11]);\n});\n\nclass BinaryTree extends program.BinaryTree {\n  constructor(value) {\n    super(value);\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n}\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9, 10]);\n  chai.expect(program.branchSums(tree)).to.deep.equal([15, 16, 18, 10, 11]);\n});\n\nclass BinaryTree extends program.BinaryTree {\n  constructor(value) {\n    super(value);\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n}\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\nfun branchSums(root: BinaryTree): List<Int> {\n    // Write your code here.\n    return listOf()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the Binary Tree\nfun branchSums(root: BinaryTree): List<Int> {\n    val sums = mutableListOf<Int>()\n    calculateBranchSums(root, 0, sums)\n    return sums\n}\n\nfun calculateBranchSums(node: BinaryTree?, runningSum: Int, sums: MutableList<Int>) {\n    if (node == null) return\n\n    val newRunningSum = runningSum + node.value\n    if (node.left == null && node.right == null) {\n        sums.add(newRunningSum)\n        return\n    }\n\n    calculateBranchSums(node.left, newRunningSum, sums)\n    calculateBranchSums(node.right, newRunningSum, sums)\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.BinaryTree as BinaryTree\nimport com.algoexpert.program.branchSums as branchSums\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree = BinaryTree(1)\n        tree.left = BinaryTree(2)\n        tree.right = BinaryTree(3)\n        tree.left!!.left = BinaryTree(4)\n        tree.left!!.right = BinaryTree(5)\n        tree.right!!.left = BinaryTree(6)\n        tree.right!!.right = BinaryTree(7)\n        tree.left!!.left!!.left = BinaryTree(8)\n        tree.left!!.left!!.right = BinaryTree(9)\n        tree.left!!.right!!.left = BinaryTree(10)\n\n        val result = branchSums(tree)\n        val expected = listOf(15, 16, 18, 10, 11)\n\n        assert(result == expected)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.BinaryTree as BinaryTree\nimport com.algoexpert.program.branchSums as branchSums\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree = BinaryTree(1)\n        tree.left = BinaryTree(2)\n        tree.right = BinaryTree(3)\n        tree.left!!.left = BinaryTree(4)\n        tree.left!!.right = BinaryTree(5)\n        tree.right!!.left = BinaryTree(6)\n        tree.right!!.right = BinaryTree(7)\n        tree.left!!.left!!.left = BinaryTree(8)\n        tree.left!!.left!!.right = BinaryTree(9)\n        tree.left!!.right!!.left = BinaryTree(10)\n\n        val result = branchSums(tree)\n        val expected = listOf(15, 16, 18, 10, 11)\n\n        assert(result == expected)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is the class of the input root. Do not edit it.\nclass BinaryTree:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\ndef branchSums(root):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass BinaryTree:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\n# O(n) time | O(n) space - where n is the number of nodes in the Binary Tree\ndef branchSums(root):\n    sums = []\n    calculateBranchSums(root, 0, sums)\n    return sums\n\n\ndef calculateBranchSums(node, runningSum, sums):\n    if node is None:\n        return\n\n    newRunningSum = runningSum + node.value\n    if node.left is None and node.right is None:\n        sums.append(newRunningSum)\n        return\n\n    calculateBranchSums(node.left, newRunningSum, sums)\n    calculateBranchSums(node.right, newRunningSum, sums)\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        tree = BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9, 10])\n        self.assertEqual(program.branchSums(tree), [15, 16, 18, 10, 11])\n\n\nclass BinaryTree(program.BinaryTree):\n    def insert(self, values, i=0):\n        if i >= len(values):\n            return\n        queue = [self]\n        while len(queue) > 0:\n            current = queue.pop(0)\n            if current.left is None:\n                current.left = BinaryTree(values[i])\n                break\n            queue.append(current.left)\n            if current.right is None:\n                current.right = BinaryTree(values[i])\n                break\n            queue.append(current.right)\n        self.insert(values, i + 1)\n        return self\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        tree = BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9, 10])\n        self.assertEqual(program.branchSums(tree), [15, 16, 18, 10, 11])\n\n\nclass BinaryTree(program.BinaryTree):\n    def insert(self, values, i=0):\n        if i >= len(values):\n            return\n        queue = [self]\n        while len(queue) > 0:\n            current = queue.pop(0)\n            if current.left is None:\n                current.left = BinaryTree(values[i])\n                break\n            queue.append(current.left)\n            if current.right is None:\n                current.right = BinaryTree(values[i])\n                break\n            queue.append(current.right)\n        self.insert(values, i + 1)\n        return self\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def branchSums(tree)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def branchSums(tree)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.branchSums\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.branchSums\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  func branchSums(root: BST) -> [Int] {\n    // Write your code here.\n    return []\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  // O(n) time | O(n) space - where n is the number of nodes in the Binary Tree\n  func branchSums(root: BST) -> [Int] {\n    var sums = [Int]()\n    calculateBranchSums(node: root, runningSum: 0, sums: &sums)\n    return sums\n  }\n\n  func calculateBranchSums(node: BST?, runningSum: Int, sums: inout [Int]) {\n    if let n = node {\n      let newRunningSum = runningSum + n.value\n      if n.left == nil, n.right == nil {\n        sums.append(newRunningSum)\n        return\n      }\n      calculateBranchSums(node: n.left, runningSum: newRunningSum, sums: &sums)\n      calculateBranchSums(node: n.right, runningSum: newRunningSum, sums: &sums)\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var tree = Program.BST(value: 1)\n      tree.left = Program.BST(value: 2)\n      tree.right = Program.BST(value: 3)\n      tree.left!.left = Program.BST(value: 4)\n      tree.left!.right = Program.BST(value: 5)\n      tree.right!.left = Program.BST(value: 6)\n      tree.right!.right = Program.BST(value: 7)\n      tree.left!.left!.left = Program.BST(value: 8)\n      tree.left!.left!.right = Program.BST(value: 9)\n      tree.left!.right!.left = Program.BST(value: 10)\n      var expected: [Int] = [15, 16, 18, 10, 11]\n      var output = program.branchSums(root: tree)\n      try assertEqual(expected, output)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var tree = Program.BST(value: 1)\n      tree.left = Program.BST(value: 2)\n      tree.right = Program.BST(value: 3)\n      tree.left!.left = Program.BST(value: 4)\n      tree.left!.right = Program.BST(value: 5)\n      tree.right!.left = Program.BST(value: 6)\n      tree.right!.right = Program.BST(value: 7)\n      tree.left!.left!.left = Program.BST(value: 8)\n      tree.left!.left!.right = Program.BST(value: 9)\n      tree.left!.right!.left = Program.BST(value: 10)\n      var expected: [Int] = [15, 16, 18, 10, 11]\n      var output = program.branchSums(root: tree)\n      try assertEqual(expected, output)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is the class of the input root.\n// Do not edit it.\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport function branchSums(root: BinaryTree): number[] {\n  // Write your code here.\n  return [-1];\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the Binary Tree\nexport function branchSums(root: BinaryTree) {\n  const sums: number[] = [];\n  calculateBranchSums(root, 0, sums);\n  return sums;\n}\n\nfunction calculateBranchSums(node: BinaryTree | null, runningSum: number, sums: number[]) {\n  if (!node) return;\n\n  const newRunningSum = runningSum + node.value;\n  if (!node.left && !node.right) {\n    sums.push(newRunningSum);\n    return;\n  }\n\n  calculateBranchSums(node.left, newRunningSum, sums);\n  calculateBranchSums(node.right, newRunningSum, sums);\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9, 10]);\n  chai.expect(program.branchSums(tree!)).to.deep.equal([15, 16, 18, 10, 11]);\n});\n\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(values: number[], i = 0) {\n    if (i >= values.length) return;\n    const queue: BinaryTree[] = [this];\n    while (queue.length > 0) {\n      let current = queue.shift()!;\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n}\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9, 10]);\n  chai.expect(program.branchSums(tree!)).to.deep.equal([15, 16, 18, 10, 11]);\n});\n\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(values: number[], i = 0) {\n    if (i >= values.length) return;\n    const queue: BinaryTree[] = [this];\n    while (queue.length > 0) {\n      let current = queue.shift()!;\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n}\n"
    }
  },
  "customInputVars": [
    {
      "name": "tree",
      "example": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "5",
            "left": "10",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          }
        ],
        "root": "1"
      },
      "schema": {
        "description": "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "left": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "right": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "left",
                "right"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "root": {
            "type": "string"
          }
        },
        "required": [
          "root",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "5",
            "left": "10",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "5",
            "left": "10",
            "right": "1-2",
            "value": 5
          },
          {
            "id": "6",
            "left": "1-3",
            "right": "1-4",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "1-2",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "1-3",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "1-4",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": "1",
            "right": null,
            "value": 0
          },
          {
            "id": "1",
            "left": "10",
            "right": null,
            "value": 1
          },
          {
            "id": "10",
            "left": "100",
            "right": null,
            "value": 10
          },
          {
            "id": "100",
            "left": null,
            "right": null,
            "value": 100
          }
        ],
        "root": "0"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": null,
            "right": "1",
            "value": 0
          },
          {
            "id": "1",
            "left": null,
            "right": "10",
            "value": 1
          },
          {
            "id": "10",
            "left": null,
            "right": "100",
            "value": 10
          },
          {
            "id": "100",
            "left": null,
            "right": null,
            "value": 100
          }
        ],
        "root": "0"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": "9",
            "right": "1",
            "value": 0
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "1",
            "left": "15",
            "right": "10",
            "value": 1
          },
          {
            "id": "15",
            "left": null,
            "right": null,
            "value": 15
          },
          {
            "id": "10",
            "left": "100",
            "right": "200",
            "value": 10
          },
          {
            "id": "100",
            "left": null,
            "right": null,
            "value": 100
          },
          {
            "id": "200",
            "left": null,
            "right": null,
            "value": 200
          }
        ],
        "root": "0"
      }
    }
  ],
  "jsonTests": [
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "5",
            "left": "10",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "5",
            "left": "10",
            "right": "1-2",
            "value": 5
          },
          {
            "id": "6",
            "left": "1-3",
            "right": "1-4",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "1-2",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "1-3",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "1-4",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": "1",
            "right": null,
            "value": 0
          },
          {
            "id": "1",
            "left": "10",
            "right": null,
            "value": 1
          },
          {
            "id": "10",
            "left": "100",
            "right": null,
            "value": 10
          },
          {
            "id": "100",
            "left": null,
            "right": null,
            "value": 100
          }
        ],
        "root": "0"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": null,
            "right": "1",
            "value": 0
          },
          {
            "id": "1",
            "left": null,
            "right": "10",
            "value": 1
          },
          {
            "id": "10",
            "left": null,
            "right": "100",
            "value": 10
          },
          {
            "id": "100",
            "left": null,
            "right": null,
            "value": 100
          }
        ],
        "root": "0"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": "9",
            "right": "1",
            "value": 0
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "1",
            "left": "15",
            "right": "10",
            "value": 1
          },
          {
            "id": "15",
            "left": null,
            "right": null,
            "value": 15
          },
          {
            "id": "10",
            "left": "100",
            "right": "200",
            "value": 10
          },
          {
            "id": "100",
            "left": null,
            "right": null,
            "value": 100
          },
          {
            "id": "200",
            "left": null,
            "right": null,
            "value": 200
          }
        ],
        "root": "0"
      }
    }
  ],
  "changelog": []
}