{
  "uid": "compare-leaf-traversal",
  "testStrategy": "JSON",
  "name": "Compare Leaf Traversal",
  "version": 0,
  "releaseDate": "2021-05-17T00:00:00Z",
  "category": "Binary Trees",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 3915,
    "failureCount": 539
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "538549609",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 2302
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in the root nodes of two Binary Trees and returns\n  a boolean representing whether their leaf traversals are the same.\n</p>\n<p>\n  The leaf traversal of a Binary Tree traverses only its leaf nodes from left to\n  right. A leaf node is any node that has no <span>left</span> or\n  <span>right</span> children.\n</p>\n<p>\n  For example, the leaf traversal of the following Binary Tree is\n  <span>1, 3, 2</span>.\n</p>\n<pre>\n   4\n /   \\\n1     5\n    /   \\\n   3     2\n</pre>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">tree1</span> = 1\n      /   \\\n     2     3\n   /   \\     \\\n  4     5     6\n      /   \\\n     7     8\n<span class=\"CodeEditor-promptParameter\">tree2</span> = 1\n      /   \\\n     2     3\n   /   \\    \\\n  4     7    5\n            /  \\\n           8    6\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n</pre>\n</div>",
  "hints": [
    "<p>\n  To traverse the leaf nodes of a tree from left to right, you'll need to use a\n  pre-order traversal.\n</p>\n",
    "\n<p>\n  The simplest approach to solving this problem is to perform a pre-order\n  traversal on both trees, to store their leaf nodes in arrays in the order in\n  which they're visited, and to then compare the two resulting arrays. This\n  solutions works, but it's not optimal from a space-complexity perspective. Can\n  you think of a way to solve this problem using less extra space? It's possible\n  to solve this with <span>O(h1 + h2)</span> space or better, where\n  <span>h1</span> is the height of <span>tree1</span> and <span>h2</span> is the\n  height of <span>tree2</span>.\n</p>\n",
    "\n<p>\n  To solve this problem with a more optimal space complexity, you can perform\n  pre-order traversals on both trees at the same time. As you traverse the\n  trees, you need to look for the next leaf node in each tree and pause the\n  traversal as soon as you find it. Once you've found the next leaf node in both\n  trees, you can compare their values and see if they match; if they do,\n  continue the traversal , and repeat the process. If they don't match, the leaf\n  traversals aren't the same, and you can return <span>false</span>.\n</p>\n",
    "\n<p>\n  Another unique way to solve this problem is to connect all of the leaf nodes\n  in each individual tree so as to form two linked lists. Since the leaf nodes\n  don't have any children, you can use their <span>right</span> pointers to\n  store the next leaf nodes in the leaf traversals. And since you're reusing the\n  input trees to store the leaf traversals, the only extra space you'll be using\n  comes from the recursion used in the traversal of the trees. Once both trees\n  have their leaf nodes connected, you can iterate through the linked lists and\n  check if they're the same. To compare the linked lists, you'll need to keep\n  track of their heads (the first leaf node in each tree).\n</p>"
  ],
  "spaceTime": "O(n + m) time | O(max(h1, h2)) space - where n is the number of nodes in the first Binary Tree, m is the number in the second, h1 is the height of the first Binary Tree, and h2 is the height of the second",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left = nullptr;\n  BinaryTree* right = nullptr;\n\n  BinaryTree(int value) { this->value = value; }\n};\n\nbool compareLeafTraversal(BinaryTree* tree1, BinaryTree* tree2) {\n  // Write your code here.\n  return false;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left = nullptr;\n  BinaryTree* right = nullptr;\n\n  BinaryTree(int value) { this->value = value; }\n};\n\nBinaryTree* getNextLeafNode(vector<BinaryTree*>& traversalStack);\nbool isLeafNode(const BinaryTree* node);\n\n// O(n + m) time | O(h1 + h2) space - where n is the number of nodes in the\n// first Binary Tree, m is the number in the second, h1 is the height of the\n// first Binary Tree, and h2 is the height of the second\nbool compareLeafTraversal(BinaryTree* tree1, BinaryTree* tree2) {\n  vector<BinaryTree*> tree1TraversalStack = {tree1};\n  vector<BinaryTree*> tree2TraversalStack = {tree2};\n\n  while (tree1TraversalStack.size() > 0 && tree2TraversalStack.size() > 0) {\n    BinaryTree* tree1Leaf = getNextLeafNode(tree1TraversalStack);\n    BinaryTree* tree2Leaf = getNextLeafNode(tree2TraversalStack);\n\n    if (tree1Leaf->value != tree2Leaf->value) return false;\n  }\n\n  return tree1TraversalStack.size() == 0 && tree2TraversalStack.size() == 0;\n}\n\nBinaryTree* getNextLeafNode(vector<BinaryTree*>& traversalStack) {\n  BinaryTree* currentNode = traversalStack.back();\n  traversalStack.pop_back();\n\n  while (!isLeafNode(currentNode)) {\n    if (currentNode->right != nullptr)\n      traversalStack.push_back(currentNode->right);\n\n    // We purposely add the left node to the stack after the\n    // right node so that it gets popped off the stack first.\n    if (currentNode->left != nullptr)\n      traversalStack.push_back(currentNode->left);\n\n    currentNode = traversalStack.back();\n    traversalStack.pop_back();\n  }\n\n  return currentNode;\n}\n\nbool isLeafNode(const BinaryTree* node) {\n  return node->left == nullptr && node->right == nullptr;\n}",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <utility>\n#include <vector>\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left = nullptr;\n  BinaryTree* right = nullptr;\n\n  BinaryTree(int value) { this->value = value; }\n};\n\npair<BinaryTree*, BinaryTree*> connectLeafNodes(\n  BinaryTree* currentNode,\n  BinaryTree* head = nullptr,\n  BinaryTree* previousNode = nullptr\n);\nbool isLeafNode(const BinaryTree* node);\n\n// O(n + m) time | O(max(h1, h2)) space - where n is the number of nodes in the\n// first Binary Tree, m is the number in the second, h1 is the height of the\n// first Binary Tree, and h2 is the height of the second\nbool compareLeafTraversal(BinaryTree* tree1, BinaryTree* tree2) {\n  BinaryTree* tree1LeafNodesLinkedList = connectLeafNodes(tree1).first;\n  BinaryTree* tree2LeafNodesLinkedList = connectLeafNodes(tree2).first;\n\n  BinaryTree* list1CurrentNode = tree1LeafNodesLinkedList;\n  BinaryTree* list2CurrentNode = tree2LeafNodesLinkedList;\n  while (list1CurrentNode != nullptr && list2CurrentNode != nullptr) {\n    if (list1CurrentNode->value != list2CurrentNode->value) return false;\n\n    list1CurrentNode = list1CurrentNode->right;\n    list2CurrentNode = list2CurrentNode->right;\n  }\n\n  return list1CurrentNode == nullptr && list2CurrentNode == nullptr;\n}\n\npair<BinaryTree*, BinaryTree*> connectLeafNodes(\n  BinaryTree* currentNode, BinaryTree* head, BinaryTree* previousNode\n) {\n  if (currentNode == nullptr) return make_pair(head, previousNode);\n\n  if (isLeafNode(currentNode)) {\n    if (previousNode == nullptr) {\n      head = currentNode;\n    } else {\n      previousNode->right = currentNode;\n    }\n\n    previousNode = currentNode;\n  }\n\n  BinaryTree* leftHead;\n  BinaryTree* leftPreviousNode;\n  tie(leftHead, leftPreviousNode) =\n    connectLeafNodes(currentNode->left, head, previousNode);\n  return connectLeafNodes(currentNode->right, leftHead, leftPreviousNode);\n}\n\nbool isLeafNode(const BinaryTree* node) {\n  return node->left == nullptr && node->right == nullptr;\n}"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree* tree1 = new BinaryTree(1);\n      tree1->left = new BinaryTree(2);\n      tree1->right = new BinaryTree(3);\n      tree1->left->left = new BinaryTree(4);\n      tree1->left->right = new BinaryTree(5);\n      tree1->right->right = new BinaryTree(6);\n      tree1->left->right->left = new BinaryTree(7);\n      tree1->left->right->right = new BinaryTree(8);\n\n      BinaryTree* tree2 = new BinaryTree(1);\n      tree2->left = new BinaryTree(2);\n      tree2->right = new BinaryTree(3);\n      tree2->left->left = new BinaryTree(4);\n      tree2->left->right = new BinaryTree(7);\n      tree2->right->right = new BinaryTree(5);\n      tree2->right->right->left = new BinaryTree(8);\n      tree2->right->right->right = new BinaryTree(6);\n\n      auto expected = true;\n      auto actual = compareLeafTraversal(tree1, tree2);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree* tree1 = new BinaryTree(1);\n      tree1->left = new BinaryTree(2);\n      tree1->right = new BinaryTree(3);\n      tree1->left->left = new BinaryTree(4);\n      tree1->left->right = new BinaryTree(5);\n      tree1->right->right = new BinaryTree(6);\n      tree1->left->right->left = new BinaryTree(7);\n      tree1->left->right->right = new BinaryTree(8);\n\n      BinaryTree* tree2 = new BinaryTree(1);\n      tree2->left = new BinaryTree(2);\n      tree2->right = new BinaryTree(3);\n      tree2->left->left = new BinaryTree(4);\n      tree2->left->right = new BinaryTree(7);\n      tree2->right->right = new BinaryTree(5);\n      tree2->right->right->left = new BinaryTree(8);\n      tree2->right->right->right = new BinaryTree(6);\n\n      auto expected = true;\n      auto actual = compareLeafTraversal(tree1, tree2);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  public bool CompareLeafTraversal(BinaryTree tree1, BinaryTree tree2) {\n    // Write your code here.\n    return false;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n + m) time | O(h1 + h2) space - where n is the number of nodes in the\n  // first Binary Tree, m is the number in the second, h1 is the height of the\n  // first Binary Tree, and h2 is the height of the second\n  public bool CompareLeafTraversal(BinaryTree tree1, BinaryTree tree2) {\n    Stack<BinaryTree> tree1TraversalStack = new Stack<BinaryTree>();\n    tree1TraversalStack.Push(tree1);\n    Stack<BinaryTree> tree2TraversalStack = new Stack<BinaryTree>();\n    tree2TraversalStack.Push(tree2);\n\n    while (tree1TraversalStack.Count > 0 && tree2TraversalStack.Count > 0) {\n      BinaryTree tree1Leaf = getNextLeafNode(tree1TraversalStack);\n      BinaryTree tree2Leaf = getNextLeafNode(tree2TraversalStack);\n\n      if (tree1Leaf.value != tree2Leaf.value) {\n        return false;\n      }\n    }\n\n    return (tree1TraversalStack.Count == 0) && (tree2TraversalStack.Count == 0);\n  }\n\n  public BinaryTree getNextLeafNode(Stack<BinaryTree> traversalStack) {\n    BinaryTree currentNode = traversalStack.Pop();\n\n    while (!isLeafNode(currentNode)) {\n      if (currentNode.right != null) {\n        traversalStack.Push(currentNode.right);\n      }\n\n      // We purposely add the left node to the stack after the\n      // right node so that it gets popped off the stack first.\n      if (currentNode.left != null) {\n        traversalStack.Push(currentNode.left);\n      }\n\n      currentNode = traversalStack.Pop();\n    }\n\n    return currentNode;\n  }\n\n  public bool isLeafNode(BinaryTree node) {\n    return (node.left == null) && (node.right == null);\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n + m) time | O(max(h1, h2)) space - where n is the number of nodes in\n  // the first Binary Tree, m is the number in the second, h1 is the height of\n  // the first Binary Tree, and h2 is the height of the second\n  public bool CompareLeafTraversal(BinaryTree tree1, BinaryTree tree2) {\n    BinaryTree tree1LeafNodesLinkedList =\n      connectLeafNodes(tree1, null, null)[0];\n    BinaryTree tree2LeafNodesLinkedList =\n      connectLeafNodes(tree2, null, null)[0];\n\n    BinaryTree list1CurrentNode = tree1LeafNodesLinkedList;\n    BinaryTree list2CurrentNode = tree2LeafNodesLinkedList;\n    while (list1CurrentNode != null && list2CurrentNode != null) {\n      if (list1CurrentNode.value != list2CurrentNode.value) return false;\n\n      list1CurrentNode = list1CurrentNode.right;\n      list2CurrentNode = list2CurrentNode.right;\n    }\n\n    return list1CurrentNode == null && list2CurrentNode == null;\n  }\n\n  BinaryTree[] connectLeafNodes(\n    BinaryTree currentNode, BinaryTree head, BinaryTree previousNode\n  ) {\n    if (currentNode == null) return new BinaryTree[] { head, previousNode };\n\n    if (isLeafNode(currentNode)) {\n      if (previousNode == null) {\n        head = currentNode;\n      } else {\n        previousNode.right = currentNode;\n      }\n\n      previousNode = currentNode;\n    }\n\n    BinaryTree[] nodes = connectLeafNodes(currentNode.left, head, previousNode);\n    BinaryTree leftHead = nodes[0];\n    BinaryTree leftPreviousNode = nodes[1];\n\n    return connectLeafNodes(currentNode.right, leftHead, leftPreviousNode);\n  }\n\n  public bool isLeafNode(BinaryTree node) {\n    return (node.left == null) && (node.right == null);\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.BinaryTree tree1 = new Program.BinaryTree(1);\n    tree1.left = new Program.BinaryTree(2);\n    tree1.right = new Program.BinaryTree(3);\n    tree1.left.left = new Program.BinaryTree(4);\n    tree1.left.right = new Program.BinaryTree(5);\n    tree1.right.right = new Program.BinaryTree(6);\n    tree1.left.right.left = new Program.BinaryTree(7);\n    tree1.left.right.right = new Program.BinaryTree(8);\n\n    Program.BinaryTree tree2 = new Program.BinaryTree(1);\n    tree2.left = new Program.BinaryTree(2);\n    tree2.right = new Program.BinaryTree(3);\n    tree2.left.left = new Program.BinaryTree(4);\n    tree2.left.right = new Program.BinaryTree(7);\n    tree2.right.right = new Program.BinaryTree(5);\n    tree2.right.right.left = new Program.BinaryTree(8);\n    tree2.right.right.right = new Program.BinaryTree(6);\n\n    var expected = true;\n    var actual = new Program().CompareLeafTraversal(tree1, tree2);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.BinaryTree tree1 = new Program.BinaryTree(1);\n    tree1.left = new Program.BinaryTree(2);\n    tree1.right = new Program.BinaryTree(3);\n    tree1.left.left = new Program.BinaryTree(4);\n    tree1.left.right = new Program.BinaryTree(5);\n    tree1.right.right = new Program.BinaryTree(6);\n    tree1.left.right.left = new Program.BinaryTree(7);\n    tree1.left.right.right = new Program.BinaryTree(8);\n\n    Program.BinaryTree tree2 = new Program.BinaryTree(1);\n    tree2.left = new Program.BinaryTree(2);\n    tree2.right = new Program.BinaryTree(3);\n    tree2.left.left = new Program.BinaryTree(4);\n    tree2.left.right = new Program.BinaryTree(7);\n    tree2.right.right = new Program.BinaryTree(5);\n    tree2.right.right.left = new Program.BinaryTree(8);\n    tree2.right.right.right = new Program.BinaryTree(6);\n\n    var expected = true;\n    var actual = new Program().CompareLeafTraversal(tree1, tree2);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\nfunc CompareLeafTraversal(tree1 *BinaryTree, tree2 *BinaryTree) bool {\n\t// Write your code here.\n\treturn false\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\n// O(n + m) time | O(h1 + h2) space - where n is the number of nodes in the first\n// Binary Tree, m is the number in the second, h1 is the height of the first Binary\n// Tree, and h2 is the height of the second\nfunc CompareLeafTraversal(tree1 *BinaryTree, tree2 *BinaryTree) bool {\n\ttree1TraversalStack := []*BinaryTree{tree1}\n\ttree2TraversalStack := []*BinaryTree{tree2}\n\n\tfor len(tree1TraversalStack) > 0 && len(tree2TraversalStack) > 0 {\n\t\ttree1Leaf := getNextLeafNode(&tree1TraversalStack)\n\t\ttree2Leaf := getNextLeafNode(&tree2TraversalStack)\n\n\t\tif tree1Leaf.Value != tree2Leaf.Value {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn len(tree1TraversalStack) == 0 && len(tree2TraversalStack) == 0\n}\n\nfunc getNextLeafNode(traversalStack *[]*BinaryTree) *BinaryTree {\n\tvar currentNode *BinaryTree\n\tcurrentNode, *traversalStack = (*traversalStack)[len(*traversalStack)-1], (*traversalStack)[:len(*traversalStack)-1]\n\n\tfor !isLeafNode(currentNode) {\n\t\tif currentNode.Right != nil {\n\t\t\t*traversalStack = append(*traversalStack, currentNode.Right)\n\t\t}\n\n\t\t// We purposely add the left node to the stack after the\n\t\t// right node so that it gets popped off the stack first.\n\t\tif currentNode.Left != nil {\n\t\t\t*traversalStack = append(*traversalStack, currentNode.Left)\n\t\t}\n\t\tcurrentNode, *traversalStack = (*traversalStack)[len(*traversalStack)-1], (*traversalStack)[:len(*traversalStack)-1]\n\t}\n\n\treturn currentNode\n}\n\nfunc isLeafNode(node *BinaryTree) bool {\n\treturn node.Left == nil && node.Right == nil\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\ntype TreePair struct {\n\tFirst  *BinaryTree\n\tSecond *BinaryTree\n}\n\n// O(n + m) time | O(max(h1, h2)) space - where n is the number of nodes in the first\n// Binary Tree, m is the number in the second, h1 is the height of the first Binary\n// Tree, and h2 is the height of the second\nfunc CompareLeafTraversal(tree1 *BinaryTree, tree2 *BinaryTree) bool {\n\ttree1LeafNodesLinkedList := connectLeafNodes(tree1, nil, nil).First\n\ttree2LeafNodesLinkedList := connectLeafNodes(tree2, nil, nil).First\n\n\tlist1CurrentNode := tree1LeafNodesLinkedList\n\tlist2CurrentNode := tree2LeafNodesLinkedList\n\tfor list1CurrentNode != nil && list2CurrentNode != nil {\n\t\tif list1CurrentNode.Value != list2CurrentNode.Value {\n\t\t\treturn false\n\t\t}\n\n\t\tlist1CurrentNode = list1CurrentNode.Right\n\t\tlist2CurrentNode = list2CurrentNode.Right\n\t}\n\n\treturn list1CurrentNode == nil && list2CurrentNode == nil\n}\n\nfunc connectLeafNodes(currentNode *BinaryTree, head *BinaryTree, previousNode *BinaryTree) TreePair {\n\tif currentNode == nil {\n\t\treturn TreePair{head, previousNode}\n\t}\n\n\tnewHead := head\n\tnewPreviousNode := previousNode\n\n\tif isLeafNode(currentNode) {\n\t\tif previousNode == nil {\n\t\t\tnewHead = currentNode\n\t\t} else {\n\t\t\tpreviousNode.Right = currentNode\n\t\t}\n\n\t\tnewPreviousNode = currentNode\n\t}\n\n\tleftPair := connectLeafNodes(currentNode.Left, newHead, newPreviousNode)\n\tleftHead, leftPreviousNode := leftPair.First, leftPair.Second\n\treturn connectLeafNodes(currentNode.Right, leftHead, leftPreviousNode)\n}\n\nfunc isLeafNode(node *BinaryTree) bool {\n\treturn node.Left == nil && node.Right == nil\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\ttree1 := &BinaryTree{Value: 1}\n\ttree1.Left = &BinaryTree{Value: 2}\n\ttree1.Right = &BinaryTree{Value: 3}\n\ttree1.Left.Left = &BinaryTree{Value: 4}\n\ttree1.Left.Right = &BinaryTree{Value: 5}\n\ttree1.Right.Right = &BinaryTree{Value: 6}\n\ttree1.Left.Right.Left = &BinaryTree{Value: 7}\n\ttree1.Left.Right.Right = &BinaryTree{Value: 8}\n\n\ttree2 := &BinaryTree{Value: 1}\n\ttree2.Left = &BinaryTree{Value: 2}\n\ttree2.Right = &BinaryTree{Value: 3}\n\ttree2.Left.Left = &BinaryTree{Value: 4}\n\ttree2.Left.Right = &BinaryTree{Value: 7}\n\ttree2.Right.Right = &BinaryTree{Value: 5}\n\ttree2.Right.Right.Left = &BinaryTree{Value: 8}\n\ttree2.Right.Right.Right = &BinaryTree{Value: 6}\n\n\texpected := true\n\tactual := CompareLeafTraversal(tree1, tree2)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\ttree1 := &BinaryTree{Value: 1}\n\ttree1.Left = &BinaryTree{Value: 2}\n\ttree1.Right = &BinaryTree{Value: 3}\n\ttree1.Left.Left = &BinaryTree{Value: 4}\n\ttree1.Left.Right = &BinaryTree{Value: 5}\n\ttree1.Right.Right = &BinaryTree{Value: 6}\n\ttree1.Left.Right.Left = &BinaryTree{Value: 7}\n\ttree1.Left.Right.Right = &BinaryTree{Value: 8}\n\n\ttree2 := &BinaryTree{Value: 1}\n\ttree2.Left = &BinaryTree{Value: 2}\n\ttree2.Right = &BinaryTree{Value: 3}\n\ttree2.Left.Left = &BinaryTree{Value: 4}\n\ttree2.Left.Right = &BinaryTree{Value: 7}\n\ttree2.Right.Right = &BinaryTree{Value: 5}\n\ttree2.Right.Right.Left = &BinaryTree{Value: 8}\n\ttree2.Right.Right.Right = &BinaryTree{Value: 6}\n\n\texpected := true\n\tactual := CompareLeafTraversal(tree1, tree2)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  public boolean compareLeafTraversal(BinaryTree tree1, BinaryTree tree2) {\n    // Write your code here.\n    return false;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n + m) time | O(h1 + h2) space - where n is the number of nodes in the\n  // first Binary Tree, m is the number in the second, h1 is the height of the\n  // first Binary Tree, and h2 is the height of the second\n  public boolean compareLeafTraversal(BinaryTree tree1, BinaryTree tree2) {\n    Stack<BinaryTree> tree1TraversalStack = new Stack<BinaryTree>();\n    tree1TraversalStack.push(tree1);\n    Stack<BinaryTree> tree2TraversalStack = new Stack<BinaryTree>();\n    tree2TraversalStack.push(tree2);\n\n    while (tree1TraversalStack.size() > 0 && tree2TraversalStack.size() > 0) {\n      BinaryTree tree1Leaf = getNextLeafNode(tree1TraversalStack);\n      BinaryTree tree2Leaf = getNextLeafNode(tree2TraversalStack);\n\n      if (tree1Leaf.value != tree2Leaf.value) {\n        return false;\n      }\n    }\n\n    return (tree1TraversalStack.size() == 0)\n      && (tree2TraversalStack.size() == 0);\n  }\n\n  public BinaryTree getNextLeafNode(Stack<BinaryTree> traversalStack) {\n    BinaryTree currentNode = traversalStack.pop();\n\n    while (!isLeafNode(currentNode)) {\n      if (currentNode.right != null) {\n        traversalStack.push(currentNode.right);\n      }\n\n      // We purposely add the left node to the stack after the\n      // right node so that it gets popped off the stack first.\n      if (currentNode.left != null) {\n        traversalStack.push(currentNode.left);\n      }\n\n      currentNode = traversalStack.pop();\n    }\n\n    return currentNode;\n  }\n\n  public boolean isLeafNode(BinaryTree node) {\n    return (node.left == null) && (node.right == null);\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n + m) time | O(max(h1, h2)) space - where n is the number of nodes in\n  // the first Binary Tree, m is the number in the second, h1 is the height of\n  // the first Binary Tree, and h2 is the height of the second\n  public boolean compareLeafTraversal(BinaryTree tree1, BinaryTree tree2) {\n    BinaryTree tree1LeafNodesLinkedList =\n      connectLeafNodes(tree1, null, null)[0];\n    BinaryTree tree2LeafNodesLinkedList =\n      connectLeafNodes(tree2, null, null)[0];\n\n    BinaryTree list1CurrentNode = tree1LeafNodesLinkedList;\n    BinaryTree list2CurrentNode = tree2LeafNodesLinkedList;\n    while (list1CurrentNode != null && list2CurrentNode != null) {\n      if (list1CurrentNode.value != list2CurrentNode.value) return false;\n\n      list1CurrentNode = list1CurrentNode.right;\n      list2CurrentNode = list2CurrentNode.right;\n    }\n\n    return list1CurrentNode == null && list2CurrentNode == null;\n  }\n\n  BinaryTree[] connectLeafNodes(\n    BinaryTree currentNode, BinaryTree head, BinaryTree previousNode\n  ) {\n    if (currentNode == null) return new BinaryTree[] {head, previousNode};\n\n    if (isLeafNode(currentNode)) {\n      if (previousNode == null) {\n        head = currentNode;\n      } else {\n        previousNode.right = currentNode;\n      }\n\n      previousNode = currentNode;\n    }\n\n    BinaryTree[] nodes = connectLeafNodes(currentNode.left, head, previousNode);\n    BinaryTree leftHead = nodes[0];\n    BinaryTree leftPreviousNode = nodes[1];\n\n    return connectLeafNodes(currentNode.right, leftHead, leftPreviousNode);\n  }\n\n  public boolean isLeafNode(BinaryTree node) {\n    return (node.left == null) && (node.right == null);\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.BinaryTree tree1 = new Program.BinaryTree(1);\n    tree1.left = new Program.BinaryTree(2);\n    tree1.right = new Program.BinaryTree(3);\n    tree1.left.left = new Program.BinaryTree(4);\n    tree1.left.right = new Program.BinaryTree(5);\n    tree1.right.right = new Program.BinaryTree(6);\n    tree1.left.right.left = new Program.BinaryTree(7);\n    tree1.left.right.right = new Program.BinaryTree(8);\n\n    Program.BinaryTree tree2 = new Program.BinaryTree(1);\n    tree2.left = new Program.BinaryTree(2);\n    tree2.right = new Program.BinaryTree(3);\n    tree2.left.left = new Program.BinaryTree(4);\n    tree2.left.right = new Program.BinaryTree(7);\n    tree2.right.right = new Program.BinaryTree(5);\n    tree2.right.right.left = new Program.BinaryTree(8);\n    tree2.right.right.right = new Program.BinaryTree(6);\n\n    var expected = true;\n    var actual = new Program().compareLeafTraversal(tree1, tree2);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.BinaryTree tree1 = new Program.BinaryTree(1);\n    tree1.left = new Program.BinaryTree(2);\n    tree1.right = new Program.BinaryTree(3);\n    tree1.left.left = new Program.BinaryTree(4);\n    tree1.left.right = new Program.BinaryTree(5);\n    tree1.right.right = new Program.BinaryTree(6);\n    tree1.left.right.left = new Program.BinaryTree(7);\n    tree1.left.right.right = new Program.BinaryTree(8);\n\n    Program.BinaryTree tree2 = new Program.BinaryTree(1);\n    tree2.left = new Program.BinaryTree(2);\n    tree2.right = new Program.BinaryTree(3);\n    tree2.left.left = new Program.BinaryTree(4);\n    tree2.left.right = new Program.BinaryTree(7);\n    tree2.right.right = new Program.BinaryTree(5);\n    tree2.right.right.left = new Program.BinaryTree(8);\n    tree2.right.right.right = new Program.BinaryTree(6);\n\n    var expected = true;\n    var actual = new Program().compareLeafTraversal(tree1, tree2);\n    Utils.assertTrue(expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction compareLeafTraversal(tree1, tree2) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.compareLeafTraversal = compareLeafTraversal;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n + m) time | O(h1 + h2) space - where n is the number of nodes in the first\n// Binary Tree, m is the number in the second, h1 is the height of the first Binary\n// Tree, and h2 is the height of the second\nfunction compareLeafTraversal(tree1, tree2) {\n  const tree1TraversalStack = [tree1];\n  const tree2TraversalStack = [tree2];\n\n  while (tree1TraversalStack.length > 0 && tree2TraversalStack.length > 0) {\n    const tree1Leaf = getNextLeafNode(tree1TraversalStack);\n    const tree2Leaf = getNextLeafNode(tree2TraversalStack);\n\n    if (tree1Leaf.value !== tree2Leaf.value) return false;\n  }\n\n  return tree1TraversalStack.length === 0 && tree2TraversalStack.length === 0;\n}\n\nfunction getNextLeafNode(traversalStack) {\n  let currentNode = traversalStack.pop();\n\n  while (!isLeafNode(currentNode)) {\n    if (currentNode.right !== null) traversalStack.push(currentNode.right);\n\n    // We purposely add the left node to the stack after the\n    // right node so that it gets popped off the stack first.\n    if (currentNode.left !== null) traversalStack.push(currentNode.left);\n\n    currentNode = traversalStack.pop();\n  }\n\n  return currentNode;\n}\n\nfunction isLeafNode(node) {\n  return node.left === null && node.right === null;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.compareLeafTraversal = compareLeafTraversal;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n + m) time | O(max(h1, h2)) space - where n is the number of nodes in the first\n// Binary Tree, m is the number in the second, h1 is the height of the first Binary\n// Tree, and h2 is the height of the second\nfunction compareLeafTraversal(tree1, tree2) {\n  const [tree1LeafNodesLinkedList, _1] = connectLeafNodes(tree1);\n  const [tree2LeafNodesLinkedList, _2] = connectLeafNodes(tree2);\n\n  let list1CurrentNode = tree1LeafNodesLinkedList;\n  let list2CurrentNode = tree2LeafNodesLinkedList;\n  while (list1CurrentNode !== null && list2CurrentNode !== null) {\n    if (list1CurrentNode.value !== list2CurrentNode.value) return false;\n\n    list1CurrentNode = list1CurrentNode.right;\n    list2CurrentNode = list2CurrentNode.right;\n  }\n\n  return list1CurrentNode === null && list2CurrentNode === null;\n}\n\nfunction connectLeafNodes(currentNode, head = null, previousNode = null) {\n  if (currentNode === null) return [head, previousNode];\n\n  if (isLeafNode(currentNode)) {\n    if (previousNode === null) {\n      head = currentNode;\n    } else {\n      previousNode.right = currentNode;\n    }\n\n    previousNode = currentNode;\n  }\n\n  const [leftHead, leftPreviousNode] = connectLeafNodes(currentNode.left, head, previousNode);\n  return connectLeafNodes(currentNode.right, leftHead, leftPreviousNode);\n}\n\nfunction isLeafNode(node) {\n  return node.left === null && node.right === null;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.compareLeafTraversal = compareLeafTraversal;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree1 = new program.BinaryTree(1);\n  tree1.left = new program.BinaryTree(2);\n  tree1.right = new program.BinaryTree(3);\n  tree1.left.left = new program.BinaryTree(4);\n  tree1.left.right = new program.BinaryTree(5);\n  tree1.right.right = new program.BinaryTree(6);\n  tree1.left.right.left = new program.BinaryTree(7);\n  tree1.left.right.right = new program.BinaryTree(8);\n\n  const tree2 = new program.BinaryTree(1);\n  tree2.left = new program.BinaryTree(2);\n  tree2.right = new program.BinaryTree(3);\n  tree2.left.left = new program.BinaryTree(4);\n  tree2.left.right = new program.BinaryTree(7);\n  tree2.right.right = new program.BinaryTree(5);\n  tree2.right.right.left = new program.BinaryTree(8);\n  tree2.right.right.right = new program.BinaryTree(6);\n\n  const expected = true;\n  const actual = program.compareLeafTraversal(tree1, tree2);\n\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree1 = new program.BinaryTree(1);\n  tree1.left = new program.BinaryTree(2);\n  tree1.right = new program.BinaryTree(3);\n  tree1.left.left = new program.BinaryTree(4);\n  tree1.left.right = new program.BinaryTree(5);\n  tree1.right.right = new program.BinaryTree(6);\n  tree1.left.right.left = new program.BinaryTree(7);\n  tree1.left.right.right = new program.BinaryTree(8);\n\n  const tree2 = new program.BinaryTree(1);\n  tree2.left = new program.BinaryTree(2);\n  tree2.right = new program.BinaryTree(3);\n  tree2.left.left = new program.BinaryTree(4);\n  tree2.left.right = new program.BinaryTree(7);\n  tree2.right.right = new program.BinaryTree(5);\n  tree2.right.right.left = new program.BinaryTree(8);\n  tree2.right.right.right = new program.BinaryTree(6);\n\n  const expected = true;\n  const actual = program.compareLeafTraversal(tree1, tree2);\n\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\nfun compareLeafTraversal(tree1: BinaryTree, tree2: BinaryTree): Boolean {\n    // Write your code here.\n    return false\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\n// O(n + m) time | O(h1 + h2) space - where n is the number of nodes in the first\n// Binary Tree, m is the number in the second, h1 is the height of the first Binary\n// Tree, and h2 is the height of the second\nfun compareLeafTraversal(tree1: BinaryTree, tree2: BinaryTree): Boolean {\n    val tree1TraversalStack = mutableListOf(tree1)\n    val tree2TraversalStack = mutableListOf(tree2)\n\n    while (tree1TraversalStack.size > 0 && tree2TraversalStack.size > 0) {\n        val tree1Leaf = getNextLeafNode(tree1TraversalStack)\n        val tree2Leaf = getNextLeafNode(tree2TraversalStack)\n\n        if (tree1Leaf.value != tree2Leaf.value) return false\n    }\n\n    return tree1TraversalStack.size == 0 && tree2TraversalStack.size == 0\n}\n\nfun getNextLeafNode(traversalStack: MutableList<BinaryTree>): BinaryTree {\n    var currentNode = traversalStack.removeAt(traversalStack.size - 1)\n\n    while (!isLeafNode(currentNode)) {\n        if (currentNode.right != null) traversalStack.add(currentNode.right!!)\n\n        // We purposely add the left node to the stack after the\n        // right node so that it gets popped off the stack first.\n        if (currentNode.left != null) traversalStack.add(currentNode.left!!)\n\n        currentNode = traversalStack.removeAt(traversalStack.size - 1)\n    }\n\n    return currentNode\n}\n\nfun isLeafNode(node: BinaryTree): Boolean {\n    return node.left == null && node.right == null\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\n// O(n + m) time | O(max(h1, h2)) space - where n is the number of nodes in the first\n// Binary Tree, m is the number in the second, h1 is the height of the first Binary\n// Tree, and h2 is the height of the second\nfun compareLeafTraversal(tree1: BinaryTree, tree2: BinaryTree): Boolean {\n    val (tree1LeafNodesLinkedList, _) = connectLeafNodes(tree1)\n    val (tree2LeafNodesLinkedList, _) = connectLeafNodes(tree2)\n\n    var list1CurrentNode: BinaryTree? = tree1LeafNodesLinkedList\n    var list2CurrentNode: BinaryTree? = tree2LeafNodesLinkedList\n    while (list1CurrentNode != null && list2CurrentNode != null) {\n        if (list1CurrentNode.value != list2CurrentNode.value) return false\n\n        list1CurrentNode = list1CurrentNode.right\n        list2CurrentNode = list2CurrentNode.right\n    }\n\n    return list1CurrentNode == null && list2CurrentNode == null\n}\n\nfun connectLeafNodes(currentNode: BinaryTree?, head: BinaryTree? = null, previousNode: BinaryTree? = null): Pair<BinaryTree?, BinaryTree?> {\n    if (currentNode == null) return Pair(head, previousNode)\n\n    var newHead = head\n    var newPreviousNode = previousNode\n\n    if (isLeafNode(currentNode)) {\n        if (previousNode == null) {\n            newHead = currentNode\n        } else {\n            previousNode.right = currentNode\n        }\n\n        newPreviousNode = currentNode\n    }\n\n    val (leftHead, leftPreviousNode) = connectLeafNodes(\n        currentNode.left,\n        newHead,\n        newPreviousNode,\n    )\n    return connectLeafNodes(currentNode.right, leftHead, leftPreviousNode)\n}\n\nfun isLeafNode(node: BinaryTree): Boolean {\n    return node.left == null && node.right == null\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.BinaryTree\nimport com.algoexpert.program.compareLeafTraversal\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree1 = BinaryTree(1)\n        tree1.left = BinaryTree(2)\n        tree1.right = BinaryTree(3)\n        tree1.left!!.left = BinaryTree(4)\n        tree1.left!!.right = BinaryTree(5)\n        tree1.right!!.right = BinaryTree(6)\n        tree1.left!!.right!!.left = BinaryTree(7)\n        tree1.left!!.right!!.right = BinaryTree(8)\n\n        val tree2 = BinaryTree(1)\n        tree2.left = BinaryTree(2)\n        tree2.right = BinaryTree(3)\n        tree2.left!!.left = BinaryTree(4)\n        tree2.left!!.right = BinaryTree(7)\n        tree2.right!!.right = BinaryTree(5)\n        tree2.right!!.right!!.left = BinaryTree(8)\n        tree2.right!!.right!!.right = BinaryTree(6)\n\n        val expected = true\n        val output = compareLeafTraversal(tree1, tree2)\n\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.BinaryTree\nimport com.algoexpert.program.compareLeafTraversal\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree1 = BinaryTree(1)\n        tree1.left = BinaryTree(2)\n        tree1.right = BinaryTree(3)\n        tree1.left!!.left = BinaryTree(4)\n        tree1.left!!.right = BinaryTree(5)\n        tree1.right!!.right = BinaryTree(6)\n        tree1.left!!.right!!.left = BinaryTree(7)\n        tree1.left!!.right!!.right = BinaryTree(8)\n\n        val tree2 = BinaryTree(1)\n        tree2.left = BinaryTree(2)\n        tree2.right = BinaryTree(3)\n        tree2.left!!.left = BinaryTree(4)\n        tree2.left!!.right = BinaryTree(7)\n        tree2.right!!.right = BinaryTree(5)\n        tree2.right!!.right!!.left = BinaryTree(8)\n        tree2.right!!.right!!.right = BinaryTree(6)\n\n        val expected = true\n        val output = compareLeafTraversal(tree1, tree2)\n\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef compareLeafTraversal(tree1, tree2):\n    # Write your code here.\n    return False\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# O(n + m) time | O(h1 + h2) space - where n is the number of nodes in the first\n# Binary Tree, m is the number in the second, h1 is the height of the first Binary\n# Tree, and h2 is the height of the second\ndef compareLeafTraversal(tree1, tree2):\n    tree1TraversalStack = [tree1]\n    tree2TraversalStack = [tree2]\n\n    while len(tree1TraversalStack) > 0 and len(tree2TraversalStack) > 0:\n        tree1Leaf = getNextLeafNode(tree1TraversalStack)\n        tree2Leaf = getNextLeafNode(tree2TraversalStack)\n\n        if tree1Leaf.value != tree2Leaf.value:\n            return False\n\n    return len(tree1TraversalStack) == 0 and len(tree2TraversalStack) == 0\n\n\ndef getNextLeafNode(traversalStack):\n    currentNode = traversalStack.pop()\n\n    while not isLeafNode(currentNode):\n        if currentNode.right is not None:\n            traversalStack.append(currentNode.right)\n\n        # We purposely add the left node to the stack after the\n        # right node so that it gets popped off the stack first.\n        if currentNode.left is not None:\n            traversalStack.append(currentNode.left)\n\n        currentNode = traversalStack.pop()\n\n    return currentNode\n\n\ndef isLeafNode(node):\n    return node.left is None and node.right is None\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# O(n + m) time | O(max(h1, h2)) space - where n is the number of nodes in the first\n# Binary Tree, m is the number in the second, h1 is the height of the first Binary\n# Tree, and h2 is the height of the second\ndef compareLeafTraversal(tree1, tree2):\n    tree1LeafNodesLinkedList, _ = connectLeafNodes(tree1)\n    tree2LeafNodesLinkedList, _ = connectLeafNodes(tree2)\n\n    list1CurrentNode = tree1LeafNodesLinkedList\n    list2CurrentNode = tree2LeafNodesLinkedList\n    while list1CurrentNode is not None and list2CurrentNode is not None:\n        if list1CurrentNode.value != list2CurrentNode.value:\n            return False\n\n        list1CurrentNode = list1CurrentNode.right\n        list2CurrentNode = list2CurrentNode.right\n\n    return list1CurrentNode is None and list2CurrentNode is None\n\n\ndef connectLeafNodes(currentNode, head=None, previousNode=None):\n    if currentNode is None:\n        return head, previousNode\n\n    if isLeafNode(currentNode):\n        if previousNode is None:\n            head = currentNode\n        else:\n            previousNode.right = currentNode\n\n        previousNode = currentNode\n\n    leftHead, leftPreviousNode = connectLeafNodes(currentNode.left, head, previousNode)\n    return connectLeafNodes(currentNode.right, leftHead, leftPreviousNode)\n\n\ndef isLeafNode(node):\n    return node.left is None and node.right is None\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        tree1 = program.BinaryTree(1)\n        tree1.left = program.BinaryTree(2)\n        tree1.right = program.BinaryTree(3)\n        tree1.left.left = program.BinaryTree(4)\n        tree1.left.right = program.BinaryTree(5)\n        tree1.right.right = program.BinaryTree(6)\n        tree1.left.right.left = program.BinaryTree(7)\n        tree1.left.right.right = program.BinaryTree(8)\n\n        tree2 = program.BinaryTree(1)\n        tree2.left = program.BinaryTree(2)\n        tree2.right = program.BinaryTree(3)\n        tree2.left.left = program.BinaryTree(4)\n        tree2.left.right = program.BinaryTree(7)\n        tree2.right.right = program.BinaryTree(5)\n        tree2.right.right.left = program.BinaryTree(8)\n        tree2.right.right.right = program.BinaryTree(6)\n\n        expected = True\n        actual = program.compareLeafTraversal(tree1, tree2)\n\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        tree1 = program.BinaryTree(1)\n        tree1.left = program.BinaryTree(2)\n        tree1.right = program.BinaryTree(3)\n        tree1.left.left = program.BinaryTree(4)\n        tree1.left.right = program.BinaryTree(5)\n        tree1.right.right = program.BinaryTree(6)\n        tree1.left.right.left = program.BinaryTree(7)\n        tree1.left.right.right = program.BinaryTree(8)\n\n        tree2 = program.BinaryTree(1)\n        tree2.left = program.BinaryTree(2)\n        tree2.right = program.BinaryTree(3)\n        tree2.left.left = program.BinaryTree(4)\n        tree2.left.right = program.BinaryTree(7)\n        tree2.right.right = program.BinaryTree(5)\n        tree2.right.right.left = program.BinaryTree(8)\n        tree2.right.right.right = program.BinaryTree(6)\n\n        expected = True\n        actual = program.compareLeafTraversal(tree1, tree2)\n\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def compareLeafTraversal(tree1, tree2)\n    # Write your code here.\n    return false\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def compareLeafTraversal(tree1, tree2)\n    # Write your code here.\n    return false\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.compareLeafTraversal\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.compareLeafTraversal\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  func compareLeafTraversal(_ tree1: BinaryTree, _ tree2: BinaryTree) -> Bool {\n    // Write your code here.\n    return false\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(n + m) time | O(h1 + h2) space - where n is the number of nodes in the first\n  // Binary Tree, m is the number in the second, h1 is the height of the first Binary\n  // Tree, and h2 is the height of the second\n  func compareLeafTraversal(_ tree1: BinaryTree, _ tree2: BinaryTree) -> Bool {\n    var tree1TraversalStack = [tree1]\n    var tree2TraversalStack = [tree2]\n\n    while tree1TraversalStack.count > 0, tree2TraversalStack.count > 0 {\n      let tree1Leaf = getNextLeafNode(&tree1TraversalStack)\n      let tree2Leaf = getNextLeafNode(&tree2TraversalStack)\n\n      if tree1Leaf.value != tree2Leaf.value {\n        return false\n      }\n    }\n    return tree1TraversalStack.count == 0 && tree2TraversalStack.count == 0\n  }\n\n  func getNextLeafNode(_ traversalStack: inout [BinaryTree]) -> BinaryTree {\n    var currentNode = traversalStack.popLast()!\n\n    while !isLeafNode(currentNode) {\n      if currentNode.right != nil {\n        traversalStack.append(currentNode.right!)\n      }\n\n      // We purposely add the left node to the stack after the\n      // right node so that it gets popped off the stack first.\n      if currentNode.left != nil {\n        traversalStack.append(currentNode.left!)\n      }\n\n      currentNode = traversalStack.popLast()!\n    }\n    return currentNode\n  }\n\n  func isLeafNode(_ node: BinaryTree) -> Bool {\n    return node.left == nil && node.right == nil\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(n + m) time | O(max(h1, h2)) space - where n is the number of nodes in the first\n  // Binary Tree, m is the number in the second, h1 is the height of the first Binary\n  // Tree, and h2 is the height of the second\n  func compareLeafTraversal(_ tree1: BinaryTree, _ tree2: BinaryTree) -> Bool {\n    var tree1LeafNodesLinkedList = connectLeafNodes(tree1, nil, nil).0\n    var tree2LeafNodesLinkedList = connectLeafNodes(tree2, nil, nil).0\n\n    var list1CurrentNode: BinaryTree? = tree1LeafNodesLinkedList\n    var list2CurrentNode: BinaryTree? = tree2LeafNodesLinkedList\n    while list1CurrentNode != nil, list2CurrentNode != nil {\n      if list1CurrentNode!.value != list2CurrentNode!.value {\n        return false\n      }\n\n      list1CurrentNode = list1CurrentNode!.right\n      list2CurrentNode = list2CurrentNode!.right\n    }\n\n    return list1CurrentNode == nil && list2CurrentNode == nil\n  }\n\n  func connectLeafNodes(_ currentNode: BinaryTree?, _ head: BinaryTree?, _ previousNode: BinaryTree?) -> (BinaryTree?, BinaryTree?) {\n    if currentNode == nil {\n      return (head, previousNode)\n    }\n\n    var newHead = head\n    var newPreviousNode = previousNode\n\n    if isLeafNode(currentNode!) {\n      if previousNode == nil {\n        newHead = currentNode\n      } else {\n        previousNode!.right = currentNode\n      }\n\n      newPreviousNode = currentNode\n    }\n\n    let (leftHead, leftPreviousNode) = connectLeafNodes(currentNode!.left, newHead, newPreviousNode)\n    return connectLeafNodes(currentNode!.right, leftHead, leftPreviousNode)\n  }\n\n  func isLeafNode(_ node: BinaryTree) -> Bool {\n    return node.left == nil && node.right == nil\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var tree1 = Program.BinaryTree(value: 1)\n      tree1.left = Program.BinaryTree(value: 2)\n      tree1.right = Program.BinaryTree(value: 3)\n      tree1.left!.left = Program.BinaryTree(value: 4)\n      tree1.left!.right = Program.BinaryTree(value: 5)\n      tree1.right!.right = Program.BinaryTree(value: 6)\n      tree1.left!.right!.left = Program.BinaryTree(value: 7)\n      tree1.left!.right!.right = Program.BinaryTree(value: 8)\n\n      var tree2 = Program.BinaryTree(value: 1)\n      tree2.left = Program.BinaryTree(value: 2)\n      tree2.right = Program.BinaryTree(value: 3)\n      tree2.left!.left = Program.BinaryTree(value: 4)\n      tree2.left!.right = Program.BinaryTree(value: 7)\n      tree2.right!.right = Program.BinaryTree(value: 5)\n      tree2.right!.right!.left = Program.BinaryTree(value: 8)\n      tree2.right!.right!.right = Program.BinaryTree(value: 6)\n\n      var expected = true\n      var actual = Program().compareLeafTraversal(tree1, tree2)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var tree1 = Program.BinaryTree(value: 1)\n      tree1.left = Program.BinaryTree(value: 2)\n      tree1.right = Program.BinaryTree(value: 3)\n      tree1.left!.left = Program.BinaryTree(value: 4)\n      tree1.left!.right = Program.BinaryTree(value: 5)\n      tree1.right!.right = Program.BinaryTree(value: 6)\n      tree1.left!.right!.left = Program.BinaryTree(value: 7)\n      tree1.left!.right!.right = Program.BinaryTree(value: 8)\n\n      var tree2 = Program.BinaryTree(value: 1)\n      tree2.left = Program.BinaryTree(value: 2)\n      tree2.right = Program.BinaryTree(value: 3)\n      tree2.left!.left = Program.BinaryTree(value: 4)\n      tree2.left!.right = Program.BinaryTree(value: 7)\n      tree2.right!.right = Program.BinaryTree(value: 5)\n      tree2.right!.right!.left = Program.BinaryTree(value: 8)\n      tree2.right!.right!.right = Program.BinaryTree(value: 6)\n\n      var expected = true\n      var actual = Program().compareLeafTraversal(tree1, tree2)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport function compareLeafTraversal(tree1: BinaryTree, tree2: BinaryTree) {\n  // Write your code here.\n  return false;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n + m) time | O(h1 + h2) space - where n is the number of nodes in the first\n// Binary Tree, m is the number in the second, h1 is the height of the first Binary\n// Tree, and h2 is the height of the second\nexport function compareLeafTraversal(tree1: BinaryTree, tree2: BinaryTree) {\n  const tree1TraversalStack = [tree1];\n  const tree2TraversalStack = [tree2];\n\n  while (tree1TraversalStack.length > 0 && tree2TraversalStack.length > 0) {\n    const tree1Leaf = getNextLeafNode(tree1TraversalStack);\n    const tree2Leaf = getNextLeafNode(tree2TraversalStack);\n\n    if (tree1Leaf.value !== tree2Leaf.value) return false;\n  }\n\n  return tree1TraversalStack.length === 0 && tree2TraversalStack.length === 0;\n}\n\nfunction getNextLeafNode(traversalStack: BinaryTree[]) {\n  let currentNode = traversalStack.pop()!;\n\n  while (!isLeafNode(currentNode)) {\n    if (currentNode.right !== null) traversalStack.push(currentNode.right);\n\n    // We purposely add the left node to the stack after the\n    // right node so that it gets popped off the stack first.\n    if (currentNode.left !== null) traversalStack.push(currentNode.left);\n\n    currentNode = traversalStack.pop()!;\n  }\n\n  return currentNode;\n}\n\nfunction isLeafNode(node: BinaryTree) {\n  return node.left === null && node.right === null;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n + m) time | O(max(h1, h2)) space - where n is the number of nodes in the first\n// Binary Tree, m is the number in the second, h1 is the height of the first Binary\n// Tree, and h2 is the height of the second\nexport function compareLeafTraversal(tree1: BinaryTree, tree2: BinaryTree) {\n  const [tree1LeafNodesLinkedList, _1] = connectLeafNodes(tree1);\n  const [tree2LeafNodesLinkedList, _2] = connectLeafNodes(tree2);\n\n  let list1CurrentNode: BinaryTree | null = tree1LeafNodesLinkedList;\n  let list2CurrentNode: BinaryTree | null = tree2LeafNodesLinkedList;\n  while (list1CurrentNode !== null && list2CurrentNode !== null) {\n    if (list1CurrentNode.value !== list2CurrentNode.value) return false;\n\n    list1CurrentNode = list1CurrentNode.right;\n    list2CurrentNode = list2CurrentNode.right;\n  }\n\n  return list1CurrentNode === null && list2CurrentNode === null;\n}\n\nfunction connectLeafNodes(\n  currentNode: BinaryTree | null,\n  head: BinaryTree | null = null,\n  previousNode: BinaryTree | null = null,\n): [BinaryTree | null, BinaryTree | null] {\n  if (currentNode === null) return [head, previousNode];\n\n  if (isLeafNode(currentNode)) {\n    if (previousNode === null) {\n      head = currentNode;\n    } else {\n      previousNode.right = currentNode;\n    }\n\n    previousNode = currentNode;\n  }\n\n  const [leftHead, leftPreviousNode] = connectLeafNodes(currentNode.left, head, previousNode);\n  return connectLeafNodes(currentNode.right, leftHead, leftPreviousNode);\n}\n\nfunction isLeafNode(node: BinaryTree) {\n  return node.left === null && node.right === null;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const tree1 = new program.BinaryTree(1);\n  tree1.left = new program.BinaryTree(2);\n  tree1.right = new program.BinaryTree(3);\n  tree1.left.left = new program.BinaryTree(4);\n  tree1.left.right = new program.BinaryTree(5);\n  tree1.right.right = new program.BinaryTree(6);\n  tree1.left.right.left = new program.BinaryTree(7);\n  tree1.left.right.right = new program.BinaryTree(8);\n\n  const tree2 = new program.BinaryTree(1);\n  tree2.left = new program.BinaryTree(2);\n  tree2.right = new program.BinaryTree(3);\n  tree2.left.left = new program.BinaryTree(4);\n  tree2.left.right = new program.BinaryTree(7);\n  tree2.right.right = new program.BinaryTree(5);\n  tree2.right.right.left = new program.BinaryTree(8);\n  tree2.right.right.right = new program.BinaryTree(6);\n\n  const expected = true;\n  const actual = program.compareLeafTraversal(tree1, tree2);\n\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const tree1 = new program.BinaryTree(1);\n  tree1.left = new program.BinaryTree(2);\n  tree1.right = new program.BinaryTree(3);\n  tree1.left.left = new program.BinaryTree(4);\n  tree1.left.right = new program.BinaryTree(5);\n  tree1.right.right = new program.BinaryTree(6);\n  tree1.left.right.left = new program.BinaryTree(7);\n  tree1.left.right.right = new program.BinaryTree(8);\n\n  const tree2 = new program.BinaryTree(1);\n  tree2.left = new program.BinaryTree(2);\n  tree2.right = new program.BinaryTree(3);\n  tree2.left.left = new program.BinaryTree(4);\n  tree2.left.right = new program.BinaryTree(7);\n  tree2.right.right = new program.BinaryTree(5);\n  tree2.right.right.left = new program.BinaryTree(8);\n  tree2.right.right.right = new program.BinaryTree(6);\n\n  const expected = true;\n  const actual = program.compareLeafTraversal(tree1, tree2);\n\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "tree1",
      "example": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "6",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "7",
            "right": "8",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "schema": {
        "description": "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "left": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "right": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "left",
                "right"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "root": {
            "type": "string"
          }
        },
        "required": [
          "root",
          "nodes"
        ],
        "type": "object"
      }
    },
    {
      "name": "tree2",
      "example": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "7",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "5",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "8",
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "schema": {
        "description": "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "left": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "right": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "left",
                "right"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "root": {
            "type": "string"
          }
        },
        "required": [
          "root",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "6",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "7",
            "right": "8",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "7",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "5",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "8",
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": "5",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "6",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "7",
            "right": "8",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "7",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "5",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "8",
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "9",
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "2"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "2",
            "left": null,
            "right": "1",
            "value": 2
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "2"
      },
      "tree2": {
        "nodes": [
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "1",
            "left": "2",
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "5",
            "value": 3
          },
          {
            "id": "4",
            "left": "7",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "8",
            "right": "9",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": "6",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "6",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "8",
            "right": "9",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": "7",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "8",
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": "9",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": "5",
            "right": "6",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "7",
            "right": "9",
            "value": 6
          },
          {
            "id": "7",
            "left": "8",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "8",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "right": "6",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "7",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "8",
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": "5",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": "7",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "8",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "6",
            "right": "7",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "8",
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": "5",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": "7",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "8",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "right": "6",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "7",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "7",
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": "6",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": "5",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "8",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "right": "6",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "7",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": "1-2",
            "value": 8
          },
          {
            "id": "1-2",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "7",
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": "6",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": "5",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": "1-2",
            "value": 8
          },
          {
            "id": "1-2",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    }
  ],
  "jsonTests": [
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "6",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "7",
            "right": "8",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "7",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "5",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "8",
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": "5",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "6",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "7",
            "right": "8",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "7",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "5",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "8",
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "9",
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "2"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "2",
            "left": null,
            "right": "1",
            "value": 2
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "2"
      },
      "tree2": {
        "nodes": [
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "1",
            "left": "2",
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "5",
            "value": 3
          },
          {
            "id": "4",
            "left": "7",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "8",
            "right": "9",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": "6",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "6",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "8",
            "right": "9",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": "7",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "8",
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": "9",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": "5",
            "right": "6",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "7",
            "right": "9",
            "value": 6
          },
          {
            "id": "7",
            "left": "8",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "8",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "right": "6",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "7",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "8",
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": "5",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": "7",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "8",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "6",
            "right": "7",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "8",
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": "5",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": "7",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "8",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "right": "6",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "7",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "7",
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": "6",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": "5",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree1": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "8",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "right": "6",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "7",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": "1-2",
            "value": 8
          },
          {
            "id": "1-2",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      },
      "tree2": {
        "nodes": [
          {
            "id": "1",
            "left": "7",
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": "6",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": "5",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": "1-2",
            "value": 8
          },
          {
            "id": "1-2",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    }
  ],
  "changelog": []
}