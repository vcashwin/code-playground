{
  "uid": "depth-first-search",
  "testStrategy": "JSON",
  "name": "Depth-first Search",
  "version": 0,
  "releaseDate": "2000-05-04T00:00:00Z",
  "category": "Graphs",
  "difficulty": 1,
  "acl": {
    "isFree": false,
    "isFreeForStudents": true,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 73185,
    "failureCount": 19945
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "226842577",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 719
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given a <span>Node</span> class that has a <span>name</span> and an\n  array of optional <span>children</span> nodes. When put together, nodes form\n  an acyclic tree-like structure.\n</p>\n<p>\n  Implement the <span>depthFirstSearch</span> method on the\n  <span>Node</span> class, which takes in an empty array, traverses the tree\n  using the Depth-first Search approach (specifically navigating the tree from\n  left to right), stores all of the nodes' names in the input array, and returns\n  it.\n</p>\n<p>\n  If you're unfamiliar with Depth-first Search, we recommend watching the\n  Conceptual Overview section of this question's video explanation before\n  starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">graph</span> = A\n     /  |  \\\n    B   C   D\n   / \\     / \\\n  E   F   G   H\n     / \\   \\\n    I   J   K\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[\"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\"]\n</pre>\n</div>",
  "hints": [
    "<p>\nThe Depth-first Search algorithm works by traversing a graph branch by branch. In other words, before traversing any Node's sibling Nodes, its children nodes must be traversed. How can you simply and effectively keep track of Nodes' sibling Nodes as you traverse them, all the while retaining the order in which you must traverse them?\n</p>\n",
    "\n<p>\nStart at the root Node and try simply calling the depthFirstSearch method on all of its children Nodes. Then, call the depthFirstSearch method on all children Nodes of each child node. Keep applying this logic until the entire graph has been traversed. Don't forget to add the current Node's name to the input array at every call of depthFirstSearch.\n</p>"
  ],
  "spaceTime": "O(v + e) time | O(v) space - where v is the number of vertices of the input graph and e is the number of edges of the input graph",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\n// Do not edit the class below except\n// for the depthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\nclass Node {\n public:\n  string name;\n  vector<Node*> children;\n\n  Node(string str) { name = str; }\n\n  vector<string> depthFirstSearch(vector<string>* array) {\n    // Write your code here.\n    return {};\n  }\n\n  Node* addChild(string name) {\n    Node* child = new Node(name);\n    children.push_back(child);\n    return this;\n  }\n};\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nclass Node {\n public:\n  string name;\n  vector<Node*> children;\n\n  Node(string name) { this->name = name; }\n\n  // O(v + e) time | O(v) space\n  vector<string> depthFirstSearch(vector<string>* array) {\n    array->push_back(this->name);\n    for (int i = 0; i < this->children.size(); i++) {\n      children[i]->depthFirstSearch(array);\n    }\n    return *array;\n  }\n\n  Node* addChild(string name) {\n    Node* child = new Node(name);\n    children.push_back(child);\n    return this;\n  }\n};\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      Node graph(\"A\");\n      graph.addChild(\"B\")->addChild(\"C\")->addChild(\"D\");\n      graph.children[0]->addChild(\"E\")->addChild(\"F\");\n      graph.children[2]->addChild(\"G\")->addChild(\"H\");\n      graph.children[0]->children[1]->addChild(\"I\")->addChild(\"J\");\n      graph.children[2]->children[0]->addChild(\"K\");\n\n      vector<string> expected{\n        \"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\"};\n      vector<string> inputArray{};\n      assert(graph.depthFirstSearch(&inputArray) == expected);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      Node graph(\"A\");\n      graph.addChild(\"B\")->addChild(\"C\")->addChild(\"D\");\n      graph.children[0]->addChild(\"E\")->addChild(\"F\");\n      graph.children[2]->addChild(\"G\")->addChild(\"H\");\n      graph.children[0]->children[1]->addChild(\"I\")->addChild(\"J\");\n      graph.children[2]->children[0]->addChild(\"K\");\n\n      vector<string> expected{\n        \"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\"};\n      vector<string> inputArray{};\n      assert(graph.depthFirstSearch(&inputArray) == expected);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n  // Do not edit the class below except\n  // for the DepthFirstSearch method.\n  // Feel free to add new properties\n  // and methods to the class.\n  public class Node {\n    public string name;\n    public List<Node> children = new List<Node>();\n\n    public Node(string name) {\n      this.name = name;\n    }\n\n    public List<string> DepthFirstSearch(List<string> array) {\n      // Write your code here.\n      return array;\n    }\n\n    public Node AddChild(string name) {\n      Node child = new Node(name);\n      children.Add(child);\n      return this;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  public class Node {\n    public string name;\n    public List<Node> children = new List<Node>();\n\n    public Node(string name) {\n      this.name = name;\n    }\n\n    // O(v + e) time | O(v) space\n    public List<string> DepthFirstSearch(List<string> array) {\n      array.Add(this.name);\n      for (int i = 0; i < children.Count; i++) {\n        children[i].DepthFirstSearch(array);\n      }\n      return array;\n    }\n\n    public Node AddChild(string name) {\n      Node child = new Node(name);\n      children.Add(child);\n      return this;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.Node graph = new Program.Node(\"A\");\n    graph.AddChild(\"B\").AddChild(\"C\").AddChild(\"D\");\n    graph.children[0].AddChild(\"E\").AddChild(\"F\");\n    graph.children[2].AddChild(\"G\").AddChild(\"H\");\n    graph.children[0].children[1].AddChild(\"I\").AddChild(\"J\");\n    graph.children[2].children[0].AddChild(\"K\");\n    string[] expected = {\n      \"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\"\n    };\n    List<string> inputArray = new List<string>();\n    Utils.AssertTrue(compare(graph.DepthFirstSearch(inputArray), expected));\n  }\n\n  public static bool compare(List<string> arr1, string[] arr2) {\n    if (arr1.Count != arr2.Length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.Count; i++) {\n      if (!arr1[i].Equals(arr2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.Node graph = new Program.Node(\"A\");\n    graph.AddChild(\"B\").AddChild(\"C\").AddChild(\"D\");\n    graph.children[0].AddChild(\"E\").AddChild(\"F\");\n    graph.children[2].AddChild(\"G\").AddChild(\"H\");\n    graph.children[0].children[1].AddChild(\"I\").AddChild(\"J\");\n    graph.children[2].children[0].AddChild(\"K\");\n    string[] expected = {\n      \"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\"\n    };\n    List<string> inputArray = new List<string>();\n    Utils.AssertTrue(compare(graph.DepthFirstSearch(inputArray), expected));\n  }\n\n  public static bool compare(List<string> arr1, string[] arr2) {\n    if (arr1.Count != arr2.Length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.Count; i++) {\n      if (!arr1[i].Equals(arr2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// Do not edit the class below except\n// for the depthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\ntype Node struct {\n\tName     string\n\tChildren []*Node\n}\n\nfunc (n *Node) DepthFirstSearch(array []string) []string {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// Do not edit the class below except\n// for the depthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\ntype Node struct {\n\tName     string\n\tChildren []*Node\n}\n\n// O(v + e) time | O(v) space\nfunc (n *Node) DepthFirstSearch(array []string) []string {\n\tarray = append(array, n.Name)\n\tfor _, child := range n.Children {\n\t\tarray = child.DepthFirstSearch(array)\n\t}\n\treturn array\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc NewNode(name string) *Node {\n\treturn &Node{\n\t\tName:     name,\n\t\tChildren: []*Node{},\n\t}\n}\n\nfunc (n *Node) AddChildren(names ...string) *Node {\n\tfor _, name := range names {\n\t\tchild := Node{Name: name}\n\t\tn.Children = append(n.Children, &child)\n\t}\n\treturn n\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tvar graph = NewNode(\"A\").AddChildren(\"B\", \"C\", \"D\")\n\tgraph.Children[0].AddChildren(\"E\").AddChildren(\"F\")\n\tgraph.Children[2].AddChildren(\"G\").AddChildren(\"H\")\n\tgraph.Children[0].Children[1].AddChildren(\"I\").AddChildren(\"J\")\n\tgraph.Children[2].Children[0].AddChildren(\"K\")\n\toutput := graph.DepthFirstSearch([]string{})\n\texpected := []string{\"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\"}\n\trequire.Equal(t, expected, output)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc NewNode(name string) *Node {\n\treturn &Node{\n\t\tName:     name,\n\t\tChildren: []*Node{},\n\t}\n}\n\nfunc (n *Node) AddChildren(names ...string) *Node {\n\tfor _, name := range names {\n\t\tchild := Node{Name: name}\n\t\tn.Children = append(n.Children, &child)\n\t}\n\treturn n\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tvar graph = NewNode(\"A\").AddChildren(\"B\", \"C\", \"D\")\n\tgraph.Children[0].AddChildren(\"E\").AddChildren(\"F\")\n\tgraph.Children[2].AddChildren(\"G\").AddChildren(\"H\")\n\tgraph.Children[0].Children[1].AddChildren(\"I\").AddChildren(\"J\")\n\tgraph.Children[2].Children[0].AddChildren(\"K\")\n\toutput := graph.DepthFirstSearch([]string{})\n\texpected := []string{\"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\"}\n\trequire.Equal(t, expected, output)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // Do not edit the class below except\n  // for the depthFirstSearch method.\n  // Feel free to add new properties\n  // and methods to the class.\n  static class Node {\n    String name;\n    List<Node> children = new ArrayList<Node>();\n\n    public Node(String name) {\n      this.name = name;\n    }\n\n    public List<String> depthFirstSearch(List<String> array) {\n      // Write your code here.\n      return array;\n    }\n\n    public Node addChild(String name) {\n      Node child = new Node(name);\n      children.add(child);\n      return this;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  static class Node {\n    String name;\n    List<Node> children = new ArrayList<Node>();\n\n    public Node(String name) {\n      this.name = name;\n    }\n\n    // O(v + e) time | O(v) space\n    public List<String> depthFirstSearch(List<String> array) {\n      array.add(this.name);\n      for (int i = 0; i < children.size(); i++) {\n        children.get(i).depthFirstSearch(array);\n      }\n      return array;\n    }\n\n    public Node addChild(String name) {\n      Node child = new Node(name);\n      children.add(child);\n      return this;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.Node graph = new Program.Node(\"A\");\n    graph.addChild(\"B\").addChild(\"C\").addChild(\"D\");\n    graph.children.get(0).addChild(\"E\").addChild(\"F\");\n    graph.children.get(2).addChild(\"G\").addChild(\"H\");\n    graph.children.get(0).children.get(1).addChild(\"I\").addChild(\"J\");\n    graph.children.get(2).children.get(0).addChild(\"K\");\n    String[] expected = {\"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\"};\n    List<String> inputArray = new ArrayList<String>();\n    Utils.assertTrue(compare(graph.depthFirstSearch(inputArray), expected));\n  }\n\n  public static boolean compare(List<String> arr1, String[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (!arr1.get(i).equals(arr2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.Node graph = new Program.Node(\"A\");\n    graph.addChild(\"B\").addChild(\"C\").addChild(\"D\");\n    graph.children.get(0).addChild(\"E\").addChild(\"F\");\n    graph.children.get(2).addChild(\"G\").addChild(\"H\");\n    graph.children.get(0).children.get(1).addChild(\"I\").addChild(\"J\");\n    graph.children.get(2).children.get(0).addChild(\"K\");\n    String[] expected = {\"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\"};\n    List<String> inputArray = new ArrayList<String>();\n    Utils.assertTrue(compare(graph.depthFirstSearch(inputArray), expected));\n  }\n\n  public static boolean compare(List<String> arr1, String[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (!arr1.get(i).equals(arr2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// Do not edit the class below except\n// for the depthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\nclass Node {\n  constructor(name) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name) {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  depthFirstSearch(array) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.Node = Node;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Node {\n  constructor(name) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name) {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  // O(v + e) time | O(v) space\n  depthFirstSearch(array) {\n    array.push(this.name);\n    for (const child of this.children) {\n      child.depthFirstSearch(array);\n    }\n    return array;\n  }\n}\n\nexports.Node = Node;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai\n    .expect(graph.depthFirstSearch([]))\n    .to.deep.equal(['A', 'B', 'E', 'F', 'I', 'J', 'C', 'D', 'G', 'K', 'H']);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai\n    .expect(graph.depthFirstSearch([]))\n    .to.deep.equal(['A', 'B', 'E', 'F', 'I', 'J', 'C', 'D', 'G', 'K', 'H']);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nclass Node(name: String) {\n    val name: String = name\n    val children = mutableListOf<Node>()\n\n    fun depthFirstSearch(): List<String> {\n        // Write your code here.\n        return listOf()\n    }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nclass Node(name: String) {\n    val name: String = name\n    val children = mutableListOf<Node>()\n\n    // O(v + e) time | O(v) space\n    fun depthFirstSearch(): List<String> {\n        return depthFirstSearch(mutableListOf())\n    }\n\n    fun depthFirstSearch(array: MutableList<String>): List<String> {\n        array.add(this.name)\n        for (child in this.children) {\n            child.depthFirstSearch(array)\n        }\n        return array\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.Node\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val i = Node(\"I\")\n        val j = Node(\"J\")\n        val k = Node(\"K\")\n\n        val e = Node(\"E\")\n        val f = Node(\"F\")\n        f.children.addAll(listOf(i, j))\n\n        val g = Node(\"G\")\n        g.children.add(k)\n\n        val h = Node(\"H\")\n\n        val b = Node(\"B\")\n        b.children.add(e)\n        b.children.add(f)\n\n        val c = Node(\"C\")\n\n        val d = Node(\"D\")\n        d.children.add(g)\n        d.children.add(h)\n\n        val graph = Node(\"A\")\n        graph.children.add(b)\n        graph.children.add(c)\n        graph.children.add(d)\n\n        val expected = listOf(\"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\")\n        val output = graph.depthFirstSearch()\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.Node\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val i = Node(\"I\")\n        val j = Node(\"J\")\n        val k = Node(\"K\")\n\n        val e = Node(\"E\")\n        val f = Node(\"F\")\n        f.children.addAll(listOf(i, j))\n\n        val g = Node(\"G\")\n        g.children.add(k)\n\n        val h = Node(\"H\")\n\n        val b = Node(\"B\")\n        b.children.add(e)\n        b.children.add(f)\n\n        val c = Node(\"C\")\n\n        val d = Node(\"D\")\n        d.children.add(g)\n        d.children.add(h)\n\n        val graph = Node(\"A\")\n        graph.children.add(b)\n        graph.children.add(c)\n        graph.children.add(d)\n\n        val expected = listOf(\"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\")\n        val output = graph.depthFirstSearch()\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# Do not edit the class below except\n# for the depthFirstSearch method.\n# Feel free to add new properties\n# and methods to the class.\nclass Node:\n    def __init__(self, name):\n        self.children = []\n        self.name = name\n\n    def addChild(self, name):\n        self.children.append(Node(name))\n        return self\n\n    def depthFirstSearch(self, array):\n        # Write your code here.\n        pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Node:\n    def __init__(self, name):\n        self.children = []\n        self.name = name\n\n    def addChild(self, name):\n        self.children.append(Node(name))\n        return self\n\n    # O(v + e) time | O(v) space\n    def depthFirstSearch(self, array):\n        array.append(self.name)\n        for child in self.children:\n            child.depthFirstSearch(array)\n        return array\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        graph = program.Node(\"A\")\n        graph.addChild(\"B\").addChild(\"C\").addChild(\"D\")\n        graph.children[0].addChild(\"E\").addChild(\"F\")\n        graph.children[2].addChild(\"G\").addChild(\"H\")\n        graph.children[0].children[1].addChild(\"I\").addChild(\"J\")\n        graph.children[2].children[0].addChild(\"K\")\n        self.assertEqual(\n            graph.depthFirstSearch([]), [\"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\"]\n        )\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        graph = program.Node(\"A\")\n        graph.addChild(\"B\").addChild(\"C\").addChild(\"D\")\n        graph.children[0].addChild(\"E\").addChild(\"F\")\n        graph.children[2].addChild(\"G\").addChild(\"H\")\n        graph.children[0].children[1].addChild(\"I\").addChild(\"J\")\n        graph.children[2].children[0].addChild(\"K\")\n        self.assertEqual(\n            graph.depthFirstSearch([]), [\"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\"]\n        )\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  class Node {\n    let name: String\n    var children: [Node]\n\n    init(name: String) {\n      self.name = name\n      children = []\n    }\n\n    func addChild(name: String) -> Node {\n      let childNode = Node(name: name)\n      children.append(childNode)\n\n      return self\n    }\n\n    func depthFirstSearch(array: inout [String]) -> [String] {\n      // Write your code here.\n      return []\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class Node {\n    let name: String\n    var children: [Node]\n\n    init(name: String) {\n      self.name = name\n      children = []\n    }\n\n    func addChild(name: String) -> Node {\n      let childNode = Node(name: name)\n      children.append(childNode)\n\n      return self\n    }\n\n    // O(v + e) time | O(v) space\n    func depthFirstSearch(array: inout [String]) -> [String] {\n      array.append(name)\n\n      for child in children {\n        child.depthFirstSearch(array: &array)\n      }\n\n      return array\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws in\n      let graph = Program.Node(name: \"A\")\n      graph.addChild(name: \"B\").addChild(name: \"C\").addChild(name: \"D\")\n      graph.children[0].addChild(name: \"E\").addChild(name: \"F\")\n      graph.children[2].addChild(name: \"G\").addChild(name: \"H\")\n      graph.children[0].children[1].addChild(name: \"I\").addChild(name: \"J\")\n      graph.children[2].children[0].addChild(name: \"K\")\n\n      var arrayToReturn = [String]()\n      try assertEqual([\"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\"], graph.depthFirstSearch(array: &arrayToReturn))\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws in\n      let graph = Program.Node(name: \"A\")\n      graph.addChild(name: \"B\").addChild(name: \"C\").addChild(name: \"D\")\n      graph.children[0].addChild(name: \"E\").addChild(name: \"F\")\n      graph.children[2].addChild(name: \"G\").addChild(name: \"H\")\n      graph.children[0].children[1].addChild(name: \"I\").addChild(name: \"J\")\n      graph.children[2].children[0].addChild(name: \"K\")\n\n      var arrayToReturn = [String]()\n      try assertEqual([\"A\", \"B\", \"E\", \"F\", \"I\", \"J\", \"C\", \"D\", \"G\", \"K\", \"H\"], graph.depthFirstSearch(array: &arrayToReturn))\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// Do not edit the class below except\n// for the depthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\nexport class Node {\n  name: string;\n  children: Node[];\n\n  constructor(name: string) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name: string) {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  depthFirstSearch(array: string[]) {\n    // Write your code here.\n    return array;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nexport class Node {\n  name: string;\n  children: Node[];\n\n  constructor(name: string) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name: string) {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  // O(v + e) time | O(v) space\n  depthFirstSearch(array: string[]) {\n    array.push(this.name);\n    for (const child of this.children) {\n      child.depthFirstSearch(array);\n    }\n    return array;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai\n    .expect(graph.depthFirstSearch([]))\n    .to.deep.equal(['A', 'B', 'E', 'F', 'I', 'J', 'C', 'D', 'G', 'K', 'H']);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai\n    .expect(graph.depthFirstSearch([]))\n    .to.deep.equal(['A', 'B', 'E', 'F', 'I', 'J', 'C', 'D', 'G', 'K', 'H']);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "graph",
      "example": {
        "nodes": [
          {
            "children": [
              "B",
              "C",
              "D"
            ],
            "id": "A",
            "value": "A"
          },
          {
            "children": [
              "E",
              "F"
            ],
            "id": "B",
            "value": "B"
          },
          {
            "children": [],
            "id": "C",
            "value": "C"
          },
          {
            "children": [
              "G",
              "H"
            ],
            "id": "D",
            "value": "D"
          },
          {
            "children": [],
            "id": "E",
            "value": "E"
          },
          {
            "children": [
              "I",
              "J"
            ],
            "id": "F",
            "value": "F"
          },
          {
            "children": [
              "K"
            ],
            "id": "G",
            "value": "G"
          },
          {
            "children": [],
            "id": "H",
            "value": "H"
          },
          {
            "children": [],
            "id": "I",
            "value": "I"
          },
          {
            "children": [],
            "id": "J",
            "value": "J"
          },
          {
            "children": [],
            "id": "K",
            "value": "K"
          }
        ],
        "startNode": "A"
      },
      "schema": {
        "description": "For the purpose of this question, a <span>graph</span> is represented by a list of <span>nodes</span> and a <span>startNode</span> node.\nEvery node has to have a unique string <span>id</span> that will be referenced by other nodes' lists of <span>children</span> and by the <span>startNode</span>.\nThe searching function will be called on the <span>startNode</span>.<br />\nRemember that your graph shouldn't have cycles!\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "children": {
                  "items": {
                    "type": "string"
                  },
                  "type": "array",
                  "uniqueItems": true
                },
                "id": {
                  "type": "string"
                },
                "value": {
                  "type": "string"
                }
              },
              "required": [
                "id",
                "value",
                "children"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "startNode": {
            "type": "string"
          }
        },
        "required": [
          "startNode",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "graph": {
        "nodes": [
          {
            "children": [
              "B",
              "C",
              "D"
            ],
            "id": "A",
            "value": "A"
          },
          {
            "children": [
              "E",
              "F"
            ],
            "id": "B",
            "value": "B"
          },
          {
            "children": [],
            "id": "C",
            "value": "C"
          },
          {
            "children": [
              "G",
              "H"
            ],
            "id": "D",
            "value": "D"
          },
          {
            "children": [],
            "id": "E",
            "value": "E"
          },
          {
            "children": [
              "I",
              "J"
            ],
            "id": "F",
            "value": "F"
          },
          {
            "children": [
              "K"
            ],
            "id": "G",
            "value": "G"
          },
          {
            "children": [],
            "id": "H",
            "value": "H"
          },
          {
            "children": [],
            "id": "I",
            "value": "I"
          },
          {
            "children": [],
            "id": "J",
            "value": "J"
          },
          {
            "children": [],
            "id": "K",
            "value": "K"
          }
        ],
        "startNode": "A"
      }
    },
    {
      "graph": {
        "nodes": [
          {
            "children": [
              "B",
              "C"
            ],
            "id": "A",
            "value": "A"
          },
          {
            "children": [
              "D"
            ],
            "id": "B",
            "value": "B"
          },
          {
            "children": [],
            "id": "C",
            "value": "C"
          },
          {
            "children": [],
            "id": "D",
            "value": "D"
          }
        ],
        "startNode": "A"
      }
    },
    {
      "graph": {
        "nodes": [
          {
            "children": [
              "B",
              "C",
              "D",
              "E"
            ],
            "id": "A",
            "value": "A"
          },
          {
            "children": [],
            "id": "B",
            "value": "B"
          },
          {
            "children": [
              "F"
            ],
            "id": "C",
            "value": "C"
          },
          {
            "children": [],
            "id": "D",
            "value": "D"
          },
          {
            "children": [],
            "id": "E",
            "value": "E"
          },
          {
            "children": [],
            "id": "F",
            "value": "F"
          }
        ],
        "startNode": "A"
      }
    },
    {
      "graph": {
        "nodes": [
          {
            "children": [
              "B"
            ],
            "id": "A",
            "value": "A"
          },
          {
            "children": [
              "C"
            ],
            "id": "B",
            "value": "B"
          },
          {
            "children": [
              "D",
              "E"
            ],
            "id": "C",
            "value": "C"
          },
          {
            "children": [
              "F"
            ],
            "id": "D",
            "value": "D"
          },
          {
            "children": [],
            "id": "E",
            "value": "E"
          },
          {
            "children": [],
            "id": "F",
            "value": "F"
          }
        ],
        "startNode": "A"
      }
    },
    {
      "graph": {
        "nodes": [
          {
            "children": [
              "B",
              "C",
              "D",
              "E",
              "F"
            ],
            "id": "A",
            "value": "A"
          },
          {
            "children": [
              "G",
              "H",
              "I"
            ],
            "id": "B",
            "value": "B"
          },
          {
            "children": [
              "J"
            ],
            "id": "C",
            "value": "C"
          },
          {
            "children": [
              "K",
              "L"
            ],
            "id": "D",
            "value": "D"
          },
          {
            "children": [],
            "id": "E",
            "value": "E"
          },
          {
            "children": [
              "M",
              "N"
            ],
            "id": "F",
            "value": "F"
          },
          {
            "children": [],
            "id": "G",
            "value": "G"
          },
          {
            "children": [
              "O",
              "P",
              "Q",
              "R"
            ],
            "id": "H",
            "value": "H"
          },
          {
            "children": [],
            "id": "I",
            "value": "I"
          },
          {
            "children": [],
            "id": "J",
            "value": "J"
          },
          {
            "children": [
              "S"
            ],
            "id": "K",
            "value": "K"
          },
          {
            "children": [],
            "id": "L",
            "value": "L"
          },
          {
            "children": [],
            "id": "M",
            "value": "M"
          },
          {
            "children": [],
            "id": "N",
            "value": "N"
          },
          {
            "children": [],
            "id": "O",
            "value": "O"
          },
          {
            "children": [
              "T",
              "U"
            ],
            "id": "P",
            "value": "P"
          },
          {
            "children": [],
            "id": "Q",
            "value": "Q"
          },
          {
            "children": [
              "V"
            ],
            "id": "R",
            "value": "R"
          },
          {
            "children": [],
            "id": "S",
            "value": "S"
          },
          {
            "children": [],
            "id": "T",
            "value": "T"
          },
          {
            "children": [],
            "id": "U",
            "value": "U"
          },
          {
            "children": [
              "W",
              "X",
              "Y"
            ],
            "id": "V",
            "value": "V"
          },
          {
            "children": [],
            "id": "W",
            "value": "W"
          },
          {
            "children": [
              "Z"
            ],
            "id": "X",
            "value": "X"
          },
          {
            "children": [],
            "id": "Y",
            "value": "Y"
          },
          {
            "children": [],
            "id": "Z",
            "value": "Z"
          }
        ],
        "startNode": "A"
      }
    }
  ],
  "jsonTests": [
    {
      "graph": {
        "nodes": [
          {
            "children": [
              "B",
              "C",
              "D"
            ],
            "id": "A",
            "value": "A"
          },
          {
            "children": [
              "E",
              "F"
            ],
            "id": "B",
            "value": "B"
          },
          {
            "children": [],
            "id": "C",
            "value": "C"
          },
          {
            "children": [
              "G",
              "H"
            ],
            "id": "D",
            "value": "D"
          },
          {
            "children": [],
            "id": "E",
            "value": "E"
          },
          {
            "children": [
              "I",
              "J"
            ],
            "id": "F",
            "value": "F"
          },
          {
            "children": [
              "K"
            ],
            "id": "G",
            "value": "G"
          },
          {
            "children": [],
            "id": "H",
            "value": "H"
          },
          {
            "children": [],
            "id": "I",
            "value": "I"
          },
          {
            "children": [],
            "id": "J",
            "value": "J"
          },
          {
            "children": [],
            "id": "K",
            "value": "K"
          }
        ],
        "startNode": "A"
      }
    },
    {
      "graph": {
        "nodes": [
          {
            "children": [
              "B",
              "C"
            ],
            "id": "A",
            "value": "A"
          },
          {
            "children": [
              "D"
            ],
            "id": "B",
            "value": "B"
          },
          {
            "children": [],
            "id": "C",
            "value": "C"
          },
          {
            "children": [],
            "id": "D",
            "value": "D"
          }
        ],
        "startNode": "A"
      }
    },
    {
      "graph": {
        "nodes": [
          {
            "children": [
              "B",
              "C",
              "D",
              "E"
            ],
            "id": "A",
            "value": "A"
          },
          {
            "children": [],
            "id": "B",
            "value": "B"
          },
          {
            "children": [
              "F"
            ],
            "id": "C",
            "value": "C"
          },
          {
            "children": [],
            "id": "D",
            "value": "D"
          },
          {
            "children": [],
            "id": "E",
            "value": "E"
          },
          {
            "children": [],
            "id": "F",
            "value": "F"
          }
        ],
        "startNode": "A"
      }
    },
    {
      "graph": {
        "nodes": [
          {
            "children": [
              "B"
            ],
            "id": "A",
            "value": "A"
          },
          {
            "children": [
              "C"
            ],
            "id": "B",
            "value": "B"
          },
          {
            "children": [
              "D",
              "E"
            ],
            "id": "C",
            "value": "C"
          },
          {
            "children": [
              "F"
            ],
            "id": "D",
            "value": "D"
          },
          {
            "children": [],
            "id": "E",
            "value": "E"
          },
          {
            "children": [],
            "id": "F",
            "value": "F"
          }
        ],
        "startNode": "A"
      }
    },
    {
      "graph": {
        "nodes": [
          {
            "children": [
              "B",
              "C",
              "D",
              "E",
              "F"
            ],
            "id": "A",
            "value": "A"
          },
          {
            "children": [
              "G",
              "H",
              "I"
            ],
            "id": "B",
            "value": "B"
          },
          {
            "children": [
              "J"
            ],
            "id": "C",
            "value": "C"
          },
          {
            "children": [
              "K",
              "L"
            ],
            "id": "D",
            "value": "D"
          },
          {
            "children": [],
            "id": "E",
            "value": "E"
          },
          {
            "children": [
              "M",
              "N"
            ],
            "id": "F",
            "value": "F"
          },
          {
            "children": [],
            "id": "G",
            "value": "G"
          },
          {
            "children": [
              "O",
              "P",
              "Q",
              "R"
            ],
            "id": "H",
            "value": "H"
          },
          {
            "children": [],
            "id": "I",
            "value": "I"
          },
          {
            "children": [],
            "id": "J",
            "value": "J"
          },
          {
            "children": [
              "S"
            ],
            "id": "K",
            "value": "K"
          },
          {
            "children": [],
            "id": "L",
            "value": "L"
          },
          {
            "children": [],
            "id": "M",
            "value": "M"
          },
          {
            "children": [],
            "id": "N",
            "value": "N"
          },
          {
            "children": [],
            "id": "O",
            "value": "O"
          },
          {
            "children": [
              "T",
              "U"
            ],
            "id": "P",
            "value": "P"
          },
          {
            "children": [],
            "id": "Q",
            "value": "Q"
          },
          {
            "children": [
              "V"
            ],
            "id": "R",
            "value": "R"
          },
          {
            "children": [],
            "id": "S",
            "value": "S"
          },
          {
            "children": [],
            "id": "T",
            "value": "T"
          },
          {
            "children": [],
            "id": "U",
            "value": "U"
          },
          {
            "children": [
              "W",
              "X",
              "Y"
            ],
            "id": "V",
            "value": "V"
          },
          {
            "children": [],
            "id": "W",
            "value": "W"
          },
          {
            "children": [
              "Z"
            ],
            "id": "X",
            "value": "X"
          },
          {
            "children": [],
            "id": "Y",
            "value": "Y"
          },
          {
            "children": [],
            "id": "Z",
            "value": "Z"
          }
        ],
        "startNode": "A"
      }
    }
  ],
  "changelog": []
}