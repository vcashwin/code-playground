{
  "uid": "find-kth-largest-value-in-bst",
  "testStrategy": "JSON",
  "name": "Find Kth Largest Value In BST",
  "version": 0,
  "releaseDate": "2021-02-20T00:00:00Z",
  "category": "Binary Search Trees",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 29131,
    "failureCount": 6912
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "511011155",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 1246
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in a Binary Search Tree (BST) and a positive\n  integer <span>k</span> and returns the kth largest integer contained in the\n  BST.\n</p>\n<p>\n  You can assume that there will only be integer values in the BST and that\n  <span>k</span> is less than or equal to the number of nodes in the tree.\n</p>\n<p>\n  Also, for the purpose of this question, duplicate integers will be treated as\n  distinct values. In other words, the second largest value in a BST containing\n  values <span>{5, 7, 7}</span> will be <span>7</span>—not <span>5</span>.\n</p>\n<p>\n  Each <span>BST</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. A node is\n  said to be a valid <span>BST</span> node if and only if it satisfies the BST\n  property: its <span>value</span> is strictly greater than the values of every\n  node to its left; its <span>value</span> is less than or equal to the values\n  of every node to its right; and its children nodes are either valid\n  <span>BST</span> nodes themselves or <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">tree</span> =   15\n       /     \\\n      5      20\n    /   \\   /   \\\n   2     5 17   22\n /   \\         \n1     3       \n<span class=\"CodeEditor-promptParameter\">k</span> = 3\n</pre>\n<h3>Sample Output</h3>\n<pre>17</pre>\n</div>",
  "hints": [
    "<p>\n  Make sure to consider the fact that the given tree is a Binary Search Tree—not\n  just a regular Binary Tree. How does this fact help you solve the problem in a\n  more optimal time complexity?\n</p>\n",
    "\n<p>\n  The brute-force approach to this problem is to simply perform an in-order\n  traversal of this BST and to store all of its node' values in the order in\n  which they're visited. Since an in-order traversal of a BST visits the nodes\n  in ascending order, the <span>k</span>th value from the end of the traversal\n  order will be the <span>k</span>th largest value.\n</p>\n",
    "\n<p>\n  You can actually solve this problem in <span>O(h + k)</span> time, where\n  <span>h</span> is the height of the tree. Rather than looking at the nodes in\n  ascending order, you should look at them in descending order.\n</p>\n",
    "\n<p>\n  To solve this problem in <span>O(h + k)</span> time as mentioned in Hint #3,\n  you need to perform a <b>reverse</b> in-order traversal. Since you'll be\n  looking at nodes in descending order, you can simply return the\n  <span>k</span>th visited node in the reverse in-order traversal.\n</p>"
  ],
  "spaceTime": "O(h + k) time | O(h) space - where h is the height of the tree and k is the input parameter",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": "tree",
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is an input class. Do not edit.\nclass BST {\n public:\n  int value;\n  BST* left = nullptr;\n  BST* right = nullptr;\n\n  BST(int value) { this->value = value; }\n};\n\nint findKthLargestValueInBst(BST* tree, int k) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BST {\n public:\n  int value;\n  BST* left = nullptr;\n  BST* right = nullptr;\n\n  BST(int value) { this->value = value; }\n};\n\nvoid inOrderTraverse(BST* node, vector<int>& sortedNodeValues);\n\n// O(n) time | O(n) space - where n is the number of nodes in the tree\nint findKthLargestValueInBst(BST* tree, int k) {\n  vector<int> sortedNodeValues;\n  inOrderTraverse(tree, sortedNodeValues);\n  return sortedNodeValues[sortedNodeValues.size() - k];\n}\n\nvoid inOrderTraverse(BST* node, vector<int>& sortedNodeValues) {\n  if (node == nullptr) return;\n\n  inOrderTraverse(node->left, sortedNodeValues);\n  sortedNodeValues.push_back(node->value);\n  inOrderTraverse(node->right, sortedNodeValues);\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BST {\n public:\n  int value;\n  BST* left = nullptr;\n  BST* right = nullptr;\n\n  BST(int value) { this->value = value; }\n};\n\nstruct TreeInfo {\n  int numberOfNodesVisited;\n  int latestVisitedNodeValue;\n};\n\nvoid reverseInOrderTraverse(BST* node, int k, TreeInfo& treeInfo);\n\n// O(h + k) time | O(h) space - where h is the height of the tree and k is the\n// input parameter\nint findKthLargestValueInBst(BST* tree, int k) {\n  auto treeInfo = TreeInfo{0, -1};\n  reverseInOrderTraverse(tree, k, treeInfo);\n  return treeInfo.latestVisitedNodeValue;\n}\n\nvoid reverseInOrderTraverse(BST* node, int k, TreeInfo& treeInfo) {\n  if (node == nullptr || treeInfo.numberOfNodesVisited >= k) return;\n\n  reverseInOrderTraverse(node->right, k, treeInfo);\n  if (treeInfo.numberOfNodesVisited < k) {\n    treeInfo.numberOfNodesVisited++;\n    treeInfo.latestVisitedNodeValue = node->value;\n    reverseInOrderTraverse(node->left, k, treeInfo);\n  }\n}"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto root = new BST(15);\n      root->left = new BST(5);\n      root->left->left = new BST(2);\n      root->left->left->left = new BST(1);\n      root->left->left->right = new BST(3);\n      root->left->right = new BST(5);\n      root->right = new BST(20);\n      root->right->left = new BST(17);\n      root->right->right = new BST(22);\n      int k = 3;\n      int expected = 17;\n      auto actual = findKthLargestValueInBst(root, k);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto root = new BST(15);\n      root->left = new BST(5);\n      root->left->left = new BST(2);\n      root->left->left->left = new BST(1);\n      root->left->left->right = new BST(3);\n      root->left->right = new BST(5);\n      root->right = new BST(20);\n      root->right->left = new BST(17);\n      root->right->right = new BST(22);\n      int k = 3;\n      int expected = 17;\n      auto actual = findKthLargestValueInBst(root, k);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  public int FindKthLargestValueInBst(BST tree, int k) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n) time | O(n) space - where n is the number of nodes in the tree\n  public int FindKthLargestValueInBst(BST tree, int k) {\n    List<int> sortedNodeValues = new List<int>();\n    inOrderTraverse(tree, sortedNodeValues);\n    return sortedNodeValues[sortedNodeValues.Count - k];\n  }\n\n  public void inOrderTraverse(BST node, List<int> sortedNodeValues) {\n    if (node == null) return;\n\n    inOrderTraverse(node.left, sortedNodeValues);\n    sortedNodeValues.Add(node.value);\n    inOrderTraverse(node.right, sortedNodeValues);\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  public class TreeInfo {\n    public int numberOfNodesVisited;\n    public int latestVisitedNodeValue;\n\n    public TreeInfo(int numberOfNodesVisited, int latestVisitedNodeValue) {\n      this.numberOfNodesVisited = numberOfNodesVisited;\n      this.latestVisitedNodeValue = latestVisitedNodeValue;\n    }\n  }\n\n  // O(h + k) time | O(h) space - where h is the height of the tree and k is the\n  // input parameter\n  public int FindKthLargestValueInBst(BST tree, int k) {\n    TreeInfo treeInfo = new TreeInfo(0, -1);\n    reverseInOrderTraverse(tree, k, treeInfo);\n    return treeInfo.latestVisitedNodeValue;\n  }\n\n  public void reverseInOrderTraverse(BST node, int k, TreeInfo treeInfo) {\n    if (node == null || treeInfo.numberOfNodesVisited >= k) return;\n\n    reverseInOrderTraverse(node.right, k, treeInfo);\n    if (treeInfo.numberOfNodesVisited < k) {\n      treeInfo.numberOfNodesVisited += 1;\n      treeInfo.latestVisitedNodeValue = node.value;\n      reverseInOrderTraverse(node.left, k, treeInfo);\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.BST root = new Program.BST(15);\n    root.left = new Program.BST(5);\n    root.left.left = new Program.BST(2);\n    root.left.left.left = new Program.BST(1);\n    root.left.left.right = new Program.BST(3);\n    root.left.right = new Program.BST(5);\n    root.right = new Program.BST(20);\n    root.right.left = new Program.BST(17);\n    root.right.right = new Program.BST(22);\n    int k = 3;\n    int expected = 17;\n    var actual = new Program().FindKthLargestValueInBst(root, k);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.BST root = new Program.BST(15);\n    root.left = new Program.BST(5);\n    root.left.left = new Program.BST(2);\n    root.left.left.left = new Program.BST(1);\n    root.left.left.right = new Program.BST(3);\n    root.left.right = new Program.BST(5);\n    root.right = new Program.BST(20);\n    root.right.left = new Program.BST(17);\n    root.right.right = new Program.BST(22);\n    int k = 3;\n    int expected = 17;\n    var actual = new Program().FindKthLargestValueInBst(root, k);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is an input class. Do not edit.\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\nfunc FindKthLargestValueInBst(tree *BST, k int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the tree\nfunc FindKthLargestValueInBst(tree *BST, k int) int {\n\tsortedNodeValues := make([]int, 0)\n\tinOrderTraverse(tree, &sortedNodeValues)\n\treturn sortedNodeValues[len(sortedNodeValues)-k]\n}\n\nfunc inOrderTraverse(node *BST, sortedNodeValues *[]int) {\n\tif node == nil {\n\t\treturn\n\t}\n\n\tinOrderTraverse(node.Left, sortedNodeValues)\n\t*sortedNodeValues = append(*sortedNodeValues, node.Value)\n\tinOrderTraverse(node.Right, sortedNodeValues)\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\ntype treeInfo struct {\n\tnumberOfNodesVisited   int\n\tlatestVisitedNodeValue int\n}\n\n// O(h + k) time | O(h) space - where h is the height of the tree and k is the input parameter\nfunc FindKthLargestValueInBst(tree *BST, k int) int {\n\ttreeInfo := treeInfo{0, -1}\n\treverseInOrderTraverse(tree, k, &treeInfo)\n\treturn treeInfo.latestVisitedNodeValue\n}\n\nfunc reverseInOrderTraverse(node *BST, k int, treeInfo *treeInfo) {\n\tif node == nil || treeInfo.numberOfNodesVisited >= k {\n\t\treturn\n\t}\n\n\treverseInOrderTraverse(node.Right, k, treeInfo)\n\tif treeInfo.numberOfNodesVisited < k {\n\t\ttreeInfo.numberOfNodesVisited += 1\n\t\ttreeInfo.latestVisitedNodeValue = node.Value\n\t\treverseInOrderTraverse(node.Left, k, treeInfo)\n\t}\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\troot := &BST{Value: 15}\n\troot.Left = &BST{Value: 5}\n\troot.Left.Left = &BST{Value: 2}\n\troot.Left.Left.Left = &BST{Value: 1}\n\troot.Left.Left.Right = &BST{Value: 3}\n\troot.Left.Right = &BST{Value: 5}\n\troot.Right = &BST{Value: 20}\n\troot.Right.Left = &BST{Value: 17}\n\troot.Right.Right = &BST{Value: 22}\n\tk := 3\n\texpected := 17\n\tactual := FindKthLargestValueInBst(root, k)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\troot := &BST{Value: 15}\n\troot.Left = &BST{Value: 5}\n\troot.Left.Left = &BST{Value: 2}\n\troot.Left.Left.Left = &BST{Value: 1}\n\troot.Left.Left.Right = &BST{Value: 3}\n\troot.Left.Right = &BST{Value: 5}\n\troot.Right = &BST{Value: 20}\n\troot.Right.Left = &BST{Value: 17}\n\troot.Right.Right = &BST{Value: 22}\n\tk := 3\n\texpected := 17\n\tactual := FindKthLargestValueInBst(root, k)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  public int findKthLargestValueInBst(BST tree, int k) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n) time | O(n) space - where n is the number of nodes in the tree\n  public int findKthLargestValueInBst(BST tree, int k) {\n    ArrayList<Integer> sortedNodeValues = new ArrayList<Integer>();\n    inOrderTraverse(tree, sortedNodeValues);\n    return sortedNodeValues.get(sortedNodeValues.size() - k);\n  }\n\n  public void inOrderTraverse(BST node, ArrayList<Integer> sortedNodeValues) {\n    if (node == null) return;\n\n    inOrderTraverse(node.left, sortedNodeValues);\n    sortedNodeValues.add(node.value);\n    inOrderTraverse(node.right, sortedNodeValues);\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  static class TreeInfo {\n    public int numberOfNodesVisited;\n    public int latestVisitedNodeValue;\n\n    public TreeInfo(int numberOfNodesVisited, int latestVisitedNodeValue) {\n      this.numberOfNodesVisited = numberOfNodesVisited;\n      this.latestVisitedNodeValue = latestVisitedNodeValue;\n    }\n  }\n\n  // O(h + k) time | O(h) space - where h is the height of the tree and k is the\n  // input parameter\n  public int findKthLargestValueInBst(BST tree, int k) {\n    TreeInfo treeInfo = new TreeInfo(0, -1);\n    reverseInOrderTraverse(tree, k, treeInfo);\n    return treeInfo.latestVisitedNodeValue;\n  }\n\n  public void reverseInOrderTraverse(BST node, int k, TreeInfo treeInfo) {\n    if (node == null || treeInfo.numberOfNodesVisited >= k) return;\n\n    reverseInOrderTraverse(node.right, k, treeInfo);\n    if (treeInfo.numberOfNodesVisited < k) {\n      treeInfo.numberOfNodesVisited += 1;\n      treeInfo.latestVisitedNodeValue = node.value;\n      reverseInOrderTraverse(node.left, k, treeInfo);\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.BST root = new Program.BST(15);\n    root.left = new Program.BST(5);\n    root.left.left = new Program.BST(2);\n    root.left.left.left = new Program.BST(1);\n    root.left.left.right = new Program.BST(3);\n    root.left.right = new Program.BST(5);\n    root.right = new Program.BST(20);\n    root.right.left = new Program.BST(17);\n    root.right.right = new Program.BST(22);\n    int k = 3;\n    int expected = 17;\n    var actual = new Program().findKthLargestValueInBst(root, k);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.BST root = new Program.BST(15);\n    root.left = new Program.BST(5);\n    root.left.left = new Program.BST(2);\n    root.left.left.left = new Program.BST(1);\n    root.left.left.right = new Program.BST(3);\n    root.left.right = new Program.BST(5);\n    root.right = new Program.BST(20);\n    root.right.left = new Program.BST(17);\n    root.right.right = new Program.BST(22);\n    int k = 3;\n    int expected = 17;\n    var actual = new Program().findKthLargestValueInBst(root, k);\n    Utils.assertTrue(expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction findKthLargestValueInBst(tree, k) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.findKthLargestValueInBst = findKthLargestValueInBst;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the tree\nfunction findKthLargestValueInBst(tree, k) {\n  const sortedNodeValues = [];\n  inOrderTraverse(tree, sortedNodeValues);\n  return sortedNodeValues[sortedNodeValues.length - k];\n}\n\nfunction inOrderTraverse(node, sortedNodeValues) {\n  if (node === null) return;\n\n  inOrderTraverse(node.left, sortedNodeValues);\n  sortedNodeValues.push(node.value);\n  inOrderTraverse(node.right, sortedNodeValues);\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.findKthLargestValueInBst = findKthLargestValueInBst;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass TreeInfo {\n  constructor(numberOfNodesVisited, latestVisitedNodeValue) {\n    this.numberOfNodesVisited = numberOfNodesVisited;\n    this.latestVisitedNodeValue = latestVisitedNodeValue;\n  }\n}\n\n// O(h + k) time | O(h) space - where h is the height of the tree and k is the input parameter\nfunction findKthLargestValueInBst(tree, k) {\n  const treeInfo = new TreeInfo(0, -1);\n  reverseInOrderTraverse(tree, k, treeInfo);\n  return treeInfo.latestVisitedNodeValue;\n}\n\nfunction reverseInOrderTraverse(node, k, treeInfo) {\n  if (node === null || treeInfo.numberOfNodesVisited >= k) return;\n\n  reverseInOrderTraverse(node.right, k, treeInfo);\n  if (treeInfo.numberOfNodesVisited < k) {\n    treeInfo.numberOfNodesVisited++;\n    treeInfo.latestVisitedNodeValue = node.value;\n    reverseInOrderTraverse(node.left, k, treeInfo);\n  }\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.findKthLargestValueInBst = findKthLargestValueInBst;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nconst {BST} = program;\n\nit('Test Case #1', function () {\n  const root = new BST(15);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.left.right = new BST(3);\n  root.left.right = new BST(5);\n  root.right = new BST(20);\n  root.right.left = new BST(17);\n  root.right.right = new BST(22);\n  const k = 3;\n  const expected = 17;\n  const actual = program.findKthLargestValueInBst(root, k);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nconst {BST} = program;\n\nit('Test Case #1', function () {\n  const root = new BST(15);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.left.right = new BST(3);\n  root.left.right = new BST(5);\n  root.right = new BST(20);\n  root.right.left = new BST(17);\n  root.right.right = new BST(22);\n  const k = 3;\n  const expected = 17;\n  const actual = program.findKthLargestValueInBst(root, k);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BST(value: Int) {\n    var value = value\n    var left: BST? = null\n    var right: BST? = null\n}\n\nfun findKthLargestValueInBst(tree: BST, k: Int): Int {\n    // Write your code here.\n    return -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BST(value: Int) {\n    var value = value\n    var left: BST? = null\n    var right: BST? = null\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the tree\nfun findKthLargestValueInBst(tree: BST, k: Int): Int {\n    val sortedNodeValues = mutableListOf<Int>()\n    inOrderTraverse(tree, sortedNodeValues)\n    return sortedNodeValues[sortedNodeValues.size - k]\n}\n\nfun inOrderTraverse(node: BST?, sortedNodeValues: MutableList<Int>) {\n    if (node == null) return\n\n    inOrderTraverse(node.left, sortedNodeValues)\n    sortedNodeValues.add(node.value)\n    inOrderTraverse(node.right, sortedNodeValues)\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BST(value: Int) {\n    var value = value\n    var left: BST? = null\n    var right: BST? = null\n}\n\nopen class TreeInfo(numberOfNodesVisited: Int, latestVisitedNodeValue: Int) {\n    var numberOfNodesVisited = numberOfNodesVisited\n    var latestVisitedNodeValue = latestVisitedNodeValue\n}\n\n// O(h + k) time | O(h) space - where h is the height of the tree and k is the input parameter\nfun findKthLargestValueInBst(tree: BST, k: Int): Int {\n    val treeInfo = TreeInfo(0, -1)\n    reverseInOrderTraverse(tree, k, treeInfo)\n    return treeInfo.latestVisitedNodeValue\n}\n\nfun reverseInOrderTraverse(node: BST?, k: Int, treeInfo: TreeInfo) {\n    if (node == null || treeInfo.numberOfNodesVisited >= k) return\n\n    reverseInOrderTraverse(node.right, k, treeInfo)\n    if (treeInfo.numberOfNodesVisited < k) {\n        treeInfo.numberOfNodesVisited += 1\n        treeInfo.latestVisitedNodeValue = node.value\n        reverseInOrderTraverse(node.left, k, treeInfo)\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.BST\nimport com.algoexpert.program.findKthLargestValueInBst\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val root = BST(15)\n        root.left = BST(5)\n        root.left!!.left = BST(2)\n        root.left!!.left!!.left = BST(1)\n        root.left!!.left!!.right = BST(3)\n        root.left!!.right = BST(5)\n        root.right = BST(20)\n        root.right!!.left = BST(17)\n        root.right!!.right = BST(22)\n        val k = 3\n        val expected = 17\n        val output = findKthLargestValueInBst(root, k)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.BST\nimport com.algoexpert.program.findKthLargestValueInBst\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val root = BST(15)\n        root.left = BST(5)\n        root.left!!.left = BST(2)\n        root.left!!.left!!.left = BST(1)\n        root.left!!.left!!.right = BST(3)\n        root.left!!.right = BST(5)\n        root.right = BST(20)\n        root.right!!.left = BST(17)\n        root.right!!.right = BST(22)\n        val k = 3\n        val expected = 17\n        val output = findKthLargestValueInBst(root, k)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass BST:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef findKthLargestValueInBst(tree, k):\n    # Write your code here.\n    return -1\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BST:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# O(n) time | O(n) space - where n is the number of nodes in the tree\ndef findKthLargestValueInBst(tree, k):\n    sortedNodeValues = []\n    inOrderTraverse(tree, sortedNodeValues)\n    return sortedNodeValues[len(sortedNodeValues) - k]\n\n\ndef inOrderTraverse(node, sortedNodeValues):\n    if node is None:\n        return\n\n    inOrderTraverse(node.left, sortedNodeValues)\n    sortedNodeValues.append(node.value)\n    inOrderTraverse(node.right, sortedNodeValues)\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BST:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\nclass TreeInfo:\n    def __init__(self, numberOfNodesVisited, latestVisitedNodeValue):\n        self.numberOfNodesVisited = numberOfNodesVisited\n        self.latestVisitedNodeValue = latestVisitedNodeValue\n\n\n# O(h + k) time | O(h) space - where h is the height of the tree and k is the input parameter\ndef findKthLargestValueInBst(tree, k):\n    treeInfo = TreeInfo(0, -1)\n    reverseInOrderTraverse(tree, k, treeInfo)\n    return treeInfo.latestVisitedNodeValue\n\n\ndef reverseInOrderTraverse(node, k, treeInfo):\n    if node is None or treeInfo.numberOfNodesVisited >= k:\n        return\n\n    reverseInOrderTraverse(node.right, k, treeInfo)\n    if treeInfo.numberOfNodesVisited < k:\n        treeInfo.numberOfNodesVisited += 1\n        treeInfo.latestVisitedNodeValue = node.value\n        reverseInOrderTraverse(node.left, k, treeInfo)\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = program.BST(15)\n        root.left = program.BST(5)\n        root.left.left = program.BST(2)\n        root.left.left.left = program.BST(1)\n        root.left.left.right = program.BST(3)\n        root.left.right = program.BST(5)\n        root.right = program.BST(20)\n        root.right.left = program.BST(17)\n        root.right.right = program.BST(22)\n        k = 3\n        expected = 17\n        actual = program.findKthLargestValueInBst(root, k)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = program.BST(15)\n        root.left = program.BST(5)\n        root.left.left = program.BST(2)\n        root.left.left.left = program.BST(1)\n        root.left.left.right = program.BST(3)\n        root.left.right = program.BST(5)\n        root.right = program.BST(20)\n        root.right.left = program.BST(17)\n        root.right.right = program.BST(22)\n        k = 3\n        expected = 17\n        actual = program.findKthLargestValueInBst(root, k)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "# This is an input struct. Do not edit.\nclass BST\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def findKthLargestValueInBst(tree, k)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BST\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def findKthLargestValueInBst(tree, k)\n    # Write your code here.\n    return -1\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BST\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def findKthLargestValueInBst(tree, k)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.findKthLargestValueInBst\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.findKthLargestValueInBst\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  func findKthLargestValueInBst(_ tree: BST, _ k: Int) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(n) time | O(n) space - where n is the number of nodes in the tree\n  func findKthLargestValueInBst(_ tree: BST, _ k: Int) -> Int {\n    var sortedNodeValues = [Int]()\n    inOrderTraverse(tree, &sortedNodeValues)\n    return sortedNodeValues[sortedNodeValues.count - k]\n  }\n\n  func inOrderTraverse(_ node: BST?, _ sortedNodeValues: inout [Int]) {\n    if node == nil {\n      return\n    }\n\n    inOrderTraverse(node!.left, &sortedNodeValues)\n    sortedNodeValues.append(node!.value)\n    inOrderTraverse(node!.right, &sortedNodeValues)\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  struct treeInfo {\n    var numberOfNodesVisited: Int\n    var latestVisitedNodeValue: Int\n  }\n\n  // O(h + k) time | O(h) space - where h is the height of the tree and k is the input parameter\n  func findKthLargestValueInBst(_ tree: BST, _ k: Int) -> Int {\n    var info = treeInfo(numberOfNodesVisited: 0, latestVisitedNodeValue: -1)\n    reverseInOrderTraverse(tree, k, &info)\n    return info.latestVisitedNodeValue\n  }\n\n  func reverseInOrderTraverse(_ node: BST?, _ k: Int, _ treeInfo: inout treeInfo) {\n    if node == nil || treeInfo.numberOfNodesVisited >= k {\n      return\n    }\n\n    reverseInOrderTraverse(node!.right, k, &treeInfo)\n    if treeInfo.numberOfNodesVisited < k {\n      treeInfo.numberOfNodesVisited += 1\n      treeInfo.latestVisitedNodeValue = node!.value\n      reverseInOrderTraverse(node!.left, k, &treeInfo)\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var root = Program.BST(value: 15)\n      root.left = Program.BST(value: 5)\n      root.left!.left = Program.BST(value: 2)\n      root.left!.left!.left = Program.BST(value: 1)\n      root.left!.left!.right = Program.BST(value: 3)\n      root.left!.right = Program.BST(value: 5)\n      root.right = Program.BST(value: 20)\n      root.right!.left = Program.BST(value: 17)\n      root.right!.right = Program.BST(value: 22)\n      let k = 3\n      let expected = 17\n      var actual = Program().findKthLargestValueInBst(root, k)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var root = Program.BST(value: 15)\n      root.left = Program.BST(value: 5)\n      root.left!.left = Program.BST(value: 2)\n      root.left!.left!.left = Program.BST(value: 1)\n      root.left!.left!.right = Program.BST(value: 3)\n      root.left!.right = Program.BST(value: 5)\n      root.right = Program.BST(value: 20)\n      root.right!.left = Program.BST(value: 17)\n      root.right!.right = Program.BST(value: 22)\n      let k = 3\n      let expected = 17\n      var actual = Program().findKthLargestValueInBst(root, k)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport function findKthLargestValueInBst(tree: BST, k: number) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the tree\nexport function findKthLargestValueInBst(tree: BST, k: number) {\n  const sortedNodeValues: number[] = [];\n  inOrderTraverse(tree, sortedNodeValues);\n  return sortedNodeValues[sortedNodeValues.length - k];\n}\n\nfunction inOrderTraverse(node: BST | null, sortedNodeValues: number[]) {\n  if (node === null) return;\n\n  inOrderTraverse(node.left, sortedNodeValues);\n  sortedNodeValues.push(node.value);\n  inOrderTraverse(node.right, sortedNodeValues);\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass TreeInfo {\n  numberOfNodesVisited: number;\n  latestVisitedNodeValue: number;\n\n  constructor(numberOfNodesVisited: number, latestVisitedNodeValue: number) {\n    this.numberOfNodesVisited = numberOfNodesVisited;\n    this.latestVisitedNodeValue = latestVisitedNodeValue;\n  }\n}\n\n// O(h + k) time | O(h) space - where h is the height of the tree and k is the input parameter\nexport function findKthLargestValueInBst(tree: BST, k: number) {\n  const treeInfo = new TreeInfo(0, -1);\n  reverseInOrderTraverse(tree, k, treeInfo);\n  return treeInfo.latestVisitedNodeValue;\n}\n\nfunction reverseInOrderTraverse(node: BST | null, k: number, treeInfo: TreeInfo) {\n  if (node === null || treeInfo.numberOfNodesVisited >= k) return;\n\n  reverseInOrderTraverse(node.right, k, treeInfo);\n  if (treeInfo.numberOfNodesVisited < k) {\n    treeInfo.numberOfNodesVisited++;\n    treeInfo.latestVisitedNodeValue = node.value;\n    reverseInOrderTraverse(node.left, k, treeInfo);\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nconst {BST} = program;\n\nit('Test Case #1', function () {\n  const root = new BST(15);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.left.right = new BST(3);\n  root.left.right = new BST(5);\n  root.right = new BST(20);\n  root.right.left = new BST(17);\n  root.right.right = new BST(22);\n  const k = 3;\n  const expected = 17;\n  const actual = program.findKthLargestValueInBst(root, k);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nconst {BST} = program;\n\nit('Test Case #1', function () {\n  const root = new BST(15);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.left.right = new BST(3);\n  root.left.right = new BST(5);\n  root.right = new BST(20);\n  root.right.left = new BST(17);\n  root.right.right = new BST(22);\n  const k = 3;\n  const expected = 17;\n  const actual = program.findKthLargestValueInBst(root, k);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "tree",
      "example": {
        "nodes": [
          {
            "id": "15",
            "left": "5",
            "right": "20",
            "value": 15
          },
          {
            "id": "20",
            "left": "17",
            "right": "22",
            "value": 20
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          },
          {
            "id": "17",
            "left": null,
            "right": null,
            "value": 17
          },
          {
            "id": "5",
            "left": "2",
            "right": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "15"
      },
      "schema": {
        "description": "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "left": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "right": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "left",
                "right"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "root": {
            "type": "string"
          }
        },
        "required": [
          "root",
          "nodes"
        ],
        "type": "object"
      }
    },
    {
      "name": "k",
      "example": 3,
      "schema": {
        "minimum": 1,
        "type": "integer"
      }
    }
  ],
  "tests": [
    {
      "k": 3,
      "tree": {
        "nodes": [
          {
            "id": "15",
            "left": "5",
            "right": "20",
            "value": 15
          },
          {
            "id": "20",
            "left": "17",
            "right": "22",
            "value": 20
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          },
          {
            "id": "17",
            "left": null,
            "right": null,
            "value": 17
          },
          {
            "id": "5",
            "left": "2",
            "right": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "15"
      }
    },
    {
      "k": 1,
      "tree": {
        "nodes": [
          {
            "id": "5",
            "left": "4",
            "right": "6",
            "value": 5
          },
          {
            "id": "4",
            "left": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "6",
            "left": null,
            "right": "7",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "5"
      }
    },
    {
      "k": 1,
      "tree": {
        "nodes": [
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "5"
      }
    },
    {
      "k": 3,
      "tree": {
        "nodes": [
          {
            "id": "20",
            "left": "15",
            "right": "25",
            "value": 20
          },
          {
            "id": "15",
            "left": "10",
            "right": "19",
            "value": 15
          },
          {
            "id": "25",
            "left": "21",
            "right": "30",
            "value": 25
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "19",
            "left": null,
            "right": null,
            "value": 19
          },
          {
            "id": "21",
            "left": null,
            "right": "22",
            "value": 21
          },
          {
            "id": "30",
            "left": null,
            "right": null,
            "value": 30
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          }
        ],
        "root": "20"
      }
    },
    {
      "k": 5,
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    },
    {
      "k": 2,
      "tree": {
        "nodes": [
          {
            "id": "10",
            "left": "8",
            "right": null,
            "value": 10
          },
          {
            "id": "8",
            "left": "6",
            "right": null,
            "value": 8
          },
          {
            "id": "6",
            "left": "4",
            "right": null,
            "value": 6
          },
          {
            "id": "4",
            "left": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "10"
      }
    },
    {
      "k": 5,
      "tree": {
        "nodes": [
          {
            "id": "10",
            "left": "8",
            "right": null,
            "value": 10
          },
          {
            "id": "8",
            "left": "6",
            "right": "9",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "6",
            "left": "4",
            "right": "7",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "4",
            "left": "2",
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": null,
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "10"
      }
    },
    {
      "k": 1,
      "tree": {
        "nodes": [
          {
            "id": "99727",
            "left": "99",
            "right": null,
            "value": 99727
          },
          {
            "id": "99",
            "left": null,
            "right": "727",
            "value": 99
          },
          {
            "id": "727",
            "left": null,
            "right": null,
            "value": 727
          }
        ],
        "root": "99727"
      }
    },
    {
      "k": 7,
      "tree": {
        "nodes": [
          {
            "id": "15",
            "left": "5",
            "right": "20",
            "value": 15
          },
          {
            "id": "20",
            "left": "17",
            "right": "22",
            "value": 20
          },
          {
            "id": "22",
            "left": null,
            "right": "24",
            "value": 22
          },
          {
            "id": "24",
            "left": "23",
            "right": "25",
            "value": 24
          },
          {
            "id": "23",
            "left": null,
            "right": null,
            "value": 23
          },
          {
            "id": "25",
            "left": null,
            "right": null,
            "value": 25
          },
          {
            "id": "17",
            "left": null,
            "right": null,
            "value": 17
          },
          {
            "id": "5",
            "left": "2",
            "right": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "15"
      }
    },
    {
      "k": 5,
      "tree": {
        "nodes": [
          {
            "id": "15",
            "left": "5",
            "right": "20",
            "value": 15
          },
          {
            "id": "20",
            "left": "17",
            "right": "22",
            "value": 20
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          },
          {
            "id": "17",
            "left": null,
            "right": null,
            "value": 17
          },
          {
            "id": "5",
            "left": "2",
            "right": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "15"
      }
    },
    {
      "k": 6,
      "tree": {
        "nodes": [
          {
            "id": "15",
            "left": "5",
            "right": "20",
            "value": 15
          },
          {
            "id": "20",
            "left": "17",
            "right": "22",
            "value": 20
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          },
          {
            "id": "17",
            "left": null,
            "right": null,
            "value": 17
          },
          {
            "id": "5",
            "left": "2",
            "right": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "15"
      }
    }
  ],
  "jsonTests": [
    {
      "k": 3,
      "tree": {
        "nodes": [
          {
            "id": "15",
            "left": "5",
            "right": "20",
            "value": 15
          },
          {
            "id": "20",
            "left": "17",
            "right": "22",
            "value": 20
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          },
          {
            "id": "17",
            "left": null,
            "right": null,
            "value": 17
          },
          {
            "id": "5",
            "left": "2",
            "right": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "15"
      }
    },
    {
      "k": 1,
      "tree": {
        "nodes": [
          {
            "id": "5",
            "left": "4",
            "right": "6",
            "value": 5
          },
          {
            "id": "4",
            "left": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "6",
            "left": null,
            "right": "7",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "5"
      }
    },
    {
      "k": 1,
      "tree": {
        "nodes": [
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "5"
      }
    },
    {
      "k": 3,
      "tree": {
        "nodes": [
          {
            "id": "20",
            "left": "15",
            "right": "25",
            "value": 20
          },
          {
            "id": "15",
            "left": "10",
            "right": "19",
            "value": 15
          },
          {
            "id": "25",
            "left": "21",
            "right": "30",
            "value": 25
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "19",
            "left": null,
            "right": null,
            "value": 19
          },
          {
            "id": "21",
            "left": null,
            "right": "22",
            "value": 21
          },
          {
            "id": "30",
            "left": null,
            "right": null,
            "value": 30
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          }
        ],
        "root": "20"
      }
    },
    {
      "k": 5,
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    },
    {
      "k": 2,
      "tree": {
        "nodes": [
          {
            "id": "10",
            "left": "8",
            "right": null,
            "value": 10
          },
          {
            "id": "8",
            "left": "6",
            "right": null,
            "value": 8
          },
          {
            "id": "6",
            "left": "4",
            "right": null,
            "value": 6
          },
          {
            "id": "4",
            "left": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "10"
      }
    },
    {
      "k": 5,
      "tree": {
        "nodes": [
          {
            "id": "10",
            "left": "8",
            "right": null,
            "value": 10
          },
          {
            "id": "8",
            "left": "6",
            "right": "9",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "6",
            "left": "4",
            "right": "7",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "4",
            "left": "2",
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": null,
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "10"
      }
    },
    {
      "k": 1,
      "tree": {
        "nodes": [
          {
            "id": "99727",
            "left": "99",
            "right": null,
            "value": 99727
          },
          {
            "id": "99",
            "left": null,
            "right": "727",
            "value": 99
          },
          {
            "id": "727",
            "left": null,
            "right": null,
            "value": 727
          }
        ],
        "root": "99727"
      }
    },
    {
      "k": 7,
      "tree": {
        "nodes": [
          {
            "id": "15",
            "left": "5",
            "right": "20",
            "value": 15
          },
          {
            "id": "20",
            "left": "17",
            "right": "22",
            "value": 20
          },
          {
            "id": "22",
            "left": null,
            "right": "24",
            "value": 22
          },
          {
            "id": "24",
            "left": "23",
            "right": "25",
            "value": 24
          },
          {
            "id": "23",
            "left": null,
            "right": null,
            "value": 23
          },
          {
            "id": "25",
            "left": null,
            "right": null,
            "value": 25
          },
          {
            "id": "17",
            "left": null,
            "right": null,
            "value": 17
          },
          {
            "id": "5",
            "left": "2",
            "right": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "15"
      }
    },
    {
      "k": 5,
      "tree": {
        "nodes": [
          {
            "id": "15",
            "left": "5",
            "right": "20",
            "value": 15
          },
          {
            "id": "20",
            "left": "17",
            "right": "22",
            "value": 20
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          },
          {
            "id": "17",
            "left": null,
            "right": null,
            "value": 17
          },
          {
            "id": "5",
            "left": "2",
            "right": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "15"
      }
    },
    {
      "k": 6,
      "tree": {
        "nodes": [
          {
            "id": "15",
            "left": "5",
            "right": "20",
            "value": 15
          },
          {
            "id": "20",
            "left": "17",
            "right": "22",
            "value": 20
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          },
          {
            "id": "17",
            "left": null,
            "right": null,
            "value": 17
          },
          {
            "id": "5",
            "left": "2",
            "right": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "15"
      }
    }
  ],
  "changelog": []
}