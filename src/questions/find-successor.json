{
  "uid": "find-successor",
  "testStrategy": "JSON",
  "name": "Find Successor",
  "version": 0,
  "releaseDate": "2020-12-23T00:00:00Z",
  "category": "Binary Trees",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 26451,
    "failureCount": 8716
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "484617481",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 1158
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in a Binary Tree (where nodes have an additional\n  pointer to their parent node) as well as a node contained in that tree and\n  returns the given node's successor.\n</p>\n<p>\n  A node's successor is the next node to be visited (immediately after the given\n  node) when traversing its tree using the in-order tree-traversal technique. A\n  node has no successor if it's the last node to be visited in the in-order\n  traversal.\n</p>\n<p>\n  If a node has no successor, your function should return <span>None</span> /\n  <span>null</span>.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>parent</span> node, a <span>left</span> child node, and a\n  <span>right</span> child node. Children nodes can either be\n  <span>BinaryTree</span> nodes themselves or <span>None</span> /\n  <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">tree</span> = \n              1\n            /   \\\n           2     3\n         /   \\ \n        4     5\n       /       \n      6  \n<span class=\"CodeEditor-promptParameter\">node</span> = 5   \n</pre>\n<h3>Sample Output</h3>\n<pre>\n1\n<span class=\"CodeEditor-promptComment\">// This tree's in-order traversal order is:</span>\n<span class=\"CodeEditor-promptComment\">// 6 -> 4 -> 2 -> 5 -> 1 -> 3 </span>\n<span class=\"CodeEditor-promptComment\">// 1 comes immediately after 5.</span>\n</pre>\n</div>",
  "hints": [
    "<p>\nStart by performing an in-order traversal of the tree and storing the nodes in an array as you go. Then, traverse the nodes that you've stored; once you find the input node, return the node immediately after it in the array.\n</p>\n",
    "\n<p>\nCan you think of a more time-efficient way to solve this problem without performing the entire in-order traversal?\n</p>\n",
    "\n<p>\nUse the fact that each node has a pointer to its parent to solve this problem in O(h) time, where h is the height of the tree.\n</p>\n",
    "\n<p>\nIf the given node has a right subtree, then the next node in the in-order traversal is simply the leftmost node in that right subtree. If it doesn't have a right subtree, then we need to traverse up the tree looking for an ancestor of this node that contains the node in question in its left subtree. The first node that we find that contains the input node in its left subtree is the one that will be visited next in the in-order traversal. If we reach the root node, and the input node isn't in the root node's left subtree, then the input node has no successor, because it must be the rightmost node of entire tree.\n</p>"
  ],
  "spaceTime": "O(h) time | O(1) space - where h is the height of the tree",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": "tree",
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left = nullptr;\n  BinaryTree* right = nullptr;\n  BinaryTree* parent = nullptr;\n\n  BinaryTree(int value) { this->value = value; }\n};\n\nBinaryTree* findSuccessor(BinaryTree* tree, BinaryTree* node) {\n  // Write your code here.\n  return nullptr;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left = nullptr;\n  BinaryTree* right = nullptr;\n  BinaryTree* parent = nullptr;\n\n  BinaryTree(int value) { this->value = value; }\n};\n\nvoid getInOrderTraversalOrder(BinaryTree* node, vector<BinaryTree*>& order);\n\n// O(n) time | O(n) space - where n is the number of nodes in the tree\nBinaryTree* findSuccessor(BinaryTree* tree, BinaryTree* node) {\n  vector<BinaryTree*> inOrderTraversalOrder;\n  getInOrderTraversalOrder(tree, inOrderTraversalOrder);\n\n  for (int i = 0; i < inOrderTraversalOrder.size(); i++) {\n    auto currentNode = inOrderTraversalOrder[i];\n\n    if (currentNode != node) {\n      continue;\n    }\n\n    if (i == inOrderTraversalOrder.size() - 1) {\n      return nullptr;\n    }\n    return inOrderTraversalOrder[i + 1];\n  }\n  return nullptr;\n}\n\nvoid getInOrderTraversalOrder(BinaryTree* node, vector<BinaryTree*>& order) {\n  if (node == nullptr) {\n    return;\n  }\n\n  getInOrderTraversalOrder(node->left, order);\n  order.push_back(node);\n  getInOrderTraversalOrder(node->right, order);\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left = nullptr;\n  BinaryTree* right = nullptr;\n  BinaryTree* parent = nullptr;\n\n  BinaryTree(int value) { this->value = value; }\n};\n\nBinaryTree* getLeftmostChild(BinaryTree* node);\nBinaryTree* getRightmostParent(BinaryTree* node);\n\n// O(h) time | O(1) space - where h is the height of the tree\nBinaryTree* findSuccessor(BinaryTree* tree, BinaryTree* node) {\n  if (node->right != nullptr) {\n    return getLeftmostChild(node->right);\n  }\n  return getRightmostParent(node);\n}\n\nBinaryTree* getLeftmostChild(BinaryTree* node) {\n  auto currentNode = node;\n  while (currentNode->left != nullptr) {\n    currentNode = currentNode->left;\n  }\n\n  return currentNode;\n}\n\nBinaryTree* getRightmostParent(BinaryTree* node) {\n  auto currentNode = node;\n  while (currentNode->parent != nullptr &&\n         currentNode->parent->right == currentNode) {\n    currentNode = currentNode->parent;\n  }\n\n  return currentNode->parent;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree* root = new BinaryTree(1);\n      root->left = new BinaryTree(2);\n      root->left->parent = root;\n      root->right = new BinaryTree(3);\n      root->right->parent = root;\n      root->left->left = new BinaryTree(4);\n      root->left->left->parent = root->left;\n      root->left->right = new BinaryTree(5);\n      root->left->right->parent = root->left;\n      root->left->left->left = new BinaryTree(6);\n      root->left->left->left->parent = root->left->left;\n      auto node = root->left->right;\n      auto expected = root;\n      auto actual = findSuccessor(root, node);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree* root = new BinaryTree(1);\n      root->left = new BinaryTree(2);\n      root->left->parent = root;\n      root->right = new BinaryTree(3);\n      root->right->parent = root;\n      root->left->left = new BinaryTree(4);\n      root->left->left->parent = root->left;\n      root->left->right = new BinaryTree(5);\n      root->left->right->parent = root->left;\n      root->left->left->left = new BinaryTree(6);\n      root->left->left->left->parent = root->left->left;\n      auto node = root->left->right;\n      auto expected = root;\n      auto actual = findSuccessor(root, node);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n    public BinaryTree parent = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  public BinaryTree FindSuccessor(BinaryTree tree, BinaryTree node) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n    public BinaryTree parent = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n) time | O(n) space - where n is the number of nodes in the tree\n  public BinaryTree FindSuccessor(BinaryTree tree, BinaryTree node) {\n    List<BinaryTree> inOrderTraversalOrder = new List<BinaryTree>();\n    getInOrderTraversalOrder(tree, inOrderTraversalOrder);\n\n    for (int i = 0; i < inOrderTraversalOrder.Count; i++) {\n      BinaryTree currentNode = inOrderTraversalOrder[i];\n\n      if (currentNode != node) {\n        continue;\n      }\n\n      if (i == inOrderTraversalOrder.Count - 1) {\n        return null;\n      }\n      return inOrderTraversalOrder[i + 1];\n    }\n    return null;\n  }\n\n  void getInOrderTraversalOrder(BinaryTree node, List<BinaryTree> order) {\n    if (node == null) {\n      return;\n    }\n\n    getInOrderTraversalOrder(node.left, order);\n    order.Add(node);\n    getInOrderTraversalOrder(node.right, order);\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n    public BinaryTree parent = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(h) time | O(1) space - where h is the height of the tree\n  public BinaryTree FindSuccessor(BinaryTree tree, BinaryTree node) {\n    if (node.right != null) return getLeftmostChild(node.right);\n    return getRightmostParent(node);\n  }\n\n  public BinaryTree getLeftmostChild(BinaryTree node) {\n    BinaryTree currentNode = node;\n    while (currentNode.left != null) {\n      currentNode = currentNode.left;\n    }\n\n    return currentNode;\n  }\n\n  public BinaryTree getRightmostParent(BinaryTree node) {\n    BinaryTree currentNode = node;\n    while (currentNode.parent != null && currentNode.parent.right == currentNode\n    ) {\n      currentNode = currentNode.parent;\n    }\n\n    return currentNode.parent;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.BinaryTree root = new Program.BinaryTree(1);\n    root.left = new Program.BinaryTree(2);\n    root.left.parent = root;\n    root.right = new Program.BinaryTree(3);\n    root.right.parent = root;\n    root.left.left = new Program.BinaryTree(4);\n    root.left.left.parent = root.left;\n    root.left.right = new Program.BinaryTree(5);\n    root.left.right.parent = root.left;\n    root.left.left.left = new Program.BinaryTree(6);\n    root.left.left.left.parent = root.left.left;\n    Program.BinaryTree node = root.left.right;\n    Program.BinaryTree expected = root;\n    Program.BinaryTree actual = new Program().FindSuccessor(root, node);\n    Utils.AssertEquals(expected, actual);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.BinaryTree root = new Program.BinaryTree(1);\n    root.left = new Program.BinaryTree(2);\n    root.left.parent = root;\n    root.right = new Program.BinaryTree(3);\n    root.right.parent = root;\n    root.left.left = new Program.BinaryTree(4);\n    root.left.left.parent = root.left;\n    root.left.right = new Program.BinaryTree(5);\n    root.left.right.parent = root.left;\n    root.left.left.left = new Program.BinaryTree(6);\n    root.left.left.left.parent = root.left.left;\n    Program.BinaryTree node = root.left.right;\n    Program.BinaryTree expected = root;\n    Program.BinaryTree actual = new Program().FindSuccessor(root, node);\n    Utils.AssertEquals(expected, actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft   *BinaryTree\n\tRight  *BinaryTree\n\tParent *BinaryTree\n}\n\nfunc FindSuccessor(tree *BinaryTree, node *BinaryTree) *BinaryTree {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft   *BinaryTree\n\tRight  *BinaryTree\n\tParent *BinaryTree\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the tree\nfunc FindSuccessor(tree *BinaryTree, node *BinaryTree) *BinaryTree {\n\tinOrderTraversalOrder := []*BinaryTree{}\n\tgetInOrderTraversalOrder(tree, &inOrderTraversalOrder)\n\n\tfor idx, currentNode := range inOrderTraversalOrder {\n\t\tif currentNode != node {\n\t\t\tcontinue\n\t\t}\n\n\t\tif idx == len(inOrderTraversalOrder)-1 {\n\t\t\treturn nil\n\t\t}\n\t\treturn inOrderTraversalOrder[idx+1]\n\t}\n\treturn nil\n}\n\nfunc getInOrderTraversalOrder(node *BinaryTree, order *[]*BinaryTree) {\n\tif node == nil {\n\t\treturn\n\t}\n\n\tgetInOrderTraversalOrder(node.Left, order)\n\t*order = append(*order, node)\n\tgetInOrderTraversalOrder(node.Right, order)\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft   *BinaryTree\n\tRight  *BinaryTree\n\tParent *BinaryTree\n}\n\n// O(h) time | O(1) space - where h is the height of the tree\nfunc FindSuccessor(tree *BinaryTree, node *BinaryTree) *BinaryTree {\n\tif node.Right != nil {\n\t\treturn getLeftmostChild(node.Right)\n\t}\n\treturn getRightmostParent(node)\n}\n\nfunc getLeftmostChild(node *BinaryTree) *BinaryTree {\n\tvar currentNode = node\n\tfor currentNode.Left != nil {\n\t\tcurrentNode = currentNode.Left\n\t}\n\n\treturn currentNode\n}\n\nfunc getRightmostParent(node *BinaryTree) *BinaryTree {\n\tvar currentNode = node\n\tfor currentNode.Parent != nil && currentNode.Parent.Right == currentNode {\n\t\tcurrentNode = currentNode.Parent\n\t}\n\n\treturn currentNode.Parent\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\troot := &BinaryTree{Value: 1}\n\troot.Left = &BinaryTree{Value: 2}\n\troot.Left.Parent = root\n\troot.Right = &BinaryTree{Value: 3}\n\troot.Right.Parent = root\n\troot.Left.Left = &BinaryTree{Value: 4}\n\troot.Left.Left.Parent = root.Left\n\troot.Left.Right = &BinaryTree{Value: 5}\n\troot.Left.Right.Parent = root.Left\n\troot.Left.Left.Left = &BinaryTree{Value: 6}\n\troot.Left.Left.Left.Parent = root.Left.Left\n\tnode := root.Left.Right\n\texpected := root\n\tactual := FindSuccessor(root, node)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\troot := &BinaryTree{Value: 1}\n\troot.Left = &BinaryTree{Value: 2}\n\troot.Left.Parent = root\n\troot.Right = &BinaryTree{Value: 3}\n\troot.Right.Parent = root\n\troot.Left.Left = &BinaryTree{Value: 4}\n\troot.Left.Left.Parent = root.Left\n\troot.Left.Right = &BinaryTree{Value: 5}\n\troot.Left.Right.Parent = root.Left\n\troot.Left.Left.Left = &BinaryTree{Value: 6}\n\troot.Left.Left.Left.Parent = root.Left.Left\n\tnode := root.Left.Right\n\texpected := root\n\tactual := FindSuccessor(root, node)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n    public BinaryTree parent = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  public BinaryTree findSuccessor(BinaryTree tree, BinaryTree node) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n    public BinaryTree parent = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n) time | O(n) space - where n is the number of nodes in the tree\n  public BinaryTree findSuccessor(BinaryTree tree, BinaryTree node) {\n    ArrayList<BinaryTree> inOrderTraversalOrder = new ArrayList<BinaryTree>();\n    getInOrderTraversalOrder(tree, inOrderTraversalOrder);\n\n    for (int i = 0; i < inOrderTraversalOrder.size(); i++) {\n      BinaryTree currentNode = inOrderTraversalOrder.get(i);\n\n      if (currentNode != node) {\n        continue;\n      }\n\n      if (i == inOrderTraversalOrder.size() - 1) {\n        return null;\n      }\n      return inOrderTraversalOrder.get(i + 1);\n    }\n    return null;\n  }\n\n  void getInOrderTraversalOrder(BinaryTree node, ArrayList<BinaryTree> order) {\n    if (node == null) {\n      return;\n    }\n\n    getInOrderTraversalOrder(node.left, order);\n    order.add(node);\n    getInOrderTraversalOrder(node.right, order);\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n    public BinaryTree parent = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(h) time | O(1) space - where h is the height of the tree\n  public BinaryTree findSuccessor(BinaryTree tree, BinaryTree node) {\n    if (node.right != null) return getLeftmostChild(node.right);\n    return getRightmostParent(node);\n  }\n\n  public BinaryTree getLeftmostChild(BinaryTree node) {\n    BinaryTree currentNode = node;\n    while (currentNode.left != null) {\n      currentNode = currentNode.left;\n    }\n\n    return currentNode;\n  }\n\n  public BinaryTree getRightmostParent(BinaryTree node) {\n    BinaryTree currentNode = node;\n    while (currentNode.parent != null && currentNode.parent.right == currentNode\n    ) {\n      currentNode = currentNode.parent;\n    }\n\n    return currentNode.parent;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.BinaryTree root = new Program.BinaryTree(1);\n    root.left = new Program.BinaryTree(2);\n    root.left.parent = root;\n    root.right = new Program.BinaryTree(3);\n    root.right.parent = root;\n    root.left.left = new Program.BinaryTree(4);\n    root.left.left.parent = root.left;\n    root.left.right = new Program.BinaryTree(5);\n    root.left.right.parent = root.left;\n    root.left.left.left = new Program.BinaryTree(6);\n    root.left.left.left.parent = root.left.left;\n    Program.BinaryTree node = root.left.right;\n    Program.BinaryTree expected = root;\n    Program.BinaryTree output = new Program().findSuccessor(root, node);\n    assert (expected == output);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.BinaryTree root = new Program.BinaryTree(1);\n    root.left = new Program.BinaryTree(2);\n    root.left.parent = root;\n    root.right = new Program.BinaryTree(3);\n    root.right.parent = root;\n    root.left.left = new Program.BinaryTree(4);\n    root.left.left.parent = root.left;\n    root.left.right = new Program.BinaryTree(5);\n    root.left.right.parent = root.left;\n    root.left.left.left = new Program.BinaryTree(6);\n    root.left.left.left.parent = root.left.left;\n    Program.BinaryTree node = root.left.right;\n    Program.BinaryTree expected = root;\n    Program.BinaryTree output = new Program().findSuccessor(root, node);\n    assert (expected == output);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n  }\n}\n\nfunction findSuccessor(tree, node) {\n  // Write your code here.\n  return null;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.findSuccessor = findSuccessor;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the tree\nfunction findSuccessor(tree, node) {\n  const inOrderTraversalOrder = getInOrderTraversalOrder(tree);\n\n  for (let idx = 0; idx < inOrderTraversalOrder.length; idx++) {\n    const currentNode = inOrderTraversalOrder[idx];\n    if (currentNode !== node) continue;\n\n    if (idx === inOrderTraversalOrder.length - 1) return null;\n\n    return inOrderTraversalOrder[idx + 1];\n  }\n}\n\nfunction getInOrderTraversalOrder(node, order = []) {\n  if (node === null) return order;\n\n  getInOrderTraversalOrder(node.left, order);\n  order.push(node);\n  getInOrderTraversalOrder(node.right, order);\n\n  return order;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.findSuccessor = findSuccessor;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n  }\n}\n\n// O(h) time | O(1) space - where h is the height of the tree\nfunction findSuccessor(tree, node) {\n  if (node.right != null) return getLeftmostChild(node.right);\n\n  return getRightmostParent(node);\n}\n\nfunction getLeftmostChild(node) {\n  let currentNode = node;\n  while (currentNode.left !== null) {\n    currentNode = currentNode.left;\n  }\n\n  return currentNode;\n}\n\nfunction getRightmostParent(node) {\n  let currentNode = node;\n  while (currentNode.parent !== null && currentNode.parent.right === currentNode) {\n    currentNode = currentNode.parent;\n  }\n\n  return currentNode.parent;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.findSuccessor = findSuccessor;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(2);\n  root.left.parent = root;\n  root.right = new program.BinaryTree(3);\n  root.right.parent = root;\n  root.left.left = new program.BinaryTree(4);\n  root.left.left.parent = root.left;\n  root.left.right = new program.BinaryTree(5);\n  root.left.right.parent = root.left;\n  root.left.left.left = new program.BinaryTree(6);\n  root.left.left.left.parent = root.left.left;\n  const node = root.left.right;\n  const expected = root;\n  const actual = program.findSuccessor(root, node);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(2);\n  root.left.parent = root;\n  root.right = new program.BinaryTree(3);\n  root.right.parent = root;\n  root.left.left = new program.BinaryTree(4);\n  root.left.left.parent = root.left;\n  root.left.right = new program.BinaryTree(5);\n  root.left.right.parent = root.left;\n  root.left.left.left = new program.BinaryTree(6);\n  root.left.left.left.parent = root.left.left;\n  const node = root.left.right;\n  const expected = root;\n  const actual = program.findSuccessor(root, node);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n    var parent: BinaryTree? = null\n}\n\nfun findSuccessor(tree: BinaryTree, node: BinaryTree): BinaryTree? {\n    // Write your code here.\n    return null\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n    var parent: BinaryTree? = null\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the tree\nfun findSuccessor(tree: BinaryTree, node: BinaryTree): BinaryTree? {\n    val inOrderTraversalOrder = getInOrderTraversalOrder(tree)\n\n    for (idx in 0 until inOrderTraversalOrder.size) {\n        val currentNode = inOrderTraversalOrder[idx]\n        if (currentNode != node) continue\n\n        if (idx == inOrderTraversalOrder.size - 1) return null\n\n        return inOrderTraversalOrder[idx + 1]\n    }\n\n    return null\n}\n\nfun getInOrderTraversalOrder(node: BinaryTree?, order: MutableList<BinaryTree> = mutableListOf<BinaryTree>()): List<BinaryTree> {\n    if (node == null) return order\n\n    getInOrderTraversalOrder(node.left, order)\n    order.add(node)\n    getInOrderTraversalOrder(node.right, order)\n\n    return order\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n    var parent: BinaryTree? = null\n}\n\n// O(h) time | O(1) space - where h is the height of the tree\nfun findSuccessor(tree: BinaryTree, node: BinaryTree): BinaryTree? {\n    if (node.right != null) return getLeftmostChild(node.right!!)\n\n    return getRightmostParent(node)\n}\n\nfun getLeftmostChild(node: BinaryTree): BinaryTree {\n    var currentNode = node\n    while (currentNode.left != null) {\n        currentNode = currentNode.left!!\n    }\n\n    return currentNode\n}\n\nfun getRightmostParent(node: BinaryTree): BinaryTree? {\n    var currentNode = node\n    while (currentNode.parent != null && currentNode.parent!!.right == currentNode) {\n        currentNode = currentNode.parent!!\n    }\n\n    return currentNode.parent\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.BinaryTree\nimport com.algoexpert.program.findSuccessor\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val root = BinaryTree(1)\n        root.left = BinaryTree(2)\n        root.left!!.parent = root\n        root.right = BinaryTree(3)\n        root.right!!.parent = root\n        root.left!!.left = BinaryTree(4)\n        root.left!!.left!!.parent = root.left!!\n        root.left!!.right = BinaryTree(5)\n        root.left!!.right!!.parent = root.left!!\n        root.left!!.left!!.left = BinaryTree(6)\n        root.left!!.left!!.left!!.parent = root.left!!.left!!\n        val node = root.left!!.right!!\n        val expected = root\n        val output = findSuccessor(root, node)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.BinaryTree\nimport com.algoexpert.program.findSuccessor\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val root = BinaryTree(1)\n        root.left = BinaryTree(2)\n        root.left!!.parent = root\n        root.right = BinaryTree(3)\n        root.right!!.parent = root\n        root.left!!.left = BinaryTree(4)\n        root.left!!.left!!.parent = root.left!!\n        root.left!!.right = BinaryTree(5)\n        root.left!!.right!!.parent = root.left!!\n        root.left!!.left!!.left = BinaryTree(6)\n        root.left!!.left!!.left!!.parent = root.left!!.left!!\n        val node = root.left!!.right!!\n        val expected = root\n        val output = findSuccessor(root, node)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None, parent=None):\n        self.value = value\n        self.left = left\n        self.right = right\n        self.parent = parent\n\n\ndef findSuccessor(tree, node):\n    # Write your code here.\n    return None\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None, parent=None):\n        self.value = value\n        self.left = left\n        self.right = right\n        self.parent = parent\n\n\n# O(n) time | O(n) space - where n is the number of nodes in the tree\ndef findSuccessor(tree, node):\n    inOrderTraversalOrder = getInOrderTraversalOrder(tree)\n\n    for idx, currentNode in enumerate(inOrderTraversalOrder):\n        if currentNode != node:\n            continue\n\n        if idx == len(inOrderTraversalOrder) - 1:\n            return None\n\n        return inOrderTraversalOrder[idx + 1]\n\n\ndef getInOrderTraversalOrder(node, order=[]):\n    if node is None:\n        return order\n\n    getInOrderTraversalOrder(node.left, order)\n    order.append(node)\n    getInOrderTraversalOrder(node.right, order)\n\n    return order\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None, parent=None):\n        self.value = value\n        self.left = left\n        self.right = right\n        self.parent = parent\n\n\n# O(h) time | O(1) space - where h is the height of the tree\ndef findSuccessor(tree, node):\n    if node.right is not None:\n        return getLeftmostChild(node.right)\n\n    return getRightmostParent(node)\n\n\ndef getLeftmostChild(node):\n    currentNode = node\n    while currentNode.left is not None:\n        currentNode = currentNode.left\n\n    return currentNode\n\n\ndef getRightmostParent(node):\n    currentNode = node\n    while currentNode.parent is not None and currentNode.parent.right == currentNode:\n        currentNode = currentNode.parent\n\n    return currentNode.parent\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = program.BinaryTree(1)\n        root.left = program.BinaryTree(2)\n        root.left.parent = root\n        root.right = program.BinaryTree(3)\n        root.right.parent = root\n        root.left.left = program.BinaryTree(4)\n        root.left.left.parent = root.left\n        root.left.right = program.BinaryTree(5)\n        root.left.right.parent = root.left\n        root.left.left.left = program.BinaryTree(6)\n        root.left.left.left.parent = root.left.left\n        node = root.left.right\n        expected = root\n        actual = program.findSuccessor(root, node)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = program.BinaryTree(1)\n        root.left = program.BinaryTree(2)\n        root.left.parent = root\n        root.right = program.BinaryTree(3)\n        root.right.parent = root\n        root.left.left = program.BinaryTree(4)\n        root.left.left.parent = root.left\n        root.left.right = program.BinaryTree(5)\n        root.left.right.parent = root.left\n        root.left.left.left = program.BinaryTree(6)\n        root.left.left.left.parent = root.left.left\n        node = root.left.right\n        expected = root\n        actual = program.findSuccessor(root, node)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def findSuccessor(tree, node)\n    # Write your code here.\n    return nil\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def findSuccessor(tree, node)\n    # Write your code here.\n    return nil\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def findSuccessor(tree, node)\n    # Write your code here.\n    return nil\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.findSuccessor\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.findSuccessor\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n    var parent: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n      parent = nil\n    }\n  }\n\n  func findSuccessor(_ tree: BinaryTree, _ node: BinaryTree) -> BinaryTree? {\n    // Write your code here.\n    return nil\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n    var parent: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n      parent = nil\n    }\n  }\n\n  // O(n) time | O(n) space - where n is the number of nodes in the tree\n  func findSuccessor(_ tree: BinaryTree, _ node: BinaryTree) -> BinaryTree? {\n    var inOrderTraversalOrder = [BinaryTree]()\n    getInOrderTraversalOrder(tree, &inOrderTraversalOrder)\n\n    for idx in stride(from: 0, to: inOrderTraversalOrder.count, by: 1) {\n      var currentNode = inOrderTraversalOrder[idx]\n      if currentNode !== node {\n        continue\n      }\n\n      if idx == inOrderTraversalOrder.count - 1 {\n        return nil\n      }\n      return inOrderTraversalOrder[idx + 1]\n    }\n    return nil\n  }\n\n  func getInOrderTraversalOrder(_ node: BinaryTree?, _ order: inout [BinaryTree]) {\n    if node == nil {\n      return\n    }\n\n    getInOrderTraversalOrder(node!.left, &order)\n    order.append(node!)\n    getInOrderTraversalOrder(node!.right, &order)\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n    var parent: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n      parent = nil\n    }\n  }\n\n  // O(h) time | O(1) space - where h is the height of the tree\n  func findSuccessor(_ tree: BinaryTree, _ node: BinaryTree) -> BinaryTree? {\n    if node.right != nil {\n      return getLeftmostChild(node.right!)\n    }\n    return getRightmostParent(node)\n  }\n\n  func getLeftmostChild(_ node: BinaryTree) -> BinaryTree {\n    var currentNode = node\n    while currentNode.left != nil {\n      currentNode = currentNode.left!\n    }\n    return currentNode\n  }\n\n  func getRightmostParent(_ node: BinaryTree) -> BinaryTree? {\n    var currentNode = node\n    while currentNode.parent != nil, currentNode.parent!.right === currentNode {\n      currentNode = currentNode.parent!\n    }\n    return currentNode.parent\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var root = Program.BinaryTree(value: 1)\n      root.left = Program.BinaryTree(value: 2)\n      root.left!.parent = root\n      root.right = Program.BinaryTree(value: 3)\n      root.right!.parent = root\n      root.left!.left = Program.BinaryTree(value: 4)\n      root.left!.left!.parent = root.left\n      root.left!.right = Program.BinaryTree(value: 5)\n      root.left!.right!.parent = root.left\n      root.left!.left!.left = Program.BinaryTree(value: 6)\n      root.left!.left!.left!.parent = root.left!.left\n      var node = root.left!.right!\n      var expected = root\n      var actual = Program().findSuccessor(root, node)\n      try assert(expected === actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var root = Program.BinaryTree(value: 1)\n      root.left = Program.BinaryTree(value: 2)\n      root.left!.parent = root\n      root.right = Program.BinaryTree(value: 3)\n      root.right!.parent = root\n      root.left!.left = Program.BinaryTree(value: 4)\n      root.left!.left!.parent = root.left\n      root.left!.right = Program.BinaryTree(value: 5)\n      root.left!.right!.parent = root.left\n      root.left!.left!.left = Program.BinaryTree(value: 6)\n      root.left!.left!.left!.parent = root.left!.left\n      var node = root.left!.right!\n      var expected = root\n      var actual = Program().findSuccessor(root, node)\n      try assert(expected === actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n  parent: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n  }\n}\n\nexport function findSuccessor(tree: BinaryTree, node: BinaryTree) {\n  // Write your code here.\n  return node;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n  parent: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the tree\nexport function findSuccessor(tree: BinaryTree, node: BinaryTree) {\n  const inOrderTraversalOrder = getInOrderTraversalOrder(tree);\n\n  for (let idx = 0; idx < inOrderTraversalOrder.length; idx++) {\n    const currentNode = inOrderTraversalOrder[idx];\n    if (currentNode !== node) continue;\n\n    if (idx === inOrderTraversalOrder.length - 1) return null;\n\n    return inOrderTraversalOrder[idx + 1];\n  }\n}\n\nfunction getInOrderTraversalOrder(node: BinaryTree | null, order: BinaryTree[] = []) {\n  if (node === null) return order;\n\n  getInOrderTraversalOrder(node.left, order);\n  order.push(node);\n  getInOrderTraversalOrder(node.right, order);\n\n  return order;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n  parent: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n  }\n}\n\n// O(h) time | O(1) space - where h is the height of the tree\nexport function findSuccessor(tree: BinaryTree, node: BinaryTree) {\n  if (node.right != null) return getLeftmostChild(node.right);\n\n  return getRightmostParent(node);\n}\n\nfunction getLeftmostChild(node: BinaryTree) {\n  let currentNode = node;\n  while (currentNode.left !== null) {\n    currentNode = currentNode.left;\n  }\n\n  return currentNode;\n}\n\nfunction getRightmostParent(node: BinaryTree) {\n  let currentNode = node;\n  while (currentNode.parent !== null && currentNode.parent.right === currentNode) {\n    currentNode = currentNode.parent;\n  }\n\n  return currentNode.parent;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(2);\n  root.left.parent = root;\n  root.right = new program.BinaryTree(3);\n  root.right.parent = root;\n  root.left.left = new program.BinaryTree(4);\n  root.left.left.parent = root.left;\n  root.left.right = new program.BinaryTree(5);\n  root.left.right.parent = root.left;\n  root.left.left.left = new program.BinaryTree(6);\n  root.left.left.left.parent = root.left.left;\n  const node = root.left.right;\n  const expected = root;\n  const actual = program.findSuccessor(root, node);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(2);\n  root.left.parent = root;\n  root.right = new program.BinaryTree(3);\n  root.right.parent = root;\n  root.left.left = new program.BinaryTree(4);\n  root.left.left.parent = root.left;\n  root.left.right = new program.BinaryTree(5);\n  root.left.right.parent = root.left;\n  root.left.left.left = new program.BinaryTree(6);\n  root.left.left.left.parent = root.left.left;\n  const node = root.left.right;\n  const expected = root;\n  const actual = program.findSuccessor(root, node);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "tree",
      "example": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "parent": "1",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "parent": "1",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "6",
            "parent": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "parent": "2",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "parent": "4",
            "right": null,
            "value": 6
          }
        ],
        "root": "1"
      },
      "schema": {
        "description": "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node.\nEvery node has to have a unique string <span>id</span> that will be referenced by other nodes'\n<span>left</span> and <span>right</span> pointers and by the <span>root</span>. The\n<span>parent</span> pointer of each node will be deduced from the collection of <span>nodes</span>.\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "left": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "right": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "left",
                "right"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "root": {
            "type": "string"
          }
        },
        "required": [
          "root",
          "nodes"
        ],
        "type": "object"
      }
    },
    {
      "name": "node",
      "example": "5",
      "schema": {
        "type": "string"
      }
    }
  ],
  "tests": [
    {
      "node": "5",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "parent": "1",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "parent": "1",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "6",
            "parent": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "parent": "2",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "parent": "4",
            "right": null,
            "value": 6
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "5",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "parent": "1",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "parent": "1",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "parent": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "6",
            "parent": "2",
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "parent": "5",
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "8",
            "parent": "5",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "parent": "7",
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "6",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "parent": "1",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "parent": "1",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "parent": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "parent": "2",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "parent": "3",
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "parent": "3",
            "right": null,
            "value": 7
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "2",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "parent": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "parent": "1",
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "parent": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "parent": "1",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "5",
            "parent": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "6",
            "parent": "4",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "7",
            "parent": "5",
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "parent": "6",
            "right": null,
            "value": 7
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "3",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "parent": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "parent": "2",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "5",
            "parent": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "parent": "4",
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "2",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "parent": "1",
            "right": "6",
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "parent": "2",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "5",
            "parent": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "parent": "4",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "7",
            "parent": "2",
            "right": "8",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "parent": "6",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "parent": "6",
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "parent": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "parent": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "parent": "1",
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "5",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "parent": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "parent": "2",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "parent": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "parent": "1",
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": "7",
            "parent": "5",
            "right": "8",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "parent": "6",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "parent": "6",
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "5",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "parent": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "parent": "2",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "parent": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "9",
            "parent": "1",
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": "7",
            "parent": "5",
            "right": "8",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "parent": "6",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "parent": "6",
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": "10",
            "parent": "5",
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": "11",
            "parent": "9",
            "right": null,
            "value": 10
          },
          {
            "id": "11",
            "left": null,
            "parent": "10",
            "right": null,
            "value": 11
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "parent": "1",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "parent": "1",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "6",
            "parent": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "parent": "2",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "parent": "4",
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "parent": "3",
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "parent": "7",
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    }
  ],
  "jsonTests": [
    {
      "node": "5",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "parent": "1",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "parent": "1",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "6",
            "parent": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "parent": "2",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "parent": "4",
            "right": null,
            "value": 6
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "5",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "parent": "1",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "parent": "1",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "parent": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "6",
            "parent": "2",
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "parent": "5",
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "8",
            "parent": "5",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "parent": "7",
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "6",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "parent": "1",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "parent": "1",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "parent": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "parent": "2",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "parent": "3",
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "parent": "3",
            "right": null,
            "value": 7
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "2",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "parent": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "parent": "1",
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "parent": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "parent": "1",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "5",
            "parent": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "6",
            "parent": "4",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "7",
            "parent": "5",
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "parent": "6",
            "right": null,
            "value": 7
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "3",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "parent": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "parent": "2",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "5",
            "parent": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "parent": "4",
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "2",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "parent": "1",
            "right": "6",
            "value": 2
          },
          {
            "id": "3",
            "left": "4",
            "parent": "2",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "5",
            "parent": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "parent": "4",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "7",
            "parent": "2",
            "right": "8",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "parent": "6",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "parent": "6",
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "parent": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "parent": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "parent": "1",
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "5",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "parent": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "parent": "2",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "parent": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "parent": "1",
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": "7",
            "parent": "5",
            "right": "8",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "parent": "6",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "parent": "6",
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "5",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "parent": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "parent": "2",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "parent": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "9",
            "parent": "1",
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": "7",
            "parent": "5",
            "right": "8",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "parent": "6",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "parent": "6",
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": "10",
            "parent": "5",
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": "11",
            "parent": "9",
            "right": null,
            "value": 10
          },
          {
            "id": "11",
            "left": null,
            "parent": "10",
            "right": null,
            "value": 11
          }
        ],
        "root": "1"
      }
    },
    {
      "node": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "parent": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "parent": "1",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "parent": "1",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "6",
            "parent": "2",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "parent": "2",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "parent": "4",
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "parent": "3",
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "parent": "7",
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    }
  ],
  "changelog": []
}