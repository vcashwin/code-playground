{
  "uid": "invert-binary-tree",
  "testStrategy": "JSON",
  "name": "Invert Binary Tree",
  "version": 0,
  "releaseDate": "2000-05-04T00:00:00Z",
  "category": "Binary Trees",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 48143,
    "failureCount": 10403
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "241868857",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1405
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in a Binary Tree and inverts it. In other words,\n  the function should swap every left node in the tree for its corresponding\n  right node.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">tree</span> =    1\n       /     \\\n      2       3\n    /   \\   /   \\\n   4     5 6     7\n /   \\\n8     9\n</pre>\n<h3>Sample Output</h3>\n<pre>\n       1\n    /     \\\n   3       2\n /   \\   /   \\\n7     6 5     4\n            /   \\\n           9     8\n</pre>\n</div>",
  "hints": [
    "<p>\nStart by inverting the root node of the Binary Tree. Inverting this root node simply consists of swapping its left and right child nodes, which can be done the same way as swapping two variables.\n</p>\n",
    "\n<p>\nOnce the first swap mentioned in Hint #1 is done, you must invert the root node's left child node and its right child node. You can do so just as you did for the root node. Then, you will have to continue inverting child nodes' nodes until you reach the bottom of the tree.\n</p>\n",
    "\n<p>\nHow can you accomplish the process described in Hint #2? While recursion seems appropriate, would an iterative approach work? What would be the time and space complexity implications of both approaches?\n</p>"
  ],
  "spaceTime": "O(n) time | O(d) space - where n is the number of nodes in the Binary Tree and d is the depth (height) of the Binary Tree",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": "tree",
    "outputType": "tree"
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left;\n  BinaryTree* right;\n\n  BinaryTree(int value);\n  void insert(vector<int> values, int i = 0);\n  void invertedInsert(vector<int> values, int i = 0);\n};\n\nvoid invertBinaryTree(BinaryTree* tree) {\n  // Write your code here.\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <deque>\n#include <vector>\nusing namespace std;\n\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left;\n  BinaryTree* right;\n\n  BinaryTree(int value);\n  void insert(vector<int> values, int i = 0);\n  void invertedInsert(vector<int> values, int i = 0);\n};\n\n// O(n) time | O(n) space\nvoid invertBinaryTree(BinaryTree* tree) {\n  deque<BinaryTree*> queue;\n  queue.push_back(tree);\n  while (queue.size() > 0) {\n    BinaryTree* current = queue.front();\n    queue.pop_front();\n    if (current == nullptr) {\n      continue;\n    }\n    swap(current->left, current->right);\n    queue.push_back(current->left);\n    queue.push_back(current->right);\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left;\n  BinaryTree* right;\n\n  BinaryTree(int value);\n  void insert(vector<int> values, int i = 0);\n  void invertedInsert(vector<int> values, int i = 0);\n};\n\n// O(n) time | O(d) space\nvoid invertBinaryTree(BinaryTree* tree) {\n  if (tree == nullptr) {\n    return;\n  }\n  swap(tree->left, tree->right);\n  invertBinaryTree(tree->left);\n  invertBinaryTree(tree->right);\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include <deque>\n\nBinaryTree::BinaryTree(int value) {\n  this->value = value;\n  this->left = nullptr;\n  this->right = nullptr;\n}\n\nvoid BinaryTree::insert(vector<int> values, int i) {\n  if (i >= values.size()) {\n    return;\n  }\n  deque<BinaryTree*> queue;\n  queue.push_back(this);\n  while (queue.size() > 0) {\n    BinaryTree* current = queue.front();\n    queue.pop_front();\n    if (current->left == nullptr) {\n      current->left = new BinaryTree(values[i]);\n      break;\n    }\n    queue.push_back(current->left);\n    if (current->right == nullptr) {\n      current->right = new BinaryTree(values[i]);\n      break;\n    }\n    queue.push_back(current->right);\n  }\n  this->insert(values, i + 1);\n}\n\nvoid BinaryTree::invertedInsert(vector<int> values, int i) {\n  if (i >= values.size()) {\n    return;\n  }\n  deque<BinaryTree*> queue;\n  queue.push_back(this);\n  while (queue.size() > 0) {\n    BinaryTree* current = queue.front();\n    queue.pop_front();\n    if (current->right == nullptr) {\n      current->right = new BinaryTree(values[i]);\n      break;\n    }\n    queue.push_back(current->right);\n    if (current->left == nullptr) {\n      current->left = new BinaryTree(values[i]);\n      break;\n    }\n    queue.push_back(current->left);\n  }\n  this->invertedInsert(values, i + 1);\n}\n\nbool compareBT(BinaryTree* a, BinaryTree* b) {\n  if (a == nullptr && b == nullptr) {\n    return true;\n  }\n  if (a != nullptr && b != nullptr) {\n    return a->value == b->value && compareBT(a->left, b->left) &&\n           compareBT(a->right, b->right);\n  }\n  return false;\n}\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree tree(1);\n      tree.insert({2, 3, 4, 5, 6, 7, 8, 9});\n      invertBinaryTree(&tree);\n      BinaryTree invertedTree(1);\n      invertedTree.invertedInsert({2, 3, 4, 5, 6, 7, 8, 9});\n      assert(compareBT(&tree, &invertedTree) == 1);\n    });\n  }\n};\n",
      "unitTests": "#include <deque>\n\nBinaryTree::BinaryTree(int value) {\n  this->value = value;\n  this->left = nullptr;\n  this->right = nullptr;\n}\n\nvoid BinaryTree::insert(vector<int> values, int i) {\n  if (i >= values.size()) {\n    return;\n  }\n  deque<BinaryTree*> queue;\n  queue.push_back(this);\n  while (queue.size() > 0) {\n    BinaryTree* current = queue.front();\n    queue.pop_front();\n    if (current->left == nullptr) {\n      current->left = new BinaryTree(values[i]);\n      break;\n    }\n    queue.push_back(current->left);\n    if (current->right == nullptr) {\n      current->right = new BinaryTree(values[i]);\n      break;\n    }\n    queue.push_back(current->right);\n  }\n  this->insert(values, i + 1);\n}\n\nvoid BinaryTree::invertedInsert(vector<int> values, int i) {\n  if (i >= values.size()) {\n    return;\n  }\n  deque<BinaryTree*> queue;\n  queue.push_back(this);\n  while (queue.size() > 0) {\n    BinaryTree* current = queue.front();\n    queue.pop_front();\n    if (current->right == nullptr) {\n      current->right = new BinaryTree(values[i]);\n      break;\n    }\n    queue.push_back(current->right);\n    if (current->left == nullptr) {\n      current->left = new BinaryTree(values[i]);\n      break;\n    }\n    queue.push_back(current->left);\n  }\n  this->invertedInsert(values, i + 1);\n}\n\nbool compareBT(BinaryTree* a, BinaryTree* b) {\n  if (a == nullptr && b == nullptr) {\n    return true;\n  }\n  if (a != nullptr && b != nullptr) {\n    return a->value == b->value && compareBT(a->left, b->left) &&\n           compareBT(a->right, b->right);\n  }\n  return false;\n}\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree tree(1);\n      tree.insert({2, 3, 4, 5, 6, 7, 8, 9});\n      invertBinaryTree(&tree);\n      BinaryTree invertedTree(1);\n      invertedTree.invertedInsert({2, 3, 4, 5, 6, 7, 8, 9});\n      assert(compareBT(&tree, &invertedTree) == 1);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public static void InvertBinaryTree(BinaryTree tree) {\n    // Write your code here.\n  }\n\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(n) time | O(n) space\n  public static void InvertBinaryTree(BinaryTree tree) {\n    List<BinaryTree> queue = new List<BinaryTree>();\n    queue.Add(tree);\n    var index = 0;\n    while (index < queue.Count) {\n      BinaryTree current = queue[index];\n      index += 1;\n      if (current == null) {\n        continue;\n      }\n      swapLeftAndRight(current);\n      if (current.left != null) {\n        queue.Add(current.left);\n      }\n      if (current.right != null) {\n        queue.Add(current.right);\n      }\n    }\n  }\n\n  private static void swapLeftAndRight(BinaryTree tree) {\n    BinaryTree left = tree.left;\n    tree.left = tree.right;\n    tree.right = left;\n  }\n\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n\npublic class Program {\n  // O(n) time | O(d) space\n  public static void InvertBinaryTree(BinaryTree tree) {\n    if (tree == null) {\n      return;\n    }\n    swapLeftAndRight(tree);\n    InvertBinaryTree(tree.left);\n    InvertBinaryTree(tree.right);\n  }\n\n  private static void swapLeftAndRight(BinaryTree tree) {\n    BinaryTree left = tree.left;\n    tree.left = tree.right;\n    tree.right = left;\n  }\n\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    TestBinaryTree tree = new TestBinaryTree(1);\n    tree.insert(new int[] { 2, 3, 4, 5, 6, 7, 8, 9 }, 0);\n    Program.InvertBinaryTree(tree);\n    InvertedBinaryTree invertedTree = new InvertedBinaryTree(1);\n    invertedTree.insert(new int[] { 2, 3, 4, 5, 6, 7, 8, 9 }, 0);\n    Utils.AssertTrue(compareBT(tree, invertedTree));\n  }\n\n  private bool compareBT(Program.BinaryTree tree1, InvertedBinaryTree tree2) {\n    if (tree1 == null && tree2 == null) {\n      return true;\n    }\n    if (tree1 != null && tree2 != null) {\n      return tree1.value == tree2.value && compareBT(tree1.left, tree2.left) &&\n             compareBT(tree1.right, tree2.right);\n    }\n    return false;\n  }\n\n  class InvertedBinaryTree {\n    public int value;\n    public InvertedBinaryTree left;\n    public InvertedBinaryTree right;\n\n    public InvertedBinaryTree(int value) {\n      this.value = value;\n    }\n\n    public void insert(int[] values, int i) {\n      if (i >= values.Length) {\n        return;\n      }\n      List<InvertedBinaryTree> queue = new List<InvertedBinaryTree>();\n      queue.Add(this);\n      var index = 0;\n      while (index < queue.Count) {\n        InvertedBinaryTree current = queue[index];\n        index += 1;\n        if (current.right == null) {\n          current.right = new InvertedBinaryTree(values[i]);\n          break;\n        }\n        queue.Add(current.right);\n        if (current.left == null) {\n          current.left = new InvertedBinaryTree(values[i]);\n          break;\n        }\n        queue.Add(current.left);\n      }\n      insert(values, i + 1);\n    }\n  }\n\n  public class TestBinaryTree : Program.BinaryTree {\n    public TestBinaryTree(int value) : base(value) {}\n\n    public void insert(int[] values, int i) {\n      if (i >= values.Length) {\n        return;\n      }\n      List<Program.BinaryTree> queue = new List<Program.BinaryTree>();\n      queue.Add(this);\n      var index = 0;\n      while (index < queue.Count) {\n        Program.BinaryTree current = queue[index];\n        index += 1;\n        if (current.left == null) {\n          current.left = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.Add(current.left);\n        if (current.right == null) {\n          current.right = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.Add(current.right);\n      }\n      insert(values, i + 1);\n    }\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    TestBinaryTree tree = new TestBinaryTree(1);\n    tree.insert(new int[] { 2, 3, 4, 5, 6, 7, 8, 9 }, 0);\n    Program.InvertBinaryTree(tree);\n    InvertedBinaryTree invertedTree = new InvertedBinaryTree(1);\n    invertedTree.insert(new int[] { 2, 3, 4, 5, 6, 7, 8, 9 }, 0);\n    Utils.AssertTrue(compareBT(tree, invertedTree));\n  }\n\n  private bool compareBT(Program.BinaryTree tree1, InvertedBinaryTree tree2) {\n    if (tree1 == null && tree2 == null) {\n      return true;\n    }\n    if (tree1 != null && tree2 != null) {\n      return tree1.value == tree2.value && compareBT(tree1.left, tree2.left) &&\n             compareBT(tree1.right, tree2.right);\n    }\n    return false;\n  }\n\n  class InvertedBinaryTree {\n    public int value;\n    public InvertedBinaryTree left;\n    public InvertedBinaryTree right;\n\n    public InvertedBinaryTree(int value) {\n      this.value = value;\n    }\n\n    public void insert(int[] values, int i) {\n      if (i >= values.Length) {\n        return;\n      }\n      List<InvertedBinaryTree> queue = new List<InvertedBinaryTree>();\n      queue.Add(this);\n      var index = 0;\n      while (index < queue.Count) {\n        InvertedBinaryTree current = queue[index];\n        index += 1;\n        if (current.right == null) {\n          current.right = new InvertedBinaryTree(values[i]);\n          break;\n        }\n        queue.Add(current.right);\n        if (current.left == null) {\n          current.left = new InvertedBinaryTree(values[i]);\n          break;\n        }\n        queue.Add(current.left);\n      }\n      insert(values, i + 1);\n    }\n  }\n\n  public class TestBinaryTree : Program.BinaryTree {\n    public TestBinaryTree(int value) : base(value) {}\n\n    public void insert(int[] values, int i) {\n      if (i >= values.Length) {\n        return;\n      }\n      List<Program.BinaryTree> queue = new List<Program.BinaryTree>();\n      queue.Add(this);\n      var index = 0;\n      while (index < queue.Count) {\n        Program.BinaryTree current = queue[index];\n        index += 1;\n        if (current.left == null) {\n          current.left = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.Add(current.left);\n        if (current.right == null) {\n          current.right = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.Add(current.right);\n      }\n      insert(values, i + 1);\n    }\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\nfunc (tree *BinaryTree) InvertBinaryTree() {\n\t// Write your code here.\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\n// O(n) time | O(n) space\nfunc (tree *BinaryTree) InvertBinaryTree() {\n\tqueue := []*BinaryTree{tree}\n\tfor len(queue) > 0 {\n\t\tcurrent := queue[0]\n\t\tqueue = queue[1:]\n\t\tif current == nil {\n\t\t\tcontinue\n\t\t}\n\t\tcurrent.Left, current.Right = current.Right, current.Left\n\t\tqueue = append(queue, current.Left, current.Right)\n\t}\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\n// O(n) time | O(d) space\nfunc (tree *BinaryTree) InvertBinaryTree() {\n\ttree.Left, tree.Right = tree.Right, tree.Left\n\tif tree.Left != nil {\n\t\ttree.Left.InvertBinaryTree()\n\t}\n\tif tree.Right != nil {\n\t\ttree.Right.InvertBinaryTree()\n\t}\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc NewBinaryTree(root int, values ...int) *BinaryTree {\n\ttree := &BinaryTree{Value: root}\n\tfor _, value := range values {\n\t\ttree.Insert(value)\n\t}\n\treturn tree\n}\n\nfunc (tree *BinaryTree) Insert(value int) *BinaryTree {\n\tqueue := []*BinaryTree{tree}\n\tfor len(queue) > 0 {\n\t\tcurrent := queue[0]\n\t\tqueue = queue[1:]\n\t\tif current.Left == nil {\n\t\t\tcurrent.Left = NewBinaryTree(value)\n\t\t\tbreak\n\t\t} else if current.Right == nil {\n\t\t\tcurrent.Right = NewBinaryTree(value)\n\t\t\tbreak\n\t\t}\n\t\tqueue = append(queue, current.Left, current.Right)\n\t}\n\treturn tree\n}\n\nfunc (tree *BinaryTree) InvertedInsert(value int) *BinaryTree {\n\tqueue := []*BinaryTree{tree}\n\tfor len(queue) > 0 {\n\t\tcurrent := queue[0]\n\t\tqueue = queue[1:]\n\t\tif current.Right == nil {\n\t\t\tcurrent.Right = NewBinaryTree(value)\n\t\t\tbreak\n\t\t} else if current.Left == nil {\n\t\t\tcurrent.Left = NewBinaryTree(value)\n\t\t\tbreak\n\t\t}\n\t\tqueue = append(queue, current.Right, current.Left)\n\t}\n\treturn tree\n}\n\nfunc (tree *BinaryTree) Equals(other *BinaryTree) bool {\n\tif other == nil || tree.Value != other.Value {\n\t\treturn false\n\t}\n\tif tree.Left != nil && !tree.Left.Equals(other.Left) {\n\t\treturn false\n\t}\n\tif tree.Right != nil && !tree.Right.Equals(other.Right) {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (tree *BinaryTree) InsertAll(values ...int) *BinaryTree {\n\tfor _, value := range values {\n\t\ttree.Insert(value)\n\t}\n\treturn tree\n}\n\nfunc (tree *BinaryTree) InvertedInsertAll(values ...int) *BinaryTree {\n\tfor _, value := range values {\n\t\ttree.InvertedInsert(value)\n\t}\n\treturn tree\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\toutput := NewBinaryTree(1).InsertAll(2, 3, 4, 5, 6, 7, 8, 9)\n\toutput.InvertBinaryTree()\n\texpected := NewBinaryTree(1).InvertedInsertAll(2, 3, 4, 5, 6, 7, 8, 9)\n\trequire.True(t, output.Equals(expected))\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc NewBinaryTree(root int, values ...int) *BinaryTree {\n\ttree := &BinaryTree{Value: root}\n\tfor _, value := range values {\n\t\ttree.Insert(value)\n\t}\n\treturn tree\n}\n\nfunc (tree *BinaryTree) Insert(value int) *BinaryTree {\n\tqueue := []*BinaryTree{tree}\n\tfor len(queue) > 0 {\n\t\tcurrent := queue[0]\n\t\tqueue = queue[1:]\n\t\tif current.Left == nil {\n\t\t\tcurrent.Left = NewBinaryTree(value)\n\t\t\tbreak\n\t\t} else if current.Right == nil {\n\t\t\tcurrent.Right = NewBinaryTree(value)\n\t\t\tbreak\n\t\t}\n\t\tqueue = append(queue, current.Left, current.Right)\n\t}\n\treturn tree\n}\n\nfunc (tree *BinaryTree) InvertedInsert(value int) *BinaryTree {\n\tqueue := []*BinaryTree{tree}\n\tfor len(queue) > 0 {\n\t\tcurrent := queue[0]\n\t\tqueue = queue[1:]\n\t\tif current.Right == nil {\n\t\t\tcurrent.Right = NewBinaryTree(value)\n\t\t\tbreak\n\t\t} else if current.Left == nil {\n\t\t\tcurrent.Left = NewBinaryTree(value)\n\t\t\tbreak\n\t\t}\n\t\tqueue = append(queue, current.Right, current.Left)\n\t}\n\treturn tree\n}\n\nfunc (tree *BinaryTree) Equals(other *BinaryTree) bool {\n\tif other == nil || tree.Value != other.Value {\n\t\treturn false\n\t}\n\tif tree.Left != nil && !tree.Left.Equals(other.Left) {\n\t\treturn false\n\t}\n\tif tree.Right != nil && !tree.Right.Equals(other.Right) {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (tree *BinaryTree) InsertAll(values ...int) *BinaryTree {\n\tfor _, value := range values {\n\t\ttree.Insert(value)\n\t}\n\treturn tree\n}\n\nfunc (tree *BinaryTree) InvertedInsertAll(values ...int) *BinaryTree {\n\tfor _, value := range values {\n\t\ttree.InvertedInsert(value)\n\t}\n\treturn tree\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\toutput := NewBinaryTree(1).InsertAll(2, 3, 4, 5, 6, 7, 8, 9)\n\toutput.InvertBinaryTree()\n\texpected := NewBinaryTree(1).InvertedInsertAll(2, 3, 4, 5, 6, 7, 8, 9)\n\trequire.True(t, output.Equals(expected))\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static void invertBinaryTree(BinaryTree tree) {\n    // Write your code here.\n  }\n\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.ArrayDeque;\n\nclass Program {\n  // O(n) time | O(n) space\n  public static void invertBinaryTree(BinaryTree tree) {\n    ArrayDeque<BinaryTree> queue = new ArrayDeque<BinaryTree>();\n    queue.addLast(tree);\n    while (queue.size() > 0) {\n      BinaryTree current = queue.pollFirst();\n      swapLeftAndRight(current);\n      if (current.left != null) {\n        queue.addLast(current.left);\n      }\n      if (current.right != null) {\n        queue.addLast(current.right);\n      }\n    }\n  }\n\n  private static void swapLeftAndRight(BinaryTree tree) {\n    BinaryTree left = tree.left;\n    tree.left = tree.right;\n    tree.right = left;\n  }\n\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(d) space\n  public static void invertBinaryTree(BinaryTree tree) {\n    if (tree == null) {\n      return;\n    }\n    swapLeftAndRight(tree);\n    invertBinaryTree(tree.left);\n    invertBinaryTree(tree.right);\n  }\n\n  private static void swapLeftAndRight(BinaryTree tree) {\n    BinaryTree left = tree.left;\n    tree.left = tree.right;\n    tree.right = left;\n  }\n\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.ArrayDeque;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    TestBinaryTree tree = new TestBinaryTree(1);\n    tree.insert(new int[] {2, 3, 4, 5, 6, 7, 8, 9}, 0);\n    Program.invertBinaryTree(tree);\n    InvertedBinaryTree invertedTree = new InvertedBinaryTree(1);\n    invertedTree.insert(new int[] {2, 3, 4, 5, 6, 7, 8, 9}, 0);\n    Utils.assertTrue(compareBT(tree, invertedTree));\n  }\n\n  private boolean compareBT(\n    Program.BinaryTree tree1, InvertedBinaryTree tree2\n  ) {\n    if (tree1 == null && tree2 == null) {\n      return true;\n    }\n    if (tree1 != null && tree2 != null) {\n      return tree1.value == tree2.value && compareBT(tree1.left, tree2.left)\n        && compareBT(tree1.right, tree2.right);\n    }\n    return false;\n  }\n\n  class InvertedBinaryTree {\n    public int value;\n    public InvertedBinaryTree left;\n    public InvertedBinaryTree right;\n\n    public InvertedBinaryTree(int value) {\n      this.value = value;\n    }\n\n    public void insert(int[] values, int i) {\n      if (i >= values.length) {\n        return;\n      }\n      ArrayDeque<InvertedBinaryTree> queue =\n        new ArrayDeque<InvertedBinaryTree>();\n      queue.addLast(this);\n      while (queue.size() > 0) {\n        InvertedBinaryTree current = queue.pollFirst();\n        if (current.right == null) {\n          current.right = new InvertedBinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.right);\n        if (current.left == null) {\n          current.left = new InvertedBinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.left);\n      }\n      insert(values, i + 1);\n    }\n  }\n\n  class TestBinaryTree extends Program.BinaryTree {\n    public TestBinaryTree(int value) {\n      super(value);\n    }\n\n    public void insert(int[] values, int i) {\n      if (i >= values.length) {\n        return;\n      }\n      ArrayDeque<Program.BinaryTree> queue =\n        new ArrayDeque<Program.BinaryTree>();\n      queue.addLast(this);\n      while (queue.size() > 0) {\n        Program.BinaryTree current = queue.pollFirst();\n        if (current.left == null) {\n          current.left = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.left);\n        if (current.right == null) {\n          current.right = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.right);\n      }\n      insert(values, i + 1);\n    }\n  }\n}\n",
      "unitTests": "import java.util.ArrayDeque;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    TestBinaryTree tree = new TestBinaryTree(1);\n    tree.insert(new int[] {2, 3, 4, 5, 6, 7, 8, 9}, 0);\n    Program.invertBinaryTree(tree);\n    InvertedBinaryTree invertedTree = new InvertedBinaryTree(1);\n    invertedTree.insert(new int[] {2, 3, 4, 5, 6, 7, 8, 9}, 0);\n    Utils.assertTrue(compareBT(tree, invertedTree));\n  }\n\n  private boolean compareBT(\n    Program.BinaryTree tree1, InvertedBinaryTree tree2\n  ) {\n    if (tree1 == null && tree2 == null) {\n      return true;\n    }\n    if (tree1 != null && tree2 != null) {\n      return tree1.value == tree2.value && compareBT(tree1.left, tree2.left)\n        && compareBT(tree1.right, tree2.right);\n    }\n    return false;\n  }\n\n  class InvertedBinaryTree {\n    public int value;\n    public InvertedBinaryTree left;\n    public InvertedBinaryTree right;\n\n    public InvertedBinaryTree(int value) {\n      this.value = value;\n    }\n\n    public void insert(int[] values, int i) {\n      if (i >= values.length) {\n        return;\n      }\n      ArrayDeque<InvertedBinaryTree> queue =\n        new ArrayDeque<InvertedBinaryTree>();\n      queue.addLast(this);\n      while (queue.size() > 0) {\n        InvertedBinaryTree current = queue.pollFirst();\n        if (current.right == null) {\n          current.right = new InvertedBinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.right);\n        if (current.left == null) {\n          current.left = new InvertedBinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.left);\n      }\n      insert(values, i + 1);\n    }\n  }\n\n  class TestBinaryTree extends Program.BinaryTree {\n    public TestBinaryTree(int value) {\n      super(value);\n    }\n\n    public void insert(int[] values, int i) {\n      if (i >= values.length) {\n        return;\n      }\n      ArrayDeque<Program.BinaryTree> queue =\n        new ArrayDeque<Program.BinaryTree>();\n      queue.addLast(this);\n      while (queue.size() > 0) {\n        Program.BinaryTree current = queue.pollFirst();\n        if (current.left == null) {\n          current.left = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.left);\n        if (current.right == null) {\n          current.right = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.right);\n      }\n      insert(values, i + 1);\n    }\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function invertBinaryTree(tree) {\n  // Write your code here.\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// Do not edit the line below.\nexports.invertBinaryTree = invertBinaryTree;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nfunction invertBinaryTree(tree) {\n  const queue = [tree];\n  while (queue.length) {\n    const current = queue.shift();\n    if (current === null) continue;\n    swapLeftAndRight(current);\n    queue.push(current.left);\n    queue.push(current.right);\n  }\n}\n\nfunction swapLeftAndRight(tree) {\n  const left = tree.left;\n  tree.left = tree.right;\n  tree.right = left;\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.invertBinaryTree = invertBinaryTree;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(d) space\nfunction invertBinaryTree(tree) {\n  if (tree === null) return;\n  swapLeftAndRight(tree);\n  invertBinaryTree(tree.left);\n  invertBinaryTree(tree.right);\n}\n\nfunction swapLeftAndRight(tree) {\n  const left = tree.left;\n  tree.left = tree.right;\n  tree.right = left;\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.invertBinaryTree = invertBinaryTree;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n\n  invertedInsert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n    }\n    this.invertedInsert(values, i + 1);\n    return this;\n  }\n}\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9]);\n  const invertedTree = new BinaryTree(1).invertedInsert([2, 3, 4, 5, 6, 7, 8, 9]);\n  program.invertBinaryTree(tree);\n  chai.expect(tree).to.deep.equal(invertedTree);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n\n  invertedInsert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n    }\n    this.invertedInsert(values, i + 1);\n    return this;\n  }\n}\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9]);\n  const invertedTree = new BinaryTree(1).invertedInsert([2, 3, 4, 5, 6, 7, 8, 9]);\n  program.invertBinaryTree(tree);\n  chai.expect(tree).to.deep.equal(invertedTree);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\nfun invertBinaryTree(tree: BinaryTree) {\n    // Write your code here.\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport java.util.ArrayDeque\n\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the Binary Tree\nfun invertBinaryTree(tree: BinaryTree) {\n    val queue = ArrayDeque<BinaryTree>()\n    queue.addLast(tree)\n    while (queue.size > 0) {\n        val current = queue.pollFirst()\n        swapLeftAndRight(current)\n        if (current.left != null) queue.addLast(current.left)\n        if (current.right != null) queue.addLast(current.right)\n    }\n}\n\nfun swapLeftAndRight(tree: BinaryTree) {\n    val left = tree.left\n    tree.left = tree.right\n    tree.right = left\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\n// O(n) time | O(d) space - where n is the number of nodes in the\n// Binary Tree and d is the depth (height) of the Binary Tree\nfun invertBinaryTree(tree: BinaryTree?) {\n    if (tree == null) return\n    swapLeftAndRight(tree)\n    invertBinaryTree(tree.left)\n    invertBinaryTree(tree.right)\n}\n\nfun swapLeftAndRight(tree: BinaryTree) {\n    val left = tree.left\n    tree.left = tree.right\n    tree.right = left\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.BinaryTree as BinaryTree\nimport com.algoexpert.program.invertBinaryTree as invertBinaryTree\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree = BinaryTree(1)\n        tree.left = BinaryTree(2)\n        tree.right = BinaryTree(3)\n        tree.left!!.left = BinaryTree(4)\n        tree.left!!.right = BinaryTree(5)\n        tree.right!!.left = BinaryTree(6)\n        tree.right!!.right = BinaryTree(7)\n        tree.left!!.left!!.left = BinaryTree(8)\n        tree.left!!.left!!.right = BinaryTree(9)\n\n        val invertedTree = BinaryTree(1)\n        invertedTree.left = BinaryTree(3)\n        invertedTree.right = BinaryTree(2)\n        invertedTree.left!!.left = BinaryTree(7)\n        invertedTree.left!!.right = BinaryTree(6)\n        invertedTree.right!!.left = BinaryTree(5)\n        invertedTree.right!!.right = BinaryTree(4)\n        invertedTree.right!!.right!!.left = BinaryTree(9)\n        invertedTree.right!!.right!!.right = BinaryTree(8)\n\n        invertBinaryTree(tree)\n\n        assert(treesAreEqual(tree, invertedTree))\n    }\n}\n\nfun treesAreEqual(treeOne: BinaryTree?, treeTwo: BinaryTree?): Boolean {\n    if (treeOne == null && treeTwo == null) return true\n    if (treeOne != null && treeTwo == null) return false\n    if (treeOne == null && treeTwo != null) return false\n    if (treeOne!!.value != treeTwo!!.value) return false\n    return treesAreEqual(treeOne.left, treeTwo.left) && treesAreEqual(treeOne.right, treeTwo.right)\n}\n",
      "unitTests": "import com.algoexpert.program.BinaryTree as BinaryTree\nimport com.algoexpert.program.invertBinaryTree as invertBinaryTree\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree = BinaryTree(1)\n        tree.left = BinaryTree(2)\n        tree.right = BinaryTree(3)\n        tree.left!!.left = BinaryTree(4)\n        tree.left!!.right = BinaryTree(5)\n        tree.right!!.left = BinaryTree(6)\n        tree.right!!.right = BinaryTree(7)\n        tree.left!!.left!!.left = BinaryTree(8)\n        tree.left!!.left!!.right = BinaryTree(9)\n\n        val invertedTree = BinaryTree(1)\n        invertedTree.left = BinaryTree(3)\n        invertedTree.right = BinaryTree(2)\n        invertedTree.left!!.left = BinaryTree(7)\n        invertedTree.left!!.right = BinaryTree(6)\n        invertedTree.right!!.left = BinaryTree(5)\n        invertedTree.right!!.right = BinaryTree(4)\n        invertedTree.right!!.right!!.left = BinaryTree(9)\n        invertedTree.right!!.right!!.right = BinaryTree(8)\n\n        invertBinaryTree(tree)\n\n        assert(treesAreEqual(tree, invertedTree))\n    }\n}\n\nfun treesAreEqual(treeOne: BinaryTree?, treeTwo: BinaryTree?): Boolean {\n    if (treeOne == null && treeTwo == null) return true\n    if (treeOne != null && treeTwo == null) return false\n    if (treeOne == null && treeTwo != null) return false\n    if (treeOne!!.value != treeTwo!!.value) return false\n    return treesAreEqual(treeOne.left, treeTwo.left) && treesAreEqual(treeOne.right, treeTwo.right)\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def invertBinaryTree(tree):\n    # Write your code here.\n    pass\n\n\n# This is the class of the input binary tree.\nclass BinaryTree:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space\ndef invertBinaryTree(tree):\n    queue = [tree]\n    while len(queue):\n        current = queue.pop(0)\n        if current is None:\n            continue\n        swapLeftAndRight(current)\n        queue.append(current.left)\n        queue.append(current.right)\n\n\ndef swapLeftAndRight(tree):\n    tree.left, tree.right = tree.right, tree.left\n\n\n# This is the class of the input binary tree.\nclass BinaryTree:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(d) space\ndef invertBinaryTree(tree):\n    if tree is None:\n        return\n    swapLeftAndRight(tree)\n    invertBinaryTree(tree.left)\n    invertBinaryTree(tree.right)\n\n\ndef swapLeftAndRight(tree):\n    tree.left, tree.right = tree.right, tree.left\n\n\n# This is the class of the input binary tree.\nclass BinaryTree:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass BinaryTree:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n    def __eq__(self, other):\n        return isinstance(other, type(self)) and self.__dict__ == other.__dict__\n\n    def insert(self, values, i=0):\n        if i >= len(values):\n            return\n        queue = [self]\n        while len(queue) > 0:\n            current = queue.pop(0)\n            if current.left is None:\n                current.left = BinaryTree(values[i])\n                break\n            queue.append(current.left)\n            if current.right is None:\n                current.right = BinaryTree(values[i])\n                break\n            queue.append(current.right)\n        self.insert(values, i + 1)\n        return self\n\n    def invertedInsert(self, values, i=0):\n        if i >= len(values):\n            return\n        queue = [self]\n        while len(queue) > 0:\n            current = queue.pop(0)\n            if current.right is None:\n                current.right = BinaryTree(values[i])\n                break\n            queue.append(current.right)\n            if current.left is None:\n                current.left = BinaryTree(values[i])\n                break\n            queue.append(current.left)\n        self.invertedInsert(values, i + 1)\n        return self\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        tree = BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9])\n        invertedTree = BinaryTree(1).invertedInsert([2, 3, 4, 5, 6, 7, 8, 9])\n        program.invertBinaryTree(tree)\n        self.assertTrue(tree.__eq__(invertedTree))\n",
      "unitTests": "import program\nimport unittest\n\n\nclass BinaryTree:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n    def __eq__(self, other):\n        return isinstance(other, type(self)) and self.__dict__ == other.__dict__\n\n    def insert(self, values, i=0):\n        if i >= len(values):\n            return\n        queue = [self]\n        while len(queue) > 0:\n            current = queue.pop(0)\n            if current.left is None:\n                current.left = BinaryTree(values[i])\n                break\n            queue.append(current.left)\n            if current.right is None:\n                current.right = BinaryTree(values[i])\n                break\n            queue.append(current.right)\n        self.insert(values, i + 1)\n        return self\n\n    def invertedInsert(self, values, i=0):\n        if i >= len(values):\n            return\n        queue = [self]\n        while len(queue) > 0:\n            current = queue.pop(0)\n            if current.right is None:\n                current.right = BinaryTree(values[i])\n                break\n            queue.append(current.right)\n            if current.left is None:\n                current.left = BinaryTree(values[i])\n                break\n            queue.append(current.left)\n        self.invertedInsert(values, i + 1)\n        return self\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        tree = BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9])\n        invertedTree = BinaryTree(1).invertedInsert([2, 3, 4, 5, 6, 7, 8, 9])\n        program.invertBinaryTree(tree)\n        self.assertTrue(tree.__eq__(invertedTree))\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def invertBinaryTree(tree)\n    # Write your code here.\n    return nil\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\ndef invertBinaryTree(tree)\n  queue = [tree]\n  while queue.count != 0\n    current = queue.shift()\n    if current == nil\n      next\n    end\n    current.left, current.right = current.right, current.left\n    queue << current.left\n    queue << current.right\n  end\n  return tree\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def invertBinaryTree(tree)\n    # Write your code here.\n    return nil\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.invertBinaryTree\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.invertBinaryTree\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "// class BinaryTree: Equatable {\n//   var value: Int?\n//   var left: BinaryTree?\n//   var right: BinaryTree?\n// }\n\nclass Program {\n  func invertBinaryTree(tree: BinaryTree?) {\n    // Write your code here.\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space\n  func invertBinaryTree(tree: BinaryTree?) {\n    var queue: [BinaryTree?] = [tree]\n\n    while queue.count > 0 {\n      let current = queue.removeFirst()\n\n      if current === nil {\n        continue\n      }\n\n      swapLeftAndright(tree: current!)\n      queue.append(current?.left)\n      queue.append(current?.right)\n    }\n  }\n\n  func swapLeftAndright(tree: BinaryTree) {\n    let left = tree.left\n    tree.left = tree.right\n    tree.right = left\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(d) space\n  func invertBinaryTree(tree: BinaryTree?) {\n    if let tree = tree {\n      swapLeftAndright(tree: tree)\n      invertBinaryTree(tree: tree.left)\n      invertBinaryTree(tree: tree.right)\n    }\n  }\n\n  func swapLeftAndright(tree: BinaryTree) {\n    let left = tree.left\n    tree.left = tree.right\n    tree.right = left\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func compareBT(firstTree: BinaryTree?, secondTree: BinaryTree?) -> Bool {\n    if firstTree === nil, secondTree === nil {\n      return true\n    }\n\n    if firstTree !== nil, secondTree !== nil {\n      return firstTree!.value == secondTree!.value && compareBT(firstTree: firstTree?.left, secondTree: secondTree?.left) && compareBT(firstTree: firstTree?.right, secondTree: secondTree?.right)\n    }\n\n    return false\n  }\n\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let tree = BinaryTree(value: 1).insert(values: [2, 3, 4, 5, 6, 7, 8, 9], index: 0)\n      let invertedTree = BinaryTree(value: 1).invertedInsert(values: [2, 3, 4, 5, 6, 7, 8, 9], index: 0)\n      program.invertBinaryTree(tree: tree)\n      try assert(compareBT(firstTree: tree, secondTree: invertedTree))\n    }\n  }\n}\n\nclass BinaryTree {\n  var value: Int?\n  var left: BinaryTree?\n  var right: BinaryTree?\n\n  init(value: Int) {\n    self.value = value\n    left = nil\n    right = nil\n  }\n\n  func insert(values: [Int], index: Int) -> BinaryTree? {\n    if index >= values.count { return nil }\n\n    var queue: [BinaryTree?] = [self]\n\n    while queue.count > 0 {\n      let current = queue.removeFirst()\n\n      if current?.left === nil {\n        current?.left = BinaryTree(value: values[index])\n        break\n      }\n\n      queue.append(current?.left)\n\n      if current?.right === nil {\n        current?.right = BinaryTree(value: values[index])\n        break\n      }\n\n      queue.append(current?.right)\n    }\n\n    insert(values: values, index: index + 1)\n\n    return self\n  }\n\n  func invertedInsert(values: [Int], index: Int) -> BinaryTree? {\n    if index >= values.count { return nil }\n\n    var queue: [BinaryTree?] = [self]\n\n    while queue.count > 0 {\n      let current = queue.removeFirst()\n\n      if current?.right === nil {\n        current?.right = BinaryTree(value: values[index])\n        break\n      }\n\n      queue.append(current?.right)\n\n      if current?.left === nil {\n        current?.left = BinaryTree(value: values[index])\n        break\n      }\n\n      queue.append(current?.left)\n    }\n\n    invertedInsert(values: values, index: index + 1)\n\n    return self\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func compareBT(firstTree: BinaryTree?, secondTree: BinaryTree?) -> Bool {\n    if firstTree === nil, secondTree === nil {\n      return true\n    }\n\n    if firstTree !== nil, secondTree !== nil {\n      return firstTree!.value == secondTree!.value && compareBT(firstTree: firstTree?.left, secondTree: secondTree?.left) && compareBT(firstTree: firstTree?.right, secondTree: secondTree?.right)\n    }\n\n    return false\n  }\n\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let tree = BinaryTree(value: 1).insert(values: [2, 3, 4, 5, 6, 7, 8, 9], index: 0)\n      let invertedTree = BinaryTree(value: 1).invertedInsert(values: [2, 3, 4, 5, 6, 7, 8, 9], index: 0)\n      program.invertBinaryTree(tree: tree)\n      try assert(compareBT(firstTree: tree, secondTree: invertedTree))\n    }\n  }\n}\n\nclass BinaryTree {\n  var value: Int?\n  var left: BinaryTree?\n  var right: BinaryTree?\n\n  init(value: Int) {\n    self.value = value\n    left = nil\n    right = nil\n  }\n\n  func insert(values: [Int], index: Int) -> BinaryTree? {\n    if index >= values.count { return nil }\n\n    var queue: [BinaryTree?] = [self]\n\n    while queue.count > 0 {\n      let current = queue.removeFirst()\n\n      if current?.left === nil {\n        current?.left = BinaryTree(value: values[index])\n        break\n      }\n\n      queue.append(current?.left)\n\n      if current?.right === nil {\n        current?.right = BinaryTree(value: values[index])\n        break\n      }\n\n      queue.append(current?.right)\n    }\n\n    insert(values: values, index: index + 1)\n\n    return self\n  }\n\n  func invertedInsert(values: [Int], index: Int) -> BinaryTree? {\n    if index >= values.count { return nil }\n\n    var queue: [BinaryTree?] = [self]\n\n    while queue.count > 0 {\n      let current = queue.removeFirst()\n\n      if current?.right === nil {\n        current?.right = BinaryTree(value: values[index])\n        break\n      }\n\n      queue.append(current?.right)\n\n      if current?.left === nil {\n        current?.left = BinaryTree(value: values[index])\n        break\n      }\n\n      queue.append(current?.left)\n    }\n\n    invertedInsert(values: values, index: index + 1)\n\n    return self\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport function invertBinaryTree(tree: BinaryTree | null) {\n  // Write your code here.\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(n) space\nexport function invertBinaryTree(tree: BinaryTree | null) {\n  const queue: Array<BinaryTree | null> = [tree];\n  while (queue.length) {\n    const current = queue.shift()!;\n    if (current === null) continue;\n    swapLeftAndRight(current);\n    queue.push(current.left);\n    queue.push(current.right);\n  }\n}\n\nfunction swapLeftAndRight(tree: BinaryTree) {\n  const left = tree.left;\n  tree.left = tree.right;\n  tree.right = left;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(d) space\nexport function invertBinaryTree(tree: BinaryTree | null) {\n  if (tree === null) return;\n  swapLeftAndRight(tree);\n  invertBinaryTree(tree.left);\n  invertBinaryTree(tree.right);\n}\n\nfunction swapLeftAndRight(tree: BinaryTree) {\n  const left = tree.left;\n  tree.left = tree.right;\n  tree.right = left;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(values: number[], i = 0): BinaryTree {\n    if (i >= values.length) return this;\n    const queue: BinaryTree[] = [this];\n    while (queue.length > 0) {\n      let current = queue.shift()!;\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n\n  invertedInsert(values: number[], i = 0): BinaryTree {\n    if (i >= values.length) return this;\n    const queue: BinaryTree[] = [this];\n    while (queue.length > 0) {\n      let current = queue.shift()!;\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n    }\n    this.invertedInsert(values, i + 1);\n    return this;\n  }\n}\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9]);\n  const invertedTree = new BinaryTree(1).invertedInsert([2, 3, 4, 5, 6, 7, 8, 9]);\n  program.invertBinaryTree(tree);\n  chai.expect(tree).to.deep.equal(invertedTree);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(values: number[], i = 0): BinaryTree {\n    if (i >= values.length) return this;\n    const queue: BinaryTree[] = [this];\n    while (queue.length > 0) {\n      let current = queue.shift()!;\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n\n  invertedInsert(values: number[], i = 0): BinaryTree {\n    if (i >= values.length) return this;\n    const queue: BinaryTree[] = [this];\n    while (queue.length > 0) {\n      let current = queue.shift()!;\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n    }\n    this.invertedInsert(values, i + 1);\n    return this;\n  }\n}\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9]);\n  const invertedTree = new BinaryTree(1).invertedInsert([2, 3, 4, 5, 6, 7, 8, 9]);\n  program.invertBinaryTree(tree);\n  chai.expect(tree).to.deep.equal(invertedTree);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "tree",
      "example": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      },
      "schema": {
        "description": "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "left": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "right": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "left",
                "right"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "root": {
            "type": "string"
          }
        },
        "required": [
          "root",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "5",
            "left": "10",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "5",
            "left": "10",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": "11",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": "12",
            "value": 8
          },
          {
            "id": "9",
            "left": "13",
            "right": "14",
            "value": 9
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "11",
            "left": "15",
            "right": "16",
            "value": 11
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "13",
            "left": null,
            "right": null,
            "value": 13
          },
          {
            "id": "14",
            "left": null,
            "right": null,
            "value": 14
          },
          {
            "id": "15",
            "left": null,
            "right": "17",
            "value": 15
          },
          {
            "id": "16",
            "left": null,
            "right": null,
            "value": 16
          },
          {
            "id": "17",
            "left": null,
            "right": "18",
            "value": 17
          },
          {
            "id": "18",
            "left": null,
            "right": "19",
            "value": 18
          },
          {
            "id": "19",
            "left": "20",
            "right": null,
            "value": 19
          },
          {
            "id": "20",
            "left": "21",
            "right": null,
            "value": 20
          },
          {
            "id": "21",
            "left": null,
            "right": null,
            "value": 21
          }
        ],
        "root": "1"
      }
    }
  ],
  "jsonTests": [
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "5",
            "left": "10",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "5",
            "left": "10",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": "11",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": "12",
            "value": 8
          },
          {
            "id": "9",
            "left": "13",
            "right": "14",
            "value": 9
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "11",
            "left": "15",
            "right": "16",
            "value": 11
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "13",
            "left": null,
            "right": null,
            "value": 13
          },
          {
            "id": "14",
            "left": null,
            "right": null,
            "value": 14
          },
          {
            "id": "15",
            "left": null,
            "right": "17",
            "value": 15
          },
          {
            "id": "16",
            "left": null,
            "right": null,
            "value": 16
          },
          {
            "id": "17",
            "left": null,
            "right": "18",
            "value": 17
          },
          {
            "id": "18",
            "left": null,
            "right": "19",
            "value": 18
          },
          {
            "id": "19",
            "left": "20",
            "right": null,
            "value": 19
          },
          {
            "id": "20",
            "left": "21",
            "right": null,
            "value": 20
          },
          {
            "id": "21",
            "left": null,
            "right": null,
            "value": 21
          }
        ],
        "root": "1"
      }
    }
  ],
  "changelog": []
}