{
  "uid": "iterative-in-order-traversal",
  "testStrategy": "JSON",
  "name": "Iterative In-order Traversal",
  "version": 0,
  "releaseDate": "2000-05-04T00:00:00Z",
  "category": "Binary Trees",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 8977,
    "failureCount": 2085
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "249313089",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1242
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in a Binary Tree (where nodes have an additional\n  pointer to their parent node) and traverses it iteratively using the in-order\n  tree-traversal technique; the traversal should specifically <i>not</i> use\n  recursion. As the tree is being traversed, a callback function passed in as an\n  argument to the main function should be called on each node (i.e.,\n  <span>callback(currentNode)</span>).\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>parent</span> node, a <span>left</span> child node, and a\n  <span>right</span> child node. Children nodes can either be\n  <span>BinaryTree</span> nodes themselves or <span>None</span> /\n  <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">tree</span> =    1\n       /     \\\n      2       3\n    /       /   \\\n   4       6     7\n     \\\n      9\n<span class=\"CodeEditor-promptParameter\">callback</span> = someCallback\n</pre>\n<h3>Sample Output</h3>\n<pre>\n<span class=\"CodeEditor-promptComment\">// The input callback will have been called in the following order:</span>\ncallback(4)\ncallback(9)\ncallback(2)\ncallback(1)\ncallback(6)\ncallback(3)\ncallback(7)\n</pre>\n</div>",
  "hints": [
    "<p>\nStart by realizing that in-order traversal always traverses left child nodes before parent nodes before right child nodes. In other words, you will somehow have to traverse the entire left side of the input Binary Tree before calling the input callback on the root node and before traversing the entire right side.\n</p>\n",
    "\n<p>\nWhile each node in the input Binary Tree does have a \"parent\" property, allowing you to traverse your way back up the tree if need be, the difficulty arises when you must choose which node to actually call the input callback on. For instance, on your way back up the left side of the input tree, how do you know whether to traverse the right side of a node or to keep going up? Is there something that you can keep track of in order to know which node to call the input callback back on next at any time during the life of your algorithm?\n</p>\n",
    "\n<p>\nTry keeping track of three nodes at all times: a current node (the node currently being traversed), a previous node (the node traversed just before the current one), and a next node (the next node to be traversed). Determine which node to traverse next and when to call the input callback on the current node by analyzing the previous node. For instance, if the previous node is actually the current node's left child node, then you know that you must call the callback on the current node and that you must then explore the right side of the current node before going back up. Figure out all of the possible scenarios, and develop an algorithm to handle all of these scenarios.\n</p>"
  ],
  "spaceTime": "O(n) time | O(1) space - where n is the number of nodes in the Binary Tree",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": "tree",
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left;\n  BinaryTree* right;\n  BinaryTree* parent;\n\n  BinaryTree(int value, BinaryTree* parent = nullptr);\n  void insert(vector<int> values, int i = 0);\n};\n\nvoid iterativeInOrderTraversal(\n  BinaryTree* tree, void (*callback)(BinaryTree* tree)\n) {\n  // Write your code here.\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left;\n  BinaryTree* right;\n  BinaryTree* parent;\n\n  BinaryTree(int value, BinaryTree* parent = nullptr);\n  void insert(vector<int> values, int i = 0);\n};\n\n// O(n) time | O(1) space\nvoid iterativeInOrderTraversal(\n  BinaryTree* tree, void (*callback)(BinaryTree* tree)\n) {\n  BinaryTree* previousNode = nullptr;\n  BinaryTree* currentNode = tree;\n  while (currentNode != nullptr) {\n    BinaryTree* nextNode;\n    if (previousNode == nullptr || previousNode == currentNode->parent) {\n      if (currentNode->left != nullptr) {\n        nextNode = currentNode->left;\n      } else {\n        (*callback)(currentNode);\n        nextNode = currentNode->right != nullptr ? currentNode->right\n                                                 : currentNode->parent;\n      }\n    } else if (previousNode == currentNode->left) {\n      (*callback)(currentNode);\n      nextNode = currentNode->right != nullptr ? currentNode->right\n                                               : currentNode->parent;\n    } else {\n      nextNode = currentNode->parent;\n    }\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include <deque>\n\nBinaryTree::BinaryTree(int value, BinaryTree* parent) {\n  this->value = value;\n  this->left = nullptr;\n  this->right = nullptr;\n  this->parent = parent;\n}\n\nvector<int> testArray = {};\n\nvoid testCallback(BinaryTree* tree) {\n  if (tree == nullptr) {\n    return;\n  }\n  testArray.push_back(tree->value);\n}\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree* root = new BinaryTree(1, nullptr);\n      root->left = new BinaryTree(2, root);\n      root->left->left = new BinaryTree(4, root->left);\n      root->left->left->right = new BinaryTree(9, root->left->left);\n      root->right = new BinaryTree(3, root);\n      root->right->left = new BinaryTree(6, root->right);\n      root->right->right = new BinaryTree(7, root->right);\n\n      testArray = {};\n      iterativeInOrderTraversal(root, &testCallback);\n      vector<int> expected{4, 9, 2, 1, 6, 3, 7};\n      assert(testArray == expected);\n    });\n  }\n};\n",
      "unitTests": "#include <deque>\n\nBinaryTree::BinaryTree(int value, BinaryTree* parent) {\n  this->value = value;\n  this->left = nullptr;\n  this->right = nullptr;\n  this->parent = parent;\n}\n\nvector<int> testArray = {};\n\nvoid testCallback(BinaryTree* tree) {\n  if (tree == nullptr) {\n    return;\n  }\n  testArray.push_back(tree->value);\n}\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree* root = new BinaryTree(1, nullptr);\n      root->left = new BinaryTree(2, root);\n      root->left->left = new BinaryTree(4, root->left);\n      root->left->left->right = new BinaryTree(9, root->left->left);\n      root->right = new BinaryTree(3, root);\n      root->right->left = new BinaryTree(6, root->right);\n      root->right->right = new BinaryTree(7, root->right);\n\n      testArray = {};\n      iterativeInOrderTraversal(root, &testCallback);\n      vector<int> expected{4, 9, 2, 1, 6, 3, 7};\n      assert(testArray == expected);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public static void IterativeInOrderTraversal(\n    BinaryTree tree, Action<BinaryTree> callback\n  ) {\n    // Write your code here.\n  }\n\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n    public BinaryTree parent;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n\n    public BinaryTree(int value, BinaryTree parent) {\n      this.value = value;\n      this.parent = parent;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // O(n) time | O(1) space\n  public static void IterativeInOrderTraversal(\n    BinaryTree tree, Action<BinaryTree> callback\n  ) {\n    BinaryTree previousNode = null;\n    BinaryTree currentNode = tree;\n    while (currentNode != null) {\n      BinaryTree nextNode;\n      if (previousNode == null || previousNode == currentNode.parent) {\n        if (currentNode.left != null) {\n          nextNode = currentNode.left;\n        } else {\n          callback(currentNode);\n          nextNode =\n            currentNode.right != null ? currentNode.right : currentNode.parent;\n        }\n      } else if (previousNode == currentNode.left) {\n        callback(currentNode);\n        nextNode =\n          currentNode.right != null ? currentNode.right : currentNode.parent;\n      } else {\n        nextNode = currentNode.parent;\n      }\n      previousNode = currentNode;\n      currentNode = nextNode;\n    }\n  }\n\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n    public BinaryTree parent;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n\n    public BinaryTree(int value, BinaryTree parent) {\n      this.value = value;\n      this.parent = parent;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  public List<int> testArray = new List<int>();\n\n  void testCallback(Program.BinaryTree tree) {\n    if (tree == null) {\n      return;\n    }\n    testArray.Add(tree.value);\n    return;\n  }\n\n  [Test]\n  public void TestCase1() {\n    var root = new Program.BinaryTree(1);\n    root.left = new Program.BinaryTree(2, root);\n    root.left.left = new Program.BinaryTree(4, root.left);\n    root.left.left.right = new Program.BinaryTree(9, root.left.left);\n    root.right = new Program.BinaryTree(3, root);\n    root.right.left = new Program.BinaryTree(6, root.right);\n    root.right.right = new Program.BinaryTree(7, root.right);\n\n    testArray.Clear();\n    Program.IterativeInOrderTraversal(root, testCallback);\n    Utils.AssertTrue(\n      Enumerable.SequenceEqual(testArray, new List<int> { 4, 9, 2, 1, 6, 3, 7 })\n    );\n  }\n}\n",
      "unitTests": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  public List<int> testArray = new List<int>();\n\n  void testCallback(Program.BinaryTree tree) {\n    if (tree == null) {\n      return;\n    }\n    testArray.Add(tree.value);\n    return;\n  }\n\n  [Test]\n  public void TestCase1() {\n    var root = new Program.BinaryTree(1);\n    root.left = new Program.BinaryTree(2, root);\n    root.left.left = new Program.BinaryTree(4, root.left);\n    root.left.left.right = new Program.BinaryTree(9, root.left.left);\n    root.right = new Program.BinaryTree(3, root);\n    root.right.left = new Program.BinaryTree(6, root.right);\n    root.right.right = new Program.BinaryTree(7, root.right);\n\n    testArray.Clear();\n    Program.IterativeInOrderTraversal(root, testCallback);\n    Utils.AssertTrue(\n      Enumerable.SequenceEqual(testArray, new List<int> { 4, 9, 2, 1, 6, 3, 7 })\n    );\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\ntype BinaryTree struct {\n\tValue int\n\n\tLeft   *BinaryTree\n\tRight  *BinaryTree\n\tParent *BinaryTree\n}\n\nfunc (tree *BinaryTree) IterativeInOrderTraversal(callback func(int)) {\n\t// Write your code here.\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype BinaryTree struct {\n\tValue int\n\n\tLeft   *BinaryTree\n\tRight  *BinaryTree\n\tParent *BinaryTree\n}\n\n// O(n) time | O(1) space\nfunc (tree *BinaryTree) IterativeInOrderTraversal(callback func(int)) {\n\tvar previous, next *BinaryTree\n\tcurrent := tree\n\tfor current != nil {\n\t\tif previous == nil || previous == current.Parent {\n\t\t\tif current.Left != nil {\n\t\t\t\tnext = current.Left\n\t\t\t} else {\n\t\t\t\tcallback(current.Value)\n\t\t\t\tif current.Right != nil {\n\t\t\t\t\tnext = current.Right\n\t\t\t\t} else {\n\t\t\t\t\tnext = current.Parent\n\t\t\t\t}\n\t\t\t}\n\t\t} else if previous == current.Left {\n\t\t\tcallback(current.Value)\n\t\t\tif current.Right != nil {\n\t\t\t\tnext = current.Right\n\t\t\t} else {\n\t\t\t\tnext = current.Parent\n\t\t\t}\n\t\t} else {\n\t\t\tnext = current.Parent\n\t\t}\n\t\tprevious, current = current, next\n\t}\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc NewBinaryTree(root int, parent *BinaryTree) *BinaryTree {\n\treturn &BinaryTree{Value: root, Parent: parent}\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\troot := NewBinaryTree(1, nil)\n\troot.Left = NewBinaryTree(2, root)\n\troot.Left.Left = NewBinaryTree(4, root.Left)\n\troot.Left.Left.Right = NewBinaryTree(9, root.Left.Left)\n\troot.Right = NewBinaryTree(3, root)\n\troot.Right.Left = NewBinaryTree(6, root.Right)\n\troot.Right.Right = NewBinaryTree(7, root.Right)\n\n\toutput := []int{}\n\troot.IterativeInOrderTraversal(func(i int) {\n\t\toutput = append(output, i)\n\t})\n\texpected := []int{4, 9, 2, 1, 6, 3, 7}\n\trequire.Equal(t, expected, output)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc NewBinaryTree(root int, parent *BinaryTree) *BinaryTree {\n\treturn &BinaryTree{Value: root, Parent: parent}\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\troot := NewBinaryTree(1, nil)\n\troot.Left = NewBinaryTree(2, root)\n\troot.Left.Left = NewBinaryTree(4, root.Left)\n\troot.Left.Left.Right = NewBinaryTree(9, root.Left.Left)\n\troot.Right = NewBinaryTree(3, root)\n\troot.Right.Left = NewBinaryTree(6, root.Right)\n\troot.Right.Right = NewBinaryTree(7, root.Right)\n\n\toutput := []int{}\n\troot.IterativeInOrderTraversal(func(i int) {\n\t\toutput = append(output, i)\n\t})\n\texpected := []int{4, 9, 2, 1, 6, 3, 7}\n\trequire.Equal(t, expected, output)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.function.Function;\n\nclass Program {\n  public static void iterativeInOrderTraversal(\n    BinaryTree tree, Function<BinaryTree, Void> callback\n  ) {\n    // Write your code here.\n  }\n\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n    public BinaryTree parent;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n\n    public BinaryTree(int value, BinaryTree parent) {\n      this.value = value;\n      this.parent = parent;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.function.Function;\n\nclass Program {\n  // O(n) time | O(1) space\n  public static void iterativeInOrderTraversal(\n    BinaryTree tree, Function<BinaryTree, Void> callback\n  ) {\n    BinaryTree previousNode = null;\n    BinaryTree currentNode = tree;\n    while (currentNode != null) {\n      BinaryTree nextNode;\n      if (previousNode == null || previousNode == currentNode.parent) {\n        if (currentNode.left != null) {\n          nextNode = currentNode.left;\n        } else {\n          callback.apply(currentNode);\n          nextNode =\n            currentNode.right != null ? currentNode.right : currentNode.parent;\n        }\n      } else if (previousNode == currentNode.left) {\n        callback.apply(currentNode);\n        nextNode =\n          currentNode.right != null ? currentNode.right : currentNode.parent;\n      } else {\n        nextNode = currentNode.parent;\n      }\n      previousNode = currentNode;\n      currentNode = nextNode;\n    }\n  }\n\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n    public BinaryTree parent;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n\n    public BinaryTree(int value, BinaryTree parent) {\n      this.value = value;\n      this.parent = parent;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  public List<Integer> testArray = new ArrayList<Integer>();\n\n  public Void testCallback(Program.BinaryTree tree) {\n    if (tree == null) {\n      return null;\n    }\n    testArray.add(tree.value);\n    return null;\n  }\n\n  @Test\n  public void TestCase1() {\n    var root = new Program.BinaryTree(1);\n    root.left = new Program.BinaryTree(2, root);\n    root.left.left = new Program.BinaryTree(4, root.left);\n    root.left.left.right = new Program.BinaryTree(9, root.left.left);\n    root.right = new Program.BinaryTree(3, root);\n    root.right.left = new Program.BinaryTree(6, root.right);\n    root.right.right = new Program.BinaryTree(7, root.right);\n\n    this.testArray.clear();\n    Program.iterativeInOrderTraversal(root, this::testCallback);\n    List<Integer> expected = Arrays.asList(new Integer[] {4, 9, 2, 1, 6, 3, 7});\n    Utils.assertTrue(expected.equals(this.testArray));\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  public List<Integer> testArray = new ArrayList<Integer>();\n\n  public Void testCallback(Program.BinaryTree tree) {\n    if (tree == null) {\n      return null;\n    }\n    testArray.add(tree.value);\n    return null;\n  }\n\n  @Test\n  public void TestCase1() {\n    var root = new Program.BinaryTree(1);\n    root.left = new Program.BinaryTree(2, root);\n    root.left.left = new Program.BinaryTree(4, root.left);\n    root.left.left.right = new Program.BinaryTree(9, root.left.left);\n    root.right = new Program.BinaryTree(3, root);\n    root.right.left = new Program.BinaryTree(6, root.right);\n    root.right.right = new Program.BinaryTree(7, root.right);\n\n    this.testArray.clear();\n    Program.iterativeInOrderTraversal(root, this::testCallback);\n    List<Integer> expected = Arrays.asList(new Integer[] {4, 9, 2, 1, 6, 3, 7});\n    Utils.assertTrue(expected.equals(this.testArray));\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function iterativeInOrderTraversal(tree, callback) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.iterativeInOrderTraversal = iterativeInOrderTraversal;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space\nfunction iterativeInOrderTraversal(tree, callback) {\n  let previousNode = null;\n  let currentNode = tree;\n  while (currentNode !== null) {\n    let nextNode;\n    if (previousNode === null || previousNode === currentNode.parent) {\n      if (currentNode.left !== null) {\n        nextNode = currentNode.left;\n      } else {\n        callback(currentNode);\n        nextNode = currentNode.right !== null ? currentNode.right : currentNode.parent;\n      }\n    } else if (previousNode === currentNode.left) {\n      callback(currentNode);\n      nextNode = currentNode.right !== null ? currentNode.right : currentNode.parent;\n    } else {\n      nextNode = currentNode.parent;\n    }\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n}\n\nexports.iterativeInOrderTraversal = iterativeInOrderTraversal;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value, parent = null) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1);\n  root.left = new BinaryTree(2, root);\n  root.left.left = new BinaryTree(4, root.left);\n  root.left.left.right = new BinaryTree(9, root.left.left);\n  root.right = new BinaryTree(3, root);\n  root.right.left = new BinaryTree(6, root.right);\n  root.right.right = new BinaryTree(7, root.right);\n\n  const array = [];\n  function testCallback(tree) {\n    if (tree === null) return;\n    array.push(tree.value);\n  }\n\n  program.iterativeInOrderTraversal(root, testCallback);\n\n  chai.expect(array).to.deep.equal([4, 9, 2, 1, 6, 3, 7]);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value, parent = null) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1);\n  root.left = new BinaryTree(2, root);\n  root.left.left = new BinaryTree(4, root.left);\n  root.left.left.right = new BinaryTree(9, root.left.left);\n  root.right = new BinaryTree(3, root);\n  root.right.left = new BinaryTree(6, root.right);\n  root.right.right = new BinaryTree(7, root.right);\n\n  const array = [];\n  function testCallback(tree) {\n    if (tree === null) return;\n    array.push(tree.value);\n  }\n\n  program.iterativeInOrderTraversal(root, testCallback);\n\n  chai.expect(array).to.deep.equal([4, 9, 2, 1, 6, 3, 7]);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nopen class BinaryTree(value: Int, parent: BinaryTree?) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n    var parent: BinaryTree? = parent\n}\n\nfun iterativeInOrderTraversal(tree: BinaryTree?, callback: (BinaryTree?) -> Unit) {\n    // Write your code here.\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class BinaryTree(value: Int, parent: BinaryTree?) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n    var parent: BinaryTree? = parent\n}\n\n// O(n) time | O(1) space\nfun iterativeInOrderTraversal(tree: BinaryTree?, callback: (BinaryTree?) -> Unit) {\n    var previousNode: BinaryTree? = null\n    var currentNode: BinaryTree? = tree\n    while (currentNode != null) {\n        var nextNode: BinaryTree?\n        if (previousNode == null || previousNode == currentNode.parent) {\n            if (currentNode.left != null) {\n                nextNode = currentNode.left\n            } else {\n                callback(currentNode)\n                nextNode = if (currentNode.right != null) currentNode.right else currentNode.parent\n            }\n        } else if (previousNode == currentNode.left) {\n            callback(currentNode)\n            nextNode = if (currentNode.right != null) currentNode.right else currentNode.parent\n        } else {\n            nextNode = currentNode.parent\n        }\n        previousNode = currentNode\n        currentNode = nextNode\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.BinaryTree as BinaryTree\nimport com.algoexpert.program.iterativeInOrderTraversal as iterativeInOrderTraversal\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree = BinaryTree(1, null)\n        tree.left = BinaryTree(2, tree)\n        tree.left!!.left = BinaryTree(4, tree.left)\n        tree.left!!.left!!.right = BinaryTree(9, tree.left!!.left)\n        tree.right = BinaryTree(3, tree)\n        tree.right!!.left = BinaryTree(6, tree.right)\n        tree.right!!.right = BinaryTree(7, tree.right)\n\n        val array = mutableListOf<Int>()\n        fun(tree: BinaryTree?) {\n            if (tree == null) return\n            array.add(tree.value)\n        }\n\n        iterativeInOrderTraversal(\n            tree,\n            fun(tree: BinaryTree?) {\n                if (tree == null) return\n                array.add(tree.value)\n            },\n        )\n\n        assert(array == listOf(4, 9, 2, 1, 6, 3, 7))\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.BinaryTree as BinaryTree\nimport com.algoexpert.program.iterativeInOrderTraversal as iterativeInOrderTraversal\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree = BinaryTree(1, null)\n        tree.left = BinaryTree(2, tree)\n        tree.left!!.left = BinaryTree(4, tree.left)\n        tree.left!!.left!!.right = BinaryTree(9, tree.left!!.left)\n        tree.right = BinaryTree(3, tree)\n        tree.right!!.left = BinaryTree(6, tree.right)\n        tree.right!!.right = BinaryTree(7, tree.right)\n\n        val array = mutableListOf<Int>()\n        fun(tree: BinaryTree?) {\n            if (tree == null) return\n            array.add(tree.value)\n        }\n\n        iterativeInOrderTraversal(\n            tree,\n            fun(tree: BinaryTree?) {\n                if (tree == null) return\n                array.add(tree.value)\n            },\n        )\n\n        assert(array == listOf(4, 9, 2, 1, 6, 3, 7))\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def iterativeInOrderTraversal(tree, callback):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(1) space\ndef iterativeInOrderTraversal(tree, callback):\n    previousNode = None\n    currentNode = tree\n    while currentNode is not None:\n        if previousNode is None or previousNode == currentNode.parent:\n            if currentNode.left is not None:\n                nextNode = currentNode.left\n            else:\n                callback(currentNode)\n                nextNode = (\n                    currentNode.right if currentNode.right is not None else currentNode.parent\n                )\n        elif previousNode == currentNode.left:\n            callback(currentNode)\n            nextNode = currentNode.right if currentNode.right is not None else currentNode.parent\n        else:\n            nextNode = currentNode.parent\n        previousNode = currentNode\n        currentNode = nextNode\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass BinaryTree:\n    def __init__(self, value, parent=None):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.parent = parent\n\n\ndef testCallback(testArray, tree):\n    if tree is None:\n        return\n    testArray.append(tree.value)\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = BinaryTree(1)\n        root.left = BinaryTree(2, parent=root)\n        root.left.left = BinaryTree(4, parent=root.left)\n        root.left.left.right = BinaryTree(9, parent=root.left.left)\n        root.right = BinaryTree(3, parent=root)\n        root.right.left = BinaryTree(6, parent=root.right)\n        root.right.right = BinaryTree(7, parent=root.right)\n\n        testArray = []\n        actualTestCallback = lambda x: testCallback(testArray, x)\n        program.iterativeInOrderTraversal(root, actualTestCallback)\n        self.assertEqual(testArray, [4, 9, 2, 1, 6, 3, 7])\n",
      "unitTests": "import program\nimport unittest\n\n\nclass BinaryTree:\n    def __init__(self, value, parent=None):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.parent = parent\n\n\ndef testCallback(testArray, tree):\n    if tree is None:\n        return\n    testArray.append(tree.value)\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = BinaryTree(1)\n        root.left = BinaryTree(2, parent=root)\n        root.left.left = BinaryTree(4, parent=root.left)\n        root.left.left.right = BinaryTree(9, parent=root.left.left)\n        root.right = BinaryTree(3, parent=root)\n        root.right.left = BinaryTree(6, parent=root.right)\n        root.right.right = BinaryTree(7, parent=root.right)\n\n        testArray = []\n        actualTestCallback = lambda x: testCallback(testArray, x)\n        program.iterativeInOrderTraversal(root, actualTestCallback)\n        self.assertEqual(testArray, [4, 9, 2, 1, 6, 3, 7])\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  class BinaryTree {\n    var value: Int\n    var parent: BinaryTree?\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int, parent: BinaryTree?) {\n      self.value = value\n      self.parent = parent\n    }\n  }\n\n  func iterativeInOrderTraversal(_ tree: BinaryTree, _ callback: (BinaryTree) -> Void) {\n    // Write your code here.\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class BinaryTree {\n    var value: Int\n    var parent: BinaryTree?\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int, parent: BinaryTree?) {\n      self.value = value\n      self.parent = parent\n    }\n  }\n\n  // O(n) time | O(1) space\n  func iterativeInOrderTraversal(_ tree: BinaryTree, _ callback: (BinaryTree) -> Void) {\n    var previousNode: BinaryTree?\n    var currentNode: BinaryTree? = tree\n\n    while currentNode !== nil {\n      let nextNode: BinaryTree?\n      if previousNode === nil || previousNode === currentNode?.parent {\n        if currentNode?.left !== nil {\n          nextNode = currentNode?.left\n        } else {\n          callback(currentNode!)\n          nextNode = currentNode?.right !== nil ? currentNode?.right : currentNode?.parent\n        }\n      } else if previousNode === currentNode?.left {\n        callback(currentNode!)\n        nextNode = currentNode?.right !== nil ? currentNode?.right : currentNode?.parent\n      } else {\n        nextNode = currentNode?.parent\n      }\n\n      previousNode = currentNode\n      currentNode = nextNode\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n\n    var testArray = [Int]()\n    func testCallback(_ tree: Program.BinaryTree) {\n      testArray.append(tree.value)\n    }\n\n    runTest(\"Test Case 1\") { () throws in\n      let root = Program.BinaryTree(value: 1, parent: nil)\n      root.left = Program.BinaryTree(value: 2, parent: root)\n      root.left!.left = Program.BinaryTree(value: 4, parent: root.left)\n      root.left!.left!.right = Program.BinaryTree(value: 9, parent: root.left!.left)\n      root.right = Program.BinaryTree(value: 3, parent: root)\n      root.right!.left = Program.BinaryTree(value: 6, parent: root.right)\n      root.right!.right = Program.BinaryTree(value: 7, parent: root.right)\n\n      testArray = []\n      program.iterativeInOrderTraversal(root, testCallback(_:))\n      try assertEqual(testArray, [4, 9, 2, 1, 6, 3, 7])\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n\n    var testArray = [Int]()\n    func testCallback(_ tree: Program.BinaryTree) {\n      testArray.append(tree.value)\n    }\n\n    runTest(\"Test Case 1\") { () throws in\n      let root = Program.BinaryTree(value: 1, parent: nil)\n      root.left = Program.BinaryTree(value: 2, parent: root)\n      root.left!.left = Program.BinaryTree(value: 4, parent: root.left)\n      root.left!.left!.right = Program.BinaryTree(value: 9, parent: root.left!.left)\n      root.right = Program.BinaryTree(value: 3, parent: root)\n      root.right!.left = Program.BinaryTree(value: 6, parent: root.right)\n      root.right!.right = Program.BinaryTree(value: 7, parent: root.right)\n\n      testArray = []\n      program.iterativeInOrderTraversal(root, testCallback(_:))\n      try assertEqual(testArray, [4, 9, 2, 1, 6, 3, 7])\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n  parent: BinaryTree | null;\n\n  constructor(value: number, parent: BinaryTree | null = null) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n  }\n}\n\nexport function iterativeInOrderTraversal(tree: BinaryTree, callback: (node: BinaryTree) => void) {\n  // Write your code here.\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n  parent: BinaryTree | null;\n\n  constructor(value: number, parent: BinaryTree | null = null) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n  }\n}\n\n// O(n) time | O(1) space\nexport function iterativeInOrderTraversal(tree: BinaryTree, callback: (node: BinaryTree) => void) {\n  let previousNode: BinaryTree | null = null;\n  let currentNode: BinaryTree | null = tree;\n  while (currentNode !== null) {\n    let nextNode;\n    if (previousNode === null || previousNode === currentNode.parent) {\n      if (currentNode.left !== null) {\n        nextNode = currentNode.left;\n      } else {\n        callback(currentNode);\n        nextNode = currentNode.right !== null ? currentNode.right : currentNode.parent;\n      }\n    } else if (previousNode === currentNode.left) {\n      callback(currentNode);\n      nextNode = currentNode.right !== null ? currentNode.right : currentNode.parent;\n    } else {\n      nextNode = currentNode.parent;\n    }\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n  parent: BinaryTree | null;\n\n  constructor(value: number, parent: BinaryTree | null = null) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1);\n  root.left = new BinaryTree(2, root);\n  root.left.left = new BinaryTree(4, root.left);\n  root.left.left.right = new BinaryTree(9, root.left.left);\n  root.right = new BinaryTree(3, root);\n  root.right.left = new BinaryTree(6, root.right);\n  root.right.right = new BinaryTree(7, root.right);\n\n  const array: number[] = [];\n  function testCallback(tree: BinaryTree | null) {\n    if (tree === null) return;\n    array.push(tree.value);\n  }\n\n  program.iterativeInOrderTraversal(root, testCallback);\n\n  chai.expect(array).to.deep.equal([4, 9, 2, 1, 6, 3, 7]);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n  parent: BinaryTree | null;\n\n  constructor(value: number, parent: BinaryTree | null = null) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1);\n  root.left = new BinaryTree(2, root);\n  root.left.left = new BinaryTree(4, root.left);\n  root.left.left.right = new BinaryTree(9, root.left.left);\n  root.right = new BinaryTree(3, root);\n  root.right.left = new BinaryTree(6, root.right);\n  root.right.right = new BinaryTree(7, root.right);\n\n  const array: number[] = [];\n  function testCallback(tree: BinaryTree | null) {\n    if (tree === null) return;\n    array.push(tree.value);\n  }\n\n  program.iterativeInOrderTraversal(root, testCallback);\n\n  chai.expect(array).to.deep.equal([4, 9, 2, 1, 6, 3, 7]);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "tree",
      "example": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "9",
            "value": 4
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      },
      "schema": {
        "description": "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node.\nEvery node has to have a unique string <span>id</span> that will be referenced by other nodes'\n<span>left</span> and <span>right</span> pointers and by the <span>root</span>. The\n<span>parent</span> pointer of each node will be deduced from the collection of <span>nodes</span>.\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "left": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "right": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "left",
                "right"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "root": {
            "type": "string"
          }
        },
        "required": [
          "root",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "9",
            "value": 4
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "2",
            "left": "4",
            "right": null,
            "value": 2
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": "10",
            "right": null,
            "value": 5
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "6",
            "left": "12",
            "right": "13",
            "value": 6
          },
          {
            "id": "13",
            "left": null,
            "right": null,
            "value": 13
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": "10",
            "right": "11",
            "value": 5
          },
          {
            "id": "11",
            "left": null,
            "right": null,
            "value": 11
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": "14",
            "right": "15",
            "value": 7
          },
          {
            "id": "15",
            "left": null,
            "right": null,
            "value": 15
          },
          {
            "id": "14",
            "left": null,
            "right": null,
            "value": 14
          },
          {
            "id": "6",
            "left": "12",
            "right": "13",
            "value": 6
          },
          {
            "id": "13",
            "left": null,
            "right": null,
            "value": 13
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": "10",
            "right": "11",
            "value": 5
          },
          {
            "id": "11",
            "left": null,
            "right": null,
            "value": 11
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "9",
            "left": "18",
            "right": null,
            "value": 9
          },
          {
            "id": "18",
            "left": null,
            "right": null,
            "value": 18
          },
          {
            "id": "8",
            "left": "16",
            "right": "17",
            "value": 8
          },
          {
            "id": "17",
            "left": null,
            "right": null,
            "value": 17
          },
          {
            "id": "16",
            "left": null,
            "right": null,
            "value": 16
          }
        ],
        "root": "1"
      }
    }
  ],
  "jsonTests": [
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": "4",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "9",
            "value": 4
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "2",
            "left": "4",
            "right": null,
            "value": 2
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": "10",
            "right": null,
            "value": 5
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "6",
            "left": "12",
            "right": "13",
            "value": 6
          },
          {
            "id": "13",
            "left": null,
            "right": null,
            "value": 13
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": "10",
            "right": "11",
            "value": 5
          },
          {
            "id": "11",
            "left": null,
            "right": null,
            "value": 11
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": "14",
            "right": "15",
            "value": 7
          },
          {
            "id": "15",
            "left": null,
            "right": null,
            "value": 15
          },
          {
            "id": "14",
            "left": null,
            "right": null,
            "value": 14
          },
          {
            "id": "6",
            "left": "12",
            "right": "13",
            "value": 6
          },
          {
            "id": "13",
            "left": null,
            "right": null,
            "value": 13
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": "10",
            "right": "11",
            "value": 5
          },
          {
            "id": "11",
            "left": null,
            "right": null,
            "value": 11
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "9",
            "left": "18",
            "right": null,
            "value": 9
          },
          {
            "id": "18",
            "left": null,
            "right": null,
            "value": 18
          },
          {
            "id": "8",
            "left": "16",
            "right": "17",
            "value": 8
          },
          {
            "id": "17",
            "left": null,
            "right": null,
            "value": 17
          },
          {
            "id": "16",
            "left": null,
            "right": null,
            "value": 16
          }
        ],
        "root": "1"
      }
    }
  ],
  "changelog": []
}