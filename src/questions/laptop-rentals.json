{
  "uid": "laptop-rentals",
  "testStrategy": "JSON",
  "name": "Laptop Rentals",
  "version": 0,
  "releaseDate": "2021-04-01T00:00:00Z",
  "category": "Heaps",
  "difficulty": 3,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 6396,
    "failureCount": 1403
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "525482653",
    "duration": 0,
    "annotations": [
      {
        "title": "Typo!",
        "content": "For interval [9, 10], we would require 2 laptops.",
        "start": 393,
        "end": 399
      }
    ],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 2296
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given a list of time intervals during which students at a school need a\n  laptop. These time intervals are represented by pairs of integers\n  <span>[start, end]</span>, where <span>0 &lt;= start &lt; end</span>. However,\n  <span>start</span> and <span>end</span> don't represent real times; therefore,\n  they may be greater than <span>24</span>.\n</p>\n<p>\n  No two students can use a laptop at the same time, but immediately after a\n  student is done using a laptop, another student can use that same laptop. For\n  example, if one student rents a laptop during the time interval\n  <span>[0, 2]</span>, another student can rent the same laptop during any time\n  interval starting with <span>2</span>.\n</p>\n<p>\n  Write a function that returns the minimum number of laptops that the school\n  needs to rent such that all students will always have access to a laptop when\n  they need one.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">times</span> = \n[\n  [0, 2],\n  [1, 4],\n  [4, 6],\n  [0, 4],\n  [7, 8],\n  [9, 11],\n  [3, 10],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3\n</pre>\n</div>",
  "hints": [
    "<p>\n  There are many different ways to solve this problem, but only a few of them\n  run in the optimal time. Can you come up with an algorithm that solves this\n  problem in <span>O(nlog(n))</span> time?\n</p>\n",
    "\n<p>\n  Suppose that you're given two time intervals: <span>[s1, e1]</span> and\n  <span>[s2, e2]</span>, where <span>s1 &lt; s2</span>. If\n  <span>e1 &lt;= s2</span>, then the second time interval can use the same\n  laptop as the first time interval.\n</p>\n<p>\n  One method to solve this problem with an optimal time complexity is to use a\n  Min Heap. If you loop through time intervals that have been sorted by their\n  start times and keep track of the smallest end time of time intervals for\n  laptops that have already been rented out, you can determine how many laptops\n  are required. Use the Min Heap to efficiency determine if any previous rental\n  time intervals have ended as you loop through all the time intervals. If a\n  rental time interval is done and another one starts after it, no extra laptop\n  is required.\n</p>\n",
    "\n<p>\n  Another way to efficiently solve this problem is to realize that we don't need\n  to know what start time corresponds with what end time. So long as we know all\n  start times and all end times, we can determine the number of laptops\n  required.\n</p>\n",
    "\n<p>\n  Start by creating two arrays—one for start times and one for end times—and\n  sort them both in ascending order. We can simply loop through the start times\n  and end times at the same time and compare the current start time to the\n  current end time. If the current start time is greater than the current end\n  time, then that means a laptop that was previously used is no longer being\n  used and can be given to the student renting a laptop at this starting time.\n  Thus, we can increment both our start-time and end-time pointers and continue\n  without needing an additional laptop. If the current start time is smaller\n  than the current end time, then another rental has started before a previous\n  rental has ended, and we thus require another laptop, so we increment the\n  start pointer and a variable keeping track of the number of laptops required.\n  See the Conceptual Overview section of this question's video explanation for a\n  more in-depth explanation.\n</p>"
  ],
  "spaceTime": "O(nlog(n)) time | O(n) space - where n is the number of times",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nint laptopRentals(vector<vector<int>> times) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nclass MinHeap {\n public:\n  vector<vector<int>>* heap;\n\n  MinHeap(vector<vector<int>>* vector) {\n    heap = vector;\n    buildHeap();\n  }\n\n  // O(n) time | O(1) space\n  void buildHeap() {\n    int firstParentIdx = (heap->size() - 2) / 2;\n    for (int currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      siftDown(currentIdx, heap->size() - 1);\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  void siftDown(int currentIdx, int endIdx) {\n    int childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      int childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      int idxToSwap;\n      if (childTwoIdx != -1 && heap->at(childTwoIdx)[1] < heap->at(childOneIdx)[1]) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap->at(idxToSwap)[1] < heap->at(currentIdx)[1]) {\n        swap(heap->at(currentIdx), heap->at(idxToSwap));\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  void siftUp(int currentIdx) {\n    int parentIdx = (currentIdx - 1) / 2;\n    while (currentIdx > 0 && heap->at(currentIdx)[1] < heap->at(parentIdx)[1]) {\n      swap(heap->at(currentIdx), heap->at(parentIdx));\n      currentIdx = parentIdx;\n      parentIdx = (currentIdx - 1) / 2;\n    }\n  }\n\n  vector<int> peek() { return heap->at(0); }\n\n  vector<int> remove() {\n    swap(heap->at(0), heap->at(heap->size() - 1));\n    vector<int> valueToRemove = heap->back();\n    heap->pop_back();\n    siftDown(0, heap->size() - 1);\n    return valueToRemove;\n  }\n\n  void insert(vector<int> value) {\n    heap->push_back(value);\n    siftUp(heap->size() - 1);\n  }\n};\n\n// O(nlog(n)) time | O(n) space - where n is the number of times\nint laptopRentals(vector<vector<int>> times) {\n  if (times.size() == 0) return 0;\n\n  sort(times.begin(), times.end(), [](vector<int> a, vector<int> b) {\n    return a[0] < b[0];\n  });\n\n  vector<vector<int>>* timesWhenLaptopIsUsed =\n    new vector<vector<int>>{times[0]};\n  MinHeap* heap = new MinHeap(timesWhenLaptopIsUsed);\n\n  for (int idx = 1; idx < times.size(); idx++) {\n    vector<int> currentInterval = times[idx];\n    if (heap->peek()[1] <= currentInterval[0]) heap->remove();\n\n    heap->insert(currentInterval);\n  }\n\n  return timesWhenLaptopIsUsed->size();\n}",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n// O(nlog(n)) time | O(n) space - where n is the number of times\nint laptopRentals(vector<vector<int>> times) {\n  if (times.size() == 0) return 0;\n\n  int usedLaptops = 0;\n  vector<int> startTimes;\n  vector<int> endTimes;\n\n  for (auto interval : times) {\n    startTimes.push_back(interval[0]);\n    endTimes.push_back(interval[1]);\n  }\n  sort(startTimes.begin(), startTimes.end());\n  sort(endTimes.begin(), endTimes.end());\n\n  int startIterator = 0;\n  int endIterator = 0;\n\n  while (startIterator < times.size()) {\n    if (startTimes[startIterator] >= endTimes[endIterator]) {\n      usedLaptops--;\n      endIterator++;\n    }\n\n    usedLaptops++;\n    startIterator++;\n  }\n\n  return usedLaptops;\n}"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> input = {\n        {0, 2}, {1, 4}, {4, 6}, {0, 4}, {7, 8}, {9, 11}, {3, 10}};\n      auto expected = 3;\n      auto actual = laptopRentals(input);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> input = {\n        {0, 2}, {1, 4}, {4, 6}, {0, 4}, {7, 8}, {9, 11}, {3, 10}};\n      auto expected = 3;\n      auto actual = laptopRentals(input);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System.Collections.Generic;\nusing System;\n\npublic class Program {\n  public int LaptopRentals(List<List<int> > times) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class Program {\n  // O(nlog(n)) time | O(n) space - where n is the number of times\n  public int LaptopRentals(List<List<int> > times) {\n    if (times.Count == 0) {\n      return 0;\n    }\n\n    times.Sort((a, b) => a[0].CompareTo(b[0]));\n\n    List<List<int> > timesWhenLaptopIsUsed = new List<List<int> >();\n    timesWhenLaptopIsUsed.Add(times[0]);\n    MinHeap heap = new MinHeap(timesWhenLaptopIsUsed);\n\n    for (int idx = 1; idx < times.Count; idx++) {\n      List<int> currentInterval = times[idx];\n      if (heap.peek()[1] <= currentInterval[0]) {\n        heap.remove();\n      }\n      heap.insert(currentInterval);\n    }\n\n    return timesWhenLaptopIsUsed.Count;\n  }\n\n  public class MinHeap {\n    List<List<int> > heap = new List<List<int> >();\n\n    public MinHeap(List<List<int> > array) {\n      heap = buildHeap(array);\n    }\n\n    public List<List<int> > buildHeap(List<List<int> > array) {\n      int firstParentIdx = (array.Count - 2) / 2;\n      for (int currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n        siftDown(currentIdx, array.Count - 1, array);\n      }\n      return array;\n    }\n\n    public void siftDown(int currentIdx, int endIdx, List<List<int> > heap) {\n      int newCurrentIdx = currentIdx;\n      int childOneIdx = currentIdx * 2 + 1;\n      while (childOneIdx <= endIdx) {\n        int childTwoIdx =\n          (newCurrentIdx * 2 + 2 <= endIdx) ? newCurrentIdx * 2 + 2 : -1;\n        int idxToSwap;\n        if (childTwoIdx != -1 && heap[childTwoIdx][1] < heap[childOneIdx][1]) {\n          idxToSwap = childTwoIdx;\n        } else {\n          idxToSwap = childOneIdx;\n        }\n        if (heap[idxToSwap][1] < heap[currentIdx][1]) {\n          swap(newCurrentIdx, idxToSwap, heap);\n          newCurrentIdx = idxToSwap;\n          childOneIdx = newCurrentIdx * 2 + 1;\n        } else {\n          return;\n        }\n      }\n    }\n\n    public void siftUp(int currentIdx, List<List<int> > heap) {\n      int newCurrentIdx = currentIdx;\n      int parentIdx = (currentIdx - 1) / 2;\n      while (newCurrentIdx > 0 && heap[newCurrentIdx][1] < heap[parentIdx][1]) {\n        swap(newCurrentIdx, parentIdx, heap);\n        newCurrentIdx = parentIdx;\n        parentIdx = (newCurrentIdx - 1) / 2;\n      }\n    }\n\n    public List<int> peek() {\n      return heap[0];\n    }\n\n    public List<int> remove() {\n      swap(0, heap.Count - 1, heap);\n      List<int> valueToRemove = heap[heap.Count - 1];\n      heap.RemoveAt(heap.Count - 1);\n      siftDown(0, heap.Count - 1, heap);\n      return valueToRemove;\n    }\n\n    public void insert(List<int> value) {\n      heap.Add(value);\n      siftUp(heap.Count - 1, heap);\n    }\n\n    public void swap(int i, int j, List<List<int> > heap) {\n      List<int> temp = heap[j];\n      heap[j] = heap[i];\n      heap[i] = temp;\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class Program {\n  // O(nlog(n)) time | O(n) space - where n is the number of times\n  public int LaptopRentals(List<List<int> > times) {\n    if (times.Count == 0) {\n      return 0;\n    }\n\n    int usedLaptops = 0;\n    List<int> startTimes = new List<int>();\n    List<int> endTimes = new List<int>();\n\n    foreach (var interval in times) {\n      startTimes.Add(interval[0]);\n      endTimes.Add((interval[1]));\n    }\n\n    startTimes.Sort();\n    endTimes.Sort();\n\n    int startIterator = 0;\n    int endIterator = 0;\n\n    while (startIterator < times.Count) {\n      if (startTimes[startIterator] >= endTimes[endIterator]) {\n        usedLaptops -= 1;\n        endIterator += 1;\n      }\n\n      usedLaptops += 1;\n      startIterator += 1;\n    }\n\n    return usedLaptops;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[][] times = new int[][] {\n      new int[] { 0, 2 },\n      new int[] { 1, 4 },\n      new int[] { 4, 6 },\n      new int[] { 0, 4 },\n      new int[] { 7, 8 },\n      new int[] { 9, 11 },\n      new int[] { 3, 10 }\n    };\n    List<List<int> > input = new List<List<int> >();\n    foreach (var time in times) {\n      input.Add(new List<int> { time[0], time[1] });\n    }\n    int expected = 3;\n    var actual = new Program().LaptopRentals(input);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[][] times = new int[][] {\n      new int[] { 0, 2 },\n      new int[] { 1, 4 },\n      new int[] { 4, 6 },\n      new int[] { 0, 4 },\n      new int[] { 7, 8 },\n      new int[] { 9, 11 },\n      new int[] { 3, 10 }\n    };\n    List<List<int> > input = new List<List<int> >();\n    foreach (var time in times) {\n      input.Add(new List<int> { time[0], time[1] });\n    }\n    int expected = 3;\n    var actual = new Program().LaptopRentals(input);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc LaptopRentals(times [][]int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t\"sort\"\n)\n\n// O(nlog(n)) time | O(n) space - where n is the number of times\nfunc LaptopRentals(times [][]int) int {\n\tif len(times) == 0 {\n\t\treturn 0\n\t}\n\n\tsort.Slice(times, func(i, j int) bool {\n\t\treturn times[i][0] < times[j][0]\n\t})\n\n\ttimesWhenLaptopIsUsed := [][]int{times[0]}\n\theap := NewMinHeap(timesWhenLaptopIsUsed)\n\n\tfor idx := 1; idx < len(times); idx++ {\n\t\tcurrentInterval := times[idx]\n\t\tif heap.Peek()[1] <= currentInterval[0] {\n\t\t\theap.Remove()\n\t\t}\n\n\t\theap.Insert(currentInterval)\n\t}\n\treturn heap.Length()\n}\n\ntype MinHeap [][]int\n\nfunc NewMinHeap(array [][]int) *MinHeap {\n\theap := MinHeap(array)\n\tptr := &heap\n\tptr.BuildHeap(array)\n\treturn ptr\n}\n\nfunc (h *MinHeap) BuildHeap(array [][]int) {\n\tfirst := (len(array) - 2) / 2\n\tfor currentIdx := first; currentIdx >= 0; currentIdx-- {\n\t\th.siftDown(currentIdx, len(array)-1)\n\t}\n}\n\nfunc (h *MinHeap) siftDown(currentIdx, endIdx int) {\n\tchildOneIdx := currentIdx*2 + 1\n\tfor childOneIdx <= endIdx {\n\t\tchildTwoIdx := -1\n\t\tif currentIdx*2+2 <= endIdx {\n\t\t\tchildTwoIdx = currentIdx*2 + 2\n\t\t}\n\t\tindexToSwap := childOneIdx\n\t\tif childTwoIdx != -1 && (*h)[childTwoIdx][1] < (*h)[childOneIdx][1] {\n\t\t\tindexToSwap = childTwoIdx\n\t\t}\n\t\tif (*h)[indexToSwap][1] < (*h)[currentIdx][1] {\n\t\t\th.swap(currentIdx, indexToSwap)\n\t\t\tcurrentIdx = indexToSwap\n\t\t\tchildOneIdx = currentIdx*2 + 1\n\t\t} else {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (h *MinHeap) siftUp(currentIdx int) {\n\tparentIdx := (currentIdx - 1) / 2\n\tfor currentIdx > 0 && (*h)[currentIdx][1] < (*h)[parentIdx][1] {\n\t\th.swap(currentIdx, parentIdx)\n\t\tcurrentIdx = parentIdx\n\t\tparentIdx = (currentIdx - 1) / 2\n\t}\n}\n\nfunc (h *MinHeap) Peek() []int {\n\treturn (*h)[0]\n}\n\nfunc (h *MinHeap) Remove() []int {\n\th.swap(0, h.Length()-1)\n\tlast := (*h)[h.Length()-1]\n\t*h = (*h)[:h.Length()-1]\n\th.siftDown(0, h.Length()-1)\n\treturn last\n}\n\nfunc (h *MinHeap) Insert(value []int) {\n\t*h = append(*h, value)\n\th.siftUp(h.Length() - 1)\n}\n\nfunc (h *MinHeap) IsEmpty() bool {\n\treturn len(*h) == 0\n}\n\nfunc (h *MinHeap) swap(i, j int) {\n\t(*h)[i], (*h)[j] = (*h)[j], (*h)[i]\n}\n\nfunc (h *MinHeap) Length() int {\n\treturn len(*h)\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t\"sort\"\n)\n\n// O(nlog(n)) time | O(n) space - where n is the number of times\nfunc LaptopRentals(times [][]int) int {\n\tif len(times) == 0 {\n\t\treturn 0\n\t}\n\n\tusedLaptops := 0\n\tstartTimes, endTimes := []int{}, []int{}\n\tfor _, time := range times {\n\t\tstartTimes = append(startTimes, time[0])\n\t\tendTimes = append(endTimes, time[1])\n\t}\n\tsort.Ints(startTimes)\n\tsort.Ints(endTimes)\n\n\tstartIterator := 0\n\tendIterator := 0\n\n\tfor startIterator < len(times) {\n\t\tif startTimes[startIterator] >= endTimes[endIterator] {\n\t\t\tusedLaptops -= 1\n\t\t\tendIterator += 1\n\t\t}\n\n\t\tusedLaptops += 1\n\t\tstartIterator += 1\n\t}\n\treturn usedLaptops\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{0, 2},\n\t\t{1, 4},\n\t\t{4, 6},\n\t\t{0, 4},\n\t\t{7, 8},\n\t\t{9, 11},\n\t\t{3, 10},\n\t}\n\texpected := 3\n\tactual := LaptopRentals(input)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{0, 2},\n\t\t{1, 4},\n\t\t{4, 6},\n\t\t{0, 4},\n\t\t{7, 8},\n\t\t{9, 11},\n\t\t{3, 10},\n\t}\n\texpected := 3\n\tactual := LaptopRentals(input)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public int laptopRentals(ArrayList<ArrayList<Integer>> times) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(nlog(n)) time | O(n) space - where n is the number of times\n  public int laptopRentals(ArrayList<ArrayList<Integer>> times) {\n    if (times.size() == 0) {\n      return 0;\n    }\n\n    Collections.sort(times, (a, b) -> Integer.compare(a.get(0), b.get(0)));\n\n    ArrayList<ArrayList<Integer>> timesWhenLaptopIsUsed =\n      new ArrayList<ArrayList<Integer>>();\n    timesWhenLaptopIsUsed.add(times.get(0));\n    MinHeap heap = new MinHeap(timesWhenLaptopIsUsed);\n\n    for (int idx = 1; idx < times.size(); idx++) {\n      ArrayList<Integer> currentInterval = times.get(idx);\n      if (heap.peek().get(1) <= currentInterval.get(0)) {\n        heap.remove();\n      }\n      heap.insert(currentInterval);\n    }\n\n    return timesWhenLaptopIsUsed.size();\n  }\n\n  static class MinHeap {\n    ArrayList<ArrayList<Integer>> heap = new ArrayList<ArrayList<Integer>>();\n\n    public MinHeap(ArrayList<ArrayList<Integer>> array) {\n      heap = buildHeap(array);\n    }\n\n    public ArrayList<ArrayList<Integer>> buildHeap(\n      ArrayList<ArrayList<Integer>> array\n    ) {\n      int firstParentIdx = (array.size() - 2) / 2;\n      for (int currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n        siftDown(currentIdx, array.size() - 1, array);\n      }\n      return array;\n    }\n\n    public void siftDown(\n      int currentIdx, int endIdx, ArrayList<ArrayList<Integer>> heap\n    ) {\n      int newCurrentIdx = currentIdx;\n      int childOneIdx = currentIdx * 2 + 1;\n      while (childOneIdx <= endIdx) {\n        int childTwoIdx =\n          (newCurrentIdx * 2 + 2 <= endIdx) ? newCurrentIdx * 2 + 2 : -1;\n        int idxToSwap;\n        if (childTwoIdx != -1\n            && heap.get(childTwoIdx).get(1) < heap.get(childOneIdx).get(1)) {\n          idxToSwap = childTwoIdx;\n        } else {\n          idxToSwap = childOneIdx;\n        }\n        if (heap.get(idxToSwap).get(1) < heap.get(currentIdx).get(1)) {\n          swap(newCurrentIdx, idxToSwap, heap);\n          newCurrentIdx = idxToSwap;\n          childOneIdx = newCurrentIdx * 2 + 1;\n        } else {\n          return;\n        }\n      }\n    }\n\n    public void siftUp(int currentIdx, ArrayList<ArrayList<Integer>> heap) {\n      int newCurrentIdx = currentIdx;\n      int parentIdx = (currentIdx - 1) / 2;\n      while (newCurrentIdx > 0\n             && heap.get(newCurrentIdx).get(1) < heap.get(parentIdx).get(1)) {\n        swap(newCurrentIdx, parentIdx, heap);\n        newCurrentIdx = parentIdx;\n        parentIdx = (newCurrentIdx - 1) / 2;\n      }\n    }\n\n    public ArrayList<Integer> peek() {\n      return heap.get(0);\n    }\n\n    public ArrayList<Integer> remove() {\n      swap(0, heap.size() - 1, heap);\n      ArrayList<Integer> valueToRemove = heap.get(heap.size() - 1);\n      heap.remove(heap.size() - 1);\n      siftDown(0, heap.size() - 1, heap);\n      return valueToRemove;\n    }\n\n    public void insert(ArrayList<Integer> value) {\n      heap.add(value);\n      siftUp(heap.size() - 1, heap);\n    }\n\n    public void swap(int i, int j, ArrayList<ArrayList<Integer>> heap) {\n      ArrayList<Integer> temp = heap.get(j);\n      heap.set(j, heap.get(i));\n      heap.set(i, temp);\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(nlog(n)) time | O(n) space - where n is the number of times\n  public int laptopRentals(ArrayList<ArrayList<Integer>> times) {\n    if (times.size() == 0) {\n      return 0;\n    }\n\n    int usedLaptops = 0;\n    ArrayList<Integer> startTimes = new ArrayList<Integer>();\n    ArrayList<Integer> endTimes = new ArrayList<Integer>();\n\n    for (ArrayList<Integer> interval : times) {\n      startTimes.add(interval.get(0));\n      endTimes.add((interval.get(1)));\n    }\n\n    Collections.sort(startTimes);\n    Collections.sort(endTimes);\n\n    int startIterator = 0;\n    int endIterator = 0;\n\n    while (startIterator < times.size()) {\n      if (startTimes.get(startIterator) >= endTimes.get(endIterator)) {\n        usedLaptops -= 1;\n        endIterator += 1;\n      }\n\n      usedLaptops += 1;\n      startIterator += 1;\n    }\n\n    return usedLaptops;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] times =\n      new int[][] {{0, 2}, {1, 4}, {4, 6}, {0, 4}, {7, 8}, {9, 11}, {3, 10}};\n    ArrayList<ArrayList<Integer>> input = new ArrayList<ArrayList<Integer>>();\n    for (int[] time : times) {\n      input.add(new ArrayList(Arrays.asList(time[0], time[1])));\n    }\n    int expected = 3;\n    var actual = new Program().laptopRentals(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] times =\n      new int[][] {{0, 2}, {1, 4}, {4, 6}, {0, 4}, {7, 8}, {9, 11}, {3, 10}};\n    ArrayList<ArrayList<Integer>> input = new ArrayList<ArrayList<Integer>>();\n    for (int[] time : times) {\n      input.add(new ArrayList(Arrays.asList(time[0], time[1])));\n    }\n    int expected = 3;\n    var actual = new Program().laptopRentals(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function laptopRentals(times) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.laptopRentals = laptopRentals;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(nlog(n)) time | O(n) space - where n is the number of times\nfunction laptopRentals(times) {\n  if (times.length === 0) return 0;\n\n  times.sort((a, b) => a[0] - b[0]);\n\n  const timesWhenLaptopIsUsed = [times[0]];\n  const heap = new MinHeap(timesWhenLaptopIsUsed);\n\n  for (let idx = 1; idx < times.length; idx++) {\n    const currentInterval = times[idx];\n    if (heap.peek()[1] <= currentInterval[0]) heap.remove();\n\n    heap.insert(currentInterval);\n  }\n\n  return timesWhenLaptopIsUsed.length;\n}\n\nclass MinHeap {\n  constructor(array) {\n    this.heap = this.buildHeap(array);\n  }\n\n  // O(n) time | O(1) space\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  // O(log(n)) time | O(1) space\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx][1] < heap[childOneIdx][1]) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap][1] < heap[currentIdx][1]) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx][1] < heap[parentIdx][1]) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  // O(1) time | O(1) space\n  peek() {\n    return this.heap[0];\n  }\n\n  // O(log(n)) time | O(1) space\n  remove() {\n    this.swap(0, this.heap.length - 1, this.heap);\n    const valueToRemove = this.heap.pop();\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return valueToRemove;\n  }\n\n  // O(log(n)) time | O(1) space\n  insert(value) {\n    this.heap.push(value);\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i, j, heap) {\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n}\n\n// Do not edit the lines below.\nexports.laptopRentals = laptopRentals;\nexports.MinHeap = MinHeap;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(nlog(n)) time | O(n) space - where n is the number of times\nfunction laptopRentals(times) {\n  if (times.length === 0) return 0;\n\n  let usedLaptops = 0;\n  const startTimes = times.map(a => a[0]).sort((a, b) => a - b);\n  const endTimes = times.map(a => a[1]).sort((a, b) => a - b);\n\n  let startIterator = 0;\n  let endIterator = 0;\n\n  while (startIterator < times.length) {\n    if (startTimes[startIterator] >= endTimes[endIterator]) {\n      usedLaptops--;\n      endIterator++;\n    }\n\n    usedLaptops++;\n    startIterator++;\n  }\n\n  return usedLaptops;\n}\n\n// Do not edit the line below.\nexports.laptopRentals = laptopRentals;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [0, 2],\n    [1, 4],\n    [4, 6],\n    [0, 4],\n    [7, 8],\n    [9, 11],\n    [3, 10],\n  ];\n  const expected = 3;\n  const actual = program.laptopRentals(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [0, 2],\n    [1, 4],\n    [4, 6],\n    [0, 4],\n    [7, 8],\n    [9, 11],\n    [3, 10],\n  ];\n  const expected = 3;\n  const actual = program.laptopRentals(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun laptopRentals(times: List<List<Int>>): Int {\n    // Write your code here.\n    return -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(nlog(n)) time | O(n) space - where n is the number of times\nfun laptopRentals(times: List<List<Int>>): Int {\n    if (times.size == 0) return 0\n\n    val sortedTimes = times.toMutableList().sortedWith(\n        Comparator<List<Int>> { a, b -> a[0].compareTo(b[0]) },\n    )\n\n    val timesWhenLaptopIsUsed = mutableListOf(sortedTimes[0])\n    val heap = MinHeap(timesWhenLaptopIsUsed)\n\n    for (idx in 1 until sortedTimes.size) {\n        val currentInterval = sortedTimes[idx]\n        if (heap.peek()!![1] <= currentInterval[0]) heap.remove()\n\n        heap.insert(currentInterval)\n    }\n\n    return timesWhenLaptopIsUsed.size\n}\n\nopen class MinHeap(array: MutableList<List<Int>>) {\n    val heap = this.buildHeap(array)\n\n    fun isEmpty(): Boolean {\n        return this.heap.size == 0\n    }\n\n    fun buildHeap(array: MutableList<List<Int>>): MutableList<List<Int>> {\n        val firstParentIdx = (array.size - 2) / 2\n        for (currentIdx in firstParentIdx downTo 0) {\n            this.siftDown(currentIdx, array.size - 1, array)\n        }\n        return array\n    }\n\n    fun siftDown(currentIdx: Int, endIdx: Int, heap: MutableList<List<Int>>) {\n        var newCurrentIdx = currentIdx\n        var childOneIdx = currentIdx * 2 + 1\n        while (childOneIdx <= endIdx) {\n            var childTwoIdx = if (newCurrentIdx * 2 + 2 <= endIdx) newCurrentIdx * 2 + 2 else -1\n            var idxToSwap: Int\n            if (childTwoIdx != -1 && heap[childTwoIdx][1] < heap[childOneIdx][1]) {\n                idxToSwap = childTwoIdx\n            } else {\n                idxToSwap = childOneIdx\n            }\n            if (heap[idxToSwap][1] < heap[newCurrentIdx][1]) {\n                this.swap(newCurrentIdx, idxToSwap, heap)\n                newCurrentIdx = idxToSwap\n                childOneIdx = newCurrentIdx * 2 + 1\n            } else {\n                return\n            }\n        }\n    }\n\n    fun siftUp(currentIdx: Int, heap: MutableList<List<Int>>) {\n        var newCurrentIdx = currentIdx\n        var parentIdx = (currentIdx - 1) / 2\n        while (newCurrentIdx > 0 && heap[newCurrentIdx][1] < heap[parentIdx][1]) {\n            this.swap(newCurrentIdx, parentIdx, heap)\n            newCurrentIdx = parentIdx\n            parentIdx = (newCurrentIdx - 1) / 2\n        }\n    }\n\n    fun peek(): List<Int>? {\n        return this.heap[0]\n    }\n\n    fun remove(): List<Int>? {\n        this.swap(0, this.heap.size - 1, this.heap)\n        val valueToRemove = this.heap.removeAt(this.heap.size - 1)\n        this.siftDown(0, this.heap.size - 1, this.heap)\n        return valueToRemove\n    }\n\n    fun insert(value: List<Int>) {\n        this.heap.add(value)\n        this.siftUp(this.heap.size - 1, this.heap)\n    }\n\n    fun swap(i: Int, j: Int, heap: MutableList<List<Int>>) {\n        val temp = heap[j]\n        heap[j] = heap[i]\n        heap[i] = temp\n    }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(nlog(n)) time | O(n) space - where n is the number of times\nfun laptopRentals(times: List<List<Int>>): Int {\n    if (times.size == 0) return 0\n\n    var usedLaptops = 0\n    val startTimes = times.map() { interval -> interval[0] }.toMutableList()\n    startTimes.sort()\n    val endTimes = times.map() { interval -> interval[1] }.toMutableList()\n    endTimes.sort()\n\n    var startIterator = 0\n    var endIterator = 0\n\n    while (startIterator < times.size) {\n        if (startTimes[startIterator] >= endTimes[endIterator]) {\n            usedLaptops -= 1\n            endIterator += 1\n        }\n\n        usedLaptops += 1\n        startIterator += 1\n    }\n\n    return usedLaptops\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.laptopRentals\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(\n            listOf(0, 2),\n            listOf(1, 4),\n            listOf(4, 6),\n            listOf(0, 4),\n            listOf(7, 8),\n            listOf(9, 11),\n            listOf(3, 10),\n        )\n        val expected = 3\n        val output = laptopRentals(input)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.laptopRentals\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(\n            listOf(0, 2),\n            listOf(1, 4),\n            listOf(4, 6),\n            listOf(0, 4),\n            listOf(7, 8),\n            listOf(9, 11),\n            listOf(3, 10),\n        )\n        val expected = 3\n        val output = laptopRentals(input)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def laptopRentals(times):\n    # Write your code here.\n    return 0\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(nlog(n)) time | O(n) space - where n is the number of times\ndef laptopRentals(times):\n    if len(times) == 0:\n        return 0\n\n    times.sort(key=lambda x: x[0])\n\n    timesWhenLaptopIsUsed = [times[0]]\n    heap = MinHeap(timesWhenLaptopIsUsed)\n\n    for idx in range(1, len(times)):\n        currentInterval = times[idx]\n        if heap.peek()[1] <= currentInterval[0]:\n            heap.remove()\n\n        heap.insert(currentInterval)\n\n    return len(timesWhenLaptopIsUsed)\n\n\nclass MinHeap:\n    def __init__(self, array):\n        self.heap = self.buildHeap(array)\n\n    # O(n) time | O(1) space\n    def buildHeap(self, array):\n        firstParentIdx = (len(array) - 2) // 2\n        for currentIdx in reversed(range(firstParentIdx + 1)):\n            self.siftDown(currentIdx, len(array) - 1, array)\n        return array\n\n    # O(log(n)) time | O(1) space\n    def siftDown(self, currentIdx, endIdx, heap):\n        childOneIdx = currentIdx * 2 + 1\n        while childOneIdx <= endIdx:\n            childTwoIdx = currentIdx * 2 + 2 if currentIdx * 2 + 2 <= endIdx else -1\n            if childTwoIdx != -1 and heap[childTwoIdx][1] < heap[childOneIdx][1]:\n                idxToSwap = childTwoIdx\n            else:\n                idxToSwap = childOneIdx\n            if heap[idxToSwap][1] < heap[currentIdx][1]:\n                self.swap(currentIdx, idxToSwap, heap)\n                currentIdx = idxToSwap\n                childOneIdx = currentIdx * 2 + 1\n            else:\n                return\n\n    # O(log(n)) time | O(1) space\n    def siftUp(self, currentIdx, heap):\n        parentIdx = (currentIdx - 1) // 2\n        while currentIdx > 0 and heap[currentIdx][1] < heap[parentIdx][1]:\n            self.swap(currentIdx, parentIdx, heap)\n            currentIdx = parentIdx\n            parentIdx = (currentIdx - 1) // 2\n\n    # O(1) time | O(1) space\n    def peek(self):\n        return self.heap[0]\n\n    # O(log(n)) time | O(1) space\n    def remove(self):\n        self.swap(0, len(self.heap) - 1, self.heap)\n        valueToRemove = self.heap.pop()\n        self.siftDown(0, len(self.heap) - 1, self.heap)\n        return valueToRemove\n\n    # O(log(n)) time | O(1) space\n    def insert(self, value):\n        self.heap.append(value)\n        self.siftUp(len(self.heap) - 1, self.heap)\n\n    def swap(self, i, j, heap):\n        heap[i], heap[j] = heap[j], heap[i]\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(nlog(n)) time | O(n) space - where n is the number of times\ndef laptopRentals(times):\n    if len(times) == 0:\n        return 0\n\n    usedLaptops = 0\n    startTimes = sorted([interval[0] for interval in times])\n    endTimes = sorted([interval[1] for interval in times])\n\n    startIterator = 0\n    endIterator = 0\n\n    while startIterator < len(times):\n        if startTimes[startIterator] >= endTimes[endIterator]:\n            usedLaptops -= 1\n            endIterator += 1\n\n        usedLaptops += 1\n        startIterator += 1\n\n    return usedLaptops\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [[0, 2], [1, 4], [4, 6], [0, 4], [7, 8], [9, 11], [3, 10]]\n        expected = 3\n        actual = program.laptopRentals(input)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [[0, 2], [1, 4], [4, 6], [0, 4], [7, 8], [9, 11], [3, 10]]\n        expected = 3\n        actual = program.laptopRentals(input)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "class Program\n  def laptopRentals(times)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def laptopRentals(times)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.laptopRentals\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.laptopRentals\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func laptopRentals(_ times: [[Int]]) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(nlog(n)) time | O(n) space - where n is the number of times\n  func laptopRentals(_ times: [[Int]]) -> Int {\n    if times.count == 0 {\n      return 0\n    }\n\n    let sortedTimes = times.sorted(by: { $0[0] < $1[0] })\n    var timesWhenLaptopIsUsed = [sortedTimes[0]]\n\n    var heap = MinHeap(timesWhenLaptopIsUsed)\n\n    for idx in stride(from: 1, to: sortedTimes.count, by: 1) {\n      let currentInterval = sortedTimes[idx]\n      if heap.peek()[1] <= currentInterval[0] {\n        heap.remove()\n      }\n\n      heap.insert(currentInterval)\n    }\n    return heap.length()\n  }\n\n  class MinHeap {\n    var heap = [[Int]]()\n\n    init(_ array: [[Int]]) {\n      heap = array\n      buildHeap(array: array)\n    }\n\n    func buildHeap(array: [[Int]]) {\n      var firstParentIndex = Double((array.count - 2) / 2)\n      firstParentIndex = firstParentIndex.rounded(.down)\n\n      for var currentIndex in (0 ... Int(firstParentIndex)).reversed() {\n        var endIndex = array.count - 1\n        siftDown(currentIndex, endIndex)\n      }\n    }\n\n    func siftDown(_ currentIndex: Int, _ endIndex: Int) {\n      var childOneIdx = currentIndex * 2 + 1\n      var current = currentIndex\n      while childOneIdx <= endIndex {\n        var childTwoIdx = -1\n        if current * 2 + 2 <= endIndex {\n          childTwoIdx = current * 2 + 2\n        }\n        var indexToSwap = childOneIdx\n        if childTwoIdx != -1, heap[childTwoIdx][1] < heap[childOneIdx][1] {\n          indexToSwap = childTwoIdx\n        }\n\n        if heap[indexToSwap][1] < heap[current][1] {\n          swap(current, indexToSwap)\n          current = indexToSwap\n          childOneIdx = current * 2 + 1\n        } else {\n          return\n        }\n      }\n    }\n\n    func siftUp() {\n      var currentIndex = heap.count - 1\n      var parentIndex = (currentIndex - 1) / 2\n\n      while currentIndex > 0, heap[currentIndex][1] < heap[parentIndex][1] {\n        swap(currentIndex, parentIndex)\n        currentIndex = parentIndex\n        parentIndex = (currentIndex - 1) / 2\n      }\n    }\n\n    func peek() -> [Int] {\n      return heap[0]\n    }\n\n    func remove() -> [Int] {\n      var l = heap.count\n      swap(0, l - 1)\n      var peeked = heap[l - 1]\n      heap.removeLast()\n      siftDown(0, l - 2)\n      return peeked\n    }\n\n    func insert(_ value: [Int]) {\n      heap.append(value)\n      siftUp()\n    }\n\n    func swap(_ firstIndex: Int, _ secondIndex: Int) {\n      let temp = heap[firstIndex]\n      heap[firstIndex] = heap[secondIndex]\n      heap[secondIndex] = temp\n    }\n\n    func length() -> Int {\n      return heap.count\n    }\n\n    func isEmpty() -> Bool {\n      return length() == 0\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(nlog(n)) time | O(n) space - where n is the number of times\n  func laptopRentals(_ times: [[Int]]) -> Int {\n    if times.count == 0 {\n      return 0\n    }\n\n    var usedLaptops = 0\n    var (startTimes, endTimes) = ([Int](), [Int]())\n    for time in times {\n      startTimes.append(time[0])\n      endTimes.append(time[1])\n    }\n    startTimes.sort()\n    endTimes.sort()\n\n    var startIterator = 0\n    var endIterator = 0\n\n    while startIterator < times.count {\n      if startTimes[startIterator] >= endTimes[endIterator] {\n        usedLaptops -= 1\n        endIterator += 1\n      }\n\n      usedLaptops += 1\n      startIterator += 1\n    }\n    return usedLaptops\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let input = [\n        [0, 2],\n        [1, 4],\n        [4, 6],\n        [0, 4],\n        [7, 8],\n        [9, 11],\n        [3, 10],\n      ]\n      var expected = 3\n      var actual = Program().laptopRentals(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let input = [\n        [0, 2],\n        [1, 4],\n        [4, 6],\n        [0, 4],\n        [7, 8],\n        [9, 11],\n        [3, 10],\n      ]\n      var expected = 3\n      var actual = Program().laptopRentals(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function laptopRentals(times: number[][]) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(nlog(n)) time | O(n) space - where n is the number of times\nexport function laptopRentals(times: number[][]) {\n  if (times.length === 0) return 0;\n\n  times.sort((a, b) => a[0] - b[0]);\n\n  const timesWhenLaptopIsUsed = [times[0]];\n  const heap = new MinHeap(timesWhenLaptopIsUsed);\n\n  for (let idx = 1; idx < times.length; idx++) {\n    const currentInterval = times[idx];\n    if (heap.peek()[1] <= currentInterval[0]) heap.remove();\n\n    heap.insert(currentInterval);\n  }\n\n  return timesWhenLaptopIsUsed.length;\n}\n\nclass MinHeap {\n  heap: number[][];\n\n  constructor(array: number[][]) {\n    this.heap = this.buildHeap(array);\n  }\n\n  // O(n) time | O(1) space\n  buildHeap(array: number[][]) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  // O(log(n)) time | O(1) space\n  siftDown(currentIdx: number, endIdx: number, heap: number[][]) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx][1] < heap[childOneIdx][1]) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap][1] < heap[currentIdx][1]) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  siftUp(currentIdx: number, heap: number[][]) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx][1] < heap[parentIdx][1]) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  // O(1) time | O(1) space\n  peek() {\n    return this.heap[0];\n  }\n\n  // O(log(n)) time | O(1) space\n  remove() {\n    this.swap(0, this.heap.length - 1, this.heap);\n    const valueToRemove = this.heap.pop();\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return valueToRemove;\n  }\n\n  // O(log(n)) time | O(1) space\n  insert(value: number[]) {\n    this.heap.push(value);\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i: number, j: number, heap: number[][]) {\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(nlog(n)) time | O(n) space - where n is the number of times\nexport function laptopRentals(times: number[][]) {\n  if (times.length === 0) return 0;\n\n  let usedLaptops = 0;\n  const startTimes = times.map(a => a[0]).sort((a, b) => a - b);\n  const endTimes = times.map(a => a[1]).sort((a, b) => a - b);\n\n  let startIterator = 0;\n  let endIterator = 0;\n\n  while (startIterator < times.length) {\n    if (startTimes[startIterator] >= endTimes[endIterator]) {\n      usedLaptops--;\n      endIterator++;\n    }\n\n    usedLaptops++;\n    startIterator++;\n  }\n\n  return usedLaptops;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [0, 2],\n    [1, 4],\n    [4, 6],\n    [0, 4],\n    [7, 8],\n    [9, 11],\n    [3, 10],\n  ];\n  const expected = 3;\n  const actual = program.laptopRentals(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [0, 2],\n    [1, 4],\n    [4, 6],\n    [0, 4],\n    [7, 8],\n    [9, 11],\n    [3, 10],\n  ];\n  const expected = 3;\n  const actual = program.laptopRentals(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "times",
      "example": [
        [
          0,
          2
        ],
        [
          1,
          4
        ],
        [
          4,
          6
        ],
        [
          0,
          4
        ],
        [
          7,
          8
        ],
        [
          9,
          11
        ],
        [
          3,
          10
        ]
      ],
      "schema": {
        "items": {
          "items": {
            "minimum": 0,
            "type": "integer"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "times": [
        [
          0,
          2
        ],
        [
          1,
          4
        ],
        [
          4,
          6
        ],
        [
          0,
          4
        ],
        [
          7,
          8
        ],
        [
          9,
          11
        ],
        [
          3,
          10
        ]
      ]
    },
    {
      "times": [
        [
          0,
          4
        ],
        [
          2,
          3
        ],
        [
          2,
          3
        ],
        [
          2,
          3
        ]
      ]
    },
    {
      "times": [
        [
          1,
          5
        ],
        [
          5,
          6
        ],
        [
          6,
          7
        ],
        [
          7,
          9
        ]
      ]
    },
    {
      "times": [
        [
          0,
          4
        ]
      ]
    },
    {
      "times": []
    },
    {
      "times": [
        [
          0,
          5
        ],
        [
          2,
          4
        ],
        [
          4,
          7
        ],
        [
          5,
          7
        ],
        [
          9,
          20
        ],
        [
          3,
          15
        ],
        [
          6,
          10
        ]
      ]
    },
    {
      "times": [
        [
          10,
          20
        ],
        [
          0,
          5
        ],
        [
          5,
          10
        ],
        [
          10,
          15
        ]
      ]
    },
    {
      "times": [
        [
          0,
          5
        ],
        [
          3,
          8
        ],
        [
          4,
          10
        ],
        [
          7,
          11
        ],
        [
          6,
          10
        ]
      ]
    },
    {
      "times": [
        [
          0,
          5
        ],
        [
          1,
          4
        ],
        [
          2,
          3
        ],
        [
          3,
          8
        ],
        [
          7,
          9
        ],
        [
          11,
          20
        ],
        [
          0,
          20
        ],
        [
          3,
          10
        ]
      ]
    },
    {
      "times": [
        [
          10,
          20
        ],
        [
          5,
          15
        ],
        [
          0,
          6
        ],
        [
          0,
          20
        ],
        [
          21,
          22
        ],
        [
          0,
          1
        ],
        [
          2,
          5
        ]
      ]
    },
    {
      "times": [
        [
          0,
          10
        ],
        [
          1,
          9
        ],
        [
          2,
          8
        ],
        [
          3,
          7
        ],
        [
          4,
          6
        ],
        [
          5,
          6
        ]
      ]
    },
    {
      "times": [
        [
          0,
          20
        ],
        [
          0,
          10
        ],
        [
          1,
          9
        ],
        [
          2,
          8
        ],
        [
          3,
          7
        ],
        [
          4,
          6
        ],
        [
          5,
          6
        ],
        [
          10,
          15
        ],
        [
          11,
          12
        ]
      ]
    },
    {
      "times": [
        [
          5,
          10
        ],
        [
          1,
          2
        ],
        [
          1,
          2
        ],
        [
          1,
          2
        ],
        [
          3,
          5
        ],
        [
          4,
          5
        ]
      ]
    },
    {
      "times": [
        [
          1,
          3
        ],
        [
          2,
          5
        ],
        [
          4,
          5
        ],
        [
          0,
          20
        ],
        [
          1,
          10
        ],
        [
          10,
          20
        ],
        [
          11,
          15
        ],
        [
          12,
          13
        ],
        [
          0,
          1
        ],
        [
          0,
          2
        ]
      ]
    },
    {
      "times": [
        [
          5,
          6
        ],
        [
          4,
          5
        ],
        [
          3,
          4
        ],
        [
          2,
          3
        ],
        [
          1,
          2
        ]
      ]
    }
  ],
  "jsonTests": [
    {
      "times": [
        [
          0,
          2
        ],
        [
          1,
          4
        ],
        [
          4,
          6
        ],
        [
          0,
          4
        ],
        [
          7,
          8
        ],
        [
          9,
          11
        ],
        [
          3,
          10
        ]
      ]
    },
    {
      "times": [
        [
          0,
          4
        ],
        [
          2,
          3
        ],
        [
          2,
          3
        ],
        [
          2,
          3
        ]
      ]
    },
    {
      "times": [
        [
          1,
          5
        ],
        [
          5,
          6
        ],
        [
          6,
          7
        ],
        [
          7,
          9
        ]
      ]
    },
    {
      "times": [
        [
          0,
          4
        ]
      ]
    },
    {
      "times": []
    },
    {
      "times": [
        [
          0,
          5
        ],
        [
          2,
          4
        ],
        [
          4,
          7
        ],
        [
          5,
          7
        ],
        [
          9,
          20
        ],
        [
          3,
          15
        ],
        [
          6,
          10
        ]
      ]
    },
    {
      "times": [
        [
          10,
          20
        ],
        [
          0,
          5
        ],
        [
          5,
          10
        ],
        [
          10,
          15
        ]
      ]
    },
    {
      "times": [
        [
          0,
          5
        ],
        [
          3,
          8
        ],
        [
          4,
          10
        ],
        [
          7,
          11
        ],
        [
          6,
          10
        ]
      ]
    },
    {
      "times": [
        [
          0,
          5
        ],
        [
          1,
          4
        ],
        [
          2,
          3
        ],
        [
          3,
          8
        ],
        [
          7,
          9
        ],
        [
          11,
          20
        ],
        [
          0,
          20
        ],
        [
          3,
          10
        ]
      ]
    },
    {
      "times": [
        [
          10,
          20
        ],
        [
          5,
          15
        ],
        [
          0,
          6
        ],
        [
          0,
          20
        ],
        [
          21,
          22
        ],
        [
          0,
          1
        ],
        [
          2,
          5
        ]
      ]
    },
    {
      "times": [
        [
          0,
          10
        ],
        [
          1,
          9
        ],
        [
          2,
          8
        ],
        [
          3,
          7
        ],
        [
          4,
          6
        ],
        [
          5,
          6
        ]
      ]
    },
    {
      "times": [
        [
          0,
          20
        ],
        [
          0,
          10
        ],
        [
          1,
          9
        ],
        [
          2,
          8
        ],
        [
          3,
          7
        ],
        [
          4,
          6
        ],
        [
          5,
          6
        ],
        [
          10,
          15
        ],
        [
          11,
          12
        ]
      ]
    },
    {
      "times": [
        [
          5,
          10
        ],
        [
          1,
          2
        ],
        [
          1,
          2
        ],
        [
          1,
          2
        ],
        [
          3,
          5
        ],
        [
          4,
          5
        ]
      ]
    },
    {
      "times": [
        [
          1,
          3
        ],
        [
          2,
          5
        ],
        [
          4,
          5
        ],
        [
          0,
          20
        ],
        [
          1,
          10
        ],
        [
          10,
          20
        ],
        [
          11,
          15
        ],
        [
          12,
          13
        ],
        [
          0,
          1
        ],
        [
          0,
          2
        ]
      ]
    },
    {
      "times": [
        [
          5,
          6
        ],
        [
          4,
          5
        ],
        [
          3,
          4
        ],
        [
          2,
          3
        ],
        [
          1,
          2
        ]
      ]
    }
  ],
  "changelog": []
}