{
  "uid": "linked-list-construction",
  "testStrategy": "JSON",
  "name": "Linked List Construction",
  "version": 0,
  "releaseDate": "2018-10-20T00:00:00Z",
  "category": "Linked Lists",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 17005,
    "failureCount": 12389
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "293493132",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 2101
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a <span>DoublyLinkedList</span> class that has a <span>head</span> and a\n  <span>tail</span>, both of which point to either a linked list\n  <span>Node</span> or <span>None</span> / <span>null</span>. The class should\n  support:\n</p>\n<ul>\n  <li>\n    Setting the head and tail of the linked list.\n  </li>\n  <li>\n    Inserting nodes before and after other nodes as well as at given positions\n    (the position of the head node is <span>1</span>).\n  </li>\n  <li>Removing given nodes and removing nodes with given values.</li>\n  <li>Searching for nodes with given values.</li>\n</ul>\n<p>\n  Note that the <span>setHead</span>, <span>setTail</span>,\n  <span>insertBefore</span>, <span>insertAfter</span>,\n  <span>insertAtPosition</span>, and <span>remove</span> methods all take in\n  actual <span>Node</span>s as input parameters—not integers (except for\n  <span>insertAtPosition</span>, which also takes in an integer representing the\n  position); this means that you don't need to create any new <span>Node</span>s\n  in these methods. The input nodes can be either stand-alone nodes or nodes\n  that are already in the linked list. If they're nodes that are already in the\n  linked list, the methods will effectively be <i>moving</i> the nodes within\n  the linked list. You won't be told if the input nodes are already in the\n  linked list, so your code will have to defensively handle this scenario.\n</p>\n<p>\n  If you're doing this problem in an untyped language like Python or JavaScript,\n  you may want to look at the various function signatures in a typed language\n  like Java or TypeScript to get a better idea of what each input parameter is.\n</p>\n<p>\n  Each <span>Node</span> has an integer <span>value</span> as well as a\n  <span>prev</span> node and a <span>next</span> node, both of which can point\n  to either another node or <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Usage</h3>\n<pre>\n<span class=\"CodeEditor-promptComment\">// Assume the following linked list has already been created:</span>\n1 <-> 2 <-> 3 <-> 4 <-> 5\n<span class=\"CodeEditor-promptComment\">// Assume that we also have the following stand-alone nodes:</span>\n3, 3, 6\n<span class=\"CodeEditor-promptParameter\">setHead</span>(4): 4 <-> 1 <-> 2 <-> 3 <-> 5 <span class=\"CodeEditor-promptComment\">// set the existing node with value 4 as the head</span>\n<span class=\"CodeEditor-promptParameter\">setTail</span>(6): 4 <-> 1 <-> 2 <-> 3 <-> 5 <-> 6 <span class=\"CodeEditor-promptComment\">// set the stand-alone node with value 6 as the tail</span>\n<span class=\"CodeEditor-promptParameter\">insertBefore</span>(6, 3): 4 <-> 1 <-> 2 <-> 5 <-> 3 <-> 6 <span class=\"CodeEditor-promptComment\">// move the existing node with value 3 before the existing node with value 6</span>\n<span class=\"CodeEditor-promptParameter\">insertAfter</span>(6, 3): 4 <-> 1 <-> 2 <-> 5 <-> 3 <-> 6 <-> 3 <span class=\"CodeEditor-promptComment\">// insert a stand-alone node with value 3 after the existing node with value 6</span>\n<span class=\"CodeEditor-promptParameter\">insertAtPosition</span>(1, 3): 3 <-> 4 <-> 1 <-> 2 <-> 5 <-> 3 <-> 6 <-> 3 <span class=\"CodeEditor-promptComment\">// insert a stand-alone node with value 3 in position 1</span>\n<span class=\"CodeEditor-promptParameter\">removeNodesWithValue</span>(3): 4 <-> 1 <-> 2 <-> 5 <-> 6 <span class=\"CodeEditor-promptComment\">// remove all nodes with value 3</span>\n<span class=\"CodeEditor-promptParameter\">remove</span>(2): 4 <-> 1 <-> 5 <-> 6 <span class=\"CodeEditor-promptComment\">// remove the existing node with value 2</span>\n<span class=\"CodeEditor-promptParameter\">containsNodeWithValue</span>(5): true\n</pre>\n</div>",
  "hints": [
    "<p>\nWhen dealing with linked lists, it's very important to keep track of pointers on nodes (i.e., the \"next\" and \"prev\" properties on the nodes). For instance, if you're inserting a node in a linked list, but that node is already located somewhere else in the linked list (in other words, if you're moving a node), it's crucial to completely update the pointers of the adjacent nodes of the node being moved before updating the node's own pointers. The order in which you update nodes' pointers will make or break your algorithm.\n</p>\n",
    "\n<p>\nRealize that the insertBefore() and insertAfter() methods can be used to implement the setHead(), setTail(), and insertAtPosition() methods; making the insertBefore() and insertAfter() methods as robust as possible will simplify your code for the other methods. Make sure to take care of edge cases involving inserting nodes before the head of the linked list or inserting nodes after the tail of the linked list.\n</p>\n",
    "\n<p>\nSimilar to Hint #2, realize that the remove() method can be used to implement the removeNodesWithValue() method as well as parts of the insertBefore() and insertAfter() methods; make sure that the remove() method handles edge cases regarding the head and the tail.\n</p>"
  ],
  "spaceTime": "setHead, setTail, insertBefore, insertAfter, and remove: O(1) time | O(1) space\ninsertAtPosition: O(p) time | O(1) space - where p is input position\nremoveNodesWithValue, containsNodeWithValue: O(n) time | O(1) space - where n is the number of nodes in the linked list",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": true,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\nclass Node {\n public:\n  int value;\n  Node* prev;\n  Node* next;\n\n  Node(int value);\n};\n\n// Feel free to add new properties and methods to the class.\nclass DoublyLinkedList {\n public:\n  Node* head;\n  Node* tail;\n\n  DoublyLinkedList() {\n    head = nullptr;\n    tail = nullptr;\n  }\n\n  void setHead(Node* node) {\n    // Write your code here.\n  }\n\n  void setTail(Node* node) {\n    // Write your code here.\n  }\n\n  void insertBefore(Node* node, Node* nodeToInsert) {\n    // Write your code here.\n  }\n\n  void insertAfter(Node* node, Node* nodeToInsert) {\n    // Write your code here.\n  }\n\n  void insertAtPosition(int position, Node* nodeToInsert) {\n    // Write your code here.\n  }\n\n  void removeNodesWithValue(int value) {\n    // Write your code here.\n  }\n\n  void remove(Node* node) {\n    // Write your code here.\n  }\n\n  bool containsNodeWithValue(int value) {\n    // Write your code here.\n    return false;\n  }\n};\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\nclass Node {\n public:\n  int value;\n  Node* prev;\n  Node* next;\n\n  Node(int value);\n};\n\nclass DoublyLinkedList {\n public:\n  Node* head;\n  Node* tail;\n\n  DoublyLinkedList() {\n    head = nullptr;\n    tail = nullptr;\n  }\n\n  // O(1) time | O(1) space\n  void setHead(Node* node) {\n    if (head == nullptr) {\n      head = node;\n      tail = node;\n      return;\n    }\n    insertBefore(head, node);\n  }\n\n  // O(1) time | O(1) space\n  void setTail(Node* node) {\n    if (tail == nullptr) {\n      setHead(node);\n      return;\n    }\n    insertAfter(tail, node);\n  }\n\n  // O(1) time | O(1) space\n  void insertBefore(Node* node, Node* nodeToInsert) {\n    if (nodeToInsert == head && nodeToInsert == tail) return;\n    remove(nodeToInsert);\n    nodeToInsert->prev = node->prev;\n    nodeToInsert->next = node;\n    if (node->prev == nullptr) {\n      head = nodeToInsert;\n    } else {\n      node->prev->next = nodeToInsert;\n    }\n    node->prev = nodeToInsert;\n  }\n\n  // O(1) time | O(1) space\n  void insertAfter(Node* node, Node* nodeToInsert) {\n    if (nodeToInsert == head && nodeToInsert == tail) return;\n    remove(nodeToInsert);\n    nodeToInsert->prev = node;\n    nodeToInsert->next = node->next;\n    if (node->next == nullptr) {\n      tail = nodeToInsert;\n    } else {\n      node->next->prev = nodeToInsert;\n    }\n    node->next = nodeToInsert;\n  }\n\n  // O(p) time | O(1) space\n  void insertAtPosition(int position, Node* nodeToInsert) {\n    if (position == 1) {\n      setHead(nodeToInsert);\n      return;\n    }\n    Node* node = head;\n    int currentPosition = 1;\n    while (node != nullptr && currentPosition++ != position) node = node->next;\n    if (node != nullptr) {\n      insertBefore(node, nodeToInsert);\n    } else {\n      setTail(nodeToInsert);\n    }\n  }\n\n  // O(n) time | O(1) space\n  void removeNodesWithValue(int value) {\n    Node* node = head;\n    while (node != nullptr) {\n      Node* nodeToRemove = node;\n      node = node->next;\n      if (nodeToRemove->value == value) remove(nodeToRemove);\n    }\n  }\n\n  // O(1) time | O(1) space\n  void remove(Node* node) {\n    if (node == head) head = head->next;\n    if (node == tail) tail = tail->prev;\n    removeNodeBindings(node);\n  }\n\n  // O(n) time | O(1) space\n  bool containsNodeWithValue(int value) {\n    Node* node = head;\n    while (node != nullptr && node->value != value) node = node->next;\n    return node != nullptr;\n  }\n\n  void removeNodeBindings(Node* node) {\n    if (node->prev != nullptr) node->prev->next = node->next;\n    if (node->next != nullptr) node->next->prev = node->prev;\n    node->prev = nullptr;\n    node->next = nullptr;\n  }\n};\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include <vector>\n\nNode::Node(int value) {\n  this->value = value;\n  prev = nullptr;\n  next = nullptr;\n};\n\nvector<int> getNodeValuesHeadToTail(DoublyLinkedList linkedList) {\n  vector<int> values = {};\n  Node* node = linkedList.head;\n  while (node != nullptr) {\n    values.push_back(node->value);\n    node = node->next;\n  }\n  return values;\n}\n\nvector<int> getNodeValuesTailToHead(DoublyLinkedList linkedList) {\n  vector<int> values = {};\n  Node* node = linkedList.tail;\n  while (node != nullptr) {\n    values.push_back(node->value);\n    node = node->prev;\n  }\n  return values;\n}\n\nvoid bindNodes(Node* nodeOne, Node* nodeTwo) {\n  nodeOne->next = nodeTwo;\n  nodeTwo->prev = nodeOne;\n}\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      DoublyLinkedList linkedList;\n      Node one(1);\n      Node two(2);\n      Node three(3);\n      Node three2(3);\n      Node three3(3);\n      Node four(4);\n      Node five(5);\n      Node six(6);\n      bindNodes(&one, &two);\n      bindNodes(&two, &three);\n      bindNodes(&three, &four);\n      bindNodes(&four, &five);\n      linkedList.head = &one;\n      linkedList.tail = &five;\n\n      linkedList.setHead(&four);\n      assert(\n        getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 2, 3, 5})\n      );\n      assert(\n        getNodeValuesTailToHead(linkedList) == (vector<int>{5, 3, 2, 1, 4})\n      );\n\n      linkedList.setTail(&six);\n      assert(\n        getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 2, 3, 5, 6})\n      );\n      assert(\n        getNodeValuesTailToHead(linkedList) == (vector<int>{6, 5, 3, 2, 1, 4})\n      );\n\n      linkedList.insertBefore(&six, &three);\n      assert(\n        getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 2, 5, 3, 6})\n      );\n      assert(\n        getNodeValuesTailToHead(linkedList) == (vector<int>{6, 3, 5, 2, 1, 4})\n      );\n\n      linkedList.insertAfter(&six, &three2);\n      assert(\n        getNodeValuesHeadToTail(linkedList) ==\n        (vector<int>{4, 1, 2, 5, 3, 6, 3})\n      );\n      assert(\n        getNodeValuesTailToHead(linkedList) ==\n        (vector<int>{3, 6, 3, 5, 2, 1, 4})\n      );\n\n      linkedList.insertAtPosition(1, &three3);\n      assert(\n        getNodeValuesHeadToTail(linkedList) ==\n        (vector<int>{3, 4, 1, 2, 5, 3, 6, 3})\n      );\n      assert(\n        getNodeValuesTailToHead(linkedList) ==\n        (vector<int>{3, 6, 3, 5, 2, 1, 4, 3})\n      );\n\n      linkedList.removeNodesWithValue(3);\n      assert(\n        getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 2, 5, 6})\n      );\n      assert(\n        getNodeValuesTailToHead(linkedList) == (vector<int>{6, 5, 2, 1, 4})\n      );\n\n      linkedList.remove(&two);\n      assert(getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 5, 6}));\n      assert(getNodeValuesTailToHead(linkedList) == (vector<int>{6, 5, 1, 4}));\n\n      assert(linkedList.containsNodeWithValue(5) == true);\n    });\n  }\n};\n",
      "unitTests": "#include <vector>\n\nNode::Node(int value) {\n  this->value = value;\n  prev = nullptr;\n  next = nullptr;\n};\n\nvector<int> getNodeValuesHeadToTail(DoublyLinkedList linkedList) {\n  vector<int> values = {};\n  Node* node = linkedList.head;\n  while (node != nullptr) {\n    values.push_back(node->value);\n    node = node->next;\n  }\n  return values;\n}\n\nvector<int> getNodeValuesTailToHead(DoublyLinkedList linkedList) {\n  vector<int> values = {};\n  Node* node = linkedList.tail;\n  while (node != nullptr) {\n    values.push_back(node->value);\n    node = node->prev;\n  }\n  return values;\n}\n\nvoid bindNodes(Node* nodeOne, Node* nodeTwo) {\n  nodeOne->next = nodeTwo;\n  nodeTwo->prev = nodeOne;\n}\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      DoublyLinkedList linkedList;\n      Node one(1);\n      Node two(2);\n      Node three(3);\n      Node three2(3);\n      Node three3(3);\n      Node four(4);\n      Node five(5);\n      Node six(6);\n      bindNodes(&one, &two);\n      bindNodes(&two, &three);\n      bindNodes(&three, &four);\n      bindNodes(&four, &five);\n      linkedList.head = &one;\n      linkedList.tail = &five;\n\n      linkedList.setHead(&four);\n      assert(\n        getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 2, 3, 5})\n      );\n      assert(\n        getNodeValuesTailToHead(linkedList) == (vector<int>{5, 3, 2, 1, 4})\n      );\n\n      linkedList.setTail(&six);\n      assert(\n        getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 2, 3, 5, 6})\n      );\n      assert(\n        getNodeValuesTailToHead(linkedList) == (vector<int>{6, 5, 3, 2, 1, 4})\n      );\n\n      linkedList.insertBefore(&six, &three);\n      assert(\n        getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 2, 5, 3, 6})\n      );\n      assert(\n        getNodeValuesTailToHead(linkedList) == (vector<int>{6, 3, 5, 2, 1, 4})\n      );\n\n      linkedList.insertAfter(&six, &three2);\n      assert(\n        getNodeValuesHeadToTail(linkedList) ==\n        (vector<int>{4, 1, 2, 5, 3, 6, 3})\n      );\n      assert(\n        getNodeValuesTailToHead(linkedList) ==\n        (vector<int>{3, 6, 3, 5, 2, 1, 4})\n      );\n\n      linkedList.insertAtPosition(1, &three3);\n      assert(\n        getNodeValuesHeadToTail(linkedList) ==\n        (vector<int>{3, 4, 1, 2, 5, 3, 6, 3})\n      );\n      assert(\n        getNodeValuesTailToHead(linkedList) ==\n        (vector<int>{3, 6, 3, 5, 2, 1, 4, 3})\n      );\n\n      linkedList.removeNodesWithValue(3);\n      assert(\n        getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 2, 5, 6})\n      );\n      assert(\n        getNodeValuesTailToHead(linkedList) == (vector<int>{6, 5, 2, 1, 4})\n      );\n\n      linkedList.remove(&two);\n      assert(getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 5, 6}));\n      assert(getNodeValuesTailToHead(linkedList) == (vector<int>{6, 5, 1, 4}));\n\n      assert(linkedList.containsNodeWithValue(5) == true);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n// Feel free to add new properties and methods to the class.\npublic class Program {\n  public class DoublyLinkedList {\n    public Node Head;\n    public Node Tail;\n\n    public void SetHead(Node node) {\n      // Write your code here.\n    }\n\n    public void SetTail(Node node) {\n      // Write your code here.\n    }\n\n    public void InsertBefore(Node node, Node nodeToInsert) {\n      // Write your code here.\n    }\n\n    public void InsertAfter(Node node, Node nodeToInsert) {\n      // Write your code here.\n    }\n\n    public void InsertAtPosition(int position, Node nodeToInsert) {\n      // Write your code here.\n    }\n\n    public void RemoveNodesWithValue(int value) {\n      // Write your code here.\n    }\n\n    public void Remove(Node node) {\n      // Write your code here.\n    }\n\n    public bool ContainsNodeWithValue(int value) {\n      // Write your code here.\n      return false;\n    }\n  }\n\n  // Do not edit the class below.\n  public class Node {\n    public int Value;\n    public Node Prev;\n    public Node Next;\n\n    public Node(int value) {\n      this.Value = value;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n  public class DoublyLinkedList {\n    public Node Head;\n    public Node Tail;\n\n    // O(1) time | O(1) space\n    public void SetHead(Node node) {\n      if (Head == null) {\n        Head = node;\n        Tail = node;\n        return;\n      }\n      InsertBefore(Head, node);\n    }\n\n    // O(1) time | O(1) space\n    public void SetTail(Node node) {\n      if (Tail == null) {\n        SetHead(node);\n        return;\n      }\n      InsertAfter(Tail, node);\n    }\n\n    // O(1) time | O(1) space\n    public void InsertBefore(Node node, Node nodeToInsert) {\n      if (nodeToInsert == Head && nodeToInsert == Tail) return;\n      Remove(nodeToInsert);\n      nodeToInsert.Prev = node.Prev;\n      nodeToInsert.Next = node;\n      if (node.Prev == null) {\n        Head = nodeToInsert;\n      } else {\n        node.Prev.Next = nodeToInsert;\n      }\n      node.Prev = nodeToInsert;\n    }\n\n    // O(1) time | O(1) space\n    public void InsertAfter(Node node, Node nodeToInsert) {\n      if (nodeToInsert == Head && nodeToInsert == Tail) return;\n      Remove(nodeToInsert);\n      nodeToInsert.Prev = node;\n      nodeToInsert.Next = node.Next;\n      if (node.Next == null) {\n        Tail = nodeToInsert;\n      } else {\n        node.Next.Prev = nodeToInsert;\n      }\n      node.Next = nodeToInsert;\n    }\n\n    // O(p) time | O(1) space\n    public void InsertAtPosition(int position, Node nodeToInsert) {\n      if (position == 1) {\n        SetHead(nodeToInsert);\n        return;\n      }\n      Node node = Head;\n      int currentPosition = 1;\n      while (node != null && currentPosition++ != position) node = node.Next;\n      if (node != null) {\n        InsertBefore(node, nodeToInsert);\n      } else {\n        SetTail(nodeToInsert);\n      }\n    }\n\n    // O(n) time | O(1) space\n    public void RemoveNodesWithValue(int value) {\n      Node node = Head;\n      while (node != null) {\n        Node nodeToRemove = node;\n        node = node.Next;\n        if (nodeToRemove.Value == value) Remove(nodeToRemove);\n      }\n    }\n\n    // O(1) time | O(1) space\n    public void Remove(Node node) {\n      if (node == Head) Head = Head.Next;\n      if (node == Tail) Tail = Tail.Prev;\n      RemoveNodeBindings(node);\n    }\n\n    // O(n) time | O(1) space\n    public bool ContainsNodeWithValue(int value) {\n      Node node = Head;\n      while (node != null && node.Value != value) node = node.Next;\n      return node != null;\n    }\n\n    public void RemoveNodeBindings(Node node) {\n      if (node.Prev != null) node.Prev.Next = node.Next;\n      if (node.Next != null) node.Next.Prev = node.Prev;\n      node.Prev = null;\n      node.Next = null;\n    }\n  }\n\n  public class Node {\n    public int Value;\n    public Node Prev;\n    public Node Next;\n\n    public Node(int value) {\n      this.Value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  private List<int> getNodeValuesHeadToTail(Program.DoublyLinkedList linkedList\n  ) {\n    List<int> values = new List<int>();\n    Program.Node node = linkedList.Head;\n    while (node != null) {\n      values.Add(node.Value);\n      node = node.Next;\n    }\n    return values;\n  }\n\n  private List<int> getNodeValuesTailToHead(Program.DoublyLinkedList linkedList\n  ) {\n    List<int> values = new List<int>();\n    Program.Node node = linkedList.Tail;\n    while (node != null) {\n      values.Add(node.Value);\n      node = node.Prev;\n    }\n    return values;\n  }\n\n  private void bindNodes(Program.Node nodeOne, Program.Node nodeTwo) {\n    nodeOne.Next = nodeTwo;\n    nodeTwo.Prev = nodeOne;\n  }\n\n  private bool compare(List<int> array1, int[] array2) {\n    if (array1.Count != array2.Length) {\n      return false;\n    }\n    for (int i = 0; i < array1.Count; i++) {\n      if (array1[i] != array2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  [Test]\n  public void TestCase1() {\n    Program.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n    Program.Node one = new Program.Node(1);\n    Program.Node two = new Program.Node(2);\n    Program.Node three = new Program.Node(3);\n    Program.Node three2 = new Program.Node(3);\n    Program.Node three3 = new Program.Node(3);\n    Program.Node four = new Program.Node(4);\n    Program.Node five = new Program.Node(5);\n    Program.Node six = new Program.Node(6);\n    bindNodes(one, two);\n    bindNodes(two, three);\n    bindNodes(three, four);\n    bindNodes(four, five);\n    linkedList.Head = one;\n    linkedList.Tail = five;\n\n    linkedList.SetHead(four);\n    Utils.AssertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] { 4, 1, 2, 3, 5 })\n    );\n    Utils.AssertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] { 5, 3, 2, 1, 4 })\n    );\n\n    linkedList.SetTail(six);\n    Utils.AssertTrue(compare(\n      getNodeValuesHeadToTail(linkedList), new int[] { 4, 1, 2, 3, 5, 6 }\n    ));\n    Utils.AssertTrue(compare(\n      getNodeValuesTailToHead(linkedList), new int[] { 6, 5, 3, 2, 1, 4 }\n    ));\n\n    linkedList.InsertBefore(six, three);\n    Utils.AssertTrue(compare(\n      getNodeValuesHeadToTail(linkedList), new int[] { 4, 1, 2, 5, 3, 6 }\n    ));\n    Utils.AssertTrue(compare(\n      getNodeValuesTailToHead(linkedList), new int[] { 6, 3, 5, 2, 1, 4 }\n    ));\n\n    linkedList.InsertAfter(six, three2);\n    Utils.AssertTrue(compare(\n      getNodeValuesHeadToTail(linkedList), new int[] { 4, 1, 2, 5, 3, 6, 3 }\n    ));\n    Utils.AssertTrue(compare(\n      getNodeValuesTailToHead(linkedList), new int[] { 3, 6, 3, 5, 2, 1, 4 }\n    ));\n\n    linkedList.InsertAtPosition(1, three3);\n    Utils.AssertTrue(compare(\n      getNodeValuesHeadToTail(linkedList), new int[] { 3, 4, 1, 2, 5, 3, 6, 3 }\n    ));\n    Utils.AssertTrue(compare(\n      getNodeValuesTailToHead(linkedList), new int[] { 3, 6, 3, 5, 2, 1, 4, 3 }\n    ));\n\n    linkedList.RemoveNodesWithValue(3);\n    Utils.AssertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] { 4, 1, 2, 5, 6 })\n    );\n    Utils.AssertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] { 6, 5, 2, 1, 4 })\n    );\n\n    linkedList.Remove(two);\n    Utils.AssertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] { 4, 1, 5, 6 })\n    );\n    Utils.AssertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] { 6, 5, 1, 4 })\n    );\n\n    Utils.AssertTrue(linkedList.ContainsNodeWithValue(5));\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\n\npublic class ProgramTest {\n  private List<int> getNodeValuesHeadToTail(Program.DoublyLinkedList linkedList\n  ) {\n    List<int> values = new List<int>();\n    Program.Node node = linkedList.Head;\n    while (node != null) {\n      values.Add(node.Value);\n      node = node.Next;\n    }\n    return values;\n  }\n\n  private List<int> getNodeValuesTailToHead(Program.DoublyLinkedList linkedList\n  ) {\n    List<int> values = new List<int>();\n    Program.Node node = linkedList.Tail;\n    while (node != null) {\n      values.Add(node.Value);\n      node = node.Prev;\n    }\n    return values;\n  }\n\n  private void bindNodes(Program.Node nodeOne, Program.Node nodeTwo) {\n    nodeOne.Next = nodeTwo;\n    nodeTwo.Prev = nodeOne;\n  }\n\n  private bool compare(List<int> array1, int[] array2) {\n    if (array1.Count != array2.Length) {\n      return false;\n    }\n    for (int i = 0; i < array1.Count; i++) {\n      if (array1[i] != array2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  [Test]\n  public void TestCase1() {\n    Program.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n    Program.Node one = new Program.Node(1);\n    Program.Node two = new Program.Node(2);\n    Program.Node three = new Program.Node(3);\n    Program.Node three2 = new Program.Node(3);\n    Program.Node three3 = new Program.Node(3);\n    Program.Node four = new Program.Node(4);\n    Program.Node five = new Program.Node(5);\n    Program.Node six = new Program.Node(6);\n    bindNodes(one, two);\n    bindNodes(two, three);\n    bindNodes(three, four);\n    bindNodes(four, five);\n    linkedList.Head = one;\n    linkedList.Tail = five;\n\n    linkedList.SetHead(four);\n    Utils.AssertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] { 4, 1, 2, 3, 5 })\n    );\n    Utils.AssertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] { 5, 3, 2, 1, 4 })\n    );\n\n    linkedList.SetTail(six);\n    Utils.AssertTrue(compare(\n      getNodeValuesHeadToTail(linkedList), new int[] { 4, 1, 2, 3, 5, 6 }\n    ));\n    Utils.AssertTrue(compare(\n      getNodeValuesTailToHead(linkedList), new int[] { 6, 5, 3, 2, 1, 4 }\n    ));\n\n    linkedList.InsertBefore(six, three);\n    Utils.AssertTrue(compare(\n      getNodeValuesHeadToTail(linkedList), new int[] { 4, 1, 2, 5, 3, 6 }\n    ));\n    Utils.AssertTrue(compare(\n      getNodeValuesTailToHead(linkedList), new int[] { 6, 3, 5, 2, 1, 4 }\n    ));\n\n    linkedList.InsertAfter(six, three2);\n    Utils.AssertTrue(compare(\n      getNodeValuesHeadToTail(linkedList), new int[] { 4, 1, 2, 5, 3, 6, 3 }\n    ));\n    Utils.AssertTrue(compare(\n      getNodeValuesTailToHead(linkedList), new int[] { 3, 6, 3, 5, 2, 1, 4 }\n    ));\n\n    linkedList.InsertAtPosition(1, three3);\n    Utils.AssertTrue(compare(\n      getNodeValuesHeadToTail(linkedList), new int[] { 3, 4, 1, 2, 5, 3, 6, 3 }\n    ));\n    Utils.AssertTrue(compare(\n      getNodeValuesTailToHead(linkedList), new int[] { 3, 6, 3, 5, 2, 1, 4, 3 }\n    ));\n\n    linkedList.RemoveNodesWithValue(3);\n    Utils.AssertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] { 4, 1, 2, 5, 6 })\n    );\n    Utils.AssertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] { 6, 5, 2, 1, 4 })\n    );\n\n    linkedList.Remove(two);\n    Utils.AssertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] { 4, 1, 5, 6 })\n    );\n    Utils.AssertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] { 6, 5, 1, 4 })\n    );\n\n    Utils.AssertTrue(linkedList.ContainsNodeWithValue(5));\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "// Feel free to add methods and fields to the struct definitions.\npackage main\n\ntype Node struct {\n\tValue      int\n\tPrev, Next *Node\n}\n\ntype DoublyLinkedList struct {\n\tHead, Tail *Node\n}\n\nfunc NewDoublyLinkedList() *DoublyLinkedList {\n\t// Write your code here.\n\treturn nil\n}\n\nfunc (ll *DoublyLinkedList) SetHead(node *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) SetTail(node *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) InsertBefore(node, nodeToInsert *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) InsertAfter(node, nodeToInsert *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) InsertAtPosition(position int, nodeToInsert *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) RemoveNodesWithValue(value int) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) Remove(node *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) ContainsNodeWithValue(value int) bool {\n\t// Write your code here.\n\treturn false\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype Node struct {\n\tValue      int\n\tPrev, Next *Node\n}\n\ntype DoublyLinkedList struct {\n\tHead, Tail *Node\n}\n\nfunc NewDoublyLinkedList() *DoublyLinkedList {\n\treturn &DoublyLinkedList{}\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) SetHead(node *Node) {\n\tif ll.Head == nil {\n\t\tll.Head = node\n\t\tll.Tail = node\n\t\treturn\n\t}\n\tll.InsertBefore(ll.Head, node)\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) SetTail(node *Node) {\n\tif ll.Tail == nil {\n\t\tll.SetHead(node)\n\t\treturn\n\t}\n\tll.InsertAfter(ll.Tail, node)\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) InsertBefore(node, nodeToInsert *Node) {\n\tif nodeToInsert == ll.Head && nodeToInsert == ll.Tail {\n\t\treturn\n\t}\n\tll.Remove(nodeToInsert)\n\tnodeToInsert.Prev = node.Prev\n\tnodeToInsert.Next = node\n\tif node.Prev == nil {\n\t\tll.Head = nodeToInsert\n\t} else {\n\t\tnode.Prev.Next = nodeToInsert\n\t}\n\tnode.Prev = nodeToInsert\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) InsertAfter(node, nodeToInsert *Node) {\n\tif nodeToInsert == ll.Head && nodeToInsert == ll.Tail {\n\t\treturn\n\t}\n\tll.Remove(nodeToInsert)\n\tnodeToInsert.Prev = node\n\tnodeToInsert.Next = node.Next\n\tif node.Next == nil {\n\t\tll.Tail = nodeToInsert\n\t} else {\n\t\tnode.Next.Prev = nodeToInsert\n\t}\n\tnode.Next = nodeToInsert\n}\n\n// O(p) time | O(1) space\nfunc (ll *DoublyLinkedList) InsertAtPosition(position int, nodeToInsert *Node) {\n\tif position == 1 {\n\t\tll.SetHead(nodeToInsert)\n\t\treturn\n\t}\n\tnode := ll.Head\n\tcurrentPosition := 1\n\tfor node != nil && currentPosition != position {\n\t\tnode = node.Next\n\t\tcurrentPosition += 1\n\t}\n\tif node != nil {\n\t\tll.InsertBefore(node, nodeToInsert)\n\t} else {\n\t\tll.SetTail(nodeToInsert)\n\t}\n}\n\n// O(n) time | O(1) space\nfunc (ll *DoublyLinkedList) RemoveNodesWithValue(value int) {\n\tnode := ll.Head\n\tfor node != nil {\n\t\tnodeToRemove := node\n\t\tnode = node.Next\n\t\tif nodeToRemove.Value == value {\n\t\t\tll.Remove(nodeToRemove)\n\t\t}\n\t}\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) Remove(node *Node) {\n\tif node == ll.Head {\n\t\tll.Head = ll.Head.Next\n\t}\n\tif node == ll.Tail {\n\t\tll.Tail = ll.Tail.Prev\n\t}\n\tll.removeNodeBindings(node)\n}\n\n// O(n) time | O(1) space\nfunc (ll *DoublyLinkedList) ContainsNodeWithValue(value int) bool {\n\tnode := ll.Head\n\tfor node != nil && node.Value != value {\n\t\tnode = node.Next\n\t}\n\treturn node != nil\n}\n\nfunc (ll *DoublyLinkedList) removeNodeBindings(node *Node) {\n\tif node.Prev != nil {\n\t\tnode.Prev.Next = node.Next\n\t}\n\tif node.Next != nil {\n\t\tnode.Next.Prev = node.Prev\n\t}\n\tnode.Prev = nil\n\tnode.Next = nil\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tlinkedList := NewDoublyLinkedList()\n\tone := NewNode(1)\n\ttwo := NewNode(2)\n\tthree := NewNode(3)\n\tthree2 := NewNode(3)\n\tthree3 := NewNode(3)\n\tfour := NewNode(4)\n\tfive := NewNode(5)\n\tsix := NewNode(6)\n\tbindNodes(one, two)\n\tbindNodes(two, three)\n\tbindNodes(three, four)\n\tbindNodes(four, five)\n\tlinkedList.Head = one\n\tlinkedList.Tail = five\n\n\tlinkedList.SetHead(four)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 3, 5})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{5, 3, 2, 1, 4})\n\n\tlinkedList.SetTail(six)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 3, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 5, 3, 2, 1, 4})\n\n\tlinkedList.InsertBefore(six, three)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 5, 3, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 3, 5, 2, 1, 4})\n\n\tlinkedList.InsertAfter(six, three2)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 5, 3, 6, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 6, 3, 5, 2, 1, 4})\n\n\tlinkedList.InsertAtPosition(1, three3)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{3, 4, 1, 2, 5, 3, 6, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 6, 3, 5, 2, 1, 4, 3})\n\n\tlinkedList.RemoveNodesWithValue(3)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 5, 2, 1, 4})\n\n\tlinkedList.Remove(two)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 5, 1, 4})\n\n\trequire.Equal(t, linkedList.ContainsNodeWithValue(5), true)\n}\n\nfunc NewNode(value int) *Node { return &Node{Value: value} }\n\nfunc getNodeValuesHeadToTail(ll *DoublyLinkedList) []int {\n\tvalues := []int{}\n\tnode := ll.Head\n\tfor node != nil {\n\t\tvalues = append(values, node.Value)\n\t\tnode = node.Next\n\t}\n\treturn values\n}\n\nfunc getNodeValuesTailToHead(ll *DoublyLinkedList) []int {\n\tvalues := []int{}\n\tnode := ll.Tail\n\tfor node != nil {\n\t\tvalues = append(values, node.Value)\n\t\tnode = node.Prev\n\t}\n\treturn values\n}\n\nfunc bindNodes(nodeOne *Node, nodeTwo *Node) {\n\tnodeOne.Next = nodeTwo\n\tnodeTwo.Prev = nodeOne\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tlinkedList := NewDoublyLinkedList()\n\tone := NewNode(1)\n\ttwo := NewNode(2)\n\tthree := NewNode(3)\n\tthree2 := NewNode(3)\n\tthree3 := NewNode(3)\n\tfour := NewNode(4)\n\tfive := NewNode(5)\n\tsix := NewNode(6)\n\tbindNodes(one, two)\n\tbindNodes(two, three)\n\tbindNodes(three, four)\n\tbindNodes(four, five)\n\tlinkedList.Head = one\n\tlinkedList.Tail = five\n\n\tlinkedList.SetHead(four)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 3, 5})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{5, 3, 2, 1, 4})\n\n\tlinkedList.SetTail(six)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 3, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 5, 3, 2, 1, 4})\n\n\tlinkedList.InsertBefore(six, three)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 5, 3, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 3, 5, 2, 1, 4})\n\n\tlinkedList.InsertAfter(six, three2)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 5, 3, 6, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 6, 3, 5, 2, 1, 4})\n\n\tlinkedList.InsertAtPosition(1, three3)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{3, 4, 1, 2, 5, 3, 6, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 6, 3, 5, 2, 1, 4, 3})\n\n\tlinkedList.RemoveNodesWithValue(3)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 5, 2, 1, 4})\n\n\tlinkedList.Remove(two)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 5, 1, 4})\n\n\trequire.Equal(t, linkedList.ContainsNodeWithValue(5), true)\n}\n\nfunc NewNode(value int) *Node { return &Node{Value: value} }\n\nfunc getNodeValuesHeadToTail(ll *DoublyLinkedList) []int {\n\tvalues := []int{}\n\tnode := ll.Head\n\tfor node != nil {\n\t\tvalues = append(values, node.Value)\n\t\tnode = node.Next\n\t}\n\treturn values\n}\n\nfunc getNodeValuesTailToHead(ll *DoublyLinkedList) []int {\n\tvalues := []int{}\n\tnode := ll.Tail\n\tfor node != nil {\n\t\tvalues = append(values, node.Value)\n\t\tnode = node.Prev\n\t}\n\treturn values\n}\n\nfunc bindNodes(nodeOne *Node, nodeTwo *Node) {\n\tnodeOne.Next = nodeTwo\n\tnodeTwo.Prev = nodeOne\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\n// Feel free to add new properties and methods to the class.\nclass Program {\n  static class DoublyLinkedList {\n    public Node head;\n    public Node tail;\n\n    public void setHead(Node node) {\n      // Write your code here.\n    }\n\n    public void setTail(Node node) {\n      // Write your code here.\n    }\n\n    public void insertBefore(Node node, Node nodeToInsert) {\n      // Write your code here.\n    }\n\n    public void insertAfter(Node node, Node nodeToInsert) {\n      // Write your code here.\n    }\n\n    public void insertAtPosition(int position, Node nodeToInsert) {\n      // Write your code here.\n    }\n\n    public void removeNodesWithValue(int value) {\n      // Write your code here.\n    }\n\n    public void remove(Node node) {\n      // Write your code here.\n    }\n\n    public boolean containsNodeWithValue(int value) {\n      // Write your code here.\n      return false;\n    }\n  }\n\n  // Do not edit the class below.\n  static class Node {\n    public int value;\n    public Node prev;\n    public Node next;\n\n    public Node(int value) {\n      this.value = value;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  static class DoublyLinkedList {\n    public Node head;\n    public Node tail;\n\n    // O(1) time | O(1) space\n    public void setHead(Node node) {\n      if (head == null) {\n        head = node;\n        tail = node;\n        return;\n      }\n      insertBefore(head, node);\n    }\n\n    // O(1) time | O(1) space\n    public void setTail(Node node) {\n      if (tail == null) {\n        setHead(node);\n        return;\n      }\n      insertAfter(tail, node);\n    }\n\n    // O(1) time | O(1) space\n    public void insertBefore(Node node, Node nodeToInsert) {\n      if (nodeToInsert == head && nodeToInsert == tail) return;\n      remove(nodeToInsert);\n      nodeToInsert.prev = node.prev;\n      nodeToInsert.next = node;\n      if (node.prev == null) {\n        head = nodeToInsert;\n      } else {\n        node.prev.next = nodeToInsert;\n      }\n      node.prev = nodeToInsert;\n    }\n\n    // O(1) time | O(1) space\n    public void insertAfter(Node node, Node nodeToInsert) {\n      if (nodeToInsert == head && nodeToInsert == tail) return;\n      remove(nodeToInsert);\n      nodeToInsert.prev = node;\n      nodeToInsert.next = node.next;\n      if (node.next == null) {\n        tail = nodeToInsert;\n      } else {\n        node.next.prev = nodeToInsert;\n      }\n      node.next = nodeToInsert;\n    }\n\n    // O(p) time | O(1) space\n    public void insertAtPosition(int position, Node nodeToInsert) {\n      if (position == 1) {\n        setHead(nodeToInsert);\n        return;\n      }\n      Node node = head;\n      int currentPosition = 1;\n      while (node != null && currentPosition++ != position) node = node.next;\n      if (node != null) {\n        insertBefore(node, nodeToInsert);\n      } else {\n        setTail(nodeToInsert);\n      }\n    }\n\n    // O(n) time | O(1) space\n    public void removeNodesWithValue(int value) {\n      Node node = head;\n      while (node != null) {\n        Node nodeToRemove = node;\n        node = node.next;\n        if (nodeToRemove.value == value) remove(nodeToRemove);\n      }\n    }\n\n    // O(1) time | O(1) space\n    public void remove(Node node) {\n      if (node == head) head = head.next;\n      if (node == tail) tail = tail.prev;\n      removeNodeBindings(node);\n    }\n\n    // O(n) time | O(1) space\n    public boolean containsNodeWithValue(int value) {\n      Node node = head;\n      while (node != null && node.value != value) node = node.next;\n      return node != null;\n    }\n\n    public void removeNodeBindings(Node node) {\n      if (node.prev != null) node.prev.next = node.next;\n      if (node.next != null) node.next.prev = node.prev;\n      node.prev = null;\n      node.next = null;\n    }\n  }\n\n  static class Node {\n    public int value;\n    public Node prev;\n    public Node next;\n\n    public Node(int value) {\n      this.value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  private List<Integer> getNodeValuesHeadToTail(\n    Program.DoublyLinkedList linkedList\n  ) {\n    List<Integer> values = new ArrayList<Integer>();\n    Program.Node node = linkedList.head;\n    while (node != null) {\n      values.add(node.value);\n      node = node.next;\n    }\n    return values;\n  }\n\n  private List<Integer> getNodeValuesTailToHead(\n    Program.DoublyLinkedList linkedList\n  ) {\n    List<Integer> values = new ArrayList<Integer>();\n    Program.Node node = linkedList.tail;\n    while (node != null) {\n      values.add(node.value);\n      node = node.prev;\n    }\n    return values;\n  }\n\n  private void bindNodes(Program.Node nodeOne, Program.Node nodeTwo) {\n    nodeOne.next = nodeTwo;\n    nodeTwo.prev = nodeOne;\n  }\n\n  private boolean compare(List<Integer> array1, int[] array2) {\n    if (array1.size() != array2.length) {\n      return false;\n    }\n    for (int i = 0; i < array1.size(); i++) {\n      if (array1.get(i) != array2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  @Test\n  public void TestCase1() {\n    Program.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n    Program.Node one = new Program.Node(1);\n    Program.Node two = new Program.Node(2);\n    Program.Node three = new Program.Node(3);\n    Program.Node three2 = new Program.Node(3);\n    Program.Node three3 = new Program.Node(3);\n    Program.Node four = new Program.Node(4);\n    Program.Node five = new Program.Node(5);\n    Program.Node six = new Program.Node(6);\n    bindNodes(one, two);\n    bindNodes(two, three);\n    bindNodes(three, four);\n    bindNodes(four, five);\n    linkedList.head = one;\n    linkedList.tail = five;\n\n    linkedList.setHead(four);\n    Utils.assertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 3, 5})\n    );\n    Utils.assertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] {5, 3, 2, 1, 4})\n    );\n\n    linkedList.setTail(six);\n    Utils.assertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 3, 5, 6})\n    );\n    Utils.assertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 3, 2, 1, 4})\n    );\n\n    linkedList.insertBefore(six, three);\n    Utils.assertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 3, 6})\n    );\n    Utils.assertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] {6, 3, 5, 2, 1, 4})\n    );\n\n    linkedList.insertAfter(six, three2);\n    Utils.assertTrue(compare(\n      getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 3, 6, 3}\n    ));\n    Utils.assertTrue(compare(\n      getNodeValuesTailToHead(linkedList), new int[] {3, 6, 3, 5, 2, 1, 4}\n    ));\n\n    linkedList.insertAtPosition(1, three3);\n    Utils.assertTrue(compare(\n      getNodeValuesHeadToTail(linkedList), new int[] {3, 4, 1, 2, 5, 3, 6, 3}\n    ));\n    Utils.assertTrue(compare(\n      getNodeValuesTailToHead(linkedList), new int[] {3, 6, 3, 5, 2, 1, 4, 3}\n    ));\n\n    linkedList.removeNodesWithValue(3);\n    Utils.assertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 6})\n    );\n    Utils.assertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 2, 1, 4})\n    );\n\n    linkedList.remove(two);\n    Utils.assertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 5, 6})\n    );\n    Utils.assertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 1, 4})\n    );\n\n    Utils.assertTrue(linkedList.containsNodeWithValue(5));\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  private List<Integer> getNodeValuesHeadToTail(\n    Program.DoublyLinkedList linkedList\n  ) {\n    List<Integer> values = new ArrayList<Integer>();\n    Program.Node node = linkedList.head;\n    while (node != null) {\n      values.add(node.value);\n      node = node.next;\n    }\n    return values;\n  }\n\n  private List<Integer> getNodeValuesTailToHead(\n    Program.DoublyLinkedList linkedList\n  ) {\n    List<Integer> values = new ArrayList<Integer>();\n    Program.Node node = linkedList.tail;\n    while (node != null) {\n      values.add(node.value);\n      node = node.prev;\n    }\n    return values;\n  }\n\n  private void bindNodes(Program.Node nodeOne, Program.Node nodeTwo) {\n    nodeOne.next = nodeTwo;\n    nodeTwo.prev = nodeOne;\n  }\n\n  private boolean compare(List<Integer> array1, int[] array2) {\n    if (array1.size() != array2.length) {\n      return false;\n    }\n    for (int i = 0; i < array1.size(); i++) {\n      if (array1.get(i) != array2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  @Test\n  public void TestCase1() {\n    Program.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n    Program.Node one = new Program.Node(1);\n    Program.Node two = new Program.Node(2);\n    Program.Node three = new Program.Node(3);\n    Program.Node three2 = new Program.Node(3);\n    Program.Node three3 = new Program.Node(3);\n    Program.Node four = new Program.Node(4);\n    Program.Node five = new Program.Node(5);\n    Program.Node six = new Program.Node(6);\n    bindNodes(one, two);\n    bindNodes(two, three);\n    bindNodes(three, four);\n    bindNodes(four, five);\n    linkedList.head = one;\n    linkedList.tail = five;\n\n    linkedList.setHead(four);\n    Utils.assertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 3, 5})\n    );\n    Utils.assertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] {5, 3, 2, 1, 4})\n    );\n\n    linkedList.setTail(six);\n    Utils.assertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 3, 5, 6})\n    );\n    Utils.assertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 3, 2, 1, 4})\n    );\n\n    linkedList.insertBefore(six, three);\n    Utils.assertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 3, 6})\n    );\n    Utils.assertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] {6, 3, 5, 2, 1, 4})\n    );\n\n    linkedList.insertAfter(six, three2);\n    Utils.assertTrue(compare(\n      getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 3, 6, 3}\n    ));\n    Utils.assertTrue(compare(\n      getNodeValuesTailToHead(linkedList), new int[] {3, 6, 3, 5, 2, 1, 4}\n    ));\n\n    linkedList.insertAtPosition(1, three3);\n    Utils.assertTrue(compare(\n      getNodeValuesHeadToTail(linkedList), new int[] {3, 4, 1, 2, 5, 3, 6, 3}\n    ));\n    Utils.assertTrue(compare(\n      getNodeValuesTailToHead(linkedList), new int[] {3, 6, 3, 5, 2, 1, 4, 3}\n    ));\n\n    linkedList.removeNodesWithValue(3);\n    Utils.assertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 6})\n    );\n    Utils.assertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 2, 1, 4})\n    );\n\n    linkedList.remove(two);\n    Utils.assertTrue(\n      compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 5, 6})\n    );\n    Utils.assertTrue(\n      compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 1, 4})\n    );\n\n    Utils.assertTrue(linkedList.containsNodeWithValue(5));\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\n// Feel free to add new properties and methods to the class.\nclass DoublyLinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  setHead(node) {\n    // Write your code here.\n  }\n\n  setTail(node) {\n    // Write your code here.\n  }\n\n  insertBefore(node, nodeToInsert) {\n    // Write your code here.\n  }\n\n  insertAfter(node, nodeToInsert) {\n    // Write your code here.\n  }\n\n  insertAtPosition(position, nodeToInsert) {\n    // Write your code here.\n  }\n\n  removeNodesWithValue(value) {\n    // Write your code here.\n  }\n\n  remove(node) {\n    // Write your code here.\n  }\n\n  containsNodeWithValue(value) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the lines below.\nexports.Node = Node;\nexports.DoublyLinkedList = DoublyLinkedList;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nclass DoublyLinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  // O(1) time | O(1) space\n  setHead(node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      return;\n    }\n    this.insertBefore(this.head, node);\n  }\n\n  // O(1) time | O(1) space\n  setTail(node) {\n    if (this.tail === null) {\n      this.setHead(node);\n      return;\n    }\n    this.insertAfter(this.tail, node);\n  }\n\n  // O(1) time | O(1) space\n  insertBefore(node, nodeToInsert) {\n    if (nodeToInsert === this.head && nodeToInsert === this.tail) return;\n    this.remove(nodeToInsert);\n    nodeToInsert.prev = node.prev;\n    nodeToInsert.next = node;\n    if (node.prev === null) {\n      this.head = nodeToInsert;\n    } else {\n      node.prev.next = nodeToInsert;\n    }\n    node.prev = nodeToInsert;\n  }\n\n  // O(1) time | O(1) space\n  insertAfter(node, nodeToInsert) {\n    if (nodeToInsert === this.head && nodeToInsert === this.tail) return;\n    this.remove(nodeToInsert);\n    nodeToInsert.prev = node;\n    nodeToInsert.next = node.next;\n    if (node.next === null) {\n      this.tail = nodeToInsert;\n    } else {\n      node.next.prev = nodeToInsert;\n    }\n    node.next = nodeToInsert;\n  }\n\n  // O(p) time | O(1) space\n  insertAtPosition(position, nodeToInsert) {\n    if (position === 1) {\n      this.setHead(nodeToInsert);\n      return;\n    }\n    let node = this.head;\n    let currentPosition = 1;\n    while (node !== null && currentPosition++ !== position) node = node.next;\n    if (node !== null) {\n      this.insertBefore(node, nodeToInsert);\n    } else {\n      this.setTail(nodeToInsert);\n    }\n  }\n\n  // O(n) time | O(1) space\n  removeNodesWithValue(value) {\n    let node = this.head;\n    while (node !== null) {\n      const nodeToRemove = node;\n      node = node.next;\n      if (nodeToRemove.value === value) this.remove(nodeToRemove);\n    }\n  }\n\n  // O(1) time | O(1) space\n  remove(node) {\n    if (node === this.head) this.head = this.head.next;\n    if (node === this.tail) this.tail = this.tail.prev;\n    this.removeNodeBindings(node);\n  }\n\n  // O(n) time | O(1) space\n  containsNodeWithValue(value) {\n    let node = this.head;\n    while (node !== null && node.value !== value) node = node.next;\n    return node !== null;\n  }\n\n  removeNodeBindings(node) {\n    if (node.prev !== null) node.prev.next = node.next;\n    if (node.next !== null) node.next.prev = node.prev;\n    node.prev = null;\n    node.next = null;\n  }\n}\n\nexports.Node = Node;\nexports.DoublyLinkedList = DoublyLinkedList;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass TestNode {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nconst Node = program.Node || TestNode;\n\nfunction getNodeValuesHeadToTail(linkedList) {\n  const values = [];\n  let node = linkedList.head;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.next;\n  }\n  return values;\n}\n\nfunction getNodeValuesTailToHead(linkedList) {\n  const values = [];\n  let node = linkedList.tail;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.prev;\n  }\n  return values;\n}\n\nfunction bindNodes(nodeOne, nodeTwo) {\n  nodeOne.next = nodeTwo;\n  nodeTwo.prev = nodeOne;\n}\n\nit('Test Case #1', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const one = new Node(1);\n  const two = new Node(2);\n  const three = new Node(3);\n  const three2 = new Node(3);\n  const three3 = new Node(3);\n  const four = new Node(4);\n  const five = new Node(5);\n  const six = new Node(6);\n  bindNodes(one, two);\n  bindNodes(two, three);\n  bindNodes(three, four);\n  bindNodes(four, five);\n  linkedList.head = one;\n  linkedList.tail = five;\n\n  linkedList.setHead(four);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([5, 3, 2, 1, 4]);\n\n  linkedList.setTail(six);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 3, 2, 1, 4]);\n\n  linkedList.insertBefore(six, three);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAfter(six, three2);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAtPosition(1, three3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4, 3]);\n\n  linkedList.removeNodesWithValue(3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 2, 1, 4]);\n\n  linkedList.remove(two);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 1, 4]);\n\n  chai.expect(linkedList.containsNodeWithValue(5)).to.deep.equal(true);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nclass TestNode {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nconst Node = program.Node || TestNode;\n\nfunction getNodeValuesHeadToTail(linkedList) {\n  const values = [];\n  let node = linkedList.head;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.next;\n  }\n  return values;\n}\n\nfunction getNodeValuesTailToHead(linkedList) {\n  const values = [];\n  let node = linkedList.tail;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.prev;\n  }\n  return values;\n}\n\nfunction bindNodes(nodeOne, nodeTwo) {\n  nodeOne.next = nodeTwo;\n  nodeTwo.prev = nodeOne;\n}\n\nit('Test Case #1', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const one = new Node(1);\n  const two = new Node(2);\n  const three = new Node(3);\n  const three2 = new Node(3);\n  const three3 = new Node(3);\n  const four = new Node(4);\n  const five = new Node(5);\n  const six = new Node(6);\n  bindNodes(one, two);\n  bindNodes(two, three);\n  bindNodes(three, four);\n  bindNodes(four, five);\n  linkedList.head = one;\n  linkedList.tail = five;\n\n  linkedList.setHead(four);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([5, 3, 2, 1, 4]);\n\n  linkedList.setTail(six);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 3, 2, 1, 4]);\n\n  linkedList.insertBefore(six, three);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAfter(six, three2);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAtPosition(1, three3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4, 3]);\n\n  linkedList.removeNodesWithValue(3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 2, 1, 4]);\n\n  linkedList.remove(two);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 1, 4]);\n\n  chai.expect(linkedList.containsNodeWithValue(5)).to.deep.equal(true);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nclass Node(value: Int) {\n    val value = value\n    var prev: Node? = null\n    var next: Node? = null\n}\n\nclass DoublyLinkedList {\n    private var head: Node? = null\n    private var tail: Node? = null\n\n    fun setHead(node: Node) {\n        // Write your code here.\n    }\n\n    fun setTail(node: Node) {\n        // Write your code here.\n    }\n\n    fun insertBefore(node: Node, nodeToInsert: Node) {\n        // Write your code here.\n    }\n\n    fun insertAfter(node: Node, nodeToInsert: Node) {\n        // Write your code here.\n    }\n\n    fun insertAtPosition(position: Int, nodeToInsert: Node) {\n        // Write your code here.\n    }\n\n    fun removeNodesWithValue(value: Int) {\n        // Write your code here.\n    }\n\n    fun remove(node: Node) {\n        // Write your code here.\n    }\n\n    fun containsNodeWithValue(value: Int): Boolean {\n        // Write your code here.\n        return false\n    }\n\n    fun getHead(): Node? { return this.head }\n\n    fun getTail(): Node? { return this.tail }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nclass Node(value: Int) {\n    val value = value\n    var prev: Node? = null\n    var next: Node? = null\n}\n\nclass DoublyLinkedList {\n    private var head: Node? = null\n    private var tail: Node? = null\n\n    // O(1) time | O(1) space\n    fun setHead(node: Node) {\n        if (this.head == null) {\n            this.head = node\n            this.tail = node\n            return\n        }\n        this.insertBefore(this.head!!, node)\n    }\n\n    // O(1) time | O(1) space\n    fun setTail(node: Node) {\n        if (this.tail == null) {\n            setHead(node)\n            return\n        }\n        insertAfter(this.tail!!, node)\n    }\n\n    // O(1) time | O(1) space\n    fun insertBefore(node: Node, nodeToInsert: Node) {\n        if (nodeToInsert == this.head && nodeToInsert == this.tail) return\n        remove(nodeToInsert)\n        nodeToInsert.prev = node.prev\n        nodeToInsert.next = node\n        if (node.prev == null) {\n            this.head = nodeToInsert\n        } else {\n            node.prev!!.next = nodeToInsert\n        }\n        node.prev = nodeToInsert\n    }\n\n    // O(1) time | O(1) space\n    fun insertAfter(node: Node, nodeToInsert: Node) {\n        if (nodeToInsert == this.head && nodeToInsert == tail) return\n        remove(nodeToInsert)\n        nodeToInsert.prev = node\n        nodeToInsert.next = node.next\n        if (node.next == null) {\n            this.tail = nodeToInsert\n        } else {\n            node.next!!.prev = nodeToInsert\n        }\n        node.next = nodeToInsert\n    }\n\n    // O(p) time | O(1) space\n    fun insertAtPosition(position: Int, nodeToInsert: Node) {\n        if (position == 1) {\n            setHead(nodeToInsert)\n            return\n        }\n\n        var node: Node? = this.head\n        var currentPosition = 1\n        while (node != null && currentPosition++ != position) {\n            node = node.next\n        }\n\n        if (node != null) {\n            insertBefore(node, nodeToInsert)\n        } else {\n            setTail(nodeToInsert)\n        }\n    }\n\n    // O(n) time | O(1) space\n    fun removeNodesWithValue(value: Int) {\n        var node: Node? = head\n        while (node != null) {\n            var nextNode = node.next\n            if (node.value == value) remove(node)\n            node = nextNode\n        }\n    }\n\n    // O(1) time | O(1) space\n    fun remove(node: Node) {\n        if (node == this.head) this.head = node.next\n        if (node == this.tail) this.tail = node.prev\n        removeNodeBindings(node)\n    }\n\n    // O(n) time | O(1) space\n    fun containsNodeWithValue(value: Int): Boolean {\n        var node: Node? = this.head\n        while (node != null) {\n            if (node.value == value) return true\n            node = node.next\n        }\n        return false\n    }\n\n    fun removeNodeBindings(node: Node) {\n        if (node.prev != null) node.prev!!.next = node.next\n        if (node.next != null) node.next!!.prev = node.prev\n        node.prev = null\n        node.next = null\n    }\n\n    fun getHead(): Node? { return this.head }\n\n    fun getTail(): Node? { return this.tail }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.DoublyLinkedList\nimport com.algoexpert.program.Node\n\nclass ProgramTest {\n\n    fun bindNodes(nodeOne: Node, nodeTwo: Node) {\n        nodeOne.next = nodeTwo\n        nodeTwo.prev = nodeOne\n    }\n\n    fun headToTail(dll: DoublyLinkedList): List<Int> {\n        val values = mutableListOf<Int>()\n        var current: Node? = dll.getHead()\n        while (current != null) {\n            values.add(current.value)\n            current = current.next\n        }\n        return values\n    }\n\n    fun tailToHead(dll: DoublyLinkedList): List<Int> {\n        val values = mutableListOf<Int>()\n        var current: Node? = dll.getTail()\n        while (current != null) {\n            values.add(current.value)\n            current = current.prev\n        }\n        return values\n    }\n\n    @Test\n    fun TestCase1() {\n        val linkedList = DoublyLinkedList()\n\n        val one = Node(1)\n        val two = Node(2)\n        val three = Node(3)\n        val three2 = Node(3)\n        val three3 = Node(3)\n        val four = Node(4)\n        val five = Node(5)\n        val six = Node(6)\n\n        linkedList.setHead(one)\n        linkedList.insertAfter(one, two)\n        linkedList.insertAfter(two, three)\n        linkedList.insertAfter(three, four)\n        linkedList.insertAfter(four, five)\n\n        linkedList.setHead(four)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 3, 5))\n        assert(tailToHead(linkedList) == listOf(5, 3, 2, 1, 4))\n\n        linkedList.setTail(six)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 3, 5, 6))\n        assert(tailToHead(linkedList) == listOf(6, 5, 3, 2, 1, 4))\n\n        linkedList.insertBefore(six, three)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 5, 3, 6))\n        assert(tailToHead(linkedList) == listOf(6, 3, 5, 2, 1, 4))\n\n        linkedList.insertAfter(six, three2)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 5, 3, 6, 3))\n        assert(tailToHead(linkedList) == listOf(3, 6, 3, 5, 2, 1, 4))\n\n        linkedList.insertAtPosition(1, three3)\n        assert(headToTail(linkedList) == listOf(3, 4, 1, 2, 5, 3, 6, 3))\n        assert(tailToHead(linkedList) == listOf(3, 6, 3, 5, 2, 1, 4, 3))\n\n        linkedList.removeNodesWithValue(3)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 5, 6))\n        assert(tailToHead(linkedList) == listOf(6, 5, 2, 1, 4))\n\n        linkedList.remove(two)\n        assert(headToTail(linkedList) == listOf(4, 1, 5, 6))\n        assert(tailToHead(linkedList) == listOf(6, 5, 1, 4))\n\n        assert(linkedList.containsNodeWithValue(5))\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.DoublyLinkedList\nimport com.algoexpert.program.Node\n\nclass ProgramTest {\n\n    fun bindNodes(nodeOne: Node, nodeTwo: Node) {\n        nodeOne.next = nodeTwo\n        nodeTwo.prev = nodeOne\n    }\n\n    fun headToTail(dll: DoublyLinkedList): List<Int> {\n        val values = mutableListOf<Int>()\n        var current: Node? = dll.getHead()\n        while (current != null) {\n            values.add(current.value)\n            current = current.next\n        }\n        return values\n    }\n\n    fun tailToHead(dll: DoublyLinkedList): List<Int> {\n        val values = mutableListOf<Int>()\n        var current: Node? = dll.getTail()\n        while (current != null) {\n            values.add(current.value)\n            current = current.prev\n        }\n        return values\n    }\n\n    @Test\n    fun TestCase1() {\n        val linkedList = DoublyLinkedList()\n\n        val one = Node(1)\n        val two = Node(2)\n        val three = Node(3)\n        val three2 = Node(3)\n        val three3 = Node(3)\n        val four = Node(4)\n        val five = Node(5)\n        val six = Node(6)\n\n        linkedList.setHead(one)\n        linkedList.insertAfter(one, two)\n        linkedList.insertAfter(two, three)\n        linkedList.insertAfter(three, four)\n        linkedList.insertAfter(four, five)\n\n        linkedList.setHead(four)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 3, 5))\n        assert(tailToHead(linkedList) == listOf(5, 3, 2, 1, 4))\n\n        linkedList.setTail(six)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 3, 5, 6))\n        assert(tailToHead(linkedList) == listOf(6, 5, 3, 2, 1, 4))\n\n        linkedList.insertBefore(six, three)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 5, 3, 6))\n        assert(tailToHead(linkedList) == listOf(6, 3, 5, 2, 1, 4))\n\n        linkedList.insertAfter(six, three2)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 5, 3, 6, 3))\n        assert(tailToHead(linkedList) == listOf(3, 6, 3, 5, 2, 1, 4))\n\n        linkedList.insertAtPosition(1, three3)\n        assert(headToTail(linkedList) == listOf(3, 4, 1, 2, 5, 3, 6, 3))\n        assert(tailToHead(linkedList) == listOf(3, 6, 3, 5, 2, 1, 4, 3))\n\n        linkedList.removeNodesWithValue(3)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 5, 6))\n        assert(tailToHead(linkedList) == listOf(6, 5, 2, 1, 4))\n\n        linkedList.remove(two)\n        assert(headToTail(linkedList) == listOf(4, 1, 5, 6))\n        assert(tailToHead(linkedList) == listOf(6, 5, 1, 4))\n\n        assert(linkedList.containsNodeWithValue(5))\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\n# Feel free to add new properties and methods to the class.\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def setHead(self, node):\n        # Write your code here.\n        pass\n\n    def setTail(self, node):\n        # Write your code here.\n        pass\n\n    def insertBefore(self, node, nodeToInsert):\n        # Write your code here.\n        pass\n\n    def insertAfter(self, node, nodeToInsert):\n        # Write your code here.\n        pass\n\n    def insertAtPosition(self, position, nodeToInsert):\n        # Write your code here.\n        pass\n\n    def removeNodesWithValue(self, value):\n        # Write your code here.\n        pass\n\n    def remove(self, node):\n        # Write your code here.\n        pass\n\n    def containsNodeWithValue(self, value):\n        # Write your code here.\n        pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    # O(1) time | O(1) space\n    def setHead(self, node):\n        if self.head is None:\n            self.head = node\n            self.tail = node\n            return\n        self.insertBefore(self.head, node)\n\n    # O(1) time | O(1) space\n    def setTail(self, node):\n        if self.tail is None:\n            self.setHead(node)\n            return\n        self.insertAfter(self.tail, node)\n\n    # O(1) time | O(1) space\n    def insertBefore(self, node, nodeToInsert):\n        if nodeToInsert == self.head and nodeToInsert == self.tail:\n            return\n        self.remove(nodeToInsert)\n        nodeToInsert.prev = node.prev\n        nodeToInsert.next = node\n        if node.prev is None:\n            self.head = nodeToInsert\n        else:\n            node.prev.next = nodeToInsert\n        node.prev = nodeToInsert\n\n    # O(1) time | O(1) space\n    def insertAfter(self, node, nodeToInsert):\n        if nodeToInsert == self.head and nodeToInsert == self.tail:\n            return\n        self.remove(nodeToInsert)\n        nodeToInsert.prev = node\n        nodeToInsert.next = node.next\n        if node.next is None:\n            self.tail = nodeToInsert\n        else:\n            node.next.prev = nodeToInsert\n        node.next = nodeToInsert\n\n    # O(p) time | O(1) space\n    def insertAtPosition(self, position, nodeToInsert):\n        if position == 1:\n            self.setHead(nodeToInsert)\n            return\n        node = self.head\n        currentPosition = 1\n        while node is not None and currentPosition != position:\n            node = node.next\n            currentPosition += 1\n        if node is not None:\n            self.insertBefore(node, nodeToInsert)\n        else:\n            self.setTail(nodeToInsert)\n\n    # O(n) time | O(1) space\n    def removeNodesWithValue(self, value):\n        node = self.head\n        while node is not None:\n            nodeToRemove = node\n            node = node.next\n            if nodeToRemove.value == value:\n                self.remove(nodeToRemove)\n\n    # O(1) time | O(1) space\n    def remove(self, node):\n        if node == self.head:\n            self.head = self.head.next\n        if node == self.tail:\n            self.tail = self.tail.prev\n        self.removeNodeBindings(node)\n\n    # O(n) time | O(1) space\n    def containsNodeWithValue(self, value):\n        node = self.head\n        while node is not None and node.value != value:\n            node = node.next\n        return node is not None\n\n    def removeNodeBindings(self, node):\n        if node.prev is not None:\n            node.prev.next = node.next\n        if node.next is not None:\n            node.next.prev = node.prev\n        node.prev = None\n        node.next = None\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestNode:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nNode = TestNode\nif hasattr(program, \"Node\"):\n    Node = program.Node\n\n\ndef getNodeValuesHeadToTail(linkedList):\n    values = []\n    node = linkedList.head\n    while node is not None:\n        values.append(node.value)\n        node = node.next\n    return values\n\n\ndef getNodeValuesTailToHead(linkedList):\n    values = []\n    node = linkedList.tail\n    while node is not None:\n        values.append(node.value)\n        node = node.prev\n    return values\n\n\ndef bindNodes(nodeOne, nodeTwo):\n    nodeOne.next = nodeTwo\n    nodeTwo.prev = nodeOne\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        linkedList = program.DoublyLinkedList()\n        one = Node(1)\n        two = Node(2)\n        three = Node(3)\n        three2 = Node(3)\n        three3 = Node(3)\n        four = Node(4)\n        five = Node(5)\n        six = Node(6)\n        bindNodes(one, two)\n        bindNodes(two, three)\n        bindNodes(three, four)\n        bindNodes(four, five)\n        linkedList.head = one\n        linkedList.tail = five\n\n        linkedList.setHead(four)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 3, 5])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [5, 3, 2, 1, 4])\n\n        linkedList.setTail(six)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 3, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 3, 2, 1, 4])\n\n        linkedList.insertBefore(six, three)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 3, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 3, 5, 2, 1, 4])\n\n        linkedList.insertAfter(six, three2)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 3, 6, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 6, 3, 5, 2, 1, 4])\n\n        linkedList.insertAtPosition(1, three3)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [3, 4, 1, 2, 5, 3, 6, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 6, 3, 5, 2, 1, 4, 3])\n\n        linkedList.removeNodesWithValue(3)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 2, 1, 4])\n\n        linkedList.remove(two)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 1, 4])\n\n        self.assertEqual(linkedList.containsNodeWithValue(5), True)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestNode:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nNode = TestNode\nif hasattr(program, \"Node\"):\n    Node = program.Node\n\n\ndef getNodeValuesHeadToTail(linkedList):\n    values = []\n    node = linkedList.head\n    while node is not None:\n        values.append(node.value)\n        node = node.next\n    return values\n\n\ndef getNodeValuesTailToHead(linkedList):\n    values = []\n    node = linkedList.tail\n    while node is not None:\n        values.append(node.value)\n        node = node.prev\n    return values\n\n\ndef bindNodes(nodeOne, nodeTwo):\n    nodeOne.next = nodeTwo\n    nodeTwo.prev = nodeOne\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        linkedList = program.DoublyLinkedList()\n        one = Node(1)\n        two = Node(2)\n        three = Node(3)\n        three2 = Node(3)\n        three3 = Node(3)\n        four = Node(4)\n        five = Node(5)\n        six = Node(6)\n        bindNodes(one, two)\n        bindNodes(two, three)\n        bindNodes(three, four)\n        bindNodes(four, five)\n        linkedList.head = one\n        linkedList.tail = five\n\n        linkedList.setHead(four)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 3, 5])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [5, 3, 2, 1, 4])\n\n        linkedList.setTail(six)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 3, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 3, 2, 1, 4])\n\n        linkedList.insertBefore(six, three)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 3, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 3, 5, 2, 1, 4])\n\n        linkedList.insertAfter(six, three2)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 3, 6, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 6, 3, 5, 2, 1, 4])\n\n        linkedList.insertAtPosition(1, three3)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [3, 4, 1, 2, 5, 3, 6, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 6, 3, 5, 2, 1, 4, 3])\n\n        linkedList.removeNodesWithValue(3)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 2, 1, 4])\n\n        linkedList.remove(two)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 1, 4])\n\n        self.assertEqual(linkedList.containsNodeWithValue(5), True)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  class Node {\n    var value: Int\n    var previous: Node?\n    var next: Node?\n\n    init(value: Int) {\n      self.value = value\n      previous = nil\n      next = nil\n    }\n  }\n\n  class DoublyLinkedList {\n    var head: Node?\n    var tail: Node?\n\n    init() {\n      head = nil\n      tail = nil\n    }\n\n    func containsNodeWithValue(value: Int) -> Bool {\n      // Write your code here.\n      return false\n    }\n\n    func remove(node: Node) {\n      // Write your code here.\n    }\n\n    func removeNodesWithValue(value: Int) {\n      // Write your code here.\n    }\n\n    func insertBefore(node: Node, nodeToInsert: Node) {\n      // Write your code here.\n    }\n\n    func insertAfter(node: Node, nodeToInsert: Node) {\n      // Write your code here.\n    }\n\n    func setHead(node: Node) {\n      // Write your code here.\n    }\n\n    func setTail(node: Node) {\n      // Write your code here.\n    }\n\n    func insertAtPosition(position: Int, nodeToInsert: Node) {\n      // Write your code here.\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class Node {\n    var value: Int\n    var previous: Node?\n    var next: Node?\n\n    init(value: Int) {\n      self.value = value\n      previous = nil\n      next = nil\n    }\n  }\n\n  class DoublyLinkedList {\n    var head: Node?\n    var tail: Node?\n\n    init() {\n      head = nil\n      tail = nil\n    }\n\n    // O(N) time | O(1) space\n    func containsNodeWithValue(value: Int) -> Bool {\n      var node = head\n      while node !== nil, node?.value != value {\n        node = node?.next\n      }\n\n      return node !== nil\n    }\n\n    // O(1) time | O(1) space\n    func remove(node: Node) {\n      if node === head {\n        head = head?.next\n      }\n\n      if node === tail {\n        tail = tail?.previous\n      }\n\n      removeNodeBindings(node: node)\n    }\n\n    // O(N) time | O(1) space\n    func removeNodesWithValue(value: Int) {\n      var node = head\n\n      while node !== nil {\n        let nodeToRemove = node\n        node = node?.next\n        if nodeToRemove?.value == value {\n          remove(node: nodeToRemove!)\n        }\n      }\n    }\n\n    // O(1) time | O(1) space\n    func insertBefore(node: Node, nodeToInsert: Node) {\n      if nodeToInsert === head, nodeToInsert === tail {\n        return\n      }\n\n      remove(node: nodeToInsert)\n      nodeToInsert.previous = node.previous\n      nodeToInsert.next = node\n\n      if node.previous == nil {\n        head = nodeToInsert\n      } else {\n        node.previous?.next = nodeToInsert\n      }\n\n      node.previous = nodeToInsert\n    }\n\n    // O(1) time | O(1) space\n    func insertAfter(node: Node, nodeToInsert: Node) {\n      if nodeToInsert === head, nodeToInsert === tail {\n        return\n      }\n\n      remove(node: nodeToInsert)\n      nodeToInsert.previous = node\n      nodeToInsert.next = node.next\n\n      if node.next == nil {\n        tail = nodeToInsert\n      } else {\n        node.next?.previous = nodeToInsert\n      }\n\n      node.next = nodeToInsert\n    }\n\n    // O(1) time | O(1) space\n    func setHead(node: Node) {\n      if head == nil {\n        head = node\n        tail = node\n        return\n      }\n\n      insertBefore(node: head!, nodeToInsert: node)\n    }\n\n    // O(1) time | O(1) space\n    func setTail(node: Node) {\n      if tail == nil {\n        setHead(node: node)\n        return\n      }\n\n      insertAfter(node: tail!, nodeToInsert: node)\n    }\n\n    // O(P) time | O(1) space\n    func insertAtPosition(position: Int, nodeToInsert: Node) {\n      if position == 1 {\n        setHead(node: nodeToInsert)\n        return\n      }\n\n      var node = head\n      var currentPosition = 1\n      while node !== nil, currentPosition != position {\n        node = node?.next\n        currentPosition = currentPosition + 1\n      }\n\n      if node !== nil {\n        insertBefore(node: node!, nodeToInsert: nodeToInsert)\n      } else {\n        setTail(node: nodeToInsert)\n      }\n    }\n\n    func removeNodeBindings(node: Node) {\n      if let previous = node.previous {\n        previous.next = node.next\n      }\n\n      if let next = node.next {\n        next.previous = node.previous\n      }\n\n      node.previous = nil\n      node.next = nil\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws in\n      let linkedList = Program.DoublyLinkedList()\n      let one = Program.Node(value: 1)\n      let two = Program.Node(value: 2)\n      let three = Program.Node(value: 3)\n      let three2 = Program.Node(value: 3)\n      let three3 = Program.Node(value: 3)\n      let four = Program.Node(value: 4)\n      let five = Program.Node(value: 5)\n      let six = Program.Node(value: 6)\n      bindNodes(nodeOne: one, nodeTwo: two)\n      bindNodes(nodeOne: two, nodeTwo: three)\n      bindNodes(nodeOne: three, nodeTwo: four)\n      bindNodes(nodeOne: four, nodeTwo: five)\n      linkedList.head = one\n      linkedList.tail = five\n\n      linkedList.setHead(node: four)\n      try assertEqual([4, 1, 2, 3, 5], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([5, 3, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.setTail(node: six)\n      try assertEqual([4, 1, 2, 3, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 3, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertBefore(node: six, nodeToInsert: three)\n      try assertEqual([4, 1, 2, 5, 3, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 3, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertAfter(node: six, nodeToInsert: three2)\n      try assertEqual([4, 1, 2, 5, 3, 6, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 6, 3, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertAtPosition(position: 1, nodeToInsert: three3)\n      try assertEqual([3, 4, 1, 2, 5, 3, 6, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 6, 3, 5, 2, 1, 4, 3], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.removeNodesWithValue(value: 3)\n      try assertEqual([4, 1, 2, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.remove(node: two)\n      try assertEqual([4, 1, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      try assertEqual(true, linkedList.containsNodeWithValue(value: 5))\n    }\n  }\n\n  func getNodeValuesHeadToTail(linkedList: Program.DoublyLinkedList) throws -> [Int] {\n    var values = [Int]()\n\n    var node = linkedList.head\n\n    while node != nil {\n      values.append(node!.value)\n      node = node?.next\n    }\n\n    return values\n  }\n\n  func getNodeValuesTailToHead(linkedList: Program.DoublyLinkedList) throws -> [Int] {\n    var values = [Int]()\n\n    var node = linkedList.tail\n\n    while node != nil {\n      values.append(node!.value)\n      node = node?.previous\n    }\n\n    return values\n  }\n\n  func bindNodes(nodeOne: Program.Node, nodeTwo: Program.Node) {\n    nodeOne.next = nodeTwo\n    nodeTwo.previous = nodeOne\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws in\n      let linkedList = Program.DoublyLinkedList()\n      let one = Program.Node(value: 1)\n      let two = Program.Node(value: 2)\n      let three = Program.Node(value: 3)\n      let three2 = Program.Node(value: 3)\n      let three3 = Program.Node(value: 3)\n      let four = Program.Node(value: 4)\n      let five = Program.Node(value: 5)\n      let six = Program.Node(value: 6)\n      bindNodes(nodeOne: one, nodeTwo: two)\n      bindNodes(nodeOne: two, nodeTwo: three)\n      bindNodes(nodeOne: three, nodeTwo: four)\n      bindNodes(nodeOne: four, nodeTwo: five)\n      linkedList.head = one\n      linkedList.tail = five\n\n      linkedList.setHead(node: four)\n      try assertEqual([4, 1, 2, 3, 5], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([5, 3, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.setTail(node: six)\n      try assertEqual([4, 1, 2, 3, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 3, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertBefore(node: six, nodeToInsert: three)\n      try assertEqual([4, 1, 2, 5, 3, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 3, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertAfter(node: six, nodeToInsert: three2)\n      try assertEqual([4, 1, 2, 5, 3, 6, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 6, 3, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertAtPosition(position: 1, nodeToInsert: three3)\n      try assertEqual([3, 4, 1, 2, 5, 3, 6, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 6, 3, 5, 2, 1, 4, 3], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.removeNodesWithValue(value: 3)\n      try assertEqual([4, 1, 2, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.remove(node: two)\n      try assertEqual([4, 1, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      try assertEqual(true, linkedList.containsNodeWithValue(value: 5))\n    }\n  }\n\n  func getNodeValuesHeadToTail(linkedList: Program.DoublyLinkedList) throws -> [Int] {\n    var values = [Int]()\n\n    var node = linkedList.head\n\n    while node != nil {\n      values.append(node!.value)\n      node = node?.next\n    }\n\n    return values\n  }\n\n  func getNodeValuesTailToHead(linkedList: Program.DoublyLinkedList) throws -> [Int] {\n    var values = [Int]()\n\n    var node = linkedList.tail\n\n    while node != nil {\n      values.append(node!.value)\n      node = node?.previous\n    }\n\n    return values\n  }\n\n  func bindNodes(nodeOne: Program.Node, nodeTwo: Program.Node) {\n    nodeOne.next = nodeTwo\n    nodeTwo.previous = nodeOne\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class Node {\n  value: number;\n  prev: Node | null;\n  next: Node | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\n// Feel free to add new properties and methods to the class.\nexport class DoublyLinkedList {\n  head: Node | null;\n  tail: Node | null;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  setHead(node: Node) {\n    // Write your code here.\n  }\n\n  setTail(node: Node) {\n    // Write your code here.\n  }\n\n  insertBefore(node: Node, nodeToInsert: Node) {\n    // Write your code here.\n  }\n\n  insertAfter(node: Node, nodeToInsert: Node) {\n    // Write your code here.\n  }\n\n  insertAtPosition(position: number, nodeToInsert: Node) {\n    // Write your code here.\n  }\n\n  removeNodesWithValue(value: number) {\n    // Write your code here.\n  }\n\n  remove(node: Node) {\n    // Write your code here.\n  }\n\n  containsNodeWithValue(value: number) {\n    // Write your code here.\n    return false;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nexport class Node {\n  value: number;\n  prev: Node | null;\n  next: Node | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nexport class DoublyLinkedList {\n  head: Node | null;\n  tail: Node | null;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  // O(1) time | O(1) space\n  setHead(node: Node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      return;\n    }\n    this.insertBefore(this.head, node);\n  }\n\n  // O(1) time | O(1) space\n  setTail(node: Node) {\n    if (this.tail === null) {\n      this.setHead(node);\n      return;\n    }\n    this.insertAfter(this.tail, node);\n  }\n\n  // O(1) time | O(1) space\n  insertBefore(node: Node, nodeToInsert: Node) {\n    if (nodeToInsert === this.head && nodeToInsert === this.tail) return;\n    this.remove(nodeToInsert);\n    nodeToInsert.prev = node.prev;\n    nodeToInsert.next = node;\n    if (node.prev === null) {\n      this.head = nodeToInsert;\n    } else {\n      node.prev.next = nodeToInsert;\n    }\n    node.prev = nodeToInsert;\n  }\n\n  // O(1) time | O(1) space\n  insertAfter(node: Node, nodeToInsert: Node) {\n    if (nodeToInsert === this.head && nodeToInsert === this.tail) return;\n    this.remove(nodeToInsert);\n    nodeToInsert.prev = node;\n    nodeToInsert.next = node.next;\n    if (node.next === null) {\n      this.tail = nodeToInsert;\n    } else {\n      node.next.prev = nodeToInsert;\n    }\n    node.next = nodeToInsert;\n  }\n\n  // O(p) time | O(1) space\n  insertAtPosition(position: number, nodeToInsert: Node) {\n    if (position === 1) {\n      this.setHead(nodeToInsert);\n      return;\n    }\n    let node = this.head;\n    let currentPosition = 1;\n    while (node !== null && currentPosition++ !== position) node = node.next;\n    if (node !== null) {\n      this.insertBefore(node, nodeToInsert);\n    } else {\n      this.setTail(nodeToInsert);\n    }\n  }\n\n  // O(n) time | O(1) space\n  removeNodesWithValue(value: number) {\n    let node = this.head;\n    while (node !== null) {\n      const nodeToRemove = node;\n      node = node.next;\n      if (nodeToRemove.value === value) this.remove(nodeToRemove);\n    }\n  }\n\n  // O(1) time | O(1) space\n  remove(node: Node) {\n    if (node === this.head) this.head = this.head.next;\n    if (node === this.tail) this.tail = this.tail.prev;\n    this.removeNodeBindings(node);\n  }\n\n  // O(n) time | O(1) space\n  containsNodeWithValue(value: number) {\n    let node = this.head;\n    while (node !== null && node.value !== value) node = node.next;\n    return node !== null;\n  }\n\n  removeNodeBindings(node: Node) {\n    if (node.prev !== null) node.prev.next = node.next;\n    if (node.next !== null) node.next.prev = node.prev;\n    node.prev = null;\n    node.next = null;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nclass TestNode {\n  value: number;\n  prev: TestNode | null;\n  next: TestNode | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nconst Node = program.Node || TestNode;\n\nfunction getNodeValuesHeadToTail(linkedList: program.DoublyLinkedList) {\n  const values = [];\n  let node = linkedList.head;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.next;\n  }\n  return values;\n}\n\nfunction getNodeValuesTailToHead(linkedList: program.DoublyLinkedList) {\n  const values = [];\n  let node = linkedList.tail;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.prev;\n  }\n  return values;\n}\n\nfunction bindNodes(nodeOne: TestNode, nodeTwo: TestNode) {\n  nodeOne.next = nodeTwo;\n  nodeTwo.prev = nodeOne;\n}\n\nit('Test Case #1', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const one = new Node(1);\n  const two = new Node(2);\n  const three = new Node(3);\n  const three2 = new Node(3);\n  const three3 = new Node(3);\n  const four = new Node(4);\n  const five = new Node(5);\n  const six = new Node(6);\n  bindNodes(one, two);\n  bindNodes(two, three);\n  bindNodes(three, four);\n  bindNodes(four, five);\n  linkedList.head = one;\n  linkedList.tail = five;\n\n  linkedList.setHead(four);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([5, 3, 2, 1, 4]);\n\n  linkedList.setTail(six);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 3, 2, 1, 4]);\n\n  linkedList.insertBefore(six, three);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAfter(six, three2);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAtPosition(1, three3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4, 3]);\n\n  linkedList.removeNodesWithValue(3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 2, 1, 4]);\n\n  linkedList.remove(two);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 1, 4]);\n\n  chai.expect(linkedList.containsNodeWithValue(5)).to.deep.equal(true);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nclass TestNode {\n  value: number;\n  prev: TestNode | null;\n  next: TestNode | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nconst Node = program.Node || TestNode;\n\nfunction getNodeValuesHeadToTail(linkedList: program.DoublyLinkedList) {\n  const values = [];\n  let node = linkedList.head;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.next;\n  }\n  return values;\n}\n\nfunction getNodeValuesTailToHead(linkedList: program.DoublyLinkedList) {\n  const values = [];\n  let node = linkedList.tail;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.prev;\n  }\n  return values;\n}\n\nfunction bindNodes(nodeOne: TestNode, nodeTwo: TestNode) {\n  nodeOne.next = nodeTwo;\n  nodeTwo.prev = nodeOne;\n}\n\nit('Test Case #1', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const one = new Node(1);\n  const two = new Node(2);\n  const three = new Node(3);\n  const three2 = new Node(3);\n  const three3 = new Node(3);\n  const four = new Node(4);\n  const five = new Node(5);\n  const six = new Node(6);\n  bindNodes(one, two);\n  bindNodes(two, three);\n  bindNodes(three, four);\n  bindNodes(four, five);\n  linkedList.head = one;\n  linkedList.tail = five;\n\n  linkedList.setHead(four);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([5, 3, 2, 1, 4]);\n\n  linkedList.setTail(six);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 3, 2, 1, 4]);\n\n  linkedList.insertBefore(six, three);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAfter(six, three2);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAtPosition(1, three3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4, 3]);\n\n  linkedList.removeNodesWithValue(3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 2, 1, 4]);\n\n  linkedList.remove(two);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 1, 4]);\n\n  chai.expect(linkedList.containsNodeWithValue(5)).to.deep.equal(true);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "nodes",
      "example": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "3-2",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "3-3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        },
        {
          "id": "5",
          "next": null,
          "prev": null,
          "value": 5
        },
        {
          "id": "6",
          "next": null,
          "prev": null,
          "value": 6
        }
      ],
      "schema": {
        "description": "You'll be able to reference these nodes by their <span>id</span>\nin the <span>classMethodsToCall</span>.\n",
        "items": {
          "properties": {
            "id": {
              "type": "string"
            },
            "next": {
              "type": "null"
            },
            "prev": {
              "type": "null"
            },
            "value": {
              "type": "integer"
            }
          },
          "required": [
            "id",
            "value",
            "prev",
            "next"
          ],
          "type": "object"
        },
        "type": "array"
      }
    },
    {
      "name": "classMethodsToCall",
      "example": [
        {
          "arguments": [
            "5"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "4"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "3"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "4"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "6"
          ],
          "method": "setTail"
        },
        {
          "arguments": [
            "6",
            "3"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "6",
            "3-2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            1,
            "3-3"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            3
          ],
          "method": "removeNodesWithValue"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "remove"
        },
        {
          "arguments": [
            5
          ],
          "method": "containsNodeWithValue"
        }
      ],
      "schema": {
        "description": "These methods will be called in the order that they appear in below\non a <span>DoublyLinkedList</span> and with their respective arguments.\nFor methods that take in actual <span>Node</span>s as parameters, you can\ncreate <span>nodes</span> below and reference them by their <span>id</span>.\n",
        "items": {
          "properties": {
            "arguments": {
              "maxItems": 2,
              "type": "array"
            },
            "method": {
              "enum": [
                "setHead",
                "setTail",
                "insertBefore",
                "insertAfter",
                "insertAtPosition",
                "removeNodesWithValue",
                "remove",
                "containsNodeWithValue"
              ],
              "type": "string"
            }
          },
          "required": [
            "method",
            "arguments"
          ],
          "type": "object"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "5"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "4"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "3"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "4"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "6"
          ],
          "method": "setTail"
        },
        {
          "arguments": [
            "6",
            "3"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "6",
            "3-2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            1,
            "3-3"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            3
          ],
          "method": "removeNodesWithValue"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "remove"
        },
        {
          "arguments": [
            5
          ],
          "method": "containsNodeWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "3-2",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "3-3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        },
        {
          "id": "5",
          "next": null,
          "prev": null,
          "value": 5
        },
        {
          "id": "6",
          "next": null,
          "prev": null,
          "value": 6
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setTail"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            1,
            "1"
          ],
          "method": "insertAtPosition"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "setTail"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "setHead"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertBefore"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setTail"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertBefore"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "setTail"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setTail"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "1"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertBefore"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "4",
            "5"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "5",
            "6"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "6",
            "7"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            7,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            1,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            2,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            3,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            4,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            5,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            6,
            "1"
          ],
          "method": "insertAtPosition"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        },
        {
          "id": "5",
          "next": null,
          "prev": null,
          "value": 5
        },
        {
          "id": "6",
          "next": null,
          "prev": null,
          "value": 6
        },
        {
          "id": "7",
          "next": null,
          "prev": null,
          "value": 7
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "remove"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            1
          ],
          "method": "removeNodesWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "remove"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "4"
          ],
          "method": "remove"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "remove"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "1-2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1-2",
            "1-3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1-3",
            "1-4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            1
          ],
          "method": "removeNodesWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-2",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-3",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-4",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "1-2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1-2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "1-3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1-3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            1
          ],
          "method": "removeNodesWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-2",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-3",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-4",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            1
          ],
          "method": "containsNodeWithValue"
        },
        {
          "arguments": [
            2
          ],
          "method": "containsNodeWithValue"
        },
        {
          "arguments": [
            3
          ],
          "method": "containsNodeWithValue"
        },
        {
          "arguments": [
            4
          ],
          "method": "containsNodeWithValue"
        },
        {
          "arguments": [
            5
          ],
          "method": "containsNodeWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    }
  ],
  "jsonTests": [
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "5"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "4"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "3"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "4"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "6"
          ],
          "method": "setTail"
        },
        {
          "arguments": [
            "6",
            "3"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "6",
            "3-2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            1,
            "3-3"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            3
          ],
          "method": "removeNodesWithValue"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "remove"
        },
        {
          "arguments": [
            5
          ],
          "method": "containsNodeWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "3-2",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "3-3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        },
        {
          "id": "5",
          "next": null,
          "prev": null,
          "value": 5
        },
        {
          "id": "6",
          "next": null,
          "prev": null,
          "value": 6
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setTail"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            1,
            "1"
          ],
          "method": "insertAtPosition"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "setTail"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "setHead"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertBefore"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setTail"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertBefore"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "setTail"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setTail"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "1"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertBefore"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "4",
            "5"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "5",
            "6"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "6",
            "7"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            7,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            1,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            2,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            3,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            4,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            5,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            6,
            "1"
          ],
          "method": "insertAtPosition"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        },
        {
          "id": "5",
          "next": null,
          "prev": null,
          "value": 5
        },
        {
          "id": "6",
          "next": null,
          "prev": null,
          "value": 6
        },
        {
          "id": "7",
          "next": null,
          "prev": null,
          "value": 7
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "remove"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            1
          ],
          "method": "removeNodesWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "remove"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "4"
          ],
          "method": "remove"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "remove"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "1-2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1-2",
            "1-3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1-3",
            "1-4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            1
          ],
          "method": "removeNodesWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-2",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-3",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-4",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "1-2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1-2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "1-3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1-3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            1
          ],
          "method": "removeNodesWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-2",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-3",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-4",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            1
          ],
          "method": "containsNodeWithValue"
        },
        {
          "arguments": [
            2
          ],
          "method": "containsNodeWithValue"
        },
        {
          "arguments": [
            3
          ],
          "method": "containsNodeWithValue"
        },
        {
          "arguments": [
            4
          ],
          "method": "containsNodeWithValue"
        },
        {
          "arguments": [
            5
          ],
          "method": "containsNodeWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    }
  ],
  "changelog": []
}