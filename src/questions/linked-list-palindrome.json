{
  "uid": "linked-list-palindrome",
  "testStrategy": "JSON",
  "name": "Linked List Palindrome",
  "version": 0,
  "releaseDate": "2020-11-16T00:00:00Z",
  "category": "Linked Lists",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 7115,
    "failureCount": 2207
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "563547921",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 1328
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in the head of a Singly Linked List and returns a\n  boolean representing whether the linked list's nodes form a palindrome. Your\n  function shouldn't make use of any auxiliary data structure.\n</p>\n<p>\n  A palindrome is usually defined as a string that's written the same forward\n  and backward. For a linked list's nodes to form a palindrome, their values\n  must be the same when read from left to right and from right to left. Note\n  that single-character strings are palindromes, which means that single-node\n  linked lists form palindromes.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it's the tail of the list.\n</p>\n<p>\n  You can assume that the input linked list will always have at least one node;\n  in other words, the head will never be <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">head</span> = 0 -> 1 -> 2 -> 2 -> 1 -> 0 <span class=\"CodeEditor-promptComment\">// the head node with value 0</span>\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n</pre>\n</div>",
  "hints": [
    "<p>\nThink about comparing two nodes at a time. To determine if the linked list's nodes form a palindrome, which two nodes should we compare?\n</p>\n",
    "\n<p>\nFollowing Hint #1, to determine if the linked list's nodes form a palindrome, we'll want to compare the first and last node, the second and second-to-last node, the third and third-to-last node, etc.. How can we compare all of these nodes recursively?\n</p>\n",
    "\n<p>\nPutting aside the recursive solution hinted at in Hint #2, we can solve this problem iteratively and with no auxiliary space if we know how to reverse a linked list. How can reversing the linked list (or part of it) help us solve this problem?\n</p>\n",
    "\n<p>\nTry reversing the second half of the linked list and then comparing nodes in the first half and in the reversed second half by simply iterating through both halves at the same time. You'll have to figure out where the second half of the linked list begins in order to reverse it.\n</p>"
  ],
  "spaceTime": "O(n) time | O(1) space - where n is the number of nodes in the Linked List",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": "linkedlist",
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is an input struct. Do not edit.\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next;\n\n  LinkedList(int value) {\n    this->value = value;\n    this->next = nullptr;\n  }\n};\n\nbool linkedListPalindrome(LinkedList* head) {\n  // Write your code here.\n  return false;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next;\n\n  LinkedList(int value) {\n    this->value = value;\n    this->next = nullptr;\n  }\n};\n\nstruct LinkedListInfo {\n  bool outerNodesAreEqual;\n  LinkedList* leftNodeToCompare;\n};\n\nLinkedListInfo isPalindrome(LinkedList* leftNode, LinkedList* rightNode);\n\n// O(n) time | O(n) space - where n is the number of nodes in the Linked List\nbool linkedListPalindrome(LinkedList* head) {\n  LinkedListInfo isPalindromeResults = isPalindrome(head, head);\n  return isPalindromeResults.outerNodesAreEqual;\n}\n\nLinkedListInfo isPalindrome(LinkedList* leftNode, LinkedList* rightNode) {\n  if (rightNode == nullptr) {\n    return LinkedListInfo{true, leftNode};\n  }\n\n  LinkedListInfo recursiveCallResults = isPalindrome(leftNode, rightNode->next);\n  LinkedList* leftNodeToCompare = recursiveCallResults.leftNodeToCompare;\n  bool outerNodesAreEqual = recursiveCallResults.outerNodesAreEqual;\n\n  bool recursiveIsEqual =\n    outerNodesAreEqual && leftNodeToCompare->value == rightNode->value;\n  LinkedList* nextLeftNodeToCompare = leftNodeToCompare->next;\n\n  return LinkedListInfo{recursiveIsEqual, nextLeftNodeToCompare};\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next;\n\n  LinkedList(int value) {\n    this->value = value;\n    this->next = nullptr;\n  }\n};\n\nLinkedList* reverseLinkedList(LinkedList* head);\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nbool linkedListPalindrome(LinkedList* head) {\n  LinkedList* slowNode = head;\n  LinkedList* fastNode = head;\n  while (fastNode != nullptr && fastNode->next != nullptr) {\n    slowNode = slowNode->next;\n    fastNode = fastNode->next->next;\n  }\n\n  LinkedList* reversedSecondHalfNode = reverseLinkedList(slowNode);\n  LinkedList* firstHalfNode = head;\n\n  while (reversedSecondHalfNode != nullptr) {\n    if (reversedSecondHalfNode->value != firstHalfNode->value) {\n      return false;\n    }\n    reversedSecondHalfNode = reversedSecondHalfNode->next;\n    firstHalfNode = firstHalfNode->next;\n  }\n\n  return true;\n}\n\nLinkedList* reverseLinkedList(LinkedList* head) {\n  LinkedList* previousNode = nullptr;\n  LinkedList* currentNode = head;\n  while (currentNode != nullptr) {\n    LinkedList* nextNode = currentNode->next;\n    currentNode->next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      LinkedList* head = new LinkedList(0);\n      head->next = new LinkedList(1);\n      head->next->next = new LinkedList(2);\n      head->next->next->next = new LinkedList(2);\n      head->next->next->next->next = new LinkedList(1);\n      head->next->next->next->next->next = new LinkedList(0);\n      bool expected = true;\n      bool actual = linkedListPalindrome(head);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      LinkedList* head = new LinkedList(0);\n      head->next = new LinkedList(1);\n      head->next->next = new LinkedList(2);\n      head->next->next->next = new LinkedList(2);\n      head->next->next->next->next = new LinkedList(1);\n      head->next->next->next->next->next = new LinkedList(0);\n      bool expected = true;\n      bool actual = linkedListPalindrome(head);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  public bool LinkedListPalindrome(LinkedList head) {\n    // Write your code here.\n    return false;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // O(n) time | O(n) space - where n is the number of nodes in the Linked List\n  public bool LinkedListPalindrome(LinkedList head) {\n    LinkedListInfo isPalindromeResults = isPalindrome(head, head);\n    return isPalindromeResults.outerNodesAreEqual;\n  }\n\n  public LinkedListInfo isPalindrome(\n    LinkedList leftNode, LinkedList rightNode\n  ) {\n    if (rightNode == null) return new LinkedListInfo(true, leftNode);\n\n    LinkedListInfo recursiveCallResults =\n      isPalindrome(leftNode, rightNode.next);\n    LinkedList leftNodeToCompare = recursiveCallResults.leftNodeToCompare;\n    bool outerNodesAreEqual = recursiveCallResults.outerNodesAreEqual;\n\n    bool recursiveIsEqual =\n      outerNodesAreEqual && (leftNodeToCompare.value == rightNode.value);\n    LinkedList nextLeftNodeToCompare = leftNodeToCompare.next;\n\n    return new LinkedListInfo(recursiveIsEqual, nextLeftNodeToCompare);\n  }\n\n  public class LinkedListInfo {\n    public bool outerNodesAreEqual;\n    public LinkedList leftNodeToCompare;\n    public LinkedListInfo(\n      bool outerNodesAreEqual, LinkedList leftNodeToCompare\n    ) {\n      this.outerNodesAreEqual = outerNodesAreEqual;\n      this.leftNodeToCompare = leftNodeToCompare;\n    }\n  }\n\n  public class LinkedList {\n    public int value;\n    public LinkedList next = null;\n\n    public LinkedList(int value) {\n      this.value = value;\n    }\n  }\n}",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // O(n) time | O(1) space - where n is the number of nodes in the Linked List\n  public bool LinkedListPalindrome(LinkedList head) {\n    LinkedList slowNode = head;\n    LinkedList fastNode = head;\n\n    while (fastNode != null && fastNode.next != null) {\n      slowNode = slowNode.next;\n      fastNode = fastNode.next.next;\n    }\n\n    LinkedList reversedSecondHalfNode = reverseLinkedList(slowNode);\n    LinkedList firstHalfNode = head;\n\n    while (reversedSecondHalfNode != null) {\n      if (reversedSecondHalfNode.value != firstHalfNode.value) return false;\n      reversedSecondHalfNode = reversedSecondHalfNode.next;\n      firstHalfNode = firstHalfNode.next;\n    }\n\n    return true;\n  }\n\n  public static LinkedList reverseLinkedList(LinkedList head) {\n    LinkedList previousNode = null;\n    LinkedList currentNode = head;\n    while (currentNode != null) {\n      LinkedList nextNode = currentNode.next;\n      currentNode.next = previousNode;\n      previousNode = currentNode;\n      currentNode = nextNode;\n    }\n    return previousNode;\n  }\n\n  public class LinkedList {\n    public int value;\n    public LinkedList next = null;\n\n    public LinkedList(int value) {\n      this.value = value;\n    }\n  }\n}"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var head = new Program.LinkedList(0);\n    head.next = new Program.LinkedList(1);\n    head.next.next = new Program.LinkedList(2);\n    head.next.next.next = new Program.LinkedList(2);\n    head.next.next.next.next = new Program.LinkedList(1);\n    head.next.next.next.next.next = new Program.LinkedList(0);\n    var expected = true;\n    var actual = new Program().LinkedListPalindrome(head);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var head = new Program.LinkedList(0);\n    head.next = new Program.LinkedList(1);\n    head.next.next = new Program.LinkedList(2);\n    head.next.next.next = new Program.LinkedList(2);\n    head.next.next.next.next = new Program.LinkedList(1);\n    head.next.next.next.next.next = new Program.LinkedList(0);\n    var expected = true;\n    var actual = new Program().LinkedListPalindrome(head);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is an input struct. Do not edit.\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\nfunc LinkedListPalindrome(head *LinkedList) bool {\n\t// Write your code here.\n\treturn false\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\ntype LinkedListInfo struct {\n\touterNodesAreEqual bool\n\tleftNodeToCompare  *LinkedList\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the Linked List\nfunc LinkedListPalindrome(head *LinkedList) bool {\n\tisPalindromeResults := isPalindrome(head, head)\n\treturn isPalindromeResults.outerNodesAreEqual\n}\n\nfunc isPalindrome(leftNode *LinkedList, rightNode *LinkedList) LinkedListInfo {\n\tif rightNode == nil {\n\t\treturn LinkedListInfo{true, leftNode}\n\t}\n\n\trecursiveCallResults := isPalindrome(leftNode, rightNode.Next)\n\tleftNodeToCompare := recursiveCallResults.leftNodeToCompare\n\touterNodesAreEqual := recursiveCallResults.outerNodesAreEqual\n\n\trecursiveIsEqual := outerNodesAreEqual && leftNodeToCompare.Value == rightNode.Value\n\tnextLeftNodeToCompare := leftNodeToCompare.Next\n\n\treturn LinkedListInfo{recursiveIsEqual, nextLeftNodeToCompare}\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\ntype LinkedListInfo struct {\n\touterNodesAreEqual bool\n\tleftNodeToCompare  *LinkedList\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfunc LinkedListPalindrome(head *LinkedList) bool {\n\tslowNode := head\n\tfastNode := head\n\tfor fastNode != nil && fastNode.Next != nil {\n\t\tslowNode = slowNode.Next\n\t\tfastNode = fastNode.Next.Next\n\t}\n\n\treversedSecondHalfNode := reverseLinkedList(slowNode)\n\tfirstHalfNode := head\n\n\tfor reversedSecondHalfNode != nil {\n\t\tif reversedSecondHalfNode.Value != firstHalfNode.Value {\n\t\t\treturn false\n\t\t}\n\t\treversedSecondHalfNode = reversedSecondHalfNode.Next\n\t\tfirstHalfNode = firstHalfNode.Next\n\t}\n\n\treturn true\n}\n\nfunc reverseLinkedList(head *LinkedList) *LinkedList {\n\tvar previousNode *LinkedList = nil\n\tvar currentNode = head\n\tfor currentNode != nil {\n\t\tnextNode := currentNode.Next\n\t\tcurrentNode.Next = previousNode\n\t\tpreviousNode = currentNode\n\t\tcurrentNode = nextNode\n\t}\n\treturn previousNode\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\thead := &LinkedList{Value: 0}\n\thead.Next = &LinkedList{Value: 1}\n\thead.Next.Next = &LinkedList{Value: 2}\n\thead.Next.Next.Next = &LinkedList{Value: 2}\n\thead.Next.Next.Next.Next = &LinkedList{Value: 1}\n\thead.Next.Next.Next.Next.Next = &LinkedList{Value: 0}\n\texpected := true\n\tactual := LinkedListPalindrome(head)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\thead := &LinkedList{Value: 0}\n\thead.Next = &LinkedList{Value: 1}\n\thead.Next.Next = &LinkedList{Value: 2}\n\thead.Next.Next.Next = &LinkedList{Value: 2}\n\thead.Next.Next.Next.Next = &LinkedList{Value: 1}\n\thead.Next.Next.Next.Next.Next = &LinkedList{Value: 0}\n\texpected := true\n\tactual := LinkedListPalindrome(head)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  public static class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  public boolean linkedListPalindrome(LinkedList head) {\n    // Write your code here.\n    return false;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n) time | O(n) space - where n is the number of nodes in the Linked List\n  public boolean linkedListPalindrome(LinkedList head) {\n    LinkedListInfo isPalindromeResults = isPalindrome(head, head);\n    return isPalindromeResults.outerNodesAreEqual;\n  }\n\n  public LinkedListInfo isPalindrome(\n    LinkedList leftNode, LinkedList rightNode\n  ) {\n    if (rightNode == null) return new LinkedListInfo(true, leftNode);\n\n    LinkedListInfo recursiveCallResults =\n      isPalindrome(leftNode, rightNode.next);\n    LinkedList leftNodeToCompare = recursiveCallResults.leftNodeToCompare;\n    boolean outerNodesAreEqual = recursiveCallResults.outerNodesAreEqual;\n\n    boolean recursiveIsEqual =\n      outerNodesAreEqual && (leftNodeToCompare.value == rightNode.value);\n    LinkedList nextLeftNodeToCompare = leftNodeToCompare.next;\n\n    return new LinkedListInfo(recursiveIsEqual, nextLeftNodeToCompare);\n  }\n\n  static class LinkedListInfo {\n    public boolean outerNodesAreEqual;\n    public LinkedList leftNodeToCompare;\n\n    public LinkedListInfo(\n      boolean outerNodesAreEqual, LinkedList leftNodeToCompare\n    ) {\n      this.outerNodesAreEqual = outerNodesAreEqual;\n      this.leftNodeToCompare = leftNodeToCompare;\n    }\n  }\n\n  static class LinkedList {\n    int value;\n    LinkedList next = null;\n\n    public LinkedList(int value) {\n      this.value = value;\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n) time | O(1) space - where n is the number of nodes in the Linked List\n  public boolean linkedListPalindrome(LinkedList head) {\n    LinkedList slowNode = head;\n    LinkedList fastNode = head;\n\n    while (fastNode != null && fastNode.next != null) {\n      slowNode = slowNode.next;\n      fastNode = fastNode.next.next;\n    }\n\n    LinkedList reversedSecondHalfNode = reverseLinkedList(slowNode);\n    LinkedList firstHalfNode = head;\n\n    while (reversedSecondHalfNode != null) {\n      if (reversedSecondHalfNode.value != firstHalfNode.value) return false;\n      reversedSecondHalfNode = reversedSecondHalfNode.next;\n      firstHalfNode = firstHalfNode.next;\n    }\n\n    return true;\n  }\n\n  public static LinkedList reverseLinkedList(LinkedList head) {\n    LinkedList previousNode = null;\n    LinkedList currentNode = head;\n    while (currentNode != null) {\n      LinkedList nextNode = currentNode.next;\n      currentNode.next = previousNode;\n      previousNode = currentNode;\n      currentNode = nextNode;\n    }\n    return previousNode;\n  }\n\n  static class LinkedList {\n    int value;\n    LinkedList next = null;\n\n    public LinkedList(int value) {\n      this.value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var head = new Program.LinkedList(0);\n    head.next = new Program.LinkedList(1);\n    head.next.next = new Program.LinkedList(2);\n    head.next.next.next = new Program.LinkedList(2);\n    head.next.next.next.next = new Program.LinkedList(1);\n    head.next.next.next.next.next = new Program.LinkedList(0);\n    var expected = true;\n    var actual = new Program().linkedListPalindrome(head);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var head = new Program.LinkedList(0);\n    head.next = new Program.LinkedList(1);\n    head.next.next = new Program.LinkedList(2);\n    head.next.next.next = new Program.LinkedList(2);\n    head.next.next.next.next = new Program.LinkedList(1);\n    head.next.next.next.next.next = new Program.LinkedList(0);\n    var expected = true;\n    var actual = new Program().linkedListPalindrome(head);\n    Utils.assertTrue(expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction linkedListPalindrome(head) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.linkedListPalindrome = linkedListPalindrome;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the Linked List\nfunction linkedListPalindrome(head) {\n  const isPalindromeResults = isPalindrome(head, head);\n  return isPalindromeResults.outerNodesAreEqual;\n}\n\nfunction isPalindrome(leftNode, rightNode) {\n  if (rightNode === null) {\n    return new LinkedListInfo(true, leftNode);\n  }\n\n  const recursiveCallResults = isPalindrome(leftNode, rightNode.next);\n  const {leftNodeToCompare, outerNodesAreEqual} = recursiveCallResults;\n\n  const recursiveIsEqual = outerNodesAreEqual && leftNodeToCompare.value === rightNode.value;\n  const nextLeftNodeToCompare = leftNodeToCompare.next;\n\n  return new LinkedListInfo(recursiveIsEqual, nextLeftNodeToCompare);\n}\n\nclass LinkedListInfo {\n  constructor(outerNodesAreEqual, leftNodeToCompare) {\n    this.outerNodesAreEqual = outerNodesAreEqual;\n    this.leftNodeToCompare = leftNodeToCompare;\n  }\n}\n\n// Do not edit the line below.\nexports.linkedListPalindrome = linkedListPalindrome;\nexports.LinkedList = LinkedList;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfunction linkedListPalindrome(head) {\n  let slowNode = head;\n  let fastNode = head;\n  while (fastNode !== null && fastNode.next !== null) {\n    slowNode = slowNode.next;\n    fastNode = fastNode.next.next;\n  }\n\n  let reversedSecondHalfNode = reverseLinkedList(slowNode);\n  let firstHalfNode = head;\n\n  while (reversedSecondHalfNode !== null) {\n    if (reversedSecondHalfNode.value !== firstHalfNode.value) {\n      return false;\n    }\n    reversedSecondHalfNode = reversedSecondHalfNode.next;\n    firstHalfNode = firstHalfNode.next;\n  }\n\n  return true;\n}\n\nfunction reverseLinkedList(head) {\n  let previousNode = null;\n  let currentNode = head;\n  while (currentNode !== null) {\n    const nextNode = currentNode.next;\n    currentNode.next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode;\n}\n\nexports.linkedListPalindrome = linkedListPalindrome;\nexports.LinkedList = LinkedList;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const head = new program.LinkedList(0);\n  head.next = new program.LinkedList(1);\n  head.next.next = new program.LinkedList(2);\n  head.next.next.next = new program.LinkedList(2);\n  head.next.next.next.next = new program.LinkedList(1);\n  head.next.next.next.next.next = new program.LinkedList(0);\n  const expected = true;\n  const actual = program.linkedListPalindrome(head);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const head = new program.LinkedList(0);\n  head.next = new program.LinkedList(1);\n  head.next.next = new program.LinkedList(2);\n  head.next.next.next = new program.LinkedList(2);\n  head.next.next.next.next = new program.LinkedList(1);\n  head.next.next.next.next.next = new program.LinkedList(0);\n  const expected = true;\n  const actual = program.linkedListPalindrome(head);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\nfun linkedListPalindrome(head: LinkedList?): Boolean {\n    // Write your code here.\n    return false\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\nopen class LinkedListInfo(outerNodesAreEqual: Boolean, leftNodeToCompare: LinkedList?) {\n    val outerNodesAreEqual = outerNodesAreEqual\n    val leftNodeToCompare = leftNodeToCompare\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the Linked List\nfun linkedListPalindrome(head: LinkedList): Boolean {\n    val isPalindromeResults = isPalindrome(head, head)\n    return isPalindromeResults.outerNodesAreEqual\n}\n\nfun isPalindrome(leftNode: LinkedList, rightNode: LinkedList?): LinkedListInfo {\n    if (rightNode == null) return LinkedListInfo(true, leftNode)\n\n    val recursiveCallResults = isPalindrome(leftNode, rightNode.next)\n    val leftNodeToCompare = recursiveCallResults.leftNodeToCompare!!\n    val outerNodesAreEqual = recursiveCallResults.outerNodesAreEqual\n\n    val recursiveIsEqual = outerNodesAreEqual && leftNodeToCompare.value == rightNode.value\n    val nextLeftNodeToCompare = leftNodeToCompare.next\n\n    return LinkedListInfo(recursiveIsEqual, nextLeftNodeToCompare)\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfun linkedListPalindrome(head: LinkedList): Boolean {\n    var slowNode = head\n    var fastNode: LinkedList? = head\n    while (fastNode != null && fastNode.next != null) {\n        slowNode = slowNode.next!!\n        fastNode = fastNode.next!!.next\n    }\n\n    var reversedSecondHalfNode: LinkedList? = reverseLinkedList(slowNode)\n    var firstHalfNode: LinkedList? = head\n\n    while (reversedSecondHalfNode != null) {\n        if (reversedSecondHalfNode.value != firstHalfNode!!.value) return false\n        reversedSecondHalfNode = reversedSecondHalfNode.next\n        firstHalfNode = firstHalfNode!!.next\n    }\n\n    return true\n}\n\nfun reverseLinkedList(head: LinkedList): LinkedList {\n    var previousNode: LinkedList? = null\n    var currentNode: LinkedList? = head\n    while (currentNode != null) {\n        val nextNode = currentNode.next\n        currentNode.next = previousNode\n        previousNode = currentNode\n        currentNode = nextNode\n    }\n    return previousNode!!\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.LinkedList\nimport com.algoexpert.program.linkedListPalindrome\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val head = addMany(LinkedList(0), listOf(1, 2, 2, 1, 0))\n        val expected = true\n        val output = linkedListPalindrome(head)\n        assert(expected == output)\n    }\n}\n\nfun addMany(linkedList: LinkedList, values: List<Int>): LinkedList {\n    var current = linkedList\n    while (current.next != null) {\n        current = current.next!!\n    }\n    for (value in values) {\n        current.next = LinkedList(value)\n        current = current.next!!\n    }\n    return linkedList\n}\n",
      "unitTests": "import com.algoexpert.program.LinkedList\nimport com.algoexpert.program.linkedListPalindrome\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val head = addMany(LinkedList(0), listOf(1, 2, 2, 1, 0))\n        val expected = true\n        val output = linkedListPalindrome(head)\n        assert(expected == output)\n    }\n}\n\nfun addMany(linkedList: LinkedList, values: List<Int>): LinkedList {\n    var current = linkedList\n    while (current.next != null) {\n        current = current.next!!\n    }\n    for (value in values) {\n        current.next = LinkedList(value)\n        current = current.next!!\n    }\n    return linkedList\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\ndef linkedListPalindrome(head):\n    # Write your code here.\n    return False\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\n# O(n) time | O(n) space - where n is the number of nodes in the Linked List\ndef linkedListPalindrome(head):\n    isPalindromeResults = isPalindrome(head, head)\n    return isPalindromeResults.outerNodesAreEqual\n\n\ndef isPalindrome(leftNode, rightNode):\n    if rightNode is None:\n        return LinkedListInfo(True, leftNode)\n\n    recursiveCallResults = isPalindrome(leftNode, rightNode.next)\n    leftNodeToCompare = recursiveCallResults.leftNodeToCompare\n    outerNodesAreEqual = recursiveCallResults.outerNodesAreEqual\n\n    recursiveIsEqual = outerNodesAreEqual and leftNodeToCompare.value == rightNode.value\n    nextLeftNodeToCompare = leftNodeToCompare.next\n\n    return LinkedListInfo(recursiveIsEqual, nextLeftNodeToCompare)\n\n\nclass LinkedListInfo:\n    def __init__(self, outerNodesAreEqual, leftNodeToCompare):\n        self.outerNodesAreEqual = outerNodesAreEqual\n        self.leftNodeToCompare = leftNodeToCompare\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\n# O(n) time | O(1) space - where n is the number of nodes in the Linked List\ndef linkedListPalindrome(head):\n    slowNode = head\n    fastNode = head\n    while fastNode is not None and fastNode.next is not None:\n        slowNode = slowNode.next\n        fastNode = fastNode.next.next\n\n    reversedSecondHalfNode = reverseLinkedList(slowNode)\n    firstHalfNode = head\n\n    while reversedSecondHalfNode is not None:\n        if reversedSecondHalfNode.value != firstHalfNode.value:\n            return False\n        reversedSecondHalfNode = reversedSecondHalfNode.next\n        firstHalfNode = firstHalfNode.next\n\n    return True\n\n\ndef reverseLinkedList(head):\n    previousNode, currentNode = None, head\n    while currentNode is not None:\n        nextNode = currentNode.next\n        currentNode.next = previousNode\n        previousNode = currentNode\n        currentNode = nextNode\n    return previousNode\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        head = program.LinkedList(0)\n        head.next = program.LinkedList(1)\n        head.next.next = program.LinkedList(2)\n        head.next.next.next = program.LinkedList(2)\n        head.next.next.next.next = program.LinkedList(1)\n        head.next.next.next.next.next = program.LinkedList(0)\n        expected = True\n        actual = program.linkedListPalindrome(head)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        head = program.LinkedList(0)\n        head.next = program.LinkedList(1)\n        head.next.next = program.LinkedList(2)\n        head.next.next.next = program.LinkedList(2)\n        head.next.next.next.next = program.LinkedList(1)\n        head.next.next.next.next.next = program.LinkedList(0)\n        expected = True\n        actual = program.linkedListPalindrome(head)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "# This is an input struct. Do not edit.\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\nclass Program\n  def linkedListPalindrome(linkedList)\n    # Write your code here.\n    return false\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\nclass Program\n  def linkedListPalindrome(linkedList)\n    # Write your code here.\n    return false\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\nclass Program\n  def linkedListPalindrome(linkedList)\n    # Write your code here.\n    return false\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.linkedListPalindrome\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.linkedListPalindrome\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class LinkedList {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  func linkedListPalindrome(_ head: LinkedList) -> Bool {\n    // Write your code here.\n    return false\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class LinkedList {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  class LinkedListInfo {\n    var outerNodesAreEqual: Bool\n    var leftNodeToCompare: LinkedList?\n\n    init(_ outerNodesAreEqual: Bool, _ leftNodeToCompare: LinkedList?) {\n      self.outerNodesAreEqual = outerNodesAreEqual\n      self.leftNodeToCompare = leftNodeToCompare\n    }\n  }\n\n  // O(n) time | O(n) space - where n is the number of nodes in the Linked List\n  func linkedListPalindrome(_ head: LinkedList) -> Bool {\n    let isPalindromeResults = isPalindrome(head, head)\n    return isPalindromeResults.outerNodesAreEqual\n  }\n\n  func isPalindrome(_ leftNode: LinkedList?, _ rightNode: LinkedList?) -> LinkedListInfo {\n    if rightNode == nil {\n      return LinkedListInfo(true, leftNode)\n    }\n\n    let recursiveCallResults = isPalindrome(leftNode, rightNode!.next)\n    let leftNodeToCompare = recursiveCallResults.leftNodeToCompare\n    let outerNodesAreEqual = recursiveCallResults.outerNodesAreEqual\n\n    let recursiveIsEqual = outerNodesAreEqual && leftNodeToCompare!.value == rightNode!.value\n    let nextLeftNodeToCompare = leftNodeToCompare!.next\n    return LinkedListInfo(recursiveIsEqual, nextLeftNodeToCompare)\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class LinkedList {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  // O(n) time | O(1) space - where n is the number of nodes in the Linked List\n  func linkedListPalindrome(_ head: LinkedList) -> Bool {\n    var slowNode: LinkedList? = head\n    var fastNode: LinkedList? = head\n    while fastNode != nil, fastNode!.next != nil {\n      slowNode = slowNode!.next\n      fastNode = fastNode!.next!.next\n    }\n\n    var reversedSecondHalfNode: LinkedList? = reverseLinkedList(slowNode)\n    var firstHalfNode: LinkedList? = head\n\n    while reversedSecondHalfNode != nil {\n      if reversedSecondHalfNode!.value != firstHalfNode!.value {\n        return false\n      }\n      reversedSecondHalfNode = reversedSecondHalfNode!.next\n      firstHalfNode = firstHalfNode!.next\n    }\n\n    return true\n  }\n\n  func reverseLinkedList(_ head: LinkedList?) -> LinkedList? {\n    var previousNode: LinkedList?\n    var currentNode: LinkedList? = head\n    while currentNode != nil {\n      let nextNode = currentNode!.next\n      currentNode!.next = previousNode\n      previousNode = currentNode\n      currentNode = nextNode\n    }\n    return previousNode\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var head = Program.LinkedList(value: 0)\n      head.next = Program.LinkedList(value: 1)\n      head.next!.next = Program.LinkedList(value: 2)\n      head.next!.next!.next = Program.LinkedList(value: 2)\n      head.next!.next!.next!.next = Program.LinkedList(value: 1)\n      head.next!.next!.next!.next!.next = Program.LinkedList(value: 0)\n      let expected = true\n      var actual = Program().linkedListPalindrome(head)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var head = Program.LinkedList(value: 0)\n      head.next = Program.LinkedList(value: 1)\n      head.next!.next = Program.LinkedList(value: 2)\n      head.next!.next!.next = Program.LinkedList(value: 2)\n      head.next!.next!.next!.next = Program.LinkedList(value: 1)\n      head.next!.next!.next!.next!.next = Program.LinkedList(value: 0)\n      let expected = true\n      var actual = Program().linkedListPalindrome(head)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nexport function linkedListPalindrome(head: LinkedList) {\n  // Write your code here.\n  return false;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the Linked List\nexport function linkedListPalindrome(head: LinkedList) {\n  const isPalindromeResults = isPalindrome(head, head);\n  return isPalindromeResults.outerNodesAreEqual;\n}\n\nfunction isPalindrome(leftNode: LinkedList, rightNode: LinkedList | null): LinkedListInfo {\n  if (rightNode === null) {\n    return new LinkedListInfo(true, leftNode);\n  }\n\n  const recursiveCallResults = isPalindrome(leftNode, rightNode.next);\n  const leftNodeToCompare = recursiveCallResults.leftNodeToCompare!;\n  const {outerNodesAreEqual} = recursiveCallResults;\n\n  const recursiveIsEqual = outerNodesAreEqual && leftNodeToCompare.value === rightNode.value;\n  const nextLeftNodeToCompare = leftNodeToCompare.next;\n\n  return new LinkedListInfo(recursiveIsEqual, nextLeftNodeToCompare);\n}\n\nclass LinkedListInfo {\n  outerNodesAreEqual: boolean;\n  leftNodeToCompare: LinkedList | null;\n\n  constructor(outerNodesAreEqual: boolean, leftNodeToCompare: LinkedList | null) {\n    this.outerNodesAreEqual = outerNodesAreEqual;\n    this.leftNodeToCompare = leftNodeToCompare;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nexport function linkedListPalindrome(head: LinkedList) {\n  let slowNode = head;\n  let fastNode: LinkedList | null = head;\n  while (fastNode !== null && fastNode.next !== null) {\n    slowNode = slowNode.next!;\n    fastNode = fastNode.next!.next;\n  }\n\n  let reversedSecondHalfNode: LinkedList | null = reverseLinkedList(slowNode);\n  let firstHalfNode: LinkedList | null = head;\n\n  while (reversedSecondHalfNode !== null) {\n    if (reversedSecondHalfNode.value !== firstHalfNode!.value) {\n      return false;\n    }\n    reversedSecondHalfNode = reversedSecondHalfNode.next;\n    firstHalfNode = firstHalfNode!.next;\n  }\n\n  return true;\n}\n\nexport function reverseLinkedList(head: LinkedList) {\n  let previousNode: LinkedList | null = null;\n  let currentNode: LinkedList | null = head;\n  while (currentNode !== null) {\n    const nextNode: LinkedList | null = currentNode.next;\n    currentNode.next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode!;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const head = new program.LinkedList(0);\n  head.next = new program.LinkedList(1);\n  head.next.next = new program.LinkedList(2);\n  head.next.next.next = new program.LinkedList(2);\n  head.next.next.next.next = new program.LinkedList(1);\n  head.next.next.next.next.next = new program.LinkedList(0);\n  const expected = true;\n  const actual = program.linkedListPalindrome(head);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const head = new program.LinkedList(0);\n  head.next = new program.LinkedList(1);\n  head.next.next = new program.LinkedList(2);\n  head.next.next.next = new program.LinkedList(2);\n  head.next.next.next.next = new program.LinkedList(1);\n  head.next.next.next.next.next = new program.LinkedList(0);\n  const expected = true;\n  const actual = program.linkedListPalindrome(head);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "linkedList",
      "example": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "2-2",
            "value": 2
          },
          {
            "id": "2-2",
            "next": "1-2",
            "value": 2
          },
          {
            "id": "1-2",
            "next": "0-2",
            "value": 1
          },
          {
            "id": "0-2",
            "next": null,
            "value": 0
          }
        ]
      },
      "schema": {
        "description": "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
        "properties": {
          "head": {
            "type": "string"
          },
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "next": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "next"
              ],
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "head",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "2-2",
            "value": 2
          },
          {
            "id": "2-2",
            "next": "1-2",
            "value": 2
          },
          {
            "id": "1-2",
            "next": "0-2",
            "value": 1
          },
          {
            "id": "0-2",
            "next": null,
            "value": 0
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": null,
            "value": 0
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "0-2",
            "value": 0
          },
          {
            "id": "0-2",
            "next": null,
            "value": 0
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": null,
            "value": 3
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "6",
        "nodes": [
          {
            "id": "6",
            "next": "5",
            "value": 6
          },
          {
            "id": "5",
            "next": "4",
            "value": 5
          },
          {
            "id": "4",
            "next": "3",
            "value": 4
          },
          {
            "id": "3",
            "next": "4-2",
            "value": 3
          },
          {
            "id": "4-2",
            "next": "5-2",
            "value": 4
          },
          {
            "id": "5-2",
            "next": "6-2",
            "value": 5
          },
          {
            "id": "6-2",
            "next": null,
            "value": 6
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "next": "4-2",
            "value": 5
          },
          {
            "id": "4-2",
            "next": "3-2",
            "value": 4
          },
          {
            "id": "3-2",
            "next": "2-2",
            "value": 3
          },
          {
            "id": "2-2",
            "next": "1-2",
            "value": 2
          },
          {
            "id": "1-2",
            "next": "0-2",
            "value": 1
          },
          {
            "id": "0-2",
            "next": "12",
            "value": 0
          },
          {
            "id": "12",
            "next": null,
            "value": 12
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "next": "4-2",
            "value": 5
          },
          {
            "id": "4-2",
            "next": "3-2",
            "value": 4
          },
          {
            "id": "3-2",
            "next": "2-2",
            "value": 3
          },
          {
            "id": "2-2",
            "next": "1-2",
            "value": 2
          },
          {
            "id": "1-2",
            "next": "0-2",
            "value": 1
          },
          {
            "id": "0-2",
            "next": null,
            "value": 0
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "10000",
        "nodes": [
          {
            "id": "10000",
            "next": "10000-2",
            "value": 10000
          },
          {
            "id": "10000-2",
            "next": "10000-3",
            "value": 10000
          },
          {
            "id": "10000-3",
            "next": null,
            "value": 10000
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "10000",
        "nodes": [
          {
            "id": "10000",
            "next": "10000-2",
            "value": 10000
          },
          {
            "id": "10000-2",
            "next": "10000-3",
            "value": 10000
          },
          {
            "id": "10000-3",
            "next": "10000-4",
            "value": 10000
          },
          {
            "id": "10000-4",
            "next": null,
            "value": 10000
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "3",
        "nodes": [
          {
            "id": "3",
            "next": "1",
            "value": 3
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3-2",
            "value": 2
          },
          {
            "id": "3-2",
            "next": null,
            "value": 3
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": "10",
            "value": 9
          },
          {
            "id": "10",
            "next": "11",
            "value": 10
          },
          {
            "id": "11",
            "next": "10-2",
            "value": 11
          },
          {
            "id": "10-2",
            "next": "9-2",
            "value": 10
          },
          {
            "id": "9-2",
            "next": "8-2",
            "value": 9
          },
          {
            "id": "8-2",
            "next": "7-2",
            "value": 8
          },
          {
            "id": "7-2",
            "next": "6-2",
            "value": 7
          },
          {
            "id": "6-2",
            "next": "5-2",
            "value": 6
          },
          {
            "id": "5-2",
            "next": "4-2",
            "value": 5
          },
          {
            "id": "4-2",
            "next": "3-2",
            "value": 4
          },
          {
            "id": "3-2",
            "next": "2-2",
            "value": 3
          },
          {
            "id": "2-2",
            "next": "1-2",
            "value": 2
          },
          {
            "id": "1-2",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": "10",
            "value": 9
          },
          {
            "id": "10",
            "next": "11",
            "value": 10
          },
          {
            "id": "11",
            "next": "10-2",
            "value": 11
          },
          {
            "id": "10-2",
            "next": "9-2",
            "value": 10
          },
          {
            "id": "9-2",
            "next": "8-2",
            "value": 9
          },
          {
            "id": "8-2",
            "next": "7-2",
            "value": 8
          },
          {
            "id": "7-2",
            "next": "6-2",
            "value": 7
          },
          {
            "id": "6-2",
            "next": "5-2",
            "value": 6
          },
          {
            "id": "5-2",
            "next": "4-2",
            "value": 5
          },
          {
            "id": "4-2",
            "next": "3-2",
            "value": 4
          },
          {
            "id": "3-2",
            "next": "2-2",
            "value": 3
          },
          {
            "id": "2-2",
            "next": "1-2",
            "value": 2
          },
          {
            "id": "1-2",
            "next": "0-2",
            "value": 1
          },
          {
            "id": "0-2",
            "next": null,
            "value": 0
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "1-2",
            "value": 3
          },
          {
            "id": "1-2",
            "next": "2-2",
            "value": 1
          },
          {
            "id": "2-2",
            "next": null,
            "value": 2
          }
        ]
      }
    }
  ],
  "jsonTests": [
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "2-2",
            "value": 2
          },
          {
            "id": "2-2",
            "next": "1-2",
            "value": 2
          },
          {
            "id": "1-2",
            "next": "0-2",
            "value": 1
          },
          {
            "id": "0-2",
            "next": null,
            "value": 0
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": null,
            "value": 0
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "0-2",
            "value": 0
          },
          {
            "id": "0-2",
            "next": null,
            "value": 0
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": null,
            "value": 3
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "6",
        "nodes": [
          {
            "id": "6",
            "next": "5",
            "value": 6
          },
          {
            "id": "5",
            "next": "4",
            "value": 5
          },
          {
            "id": "4",
            "next": "3",
            "value": 4
          },
          {
            "id": "3",
            "next": "4-2",
            "value": 3
          },
          {
            "id": "4-2",
            "next": "5-2",
            "value": 4
          },
          {
            "id": "5-2",
            "next": "6-2",
            "value": 5
          },
          {
            "id": "6-2",
            "next": null,
            "value": 6
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "next": "4-2",
            "value": 5
          },
          {
            "id": "4-2",
            "next": "3-2",
            "value": 4
          },
          {
            "id": "3-2",
            "next": "2-2",
            "value": 3
          },
          {
            "id": "2-2",
            "next": "1-2",
            "value": 2
          },
          {
            "id": "1-2",
            "next": "0-2",
            "value": 1
          },
          {
            "id": "0-2",
            "next": "12",
            "value": 0
          },
          {
            "id": "12",
            "next": null,
            "value": 12
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "next": "4-2",
            "value": 5
          },
          {
            "id": "4-2",
            "next": "3-2",
            "value": 4
          },
          {
            "id": "3-2",
            "next": "2-2",
            "value": 3
          },
          {
            "id": "2-2",
            "next": "1-2",
            "value": 2
          },
          {
            "id": "1-2",
            "next": "0-2",
            "value": 1
          },
          {
            "id": "0-2",
            "next": null,
            "value": 0
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "10000",
        "nodes": [
          {
            "id": "10000",
            "next": "10000-2",
            "value": 10000
          },
          {
            "id": "10000-2",
            "next": "10000-3",
            "value": 10000
          },
          {
            "id": "10000-3",
            "next": null,
            "value": 10000
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "10000",
        "nodes": [
          {
            "id": "10000",
            "next": "10000-2",
            "value": 10000
          },
          {
            "id": "10000-2",
            "next": "10000-3",
            "value": 10000
          },
          {
            "id": "10000-3",
            "next": "10000-4",
            "value": 10000
          },
          {
            "id": "10000-4",
            "next": null,
            "value": 10000
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "3",
        "nodes": [
          {
            "id": "3",
            "next": "1",
            "value": 3
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3-2",
            "value": 2
          },
          {
            "id": "3-2",
            "next": null,
            "value": 3
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": "10",
            "value": 9
          },
          {
            "id": "10",
            "next": "11",
            "value": 10
          },
          {
            "id": "11",
            "next": "10-2",
            "value": 11
          },
          {
            "id": "10-2",
            "next": "9-2",
            "value": 10
          },
          {
            "id": "9-2",
            "next": "8-2",
            "value": 9
          },
          {
            "id": "8-2",
            "next": "7-2",
            "value": 8
          },
          {
            "id": "7-2",
            "next": "6-2",
            "value": 7
          },
          {
            "id": "6-2",
            "next": "5-2",
            "value": 6
          },
          {
            "id": "5-2",
            "next": "4-2",
            "value": 5
          },
          {
            "id": "4-2",
            "next": "3-2",
            "value": 4
          },
          {
            "id": "3-2",
            "next": "2-2",
            "value": 3
          },
          {
            "id": "2-2",
            "next": "1-2",
            "value": 2
          },
          {
            "id": "1-2",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": "10",
            "value": 9
          },
          {
            "id": "10",
            "next": "11",
            "value": 10
          },
          {
            "id": "11",
            "next": "10-2",
            "value": 11
          },
          {
            "id": "10-2",
            "next": "9-2",
            "value": 10
          },
          {
            "id": "9-2",
            "next": "8-2",
            "value": 9
          },
          {
            "id": "8-2",
            "next": "7-2",
            "value": 8
          },
          {
            "id": "7-2",
            "next": "6-2",
            "value": 7
          },
          {
            "id": "6-2",
            "next": "5-2",
            "value": 6
          },
          {
            "id": "5-2",
            "next": "4-2",
            "value": 5
          },
          {
            "id": "4-2",
            "next": "3-2",
            "value": 4
          },
          {
            "id": "3-2",
            "next": "2-2",
            "value": 3
          },
          {
            "id": "2-2",
            "next": "1-2",
            "value": 2
          },
          {
            "id": "1-2",
            "next": "0-2",
            "value": 1
          },
          {
            "id": "0-2",
            "next": null,
            "value": 0
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "1-2",
            "value": 3
          },
          {
            "id": "1-2",
            "next": "2-2",
            "value": 1
          },
          {
            "id": "2-2",
            "next": null,
            "value": 2
          }
        ]
      }
    }
  ],
  "changelog": []
}