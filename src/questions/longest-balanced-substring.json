{
  "uid": "longest-balanced-substring",
  "testStrategy": "JSON",
  "name": "Longest Balanced Substring",
  "version": 0,
  "releaseDate": "2020-11-16T00:00:00Z",
  "category": "Strings",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 4746,
    "failureCount": 2068
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "563549297",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 1691
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in a string made up of parentheses (<span>(</span>\n  and <span>)</span>). The function should return an integer representing the\n  length of the longest balanced substring with regards to parentheses.\n</p>\n<p>\n  A string is said to be balanced if it has as many opening parentheses as it\n  has closing parentheses and if no parenthesis is unmatched. Note that an\n  opening parenthesis can't match a closing parenthesis that comes before it,\n  and similarly, a closing parenthesis can't match an opening parenthesis that\n  comes after it.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">string</span> = \"(()))(\"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n4 <span class=\"CodeEditor-promptComment\">// The longest balanced substring is \"(())\".</span>\n</pre>\n</div>",
  "hints": [
    "<p>\nWith a brute-force style approach, you can iterate through all substrings of the input string, check if they're balanced, and keep track of the longest balanced one. This approach will require using an auxiliary method to check whether a substring is balanced.\n</p>\n",
    "\n<p>\nA more efficient approach to solving this problem is to iterate through the input string only once, using a stack to track the indices of all unmatched opening parentheses. Whenever a closing parenthesis is encountered, you check if the stack has a corresponding opening-parenthesis index, and you pop that index off the stack if it does. If the stack doesn't have a corresponding opening-parenthesis index, then the closing parenthesis is unmatched, and its own index in the input string denotes the start of a new, potentially balanced substring. With this approach, you'll have to figure out a way to keep track of how long a balanced substring is.\n</p>\n",
    "\n<p>\nThe most efficient way to solve this problem is to use only two variables to keep track of the numbers of opening and closing parentheses, respectively, as you traverse the string. Think about how you can use these two pieces of information alone to find the longest balanced substring. Specifically, how do these two pieces of information help you figure out if a substring is balanced, and how can you use them to calculate the length of such a substring?\n</p>"
  ],
  "spaceTime": "O(n) time | O(1) space - where n is the length of the input string",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\nint longestBalancedSubstring(string str) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nbool isBalanced(string str);\n\n// O(n^3) time | O(n) space - where n is the length of the input string\nint longestBalancedSubstring(string str) {\n  int maxLength = 0;\n\n  for (int i = 0; i < str.size(); i++) {\n    for (int j = i + 2; j < str.size() + 1; j++) {\n      if (isBalanced(str.substr(i, j - i))) {\n        int currentLength = j - i;\n        maxLength = max(maxLength, currentLength);\n      }\n    }\n  }\n  return maxLength;\n}\n\nbool isBalanced(string str) {\n  vector<char> openParensStack;\n\n  for (char c : str) {\n    if (c == '(') {\n      openParensStack.push_back('(');\n    } else if (openParensStack.size() > 0) {\n      openParensStack.pop_back();\n    } else {\n      return false;\n    }\n  }\n\n  return openParensStack.size() == 0;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n// O(n) time | O(n) space - where n is the length of the input string\nint longestBalancedSubstring(string str) {\n  int maxLength = 0;\n  vector<int> idxStack = {-1};\n\n  for (int i = 0; i < str.size(); i++) {\n    if (str[i] == '(') {\n      idxStack.push_back(i);\n    } else {\n      idxStack.pop_back();\n      if (idxStack.size() == 0) {\n        idxStack.push_back(i);\n      } else {\n        int balancedSubstringStartIdx = idxStack[idxStack.size() - 1];\n        int currentLength = i - balancedSubstringStartIdx;\n        maxLength = max(maxLength, currentLength);\n      }\n    }\n  }\n  return maxLength;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n\nusing namespace std;\n\n// O(n) time | O(1) space - where n is the length of the input string\nint longestBalancedSubstring(string str) {\n  int maxLength = 0;\n\n  int openingCount = 0;\n  int closingCount = 0;\n\n  for (char c : str) {\n    if (c == '(') {\n      openingCount++;\n    } else {\n      closingCount++;\n    }\n\n    if (openingCount == closingCount) {\n      maxLength = max(maxLength, closingCount * 2);\n    } else if (closingCount > openingCount) {\n      openingCount = 0;\n      closingCount = 0;\n    }\n  }\n\n  openingCount = 0;\n  closingCount = 0;\n\n  for (int i = str.length() - 1; i >= 0; i--) {\n    char c = str[i];\n\n    if (c == '(') {\n      openingCount++;\n    } else {\n      closingCount++;\n    }\n\n    if (openingCount == closingCount) {\n      maxLength = max(maxLength, openingCount * 2);\n    } else if (openingCount > closingCount) {\n      openingCount = 0;\n      closingCount = 0;\n    }\n  }\n\n  return maxLength;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n\nusing namespace std;\n\nint getLongestBalancedInDirection(string str, bool leftToRight);\n\n// O(n) time | O(1) space - where n is the length of the input string\nint longestBalancedSubstring(string str) {\n  return max(\n    getLongestBalancedInDirection(str, true),\n    getLongestBalancedInDirection(str, false)\n  );\n}\n\nint getLongestBalancedInDirection(string str, bool leftToRight) {\n  char openingParens = leftToRight ? '(' : ')';\n  int startIdx = leftToRight ? 0 : str.length() - 1;\n  int step = leftToRight ? 1 : -1;\n\n  int maxLength = 0;\n\n  int openingCount = 0;\n  int closingCount = 0;\n\n  int idx = startIdx;\n  while (idx >= 0 && idx < str.length()) {\n    char c = str[idx];\n\n    if (c == openingParens) {\n      openingCount++;\n    } else {\n      closingCount++;\n    }\n\n    if (openingCount == closingCount) {\n      maxLength = max(maxLength, closingCount * 2);\n    } else if (closingCount > openingCount) {\n      openingCount = 0;\n      closingCount = 0;\n    }\n\n    idx += step;\n  }\n\n  return maxLength;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto input = \"(()))(\";\n      auto expected = 4;\n      auto actual = longestBalancedSubstring(input);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto input = \"(()))(\";\n      auto expected = 4;\n      auto actual = longestBalancedSubstring(input);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public int LongestBalancedSubstring(string str) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(n^3) time | O(n) space - where n is the length of the input string\n  public int LongestBalancedSubstring(string str) {\n    int maxLength = 0;\n\n    for (int i = 0; i < str.Length; i++) {\n      for (int j = i + 2; j < str.Length + 1; j += 2) {\n        if (isBalanced(str.Substring(i, j - i))) {\n          int currentLength = j - i;\n          maxLength = Math.Max(maxLength, currentLength);\n        }\n      }\n    }\n\n    return maxLength;\n  }\n\n  public bool isBalanced(string str) {\n    Stack<char> openParensStack = new Stack<char>();\n\n    for (int i = 0; i < str.Length; i++) {\n      char c = str[i];\n      if (c == '(') {\n        openParensStack.Push('(');\n      } else if (openParensStack.Count > 0) {\n        openParensStack.Pop();\n      } else {\n        return false;\n      }\n    }\n\n    return openParensStack.Count == 0;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(n) time | O(n) space - where n is the length of the input string\n  public int LongestBalancedSubstring(string str) {\n    int maxLength = 0;\n    Stack<int> idxStack = new Stack<int>();\n    idxStack.Push(-1);\n\n    for (int i = 0; i < str.Length; i++) {\n      if (str[i] == '(') {\n        idxStack.Push(i);\n      } else {\n        idxStack.Pop();\n        if (idxStack.Count == 0) {\n          idxStack.Push(i);\n        } else {\n          int balancedSubstringStartIdx = idxStack.Peek();\n          int currentLength = i - balancedSubstringStartIdx;\n          maxLength = Math.Max(maxLength, currentLength);\n        }\n      }\n    }\n\n    return maxLength;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // O(n) time | O(1) space - where n is the length of the input string\n  public int LongestBalancedSubstring(string str) {\n    int maxLength = 0;\n\n    int openingCount = 0;\n    int closingCount = 0;\n\n    for (int i = 0; i < str.Length; i++) {\n      char c = str[i];\n\n      if (c == '(') {\n        openingCount += 1;\n      } else {\n        closingCount += 1;\n      }\n\n      if (openingCount == closingCount) {\n        maxLength = Math.Max(maxLength, closingCount * 2);\n      } else if (closingCount > openingCount) {\n        openingCount = 0;\n        closingCount = 0;\n      }\n    }\n\n    openingCount = 0;\n    closingCount = 0;\n\n    for (int i = str.Length - 1; i >= 0; i--) {\n      char c = str[i];\n\n      if (c == '(') {\n        openingCount += 1;\n      } else {\n        closingCount += 1;\n      }\n\n      if (openingCount == closingCount) {\n        maxLength = Math.Max(maxLength, openingCount * 2);\n      } else if (openingCount > closingCount) {\n        openingCount = 0;\n        closingCount = 0;\n      }\n    }\n\n    return maxLength;\n  }\n}",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // O(n) time | O(1) space - where n is the length of the input string\n  public int LongestBalancedSubstring(string str) {\n    return Math.Max(\n      GetLongestBalancedInDirection(str, true),\n      GetLongestBalancedInDirection(str, false)\n    );\n  }\n\n  public int GetLongestBalancedInDirection(string str, bool leftToRight) {\n    char openingParens = leftToRight ? '(' : ')';\n    int startIdx = leftToRight ? 0 : str.Length - 1;\n    int step = leftToRight ? 1 : -1;\n\n    int maxLength = 0;\n\n    int openingCount = 0;\n    int closingCount = 0;\n\n    int idx = startIdx;\n    while (idx >= 0 && idx < str.Length) {\n      char c = str[idx];\n\n      if (c == openingParens) {\n        openingCount += 1;\n      } else {\n        closingCount += 1;\n      }\n\n      if (openingCount == closingCount) {\n        maxLength = Math.Max(maxLength, closingCount * 2);\n      } else if (closingCount > openingCount) {\n        openingCount = 0;\n        closingCount = 0;\n      }\n\n      idx += step;\n    }\n\n    return maxLength;\n  }\n}"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var input = \"(()))(\";\n    var expected = 4;\n    var actual = new Program().LongestBalancedSubstring(input);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var input = \"(()))(\";\n    var expected = 4;\n    var actual = new Program().LongestBalancedSubstring(input);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc LongestBalancedSubstring(str string) int {\n\t// Write your code here.\n\treturn -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n^3) time | O(n) space - where n is the length of the input string\nfunc LongestBalancedSubstring(str string) int {\n\tmaxLength := 0\n\n\tfor i := range str {\n\t\tfor j := i + 2; j < len(str)+1; j++ {\n\t\t\tif isBalanced(str[i:j]) {\n\t\t\t\tcurrentLength := j - i\n\t\t\t\tmaxLength = max(maxLength, currentLength)\n\t\t\t}\n\t\t}\n\t}\n\treturn maxLength\n}\n\nfunc isBalanced(str string) bool {\n\topenParensStack := []rune{}\n\tfor _, char := range str {\n\t\tif char == '(' {\n\t\t\topenParensStack = append(openParensStack, char)\n\t\t} else if len(openParensStack) > 0 {\n\t\t\topenParensStack = openParensStack[:len(openParensStack)-1]\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn len(openParensStack) == 0\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(n) space - where n is the length of the input string\nfunc LongestBalancedSubstring(str string) int {\n\tmaxLength := 0\n\tidxStack := []int{-1}\n\n\tfor i := range str {\n\t\tif str[i] == '(' {\n\t\t\tidxStack = append(idxStack, i)\n\t\t} else {\n\t\t\tidxStack = idxStack[:len(idxStack)-1]\n\t\t\tif len(idxStack) == 0 {\n\t\t\t\tidxStack = append(idxStack, i)\n\t\t\t} else {\n\t\t\t\tbalancedSubstringStartIdx := idxStack[len(idxStack)-1]\n\t\t\t\tcurrentLength := i - balancedSubstringStartIdx\n\t\t\t\tmaxLength = max(maxLength, currentLength)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn maxLength\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(1) space - where n is the length of the input string\nfunc LongestBalancedSubstring(str string) int {\n\tmaxLength := 0\n\n\topeningCount := 0\n\tclosingCount := 0\n\n\tfor _, char := range str {\n\t\tif char == '(' {\n\t\t\topeningCount++\n\t\t} else {\n\t\t\tclosingCount++\n\t\t}\n\n\t\tif openingCount == closingCount {\n\t\t\tmaxLength = max(maxLength, closingCount*2)\n\t\t} else if closingCount > openingCount {\n\t\t\topeningCount = 0\n\t\t\tclosingCount = 0\n\t\t}\n\t}\n\n\topeningCount = 0\n\tclosingCount = 0\n\n\tfor i := len(str) - 1; i >= 0; i-- {\n\t\tchar := str[i]\n\n\t\tif char == '(' {\n\t\t\topeningCount++\n\t\t} else {\n\t\t\tclosingCount++\n\t\t}\n\n\t\tif openingCount == closingCount {\n\t\t\tmaxLength = max(maxLength, openingCount*2)\n\t\t} else if openingCount > closingCount {\n\t\t\topeningCount = 0\n\t\t\tclosingCount = 0\n\t\t}\n\t}\n\n\treturn maxLength\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(1) space - where n is the length of the input string\nfunc LongestBalancedSubstring(str string) int {\n\treturn max(\n\t\tgetLongestBalancedInDirection(str, true),\n\t\tgetLongestBalancedInDirection(str, false),\n\t)\n}\n\nfunc getLongestBalancedInDirection(str string, leftToRight bool) int {\n\topeningParens := '('\n\tstartIdx := 0\n\tstep := 1\n\tif !leftToRight {\n\t\topeningParens = ')'\n\t\tstartIdx = len(str) - 1\n\t\tstep = -1\n\t}\n\n\tmaxLength := 0\n\n\topeningCount := 0\n\tclosingCount := 0\n\n\tidx := startIdx\n\tfor idx >= 0 && idx < len(str) {\n\t\tchar := str[idx]\n\n\t\tif rune(char) == openingParens {\n\t\t\topeningCount++\n\t\t} else {\n\t\t\tclosingCount++\n\t\t}\n\n\t\tif openingCount == closingCount {\n\t\t\tmaxLength = max(maxLength, closingCount*2)\n\t\t} else if closingCount > openingCount {\n\t\t\topeningCount = 0\n\t\t\tclosingCount = 0\n\t\t}\n\n\t\tidx += step\n\t}\n\n\treturn maxLength\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := \"(()))(\"\n\texpected := 4\n\tactual := LongestBalancedSubstring(input)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := \"(()))(\"\n\texpected := 4\n\tactual := LongestBalancedSubstring(input)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public int longestBalancedSubstring(String string) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n^3) time | O(n) space - where n is the length of the input string\n  public int longestBalancedSubstring(String string) {\n    int maxLength = 0;\n\n    for (int i = 0; i < string.length(); i++) {\n      for (int j = i + 2; j < string.length() + 1; j += 2) {\n        if (isBalanced(string.substring(i, j))) {\n          int currentLength = j - i;\n          maxLength = Math.max(maxLength, currentLength);\n        }\n      }\n    }\n\n    return maxLength;\n  }\n\n  public boolean isBalanced(String string) {\n    Stack<Character> openParensStack = new Stack();\n\n    for (int i = 0; i < string.length(); i++) {\n      char c = string.charAt(i);\n      if (c == '(') {\n        openParensStack.push('(');\n      } else if (openParensStack.size() > 0) {\n        openParensStack.pop();\n      } else {\n        return false;\n      }\n    }\n\n    return openParensStack.size() == 0;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n) time | O(n) space - where n is the length of the input string\n  public int longestBalancedSubstring(String string) {\n    int maxLength = 0;\n    Stack<Integer> idxStack = new Stack();\n    idxStack.push(-1);\n\n    for (int i = 0; i < string.length(); i++) {\n      if (string.charAt(i) == '(') {\n        idxStack.push(i);\n      } else {\n        idxStack.pop();\n        if (idxStack.size() == 0) {\n          idxStack.push(i);\n        } else {\n          int balancedSubstringStartIdx = idxStack.peek();\n          int currentLength = i - balancedSubstringStartIdx;\n          maxLength = Math.max(maxLength, currentLength);\n        }\n      }\n    }\n\n    return maxLength;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n) time | O(1) space - where n is the length of the input string\n  public int longestBalancedSubstring(String string) {\n    int maxLength = 0;\n\n    int openingCount = 0;\n    int closingCount = 0;\n\n    for (int i = 0; i < string.length(); i++) {\n      char c = string.charAt(i);\n\n      if (c == '(') {\n        openingCount += 1;\n      } else {\n        closingCount += 1;\n      }\n\n      if (openingCount == closingCount) {\n        maxLength = Math.max(maxLength, closingCount * 2);\n      } else if (closingCount > openingCount) {\n        openingCount = 0;\n        closingCount = 0;\n      }\n    }\n\n    openingCount = 0;\n    closingCount = 0;\n\n    for (int i = string.length() - 1; i >= 0; i--) {\n      char c = string.charAt(i);\n\n      if (c == '(') {\n        openingCount += 1;\n      } else {\n        closingCount += 1;\n      }\n\n      if (openingCount == closingCount) {\n        maxLength = Math.max(maxLength, openingCount * 2);\n      } else if (openingCount > closingCount) {\n        openingCount = 0;\n        closingCount = 0;\n      }\n    }\n\n    return maxLength;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n) time | O(1) space - where n is the length of the input string\n  public int longestBalancedSubstring(String string) {\n    return Math.max(\n      getLongestBalancedInDirection(string, true),\n      getLongestBalancedInDirection(string, false)\n    );\n  }\n\n  public int getLongestBalancedInDirection(String string, Boolean leftToRight) {\n    char openingParens = leftToRight ? '(' : ')';\n    int startIdx = leftToRight ? 0 : string.length() - 1;\n    int step = leftToRight ? 1 : -1;\n\n    int maxLength = 0;\n\n    int openingCount = 0;\n    int closingCount = 0;\n\n    int idx = startIdx;\n    while (idx >= 0 && idx < string.length()) {\n      char c = string.charAt(idx);\n\n      if (c == openingParens) {\n        openingCount += 1;\n      } else {\n        closingCount += 1;\n      }\n\n      if (openingCount == closingCount) {\n        maxLength = Math.max(maxLength, closingCount * 2);\n      } else if (closingCount > openingCount) {\n        openingCount = 0;\n        closingCount = 0;\n      }\n\n      idx += step;\n    }\n\n    return maxLength;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var input = \"(()))(\";\n    var expected = 4;\n    var actual = new Program().longestBalancedSubstring(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var input = \"(()))(\";\n    var expected = 4;\n    var actual = new Program().longestBalancedSubstring(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function longestBalancedSubstring(string) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.longestBalancedSubstring = longestBalancedSubstring;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n^3) time | O(n) space - where n is the length of the input string\nfunction longestBalancedSubstring(string) {\n  let maxLength = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    for (let j = i + 2; j < string.length + 1; j += 2) {\n      if (isBalanced(string.slice(i, j))) {\n        const currentLength = j - i;\n        maxLength = Math.max(maxLength, currentLength);\n      }\n    }\n  }\n\n  return maxLength;\n}\n\nfunction isBalanced(string) {\n  const openParensStack = [];\n\n  for (const char of string) {\n    if (char === '(') {\n      openParensStack.push('(');\n    } else if (openParensStack.length > 0) {\n      openParensStack.pop();\n    } else {\n      return false;\n    }\n  }\n\n  return openParensStack.length === 0;\n}\n\nexports.longestBalancedSubstring = longestBalancedSubstring;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the length of the input string\nfunction longestBalancedSubstring(string) {\n  let maxLength = 0;\n  const idxStack = [];\n  idxStack.push(-1);\n\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '(') {\n      idxStack.push(i);\n    } else {\n      idxStack.pop();\n      if (idxStack.length === 0) {\n        idxStack.push(i);\n      } else {\n        const balancedSubstringStartIdx = idxStack[idxStack.length - 1];\n        const currentLength = i - balancedSubstringStartIdx;\n        maxLength = Math.max(maxLength, currentLength);\n      }\n    }\n  }\n\n  return maxLength;\n}\n\nexports.longestBalancedSubstring = longestBalancedSubstring;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space - where n is the length of the input string\nfunction longestBalancedSubstring(string) {\n  let maxLength = 0;\n\n  let openingCount = 0;\n  let closingCount = 0;\n\n  for (const char of string) {\n    if (char === '(') {\n      openingCount++;\n    } else {\n      closingCount++;\n    }\n\n    if (openingCount === closingCount) {\n      maxLength = Math.max(maxLength, closingCount * 2);\n    } else if (closingCount > openingCount) {\n      openingCount = 0;\n      closingCount = 0;\n    }\n  }\n\n  openingCount = 0;\n  closingCount = 0;\n\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string[i];\n\n    if (char === '(') {\n      openingCount++;\n    } else {\n      closingCount++;\n    }\n\n    if (openingCount === closingCount) {\n      maxLength = Math.max(maxLength, openingCount * 2);\n    } else if (openingCount > closingCount) {\n      openingCount = 0;\n      closingCount = 0;\n    }\n  }\n\n  return maxLength;\n}\n\nexports.longestBalancedSubstring = longestBalancedSubstring;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space - where n is the length of the input string\nfunction longestBalancedSubstring(string) {\n  return Math.max(\n    getLongestBalancedInDirection(string, true),\n    getLongestBalancedInDirection(string, false),\n  );\n}\n\nfunction getLongestBalancedInDirection(string, leftToRight) {\n  const openingParens = leftToRight ? '(' : ')';\n  const startIdx = leftToRight ? 0 : string.length - 1;\n  const step = leftToRight ? 1 : -1;\n\n  let maxLength = 0;\n\n  let openingCount = 0;\n  let closingCount = 0;\n\n  let idx = startIdx;\n  while (idx >= 0 && idx < string.length) {\n    const char = string[idx];\n\n    if (char === openingParens) {\n      openingCount++;\n    } else {\n      closingCount++;\n    }\n\n    if (openingCount === closingCount) {\n      maxLength = Math.max(maxLength, closingCount * 2);\n    } else if (closingCount > openingCount) {\n      openingCount = 0;\n      closingCount = 0;\n    }\n\n    idx += step;\n  }\n\n  return maxLength;\n}\n\nexports.longestBalancedSubstring = longestBalancedSubstring;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const string = '(()))(';\n  const expected = 4;\n  const actual = program.longestBalancedSubstring(string);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const string = '(()))(';\n  const expected = 4;\n  const actual = program.longestBalancedSubstring(string);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun longestBalancedSubstring(string: String): Int {\n    // Write your code here.\n    return -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport java.util.Stack\nimport kotlin.math.max\n\n// O(n^3) time | O(n) space - where n is the length of the input string\nfun longestBalancedSubstring(string: String): Int {\n    var maxLength = 0\n\n    for (i in 0 until string.length) {\n        for (j in i + 2 until string.length + 1 step 2) {\n            if (isBalanced(string.substring(i, j))) {\n                val currentLength = j - i\n                maxLength = max(maxLength, currentLength)\n            }\n        }\n    }\n\n    return maxLength\n}\n\nfun isBalanced(string: String): Boolean {\n    val openParensStack = Stack<Char>()\n\n    for (char in string) {\n        if (char == '(') {\n            openParensStack.add(char)\n        } else if (openParensStack.size > 0) {\n            openParensStack.pop()\n        } else {\n            return false\n        }\n    }\n\n    return openParensStack.size == 0\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport java.util.Stack\nimport kotlin.math.max\n\n// O(n) time | O(n) space - where n is the length of the input string\nfun longestBalancedSubstring(string: String): Int {\n    var maxLength = 0\n    val idxStack = Stack<Int>()\n    idxStack.add(-1)\n\n    for (i in 0 until string.length) {\n        if (string[i] == '(') {\n            idxStack.add(i)\n        } else {\n            idxStack.pop()\n            if (idxStack.size == 0) {\n                idxStack.add(i)\n            } else {\n                val balancedSubstringStartIdx = idxStack[idxStack.size - 1]\n                val currentLength = i - balancedSubstringStartIdx\n                maxLength = max(maxLength, currentLength)\n            }\n        }\n    }\n\n    return maxLength\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.max\n\n// O(n) time | O(1) space - where n is the length of the input string\nfun longestBalancedSubstring(string: String): Int {\n    var maxLength = 0\n\n    var openingCount = 0\n    var closingCount = 0\n\n    for (char in string) {\n        if (char == '(') {\n            openingCount++\n        } else {\n            closingCount++\n        }\n\n        if (openingCount == closingCount) {\n            maxLength = max(maxLength, closingCount * 2)\n        } else if (closingCount > openingCount) {\n            openingCount = 0\n            closingCount = 0\n        }\n    }\n\n    openingCount = 0\n    closingCount = 0\n\n    for (i in string.length - 1 downTo 0) {\n        val char = string[i]\n\n        if (char == '(') {\n            openingCount++\n        } else {\n            closingCount++\n        }\n\n        if (openingCount == closingCount) {\n            maxLength = max(maxLength, openingCount * 2)\n        } else if (openingCount > closingCount) {\n            openingCount = 0\n            closingCount = 0\n        }\n    }\n\n    return maxLength\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.max\n\n// O(n) time | O(1) space - where n is the length of the input string\nfun longestBalancedSubstring(string: String): Int {\n    return max(\n        getLongestBalancedInDirection(string, true),\n        getLongestBalancedInDirection(string, false),\n    )\n}\n\nfun getLongestBalancedInDirection(string: String, leftToRight: Boolean): Int {\n    val openingParens = if (leftToRight) '(' else ')'\n    val startIdx = if (leftToRight) 0 else string.length - 1\n    val step = if (leftToRight) 1 else -1\n\n    var maxLength = 0\n\n    var openingCount = 0\n    var closingCount = 0\n\n    var idx = startIdx\n    while (idx >= 0 && idx < string.length) {\n        val char = string[idx]\n\n        if (char == openingParens) {\n            openingCount++\n        } else {\n            closingCount++\n        }\n\n        if (openingCount == closingCount) {\n            maxLength = max(maxLength, closingCount * 2)\n        } else if (closingCount > openingCount) {\n            openingCount = 0\n            closingCount = 0\n        }\n\n        idx += step\n    }\n\n    return maxLength\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.longestBalancedSubstring\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = \"(()))(\"\n        val expected = 4\n        val output = longestBalancedSubstring(input)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.longestBalancedSubstring\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = \"(()))(\"\n        val expected = 4\n        val output = longestBalancedSubstring(input)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def longestBalancedSubstring(string):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n^3) time | O(n) space - where n is the length of the input string\ndef longestBalancedSubstring(string):\n    maxLength = 0\n\n    for i in range(len(string)):\n        for j in range(i + 2, len(string) + 1, 2):\n            if isBalanced(string[i:j]):\n                currentLength = j - i\n                maxLength = max(maxLength, currentLength)\n\n    return maxLength\n\n\ndef isBalanced(string):\n    openParensStack = []\n\n    for char in string:\n        if char == \"(\":\n            openParensStack.append(\"(\")\n        elif len(openParensStack) > 0:\n            openParensStack.pop()\n        else:\n            return False\n\n    return len(openParensStack) == 0\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space - where n is the length of the input string\ndef longestBalancedSubstring(string):\n    maxLength = 0\n    idxStack = []\n    idxStack.append(-1)\n\n    for i in range(len(string)):\n        if string[i] == \"(\":\n            idxStack.append(i)\n        else:\n            idxStack.pop()\n            if len(idxStack) == 0:\n                idxStack.append(i)\n            else:\n                balancedSubstringStartIdx = idxStack[len(idxStack) - 1]\n                currentLength = i - balancedSubstringStartIdx\n                maxLength = max(maxLength, currentLength)\n\n    return maxLength\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(1) space - where n is the length of the input string\ndef longestBalancedSubstring(string):\n    maxLength = 0\n\n    openingCount = 0\n    closingCount = 0\n\n    for char in string:\n        if char == \"(\":\n            openingCount += 1\n        else:\n            closingCount += 1\n\n        if openingCount == closingCount:\n            maxLength = max(maxLength, closingCount * 2)\n        elif closingCount > openingCount:\n            openingCount = 0\n            closingCount = 0\n\n    openingCount = 0\n    closingCount = 0\n\n    for i in reversed(range(len(string))):\n        char = string[i]\n\n        if char == \"(\":\n            openingCount += 1\n        else:\n            closingCount += 1\n\n        if openingCount == closingCount:\n            maxLength = max(maxLength, openingCount * 2)\n        elif openingCount > closingCount:\n            openingCount = 0\n            closingCount = 0\n\n    return maxLength\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(1) space - where n is the length of the input string\ndef longestBalancedSubstring(string):\n    return max(\n        getLongestBalancedInDirection(string, True),\n        getLongestBalancedInDirection(string, False),\n    )\n\n\ndef getLongestBalancedInDirection(string, leftToRight):\n    openingParens = \"(\" if leftToRight else \")\"\n    startIdx = 0 if leftToRight else len(string) - 1\n    step = 1 if leftToRight else -1\n\n    maxLength = 0\n\n    openingCount = 0\n    closingCount = 0\n\n    idx = startIdx\n    while idx >= 0 and idx < len(string):\n        char = string[idx]\n\n        if char == openingParens:\n            openingCount += 1\n        else:\n            closingCount += 1\n\n        if openingCount == closingCount:\n            maxLength = max(maxLength, closingCount * 2)\n        elif closingCount > openingCount:\n            openingCount = 0\n            closingCount = 0\n\n        idx += step\n\n    return maxLength\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        string = \"(()))(\"\n        expected = 4\n        actual = program.longestBalancedSubstring(string)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        string = \"(()))(\"\n        expected = 4\n        actual = program.longestBalancedSubstring(string)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def longestBalancedSubstring(string)\n    # Write your code here.\n    return -1\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def longestBalancedSubstring(string)\n    # Write your code here.\n    return -1\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def longestBalancedSubstring(string)\n    # Write your code here.\n    return -1\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def longestBalancedSubstring(string)\n    # Write your code here.\n    return -1\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def longestBalancedSubstring(string)\n    # Write your code here.\n    return -1\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.longestBalancedSubstring\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.longestBalancedSubstring\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func longestBalancedSubstring(_ string: String) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^3) time | O(n) space - where n is the length of the input string\n  func longestBalancedSubstring(_ string: String) -> Int {\n    var maxLength = 0\n\n    for i in 0 ..< string.count {\n      for j in stride(from: i + 2, through: string.count, by: 1) {\n        let start = string.index(string.startIndex, offsetBy: i)\n        let end = string.index(string.startIndex, offsetBy: j)\n        let substring = string[start ..< end]\n        if isBalanced(String(substring)) {\n          let currentLength = j - i\n          maxLength = max(maxLength, currentLength)\n        }\n      }\n    }\n    return maxLength\n  }\n\n  func isBalanced(_ string: String) -> Bool {\n    var openParensStack = [Character]()\n    for char in string {\n      if char == \"(\" {\n        openParensStack.append(char)\n      } else if openParensStack.count > 0 {\n        openParensStack.removeLast()\n      } else {\n        return false\n      }\n    }\n    return openParensStack.count == 0\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space - where n is the length of the input string\n  func longestBalancedSubstring(_ string: String) -> Int {\n    var maxLength = 0\n    var idxStack = [-1]\n\n    let indexedString = Array(string)\n    for i in 0 ..< string.count {\n      if indexedString[i] == \"(\" {\n        idxStack.append(i)\n      } else {\n        idxStack.removeLast()\n        if idxStack.count == 0 {\n          idxStack.append(i)\n        } else {\n          let balancedSubstringStartIdx = idxStack[idxStack.count - 1]\n          let currentLength = i - balancedSubstringStartIdx\n          maxLength = max(maxLength, currentLength)\n        }\n      }\n    }\n    return maxLength\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space - where n is the length of the input string\n  func longestBalancedSubstring(_ string: String) -> Int {\n    var maxLength = 0\n\n    var openingCount = 0\n    var closingCount = 0\n\n    for char in string {\n      if char == \"(\" {\n        openingCount += 1\n      } else {\n        closingCount += 1\n      }\n\n      if openingCount == closingCount {\n        maxLength = max(maxLength, closingCount * 2)\n      } else if closingCount > openingCount {\n        openingCount = 0\n        closingCount = 0\n      }\n    }\n\n    openingCount = 0\n    closingCount = 0\n\n    let indexedString = Array(string)\n    for idx in stride(from: string.count - 1, through: 0, by: -1) {\n      let char = indexedString[idx]\n\n      if char == \"(\" {\n        openingCount += 1\n      } else {\n        closingCount += 1\n      }\n\n      if openingCount == closingCount {\n        maxLength = max(maxLength, openingCount * 2)\n      } else if openingCount > closingCount {\n        openingCount = 0\n        closingCount = 0\n      }\n    }\n\n    return maxLength\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space - where n is the length of the input string\n  func longestBalancedSubstring(_ string: String) -> Int {\n    max(\n      getLongestBalancedInDirection(string, true),\n      getLongestBalancedInDirection(string, false)\n    )\n  }\n\n  func getLongestBalancedInDirection(_ string: String, _ leftToRight: Bool) -> Int {\n    var openingParens = \"(\"\n    var startIdx = 0\n    var step = 1\n    if !leftToRight {\n      openingParens = \")\"\n      startIdx = string.count - 1\n      step = -1\n    }\n    let openingParensIdx = openingParens.index(string.startIndex, offsetBy: 0)\n    let openingParensChar = openingParens[openingParensIdx]\n\n    var maxLength = 0\n\n    var openingCount = 0\n    var closingCount = 0\n\n    var idx = startIdx\n    let indexedString = Array(string)\n    while idx >= 0, idx < string.count {\n      let char = indexedString[idx]\n\n      if char == openingParensChar {\n        openingCount += 1\n      } else {\n        closingCount += 1\n      }\n\n      if openingCount == closingCount {\n        maxLength = max(maxLength, closingCount * 2)\n      } else if closingCount > openingCount {\n        openingCount = 0\n        closingCount = 0\n      }\n\n      idx += step\n    }\n\n    return maxLength\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var input = \"(()))(\"\n      var expected = 4\n      var actual = Program().longestBalancedSubstring(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var input = \"(()))(\"\n      var expected = 4\n      var actual = Program().longestBalancedSubstring(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function longestBalancedSubstring(string: string) {\n  // Write your code here.\n  return -1;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n^3) time | O(n) space - where n is the length of the input string\nexport function longestBalancedSubstring(string: string) {\n  let maxLength = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    for (let j = i + 2; j < string.length + 1; j += 2) {\n      if (isBalanced(string.slice(i, j))) {\n        const currentLength = j - i;\n        maxLength = Math.max(maxLength, currentLength);\n      }\n    }\n  }\n\n  return maxLength;\n}\n\nfunction isBalanced(string: string) {\n  const openParensStack: string[] = [];\n\n  for (const char of string) {\n    if (char === '(') {\n      openParensStack.push('(');\n    } else if (openParensStack.length > 0) {\n      openParensStack.pop();\n    } else {\n      return false;\n    }\n  }\n\n  return openParensStack.length === 0;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the length of the input string\nexport function longestBalancedSubstring(string: string) {\n  let maxLength = 0;\n  const idxStack: number[] = [];\n  idxStack.push(-1);\n\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '(') {\n      idxStack.push(i);\n    } else {\n      idxStack.pop();\n      if (idxStack.length === 0) {\n        idxStack.push(i);\n      } else {\n        const balancedSubstringStartIdx = idxStack[idxStack.length - 1];\n        const currentLength = i - balancedSubstringStartIdx;\n        maxLength = Math.max(maxLength, currentLength);\n      }\n    }\n  }\n\n  return maxLength;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space - where n is the length of the input string\nexport function longestBalancedSubstring(string: string) {\n  let maxLength = 0;\n\n  let openingCount = 0;\n  let closingCount = 0;\n\n  for (const char of string) {\n    if (char === '(') {\n      openingCount++;\n    } else {\n      closingCount++;\n    }\n\n    if (openingCount === closingCount) {\n      maxLength = Math.max(maxLength, closingCount * 2);\n    } else if (closingCount > openingCount) {\n      openingCount = 0;\n      closingCount = 0;\n    }\n  }\n\n  openingCount = 0;\n  closingCount = 0;\n\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string[i];\n\n    if (char === '(') {\n      openingCount++;\n    } else {\n      closingCount++;\n    }\n\n    if (openingCount === closingCount) {\n      maxLength = Math.max(maxLength, openingCount * 2);\n    } else if (openingCount > closingCount) {\n      openingCount = 0;\n      closingCount = 0;\n    }\n  }\n\n  return maxLength;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space - where n is the length of the input string\nexport function longestBalancedSubstring(string: string) {\n  return Math.max(\n    getLongestBalancedInDirection(string, true),\n    getLongestBalancedInDirection(string, false),\n  );\n}\n\nfunction getLongestBalancedInDirection(string: string, leftToRight: boolean) {\n  const openingParens = leftToRight ? '(' : ')';\n  const startIdx = leftToRight ? 0 : string.length - 1;\n  const step = leftToRight ? 1 : -1;\n\n  let maxLength = 0;\n\n  let openingCount = 0;\n  let closingCount = 0;\n\n  let idx = startIdx;\n  while (idx >= 0 && idx < string.length) {\n    const char = string[idx];\n\n    if (char === openingParens) {\n      openingCount++;\n    } else {\n      closingCount++;\n    }\n\n    if (openingCount === closingCount) {\n      maxLength = Math.max(maxLength, closingCount * 2);\n    } else if (closingCount > openingCount) {\n      openingCount = 0;\n      closingCount = 0;\n    }\n\n    idx += step;\n  }\n\n  return maxLength;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const string = '(()))(';\n  const expected = 4;\n  const actual = program.longestBalancedSubstring(string);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const string = '(()))(';\n  const expected = 4;\n  const actual = program.longestBalancedSubstring(string);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "string",
      "example": "(()))(",
      "schema": {
        "pattern": "^[()]+$|^$",
        "type": "string"
      }
    }
  ],
  "tests": [
    {
      "string": "(()))("
    },
    {
      "string": "())()(()())"
    },
    {
      "string": "()()()()()()()()()()"
    },
    {
      "string": "((()))()()()()()()()()()()"
    },
    {
      "string": "()"
    },
    {
      "string": "(())"
    },
    {
      "string": "((((((((()))))))))"
    },
    {
      "string": "((((((((((((((((()))))))))))))))))"
    },
    {
      "string": "(((()))()())))(()()()())()()"
    },
    {
      "string": "((((((()()()())()))((())))()"
    },
    {
      "string": "(("
    },
    {
      "string": "))"
    },
    {
      "string": "("
    },
    {
      "string": ")"
    },
    {
      "string": "(((((((((((((((((("
    },
    {
      "string": "))))))))))))))))))"
    },
    {
      "string": "(((((((((((((((((()"
    },
    {
      "string": "()))))))))))))))))))"
    },
    {
      "string": ")("
    },
    {
      "string": "(((((((((())))))))))"
    },
    {
      "string": "(((((((((()())))))))))"
    },
    {
      "string": "(((((((((()))))))))))"
    },
    {
      "string": "))))))))))(((((((((("
    },
    {
      "string": ""
    },
    {
      "string": "())()"
    },
    {
      "string": "()(()"
    },
    {
      "string": ")))))))()))))())(((("
    },
    {
      "string": "))())(())((())(())(("
    },
    {
      "string": ")())()(()(()())))((("
    },
    {
      "string": "((()))())()()()()))("
    },
    {
      "string": ")(())))(())()))))))("
    },
    {
      "string": "()()((((()()))()()()"
    },
    {
      "string": "()(())()(()()))((())"
    },
    {
      "string": ")(()((()()(()()()((("
    },
    {
      "string": ")())()(()))()((()))("
    },
    {
      "string": "()()))))(())((()(()("
    },
    {
      "string": "(()())())()((())())("
    },
    {
      "string": "(()))((())()))))))()"
    },
    {
      "string": "(((()()()(())((()()("
    },
    {
      "string": ")(()())((()(()())((("
    },
    {
      "string": "))()(()()()(()()()))"
    },
    {
      "string": "(((((((((((((()(()()"
    },
    {
      "string": ")))(()(()(()()()((()"
    },
    {
      "string": "()(()((()((()(((((()"
    },
    {
      "string": ")((())(((()(()()(())"
    },
    {
      "string": ")((((((()))(()))()(("
    },
    {
      "string": "()(()()(()(()))((())"
    },
    {
      "string": ")))((())()()))())(()"
    },
    {
      "string": "()())()((()()(((()))"
    },
    {
      "string": ")(()))))(()())))(()("
    },
    {
      "string": "))(()()((()))()))()("
    },
    {
      "string": ")()()))()(())))))))("
    },
    {
      "string": "(((())(())()())()()("
    },
    {
      "string": "()()(()()())((((()))"
    },
    {
      "string": "((()()((()(((()))())"
    },
    {
      "string": "))(())()())())))()))"
    },
    {
      "string": "(()(()()())())()((()"
    },
    {
      "string": "()()())))()()()())()"
    },
    {
      "string": "))((((()))()))()))))"
    },
    {
      "string": ")())(())((((((()((()"
    },
    {
      "string": ")((()())))((()((()))"
    },
    {
      "string": "())(())))(((()()((()"
    },
    {
      "string": ")()))((()))(((((((()"
    },
    {
      "string": ")((((((((()())((())("
    },
    {
      "string": ")(())))((()()()(((()"
    },
    {
      "string": ")()()))((((())))((()"
    },
    {
      "string": "(()(())(()((()))()()"
    },
    {
      "string": "(((()(((()()))((())("
    },
    {
      "string": ")()()())()))(())()()"
    },
    {
      "string": "((()))())(((()((())("
    },
    {
      "string": ")((((()()(()))))()))"
    },
    {
      "string": "((()(())))))((()))(("
    },
    {
      "string": "(()()))())()()(())(("
    },
    {
      "string": "(()))((())()()(((((("
    },
    {
      "string": "((()(()))(((((())((("
    },
    {
      "string": "())))))())(((())((()"
    },
    {
      "string": "(()(()"
    }
  ],
  "jsonTests": [
    {
      "string": "(()))("
    },
    {
      "string": "())()(()())"
    },
    {
      "string": "()()()()()()()()()()"
    },
    {
      "string": "((()))()()()()()()()()()()"
    },
    {
      "string": "()"
    },
    {
      "string": "(())"
    },
    {
      "string": "((((((((()))))))))"
    },
    {
      "string": "((((((((((((((((()))))))))))))))))"
    },
    {
      "string": "(((()))()())))(()()()())()()"
    },
    {
      "string": "((((((()()()())()))((())))()"
    },
    {
      "string": "(("
    },
    {
      "string": "))"
    },
    {
      "string": "("
    },
    {
      "string": ")"
    },
    {
      "string": "(((((((((((((((((("
    },
    {
      "string": "))))))))))))))))))"
    },
    {
      "string": "(((((((((((((((((()"
    },
    {
      "string": "()))))))))))))))))))"
    },
    {
      "string": ")("
    },
    {
      "string": "(((((((((())))))))))"
    },
    {
      "string": "(((((((((()())))))))))"
    },
    {
      "string": "(((((((((()))))))))))"
    },
    {
      "string": "))))))))))(((((((((("
    },
    {
      "string": ""
    },
    {
      "string": "())()"
    },
    {
      "string": "()(()"
    },
    {
      "string": ")))))))()))))())(((("
    },
    {
      "string": "))())(())((())(())(("
    },
    {
      "string": ")())()(()(()())))((("
    },
    {
      "string": "((()))())()()()()))("
    },
    {
      "string": ")(())))(())()))))))("
    },
    {
      "string": "()()((((()()))()()()"
    },
    {
      "string": "()(())()(()()))((())"
    },
    {
      "string": ")(()((()()(()()()((("
    },
    {
      "string": ")())()(()))()((()))("
    },
    {
      "string": "()()))))(())((()(()("
    },
    {
      "string": "(()())())()((())())("
    },
    {
      "string": "(()))((())()))))))()"
    },
    {
      "string": "(((()()()(())((()()("
    },
    {
      "string": ")(()())((()(()())((("
    },
    {
      "string": "))()(()()()(()()()))"
    },
    {
      "string": "(((((((((((((()(()()"
    },
    {
      "string": ")))(()(()(()()()((()"
    },
    {
      "string": "()(()((()((()(((((()"
    },
    {
      "string": ")((())(((()(()()(())"
    },
    {
      "string": ")((((((()))(()))()(("
    },
    {
      "string": "()(()()(()(()))((())"
    },
    {
      "string": ")))((())()()))())(()"
    },
    {
      "string": "()())()((()()(((()))"
    },
    {
      "string": ")(()))))(()())))(()("
    },
    {
      "string": "))(()()((()))()))()("
    },
    {
      "string": ")()()))()(())))))))("
    },
    {
      "string": "(((())(())()())()()("
    },
    {
      "string": "()()(()()())((((()))"
    },
    {
      "string": "((()()((()(((()))())"
    },
    {
      "string": "))(())()())())))()))"
    },
    {
      "string": "(()(()()())())()((()"
    },
    {
      "string": "()()())))()()()())()"
    },
    {
      "string": "))((((()))()))()))))"
    },
    {
      "string": ")())(())((((((()((()"
    },
    {
      "string": ")((()())))((()((()))"
    },
    {
      "string": "())(())))(((()()((()"
    },
    {
      "string": ")()))((()))(((((((()"
    },
    {
      "string": ")((((((((()())((())("
    },
    {
      "string": ")(())))((()()()(((()"
    },
    {
      "string": ")()()))((((())))((()"
    },
    {
      "string": "(()(())(()((()))()()"
    },
    {
      "string": "(((()(((()()))((())("
    },
    {
      "string": ")()()())()))(())()()"
    },
    {
      "string": "((()))())(((()((())("
    },
    {
      "string": ")((((()()(()))))()))"
    },
    {
      "string": "((()(())))))((()))(("
    },
    {
      "string": "(()()))())()()(())(("
    },
    {
      "string": "(()))((())()()(((((("
    },
    {
      "string": "((()(()))(((((())((("
    },
    {
      "string": "())))))())(((())((()"
    },
    {
      "string": "(()(()"
    }
  ],
  "changelog": []
}