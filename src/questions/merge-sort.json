{
  "uid": "merge-sort",
  "testStrategy": "JSON",
  "name": "Merge Sort",
  "version": 0,
  "releaseDate": "2000-05-04T00:00:00Z",
  "category": "Sorting",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 15432,
    "failureCount": 4492
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "264852477",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 3271
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in an array of integers and returns a sorted\n  version of that array. Use the Merge Sort algorithm to sort the array.\n</p>\n<p>\n  If you're unfamiliar with Merge Sort, we recommend watching the Conceptual\n  Overview section of this question's video explanation before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">array</span> = [8, 5, 2, 9, 5, 6, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[2, 3, 5, 5, 6, 8, 9]\n</pre>\n</div>",
  "hints": [
    "<p>\nMerge Sort works by cutting an array in two halves, respectively sorting those two halves by performing some special logic, and then merging the two newly-sorted halves into one sorted array. The respective sorting of the two halves is done by reapplying the Merge Sort algorithm / logic on each half until single-element halves are obtained; these single-element arrays are sorted by nature and can very easily be merged back together.\n</p>\n",
    "\n<p>\nDivide the input array in two halves by finding the middle-most index in the array and slicing the two halves around that index. Then, recursively apply Merge Sort to each half, and finally merge them into one single, sorted array by iterating through their values and progressively adding them to the new array in ascending order.\n</p>\n",
    "\n<p>\nYour implementation of Merge Sort almost certainly uses a lot of auxiliary space and likely does not sort the input array in place. What is the space complexity of your algorithm? Can you implement a version of the algorithm using only one additional array of the same length as the input array, and can this version sort the input array in place?\n</p>"
  ],
  "spaceTime": "Best: O(nlog(n)) time | O(n) space - where n is the length of the input array\nAverage: O(nlog(n)) time | O(n) space - where n is the length of the input array\nWorst: O(nlog(n)) time | O(n) space - where n is the length of the input array",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nvector<int> mergeSort(vector<int> array) {\n  // Write your code here.\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nvector<int> mergeSortedArrays(vector<int> leftHalf, vector<int> rightHalf);\n\n// Best: O(nlog(n)) time | O(nlog(n)) space\n// Average: O(nlog(n)) time | O(nlog(n)) space\n// Worst: O(nlog(n)) time | O(nlog(n)) space\nvector<int> mergeSort(vector<int> array) {\n  if (array.size() <= 1) {\n    return array;\n  }\n  int middleIdx = array.size() / 2;\n  vector<int> leftHalf(array.begin(), array.begin() + middleIdx);\n  vector<int> rightHalf(array.begin() + middleIdx, array.end());\n  return mergeSortedArrays(mergeSort(leftHalf), mergeSort(rightHalf));\n}\n\nvector<int> mergeSortedArrays(vector<int> leftHalf, vector<int> rightHalf) {\n  vector<int> sortedArray(leftHalf.size() + rightHalf.size(), 0);\n  int k = 0;\n  int i = 0;\n  int j = 0;\n  while (i < leftHalf.size() && j < rightHalf.size()) {\n    if (leftHalf[i] <= rightHalf[j]) {\n      sortedArray[k++] = leftHalf[i++];\n    } else {\n      sortedArray[k++] = rightHalf[j++];\n    }\n  }\n  while (i < leftHalf.size()) {\n    sortedArray[k++] = leftHalf[i++];\n  }\n  while (j < rightHalf.size()) {\n    sortedArray[k++] = rightHalf[j++];\n  }\n  return sortedArray;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nvoid mergeSortHelper(\n  vector<int>* mainArray, int startIdx, int endIdx, vector<int>* auxiliaryArray\n);\nvoid doMerge(\n  vector<int>* mainArray,\n  int startIdx,\n  int middleIdx,\n  int endIdx,\n  vector<int>* auxiliaryArray\n);\n\n// Best: O(nlog(n)) time | O(n) space\n// Average: O(nlog(n)) time | O(n) space\n// Worst: O(nlog(n)) time | O(n) space\nvector<int> mergeSort(vector<int> array) {\n  if (array.size() <= 1) {\n    return array;\n  }\n  vector<int> auxiliaryArray = array;\n  mergeSortHelper(&array, 0, array.size() - 1, &auxiliaryArray);\n  return array;\n}\n\nvoid mergeSortHelper(\n  vector<int>* mainArray, int startIdx, int endIdx, vector<int>* auxiliaryArray\n) {\n  if (startIdx == endIdx) {\n    return;\n  }\n  int middleIdx = (startIdx + endIdx) / 2;\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray);\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray);\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray);\n}\n\nvoid doMerge(\n  vector<int>* mainArray,\n  int startIdx,\n  int middleIdx,\n  int endIdx,\n  vector<int>* auxiliaryArray\n) {\n  int k = startIdx;\n  int i = startIdx;\n  int j = middleIdx + 1;\n  while (i <= middleIdx && j <= endIdx) {\n    if (auxiliaryArray->at(i) <= auxiliaryArray->at(j)) {\n      mainArray->at(k++) = auxiliaryArray->at(i++);\n    } else {\n      mainArray->at(k++) = auxiliaryArray->at(j++);\n    }\n  }\n  while (i <= middleIdx) {\n    mainArray->at(k++) = auxiliaryArray->at(i++);\n  }\n  while (j <= endIdx) {\n    mainArray->at(k++) = auxiliaryArray->at(j++);\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<int> expected = {2, 3, 5, 5, 6, 8, 9};\n      assert(mergeSort({8, 5, 2, 9, 5, 6, 3}) == expected);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<int> expected = {2, 3, 5, 5, 6, 8, 9};\n      assert(mergeSort({8, 5, 2, 9, 5, 6, 3}) == expected);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public static int[] MergeSort(int[] array) {\n    // Write your code here.\n    return new int[] {};\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Linq;\n\npublic class Program {\n  // Best: O(nlog(n)) time | O(nlog(n)) space\n  // Average: O(nlog(n)) time | O(nlog(n)) space\n  // Worst: O(nlog(n)) time | O(nlog(n)) space\n  public static int[] MergeSort(int[] array) {\n    if (array.Length <= 1) {\n      return array;\n    }\n    int middleIdx = array.Length / 2;\n    int[] leftHalf = array.Take(middleIdx).ToArray();\n    int[] rightHalf = array.Skip(middleIdx).ToArray();\n    return mergeSortedArrays(MergeSort(leftHalf), MergeSort(rightHalf));\n  }\n\n  public static int[] mergeSortedArrays(int[] leftHalf, int[] rightHalf) {\n    int[] sortedArray = new int[leftHalf.Length + rightHalf.Length];\n    int k = 0;\n    int i = 0;\n    int j = 0;\n    while (i < leftHalf.Length && j < rightHalf.Length) {\n      if (leftHalf[i] <= rightHalf[j]) {\n        sortedArray[k++] = leftHalf[i++];\n      } else {\n        sortedArray[k++] = rightHalf[j++];\n      }\n    }\n    while (i < leftHalf.Length) {\n      sortedArray[k++] = leftHalf[i++];\n    }\n    while (j < rightHalf.Length) {\n      sortedArray[k++] = rightHalf[j++];\n    }\n    return sortedArray;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n\npublic class Program {\n  // Best: O(nlog(n)) time | O(n) space\n  // Average: O(nlog(n)) time | O(n) space\n  // Worst: O(nlog(n)) time | O(n) space\n  public static int[] MergeSort(int[] array) {\n    if (array.Length <= 1) {\n      return array;\n    }\n    int[] auxiliaryArray = (int[])array.Clone();\n    MergeSort(array, 0, array.Length - 1, auxiliaryArray);\n    return array;\n  }\n\n  public static void MergeSort(\n    int[] mainArray, int startIdx, int endIdx, int[] auxiliaryArray\n  ) {\n    if (startIdx == endIdx) {\n      return;\n    }\n    int middleIdx = (startIdx + endIdx) / 2;\n    MergeSort(auxiliaryArray, startIdx, middleIdx, mainArray);\n    MergeSort(auxiliaryArray, middleIdx + 1, endIdx, mainArray);\n    doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray);\n  }\n\n  public static void doMerge(\n    int[] mainArray,\n    int startIdx,\n    int middleIdx,\n    int endIdx,\n    int[] auxiliaryArray\n  ) {\n    int k = startIdx;\n    int i = startIdx;\n    int j = middleIdx + 1;\n    while (i <= middleIdx && j <= endIdx) {\n      if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n        mainArray[k++] = auxiliaryArray[i++];\n      } else {\n        mainArray[k++] = auxiliaryArray[j++];\n      }\n    }\n    while (i <= middleIdx) {\n      mainArray[k++] = auxiliaryArray[i++];\n    }\n    while (j <= endIdx) {\n      mainArray[k++] = auxiliaryArray[j++];\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[] expected = { 2, 3, 5, 5, 6, 8, 9 };\n    int[] input = { 8, 5, 2, 9, 5, 6, 3 };\n    Utils.AssertTrue(compare(Program.MergeSort(input), expected));\n  }\n\n  public bool compare(int[] arr1, int[] arr2) {\n    if (arr1.Length != arr2.Length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.Length; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
      "unitTests": "public class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[] expected = { 2, 3, 5, 5, 6, 8, 9 };\n    int[] input = { 8, 5, 2, 9, 5, 6, 3 };\n    Utils.AssertTrue(compare(Program.MergeSort(input), expected));\n  }\n\n  public bool compare(int[] arr1, int[] arr2) {\n    if (arr1.Length != arr2.Length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.Length; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc MergeSort(array []int) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// Best: O(nlog(n)) time | O(nlog(n)) space\n// Average: O(nlog(n)) time | O(nlog(n)) space\n// Worst: O(nlog(n)) time | O(nlog(n)) space\nfunc MergeSort(array []int) []int {\n\tif len(array) <= 1 {\n\t\treturn array\n\t}\n\tmiddleIndex := len(array) / 2\n\tleftHalf := MergeSort(array[:middleIndex])\n\trightHalf := MergeSort(array[middleIndex:])\n\treturn mergeSortedArrays(leftHalf, rightHalf)\n}\n\nfunc mergeSortedArrays(leftHalf, rightHalf []int) []int {\n\tsortedArray := make([]int, len(leftHalf)+len(rightHalf))\n\tk, i, j := 0, 0, 0\n\tfor i < len(leftHalf) && j < len(rightHalf) {\n\t\tif leftHalf[i] <= rightHalf[j] {\n\t\t\tsortedArray[k] = leftHalf[i]\n\t\t\ti++\n\t\t} else {\n\t\t\tsortedArray[k] = rightHalf[j]\n\t\t\tj++\n\t\t}\n\t\tk++\n\t}\n\tfor i < len(leftHalf) {\n\t\tsortedArray[k] = leftHalf[i]\n\t\ti++\n\t\tk++\n\t}\n\tfor j < len(rightHalf) {\n\t\tsortedArray[k] = rightHalf[j]\n\t\tj++\n\t\tk++\n\t}\n\treturn sortedArray\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// Best: O(nlog(n)) time | O(n) space\n// Average: O(nlog(n)) time | O(n) space\n// Worst: O(nlog(n)) time | O(n) space\nfunc MergeSort(array []int) []int {\n\tif len(array) <= 1 {\n\t\treturn array\n\t}\n\tauxiliaryArray := make([]int, len(array))\n\tcopy(auxiliaryArray, array)\n\tmergeSortHelper(array, 0, len(array)-1, auxiliaryArray)\n\treturn array\n}\n\nfunc mergeSortHelper(mainArray []int, startIdx, endIdx int, auxiliaryArray []int) {\n\tif startIdx == endIdx {\n\t\treturn\n\t}\n\tmiddleIdx := (startIdx + endIdx) / 2\n\tmergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray)\n\tmergeSortHelper(auxiliaryArray, middleIdx+1, endIdx, mainArray)\n\tdoMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray)\n}\n\nfunc doMerge(mainArray []int, startIdx, middleIdx, endIdx int, auxiliaryArray []int) {\n\tk := startIdx\n\ti := startIdx\n\tj := middleIdx + 1\n\tfor i <= middleIdx && j <= endIdx {\n\t\tif auxiliaryArray[i] <= auxiliaryArray[j] {\n\t\t\tmainArray[k] = auxiliaryArray[i]\n\t\t\ti++\n\t\t} else {\n\t\t\tmainArray[k] = auxiliaryArray[j]\n\t\t\tj++\n\t\t}\n\t\tk++\n\t}\n\tfor i <= middleIdx {\n\t\tmainArray[k] = auxiliaryArray[i]\n\t\ti++\n\t\tk++\n\t}\n\tfor j <= endIdx {\n\t\tmainArray[k] = auxiliaryArray[j]\n\t\tj++\n\t\tk++\n\t}\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{2, 3, 5, 5, 6, 8, 9}\n\toutput := MergeSort([]int{8, 5, 2, 9, 5, 6, 3})\n\trequire.Equal(t, expected, output)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{2, 3, 5, 5, 6, 8, 9}\n\toutput := MergeSort([]int{8, 5, 2, 9, 5, 6, 3})\n\trequire.Equal(t, expected, output)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static int[] mergeSort(int[] array) {\n    // Write your code here.\n    return new int[] {};\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.Arrays;\n\nclass Program {\n  // Best: O(nlog(n)) time | O(nlog(n)) space\n  // Average: O(nlog(n)) time | O(nlog(n)) space\n  // Worst: O(nlog(n)) time | O(nlog(n)) space\n  public static int[] mergeSort(int[] array) {\n    if (array.length <= 1) {\n      return array;\n    }\n    int middleIdx = array.length / 2;\n    int[] leftHalf = Arrays.copyOfRange(array, 0, middleIdx);\n    int[] rightHalf = Arrays.copyOfRange(array, middleIdx, array.length);\n    return mergeSortedArrays(mergeSort(leftHalf), mergeSort(rightHalf));\n  }\n\n  public static int[] mergeSortedArrays(int[] leftHalf, int[] rightHalf) {\n    int[] sortedArray = new int[leftHalf.length + rightHalf.length];\n    int k = 0;\n    int i = 0;\n    int j = 0;\n    while (i < leftHalf.length && j < rightHalf.length) {\n      if (leftHalf[i] <= rightHalf[j]) {\n        sortedArray[k++] = leftHalf[i++];\n      } else {\n        sortedArray[k++] = rightHalf[j++];\n      }\n    }\n    while (i < leftHalf.length) {\n      sortedArray[k++] = leftHalf[i++];\n    }\n    while (j < rightHalf.length) {\n      sortedArray[k++] = rightHalf[j++];\n    }\n    return sortedArray;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Best: O(nlog(n)) time | O(n) space\n  // Average: O(nlog(n)) time | O(n) space\n  // Worst: O(nlog(n)) time | O(n) space\n  public static int[] mergeSort(int[] array) {\n    if (array.length <= 1) {\n      return array;\n    }\n    int[] auxiliaryArray = array.clone();\n    mergeSort(array, 0, array.length - 1, auxiliaryArray);\n    return array;\n  }\n\n  public static void mergeSort(\n    int[] mainArray, int startIdx, int endIdx, int[] auxiliaryArray\n  ) {\n    if (startIdx == endIdx) {\n      return;\n    }\n    int middleIdx = (startIdx + endIdx) / 2;\n    mergeSort(auxiliaryArray, startIdx, middleIdx, mainArray);\n    mergeSort(auxiliaryArray, middleIdx + 1, endIdx, mainArray);\n    doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray);\n  }\n\n  public static void doMerge(\n    int[] mainArray,\n    int startIdx,\n    int middleIdx,\n    int endIdx,\n    int[] auxiliaryArray\n  ) {\n    int k = startIdx;\n    int i = startIdx;\n    int j = middleIdx + 1;\n    while (i <= middleIdx && j <= endIdx) {\n      if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n        mainArray[k++] = auxiliaryArray[i++];\n      } else {\n        mainArray[k++] = auxiliaryArray[j++];\n      }\n    }\n    while (i <= middleIdx) {\n      mainArray[k++] = auxiliaryArray[i++];\n    }\n    while (j <= endIdx) {\n      mainArray[k++] = auxiliaryArray[j++];\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] expected = {2, 3, 5, 5, 6, 8, 9};\n    int[] input = {8, 5, 2, 9, 5, 6, 3};\n    Utils.assertTrue(compare(Program.mergeSort(input), expected));\n  }\n\n  public boolean compare(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.length; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
      "unitTests": "class ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] expected = {2, 3, 5, 5, 6, 8, 9};\n    int[] input = {8, 5, 2, 9, 5, 6, 3};\n    Utils.assertTrue(compare(Program.mergeSort(input), expected));\n  }\n\n  public boolean compare(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.length; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function mergeSort(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.mergeSort = mergeSort;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// Best: O(nlog(n)) time | O(nlog(n)) space\n// Average: O(nlog(n)) time | O(nlog(n)) space\n// Worst: O(nlog(n)) time | O(nlog(n)) space\nfunction mergeSort(array) {\n  if (array.length <= 1) return array;\n  const middleIdx = Math.floor(array.length / 2);\n  const leftHalf = array.slice(0, middleIdx);\n  const rightHalf = array.slice(middleIdx);\n  return mergeSortedArrays(mergeSort(leftHalf), mergeSort(rightHalf));\n}\n\nfunction mergeSortedArrays(leftHalf, rightHalf) {\n  const sortedArray = new Array(leftHalf.length + rightHalf.length);\n  let k = 0;\n  let i = 0;\n  let j = 0;\n  while (i < leftHalf.length && j < rightHalf.length) {\n    if (leftHalf[i] <= rightHalf[j]) {\n      sortedArray[k++] = leftHalf[i++];\n    } else {\n      sortedArray[k++] = rightHalf[j++];\n    }\n  }\n  while (i < leftHalf.length) {\n    sortedArray[k++] = leftHalf[i++];\n  }\n  while (j < rightHalf.length) {\n    sortedArray[k++] = rightHalf[j++];\n  }\n  return sortedArray;\n}\n\nexports.mergeSort = mergeSort;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// Best: O(nlog(n)) time | O(n) space\n// Average: O(nlog(n)) time | O(n) space\n// Worst: O(nlog(n)) time | O(n) space\nfunction mergeSort(array) {\n  if (array.length <= 1) return array;\n  const auxiliaryArray = array.slice();\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray);\n  return array;\n}\n\nfunction mergeSortHelper(mainArray, startIdx, endIdx, auxiliaryArray) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray);\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray);\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray);\n}\n\nfunction doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n  while (i <= middleIdx && j <= endIdx) {\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n      mainArray[k++] = auxiliaryArray[i++];\n    } else {\n      mainArray[k++] = auxiliaryArray[j++];\n    }\n  }\n  while (i <= middleIdx) {\n    mainArray[k++] = auxiliaryArray[i++];\n  }\n  while (j <= endIdx) {\n    mainArray[k++] = auxiliaryArray[j++];\n  }\n}\n\nexports.mergeSort = mergeSort;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.mergeSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.mergeSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun mergeSort(array: MutableList<Int>): List<Int> {\n    // Write your code here.\n    return array\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// Best: O(nlog(n)) time | O(nlog(n)) space\n// Average: O(nlog(n)) time | O(nlog(n)) space\n// Worst: O(nlog(n)) time | O(nlog(n)) space\nfun mergeSort(array: MutableList<Int>): List<Int> {\n    if (array.size <= 1) return array\n    val middleIdx = array.size / 2\n    val leftHalf = array.subList(0, middleIdx).toMutableList()\n    val rightHalf = array.subList(middleIdx, array.size).toMutableList()\n    return mergeSortedArrays(mergeSort(leftHalf), mergeSort(rightHalf))\n}\n\nfun mergeSortedArrays(leftHalf: List<Int>, rightHalf: List<Int>): List<Int> {\n    val sortedArray = MutableList<Int>(leftHalf.size + rightHalf.size) { 0 }\n    var k = 0\n    var i = 0\n    var j = 0\n    while (i < leftHalf.size && j < rightHalf.size) {\n        if (leftHalf[i] <= rightHalf[j]) {\n            sortedArray[k++] = leftHalf[i++]\n        } else {\n            sortedArray[k++] = rightHalf[j++]\n        }\n    }\n    while (i < leftHalf.size) {\n        sortedArray[k++] = leftHalf[i++]\n    }\n    while (j < rightHalf.size) {\n        sortedArray[k++] = rightHalf[j++]\n    }\n    return sortedArray\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// Best: O(nlog(n)) time | O(n) space\n// Average: O(nlog(n)) time | O(n) space\n// Worst: O(nlog(n)) time | O(n) space\nfun mergeSort(array: MutableList<Int>): List<Int> {\n    if (array.size <= 1) return array\n    val auxiliaryArray = array.toMutableList()\n    mergeSortHelper(array, 0, array.size - 1, auxiliaryArray)\n    return array\n}\n\nfun mergeSortHelper(mainArray: MutableList<Int>, startIdx: Int, endIdx: Int, auxiliaryArray: MutableList<Int>) {\n    if (startIdx == endIdx) return\n    val middleIdx = (startIdx + endIdx) / 2\n    mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray)\n    mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray)\n    doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray)\n}\n\nfun doMerge(mainArray: MutableList<Int>, startIdx: Int, middleIdx: Int, endIdx: Int, auxiliaryArray: List<Int>) {\n    var k = startIdx\n    var i = startIdx\n    var j = middleIdx + 1\n    while (i <= middleIdx && j <= endIdx) {\n        if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n            mainArray[k++] = auxiliaryArray[i++]\n        } else {\n            mainArray[k++] = auxiliaryArray[j++]\n        }\n    }\n    while (i <= middleIdx) {\n        mainArray[k++] = auxiliaryArray[i++]\n    }\n    while (j <= endIdx) {\n        mainArray[k++] = auxiliaryArray[j++]\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.mergeSort as mergeSort\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val expected = mutableListOf(2, 3, 5, 5, 6, 8, 9)\n        val input = mutableListOf(8, 5, 2, 9, 5, 6, 3)\n        assert(mergeSort(input) == expected)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.mergeSort as mergeSort\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val expected = mutableListOf(2, 3, 5, 5, 6, 8, 9)\n        val input = mutableListOf(8, 5, 2, 9, 5, 6, 3)\n        assert(mergeSort(input) == expected)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def mergeSort(array):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# Best: O(nlog(n)) time | O(nlog(n)) space\n# Average: O(nlog(n)) time | O(nlog(n)) space\n# Worst: O(nlog(n)) time | O(nlog(n)) space\ndef mergeSort(array):\n    if len(array) == 1:\n        return array\n    middleIdx = len(array) // 2\n    leftHalf = array[:middleIdx]\n    rightHalf = array[middleIdx:]\n    return mergeSortedArrays(mergeSort(leftHalf), mergeSort(rightHalf))\n\n\ndef mergeSortedArrays(leftHalf, rightHalf):\n    sortedArray = [None] * (len(leftHalf) + len(rightHalf))\n    k = i = j = 0\n    while i < len(leftHalf) and j < len(rightHalf):\n        if leftHalf[i] <= rightHalf[j]:\n            sortedArray[k] = leftHalf[i]\n            i += 1\n        else:\n            sortedArray[k] = rightHalf[j]\n            j += 1\n        k += 1\n    while i < len(leftHalf):\n        sortedArray[k] = leftHalf[i]\n        i += 1\n        k += 1\n    while j < len(rightHalf):\n        sortedArray[k] = rightHalf[j]\n        j += 1\n        k += 1\n    return sortedArray\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# Best: O(nlog(n)) time | O(n) space\n# Average: O(nlog(n)) time | O(n) space\n# Worst: O(nlog(n)) time | O(n) space\ndef mergeSort(array):\n    if len(array) <= 1:\n        return array\n    auxiliaryArray = array[:]\n    mergeSortHelper(array, 0, len(array) - 1, auxiliaryArray)\n    return array\n\n\ndef mergeSortHelper(mainArray, startIdx, endIdx, auxiliaryArray):\n    if startIdx == endIdx:\n        return\n    middleIdx = (startIdx + endIdx) // 2\n    mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray)\n    mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray)\n    doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray)\n\n\ndef doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray):\n    k = startIdx\n    i = startIdx\n    j = middleIdx + 1\n    while i <= middleIdx and j <= endIdx:\n        if auxiliaryArray[i] <= auxiliaryArray[j]:\n            mainArray[k] = auxiliaryArray[i]\n            i += 1\n        else:\n            mainArray[k] = auxiliaryArray[j]\n            j += 1\n        k += 1\n    while i <= middleIdx:\n        mainArray[k] = auxiliaryArray[i]\n        i += 1\n        k += 1\n    while j <= endIdx:\n        mainArray[k] = auxiliaryArray[j]\n        j += 1\n        k += 1\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.mergeSort([8, 5, 2, 9, 5, 6, 3]), [2, 3, 5, 5, 6, 8, 9])\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.mergeSort([8, 5, 2, 9, 5, 6, 3]), [2, 3, 5, 5, 6, 8, 9])\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def mergeSort(array)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def mergeSort(array)\n    # Write your code here.\n    return []\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def mergeSort(array)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.mergeSort\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.mergeSort\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func mergeSort(_ array: inout [Int]) -> [Int] {\n    // Write your code here.\n    return []\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Best: O(nlog(n)) time | O(nlog(n)) space\n  // Average: O(nlog(n)) time | O(nlog(n)) space\n  // Worst: O(nlog(n)) time | O(nlog(n)) space\n  func mergeSort(_ array: inout [Int]) -> [Int] {\n    if array.count <= 1 {\n      return array\n    }\n\n    let middleIndex = Int(Double(array.count / 2).rounded(.down))\n    var leftHalf = Array(array[0 ..< middleIndex])\n    var rightHalf = Array(array[middleIndex ..< array.count])\n\n    return mergeSortedArrays(mergeSort(&leftHalf), mergeSort(&rightHalf))\n  }\n\n  func mergeSortedArrays(_ leftHalf: [Int], _ rightHalf: [Int]) -> [Int] {\n    var sortedArray = Array(repeating: 0, count: leftHalf.count + rightHalf.count)\n\n    var k = 0, i = 0, j = 0\n\n    while i < leftHalf.count, j < rightHalf.count {\n      if leftHalf[i] <= rightHalf[j] {\n        sortedArray[k] = leftHalf[i]\n        i += 1\n      } else {\n        sortedArray[k] = rightHalf[j]\n        j += 1\n      }\n\n      k += 1\n    }\n\n    while i < leftHalf.count {\n      sortedArray[k] = leftHalf[i]\n      i += 1\n      k += 1\n    }\n\n    while j < rightHalf.count {\n      sortedArray[k] = rightHalf[j]\n      j += 1\n      k += 1\n    }\n\n    return sortedArray\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Best: O(nlog(n) time | O(n) space\n  // Average: O(nlog(n) time | O(n) space\n  // Worst: O(nlog(n) time | O(n) space\n  func mergeSort(_ array: inout [Int]) -> [Int] {\n    if array.count <= 1 {\n      return array\n    }\n\n    var auxiliaryArray = array\n    mergeSortHelper(0, array.count - 1, &array, &auxiliaryArray)\n\n    return array\n  }\n\n  func mergeSortHelper(_ startIndex: Int, _ endIndex: Int, _ firstArray: inout [Int], _ secondArray: inout [Int]) {\n    if startIndex == endIndex {\n      return\n    }\n\n    let middleIndex = Int(Double((startIndex + endIndex) / 2).rounded(.down))\n\n    mergeSortHelper(startIndex, middleIndex, &secondArray, &firstArray)\n    mergeSortHelper(middleIndex + 1, endIndex, &secondArray, &firstArray)\n    doMerge(startIndex, middleIndex, endIndex, &firstArray, &secondArray)\n  }\n\n  func doMerge(_ startIndex: Int, _ middleIndex: Int, _ endIndex: Int, _ firstArray: inout [Int], _ secondArray: inout [Int]) {\n    var k = startIndex, i = startIndex, j = middleIndex + 1\n\n    while i <= middleIndex, j <= endIndex {\n      if secondArray[i] <= secondArray[j] {\n        firstArray[k] = secondArray[i]\n        i += 1\n      } else {\n        firstArray[k] = secondArray[j]\n        j += 1\n      }\n\n      k += 1\n    }\n\n    while i <= middleIndex {\n      firstArray[k] = secondArray[i]\n      i += 1\n      k += 1\n    }\n\n    while j <= endIndex {\n      firstArray[k] = secondArray[j]\n      j += 1\n      k += 1\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var arrayToSort = [8, 5, 2, 9, 5, 6, 3]\n      try assertEqual([2, 3, 5, 5, 6, 8, 9], program.mergeSort(&arrayToSort))\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var arrayToSort = [8, 5, 2, 9, 5, 6, 3]\n      try assertEqual([2, 3, 5, 5, 6, 8, 9], program.mergeSort(&arrayToSort))\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function mergeSort(array: number[]) {\n  // Write your code here.\n  return array;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// Best: O(nlog(n)) time | O(nlog(n)) space\n// Average: O(nlog(n)) time | O(nlog(n)) space\n// Worst: O(nlog(n)) time | O(nlog(n)) space\nexport function mergeSort(array: number[]): number[] {\n  if (array.length <= 1) return array;\n  const middleIdx = Math.floor(array.length / 2);\n  const leftHalf = array.slice(0, middleIdx);\n  const rightHalf = array.slice(middleIdx);\n  return mergeSortedArrays(mergeSort(leftHalf), mergeSort(rightHalf));\n}\n\nfunction mergeSortedArrays(leftHalf: number[], rightHalf: number[]) {\n  const sortedArray: number[] = new Array(leftHalf.length + rightHalf.length);\n  let k = 0;\n  let i = 0;\n  let j = 0;\n  while (i < leftHalf.length && j < rightHalf.length) {\n    if (leftHalf[i] <= rightHalf[j]) {\n      sortedArray[k++] = leftHalf[i++];\n    } else {\n      sortedArray[k++] = rightHalf[j++];\n    }\n  }\n  while (i < leftHalf.length) {\n    sortedArray[k++] = leftHalf[i++];\n  }\n  while (j < rightHalf.length) {\n    sortedArray[k++] = rightHalf[j++];\n  }\n  return sortedArray;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// Best: O(nlog(n)) time | O(n) space\n// Average: O(nlog(n)) time | O(n) space\n// Worst: O(nlog(n)) time | O(n) space\nexport function mergeSort(array: number[]) {\n  if (array.length <= 1) return array;\n  const auxiliaryArray = array.slice();\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray);\n  return array;\n}\n\nfunction mergeSortHelper(\n  mainArray: number[],\n  startIdx: number,\n  endIdx: number,\n  auxiliaryArray: number[],\n) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray);\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray);\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray);\n}\n\nfunction doMerge(\n  mainArray: number[],\n  startIdx: number,\n  middleIdx: number,\n  endIdx: number,\n  auxiliaryArray: number[],\n) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n  while (i <= middleIdx && j <= endIdx) {\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n      mainArray[k++] = auxiliaryArray[i++];\n    } else {\n      mainArray[k++] = auxiliaryArray[j++];\n    }\n  }\n  while (i <= middleIdx) {\n    mainArray[k++] = auxiliaryArray[i++];\n  }\n  while (j <= endIdx) {\n    mainArray[k++] = auxiliaryArray[j++];\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.mergeSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.mergeSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "array",
      "example": [
        8,
        5,
        2,
        9,
        5,
        6,
        3
      ],
      "schema": {
        "items": {
          "type": "integer"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "array": [
        8,
        5,
        2,
        9,
        5,
        6,
        3
      ]
    },
    {
      "array": [
        1
      ]
    },
    {
      "array": [
        1,
        2
      ]
    },
    {
      "array": [
        2,
        1
      ]
    },
    {
      "array": [
        1,
        3,
        2
      ]
    },
    {
      "array": [
        3,
        1,
        2
      ]
    },
    {
      "array": [
        1,
        2,
        3
      ]
    },
    {
      "array": [
        -4,
        5,
        10,
        8,
        -10,
        -6,
        -4,
        -2,
        -5,
        3,
        5,
        -4,
        -5,
        -1,
        1,
        6,
        -7,
        -6,
        -7,
        8
      ]
    },
    {
      "array": [
        -7,
        2,
        3,
        8,
        -10,
        4,
        -6,
        -10,
        -2,
        -7,
        10,
        5,
        2,
        9,
        -9,
        -5,
        3,
        8
      ]
    },
    {
      "array": [
        8,
        -6,
        7,
        10,
        8,
        -1,
        6,
        2,
        4,
        -5,
        1,
        10,
        8,
        -10,
        -9,
        -10,
        8,
        9,
        -2,
        7,
        -2,
        4
      ]
    },
    {
      "array": [
        5,
        -2,
        2,
        -8,
        3,
        -10,
        -6,
        -1,
        2,
        -2,
        9,
        1,
        1
      ]
    },
    {
      "array": [
        2,
        -2,
        -6,
        -10,
        10,
        4,
        -8,
        -1,
        -8,
        -4,
        7,
        -4,
        0,
        9,
        -9,
        0,
        -9,
        -9,
        8,
        1,
        -4,
        4,
        8,
        5,
        1,
        5,
        0,
        0,
        2,
        -10
      ]
    },
    {
      "array": [
        4,
        1,
        5,
        0,
        -9,
        -3,
        -3,
        9,
        3,
        -4,
        -9,
        8,
        1,
        -3,
        -7,
        -4,
        -9,
        -1,
        -7,
        -2,
        -7,
        4
      ]
    },
    {
      "array": [
        427,
        787,
        222,
        996,
        -359,
        -614,
        246,
        230,
        107,
        -706,
        568,
        9,
        -246,
        12,
        -764,
        -212,
        -484,
        603,
        934,
        -848,
        -646,
        -991,
        661,
        -32,
        -348,
        -474,
        -439,
        -56,
        507,
        736,
        635,
        -171,
        -215,
        564,
        -710,
        710,
        565,
        892,
        970,
        -755,
        55,
        821,
        -3,
        -153,
        240,
        -160,
        -610,
        -583,
        -27,
        131
      ]
    },
    {
      "array": [
        991,
        -731,
        -882,
        100,
        280,
        -43,
        432,
        771,
        -581,
        180,
        -382,
        -998,
        847,
        80,
        -220,
        680,
        769,
        -75,
        -817,
        366,
        956,
        749,
        471,
        228,
        -435,
        -269,
        652,
        -331,
        -387,
        -657,
        -255,
        382,
        -216,
        -6,
        -163,
        -681,
        980,
        913,
        -169,
        972,
        -523,
        354,
        747,
        805,
        382,
        -827,
        -796,
        372,
        753,
        519,
        906
      ]
    },
    {
      "array": [
        384,
        -67,
        120,
        759,
        697,
        232,
        -7,
        -557,
        -772,
        -987,
        687,
        397,
        -763,
        -86,
        -491,
        947,
        921,
        421,
        825,
        -679,
        946,
        -562,
        -626,
        -898,
        204,
        776,
        -343,
        393,
        51,
        -796,
        -425,
        31,
        165,
        975,
        -720,
        878,
        -785,
        -367,
        -609,
        662,
        -79,
        -112,
        -313,
        -94,
        187,
        260,
        43,
        85,
        -746,
        612,
        67,
        -389,
        508,
        777,
        624,
        993,
        -581,
        34,
        444,
        -544,
        243,
        -995,
        432,
        -755,
        -978,
        515,
        -68,
        -559,
        489,
        732,
        -19,
        -489,
        737,
        924
      ]
    },
    {
      "array": [
        544,
        -578,
        556,
        713,
        -655,
        -359,
        -810,
        -731,
        194,
        -531,
        -685,
        689,
        -279,
        -738,
        886,
        -54,
        -320,
        -500,
        738,
        445,
        -401,
        993,
        -753,
        329,
        -396,
        -924,
        -975,
        376,
        748,
        -356,
        972,
        459,
        399,
        669,
        -488,
        568,
        -702,
        551,
        763,
        -90,
        -249,
        -45,
        452,
        -917,
        394,
        195,
        -877,
        153,
        153,
        788,
        844,
        867,
        266,
        -739,
        904,
        -154,
        -947,
        464,
        343,
        -312,
        150,
        -656,
        528,
        61,
        94,
        -581
      ]
    },
    {
      "array": [
        -19,
        759,
        168,
        306,
        270,
        -602,
        558,
        -821,
        -599,
        328,
        753,
        -50,
        -568,
        268,
        -92,
        381,
        -96,
        730,
        629,
        678,
        -837,
        351,
        896,
        63,
        -85,
        437,
        -453,
        -991,
        294,
        -384,
        -628,
        -529,
        518,
        613,
        -319,
        -519,
        -220,
        -67,
        834,
        619,
        802,
        207,
        946,
        -904,
        295,
        718,
        -740,
        -557,
        -560,
        80,
        296,
        -90,
        401,
        407,
        798,
        254,
        154,
        387,
        434,
        491,
        228,
        307,
        268,
        505,
        -415,
        -976,
        676,
        -917,
        937,
        -609,
        593,
        -36,
        881,
        607,
        121,
        -373,
        915,
        -885,
        879,
        391,
        -158,
        588,
        -641,
        -937,
        986,
        949,
        -321
      ]
    },
    {
      "array": [
        -823,
        164,
        48,
        -987,
        323,
        399,
        -293,
        183,
        -908,
        -376,
        14,
        980,
        965,
        842,
        422,
        829,
        59,
        724,
        -415,
        -733,
        356,
        -855,
        -155,
        52,
        328,
        -544,
        -371,
        -160,
        -942,
        -51,
        700,
        -363,
        -353,
        -359,
        238,
        892,
        -730,
        -575,
        892,
        490,
        490,
        995,
        572,
        888,
        -935,
        919,
        -191,
        646,
        -120,
        125,
        -817,
        341,
        -575,
        372,
        -874,
        243,
        610,
        -36,
        -685,
        -337,
        -13,
        295,
        800,
        -950,
        -949,
        -257,
        631,
        -542,
        201,
        -796,
        157,
        950,
        540,
        -846,
        -265,
        746,
        355,
        -578,
        -441,
        -254,
        -941,
        -738,
        -469,
        -167,
        -420,
        -126,
        -410,
        59
      ]
    }
  ],
  "jsonTests": [
    {
      "array": [
        8,
        5,
        2,
        9,
        5,
        6,
        3
      ]
    },
    {
      "array": [
        1
      ]
    },
    {
      "array": [
        1,
        2
      ]
    },
    {
      "array": [
        2,
        1
      ]
    },
    {
      "array": [
        1,
        3,
        2
      ]
    },
    {
      "array": [
        3,
        1,
        2
      ]
    },
    {
      "array": [
        1,
        2,
        3
      ]
    },
    {
      "array": [
        -4,
        5,
        10,
        8,
        -10,
        -6,
        -4,
        -2,
        -5,
        3,
        5,
        -4,
        -5,
        -1,
        1,
        6,
        -7,
        -6,
        -7,
        8
      ]
    },
    {
      "array": [
        -7,
        2,
        3,
        8,
        -10,
        4,
        -6,
        -10,
        -2,
        -7,
        10,
        5,
        2,
        9,
        -9,
        -5,
        3,
        8
      ]
    },
    {
      "array": [
        8,
        -6,
        7,
        10,
        8,
        -1,
        6,
        2,
        4,
        -5,
        1,
        10,
        8,
        -10,
        -9,
        -10,
        8,
        9,
        -2,
        7,
        -2,
        4
      ]
    },
    {
      "array": [
        5,
        -2,
        2,
        -8,
        3,
        -10,
        -6,
        -1,
        2,
        -2,
        9,
        1,
        1
      ]
    },
    {
      "array": [
        2,
        -2,
        -6,
        -10,
        10,
        4,
        -8,
        -1,
        -8,
        -4,
        7,
        -4,
        0,
        9,
        -9,
        0,
        -9,
        -9,
        8,
        1,
        -4,
        4,
        8,
        5,
        1,
        5,
        0,
        0,
        2,
        -10
      ]
    },
    {
      "array": [
        4,
        1,
        5,
        0,
        -9,
        -3,
        -3,
        9,
        3,
        -4,
        -9,
        8,
        1,
        -3,
        -7,
        -4,
        -9,
        -1,
        -7,
        -2,
        -7,
        4
      ]
    },
    {
      "array": [
        427,
        787,
        222,
        996,
        -359,
        -614,
        246,
        230,
        107,
        -706,
        568,
        9,
        -246,
        12,
        -764,
        -212,
        -484,
        603,
        934,
        -848,
        -646,
        -991,
        661,
        -32,
        -348,
        -474,
        -439,
        -56,
        507,
        736,
        635,
        -171,
        -215,
        564,
        -710,
        710,
        565,
        892,
        970,
        -755,
        55,
        821,
        -3,
        -153,
        240,
        -160,
        -610,
        -583,
        -27,
        131
      ]
    },
    {
      "array": [
        991,
        -731,
        -882,
        100,
        280,
        -43,
        432,
        771,
        -581,
        180,
        -382,
        -998,
        847,
        80,
        -220,
        680,
        769,
        -75,
        -817,
        366,
        956,
        749,
        471,
        228,
        -435,
        -269,
        652,
        -331,
        -387,
        -657,
        -255,
        382,
        -216,
        -6,
        -163,
        -681,
        980,
        913,
        -169,
        972,
        -523,
        354,
        747,
        805,
        382,
        -827,
        -796,
        372,
        753,
        519,
        906
      ]
    },
    {
      "array": [
        384,
        -67,
        120,
        759,
        697,
        232,
        -7,
        -557,
        -772,
        -987,
        687,
        397,
        -763,
        -86,
        -491,
        947,
        921,
        421,
        825,
        -679,
        946,
        -562,
        -626,
        -898,
        204,
        776,
        -343,
        393,
        51,
        -796,
        -425,
        31,
        165,
        975,
        -720,
        878,
        -785,
        -367,
        -609,
        662,
        -79,
        -112,
        -313,
        -94,
        187,
        260,
        43,
        85,
        -746,
        612,
        67,
        -389,
        508,
        777,
        624,
        993,
        -581,
        34,
        444,
        -544,
        243,
        -995,
        432,
        -755,
        -978,
        515,
        -68,
        -559,
        489,
        732,
        -19,
        -489,
        737,
        924
      ]
    },
    {
      "array": [
        544,
        -578,
        556,
        713,
        -655,
        -359,
        -810,
        -731,
        194,
        -531,
        -685,
        689,
        -279,
        -738,
        886,
        -54,
        -320,
        -500,
        738,
        445,
        -401,
        993,
        -753,
        329,
        -396,
        -924,
        -975,
        376,
        748,
        -356,
        972,
        459,
        399,
        669,
        -488,
        568,
        -702,
        551,
        763,
        -90,
        -249,
        -45,
        452,
        -917,
        394,
        195,
        -877,
        153,
        153,
        788,
        844,
        867,
        266,
        -739,
        904,
        -154,
        -947,
        464,
        343,
        -312,
        150,
        -656,
        528,
        61,
        94,
        -581
      ]
    },
    {
      "array": [
        -19,
        759,
        168,
        306,
        270,
        -602,
        558,
        -821,
        -599,
        328,
        753,
        -50,
        -568,
        268,
        -92,
        381,
        -96,
        730,
        629,
        678,
        -837,
        351,
        896,
        63,
        -85,
        437,
        -453,
        -991,
        294,
        -384,
        -628,
        -529,
        518,
        613,
        -319,
        -519,
        -220,
        -67,
        834,
        619,
        802,
        207,
        946,
        -904,
        295,
        718,
        -740,
        -557,
        -560,
        80,
        296,
        -90,
        401,
        407,
        798,
        254,
        154,
        387,
        434,
        491,
        228,
        307,
        268,
        505,
        -415,
        -976,
        676,
        -917,
        937,
        -609,
        593,
        -36,
        881,
        607,
        121,
        -373,
        915,
        -885,
        879,
        391,
        -158,
        588,
        -641,
        -937,
        986,
        949,
        -321
      ]
    },
    {
      "array": [
        -823,
        164,
        48,
        -987,
        323,
        399,
        -293,
        183,
        -908,
        -376,
        14,
        980,
        965,
        842,
        422,
        829,
        59,
        724,
        -415,
        -733,
        356,
        -855,
        -155,
        52,
        328,
        -544,
        -371,
        -160,
        -942,
        -51,
        700,
        -363,
        -353,
        -359,
        238,
        892,
        -730,
        -575,
        892,
        490,
        490,
        995,
        572,
        888,
        -935,
        919,
        -191,
        646,
        -120,
        125,
        -817,
        341,
        -575,
        372,
        -874,
        243,
        610,
        -36,
        -685,
        -337,
        -13,
        295,
        800,
        -950,
        -949,
        -257,
        631,
        -542,
        201,
        -796,
        157,
        950,
        540,
        -846,
        -265,
        746,
        355,
        -578,
        -441,
        -254,
        -941,
        -738,
        -469,
        -167,
        -420,
        -126,
        -410,
        59
      ]
    }
  ],
  "changelog": []
}