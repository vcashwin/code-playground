{
  "uid": "min-max-stack-construction",
  "testStrategy": "JSON",
  "name": "Min Max Stack Construction",
  "version": 0,
  "releaseDate": "2018-10-20T00:00:00Z",
  "category": "Stacks",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 24527,
    "failureCount": 7286
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "291687370",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1060
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a <span>MinMaxStack</span> class for a Min Max Stack. The class should\n  support:\n</p>\n<ul>\n  <li>Pushing and popping values on and off the stack.</li>\n  <li>Peeking at the value at the top of the stack.</li>\n  <li>\n    Getting both the minimum and the maximum values in the stack at any given\n    point in time.\n  </li>\n</ul>\n<p>\n  All class methods, when considered independently, should run in constant time\n  and with constant space.\n</p>\n<h3>Sample Usage</h3>\n<pre>\n<span class=\"CodeEditor-promptComment\">// All operations below are performed sequentially.</span>\n<span class=\"CodeEditor-promptParameter\">MinMaxStack</span>(): - <span class=\"CodeEditor-promptComment\">// instantiate a MinMaxStack</span>\n<span class=\"CodeEditor-promptParameter\">push</span>(5): -\n<span class=\"CodeEditor-promptParameter\">getMin</span>(): 5\n<span class=\"CodeEditor-promptParameter\">getMax</span>(): 5\n<span class=\"CodeEditor-promptParameter\">peek</span>(): 5\n<span class=\"CodeEditor-promptParameter\">push</span>(7): -\n<span class=\"CodeEditor-promptParameter\">getMin</span>(): 5\n<span class=\"CodeEditor-promptParameter\">getMax</span>(): 7\n<span class=\"CodeEditor-promptParameter\">peek</span>(): 7\n<span class=\"CodeEditor-promptParameter\">push</span>(2): -\n<span class=\"CodeEditor-promptParameter\">getMin</span>(): 2\n<span class=\"CodeEditor-promptParameter\">getMax</span>(): 7\n<span class=\"CodeEditor-promptParameter\">peek</span>(): 2\n<span class=\"CodeEditor-promptParameter\">pop</span>(): 2\n<span class=\"CodeEditor-promptParameter\">pop</span>(): 7\n<span class=\"CodeEditor-promptParameter\">getMin</span>(): 5\n<span class=\"CodeEditor-promptParameter\">getMax</span>(): 5\n<span class=\"CodeEditor-promptParameter\">peek</span>(): 5\n</pre>\n</div>",
  "hints": [
    "<p>\nYou should be able to push values on, pop values off, and peek at values on top of the stack at any time and in constant time, using constant space. What data structure maintains order and would allow you to do this?\n</p>\n",
    "\n<p>\nYou should be able to get the minimum and maximum values in the stack at any time and in constant time, using constant space. What data structure would allow you to do this?\n</p>\n",
    "\n<p>\nSince the minimum and maximum values in the stack can change with every push and pop, you will likely need to keep track of all the mins and maxes at every value in the stack.\n</p>"
  ],
  "spaceTime": "All methods: O(1) time | O(1) space",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// Feel free to add new properties and methods to the class.\nclass MinMaxStack {\n public:\n  int peek() {\n    // Write your code here.\n    return -1;\n  }\n\n  int pop() {\n    // Write your code here.\n    return -1;\n  }\n\n  void push(int number) {\n    // Write your code here.\n  }\n\n  int getMin() {\n    // Write your code here.\n    return -1;\n  }\n\n  int getMax() {\n    // Write your code here.\n    return -1;\n  }\n};\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nclass MinMaxStack {\n public:\n  vector<unordered_map<string, int>> minMaxStack = {};\n  vector<int> stack = {};\n\n  // O(1) time | O(1) space\n  int peek() { return stack[stack.size() - 1]; }\n\n  // O(1) time | O(1) space\n  int pop() {\n    minMaxStack.pop_back();\n    int result = stack[stack.size() - 1];\n    stack.pop_back();\n    return result;\n  }\n\n  // O(1) time | O(1) space\n  void push(int number) {\n    unordered_map<string, int> newMinMax = {{\"min\", number}, {\"max\", number}};\n    if (minMaxStack.size()) {\n      unordered_map<string, int> lastMinMax =\n        minMaxStack[minMaxStack.size() - 1];\n      newMinMax[\"min\"] = min(lastMinMax[\"min\"], number);\n      newMinMax[\"max\"] = max(lastMinMax[\"max\"], number);\n    }\n    minMaxStack.push_back(newMinMax);\n    stack.push_back(number);\n  }\n\n  // O(1) time | O(1) space\n  int getMin() { return minMaxStack[minMaxStack.size() - 1][\"min\"]; }\n\n  // O(1) time | O(1) space\n  int getMax() { return minMaxStack[minMaxStack.size() - 1][\"max\"]; }\n};\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#define testMinMaxPeek(min, max, peekValue, stack) \\\n  {                                                \\\n    assert(stack.getMin() == min);                 \\\n    assert(stack.getMax() == max);                 \\\n    assert(stack.peek() == peekValue);             \\\n  }\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      MinMaxStack stack;\n      stack.push(5);\n      testMinMaxPeek(5, 5, 5, stack);\n      stack.push(7);\n      testMinMaxPeek(5, 7, 7, stack);\n      stack.push(2);\n      testMinMaxPeek(2, 7, 2, stack);\n      assert(stack.pop() == 2);\n      assert(stack.pop() == 7);\n      testMinMaxPeek(5, 5, 5, stack);\n    });\n  }\n};\n",
      "unitTests": "#define testMinMaxPeek(min, max, peekValue, stack) \\\n  {                                                \\\n    assert(stack.getMin() == min);                 \\\n    assert(stack.getMax() == max);                 \\\n    assert(stack.peek() == peekValue);             \\\n  }\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      MinMaxStack stack;\n      stack.push(5);\n      testMinMaxPeek(5, 5, 5, stack);\n      stack.push(7);\n      testMinMaxPeek(5, 7, 7, stack);\n      stack.push(2);\n      testMinMaxPeek(2, 7, 2, stack);\n      assert(stack.pop() == 2);\n      assert(stack.pop() == 7);\n      testMinMaxPeek(5, 5, 5, stack);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  // Feel free to add new properties and methods to the class.\n  public class MinMaxStack {\n    public int Peek() {\n      // Write your code here.\n      return -1;\n    }\n\n    public int Pop() {\n      // Write your code here.\n      return -1;\n    }\n\n    public void Push(int number) {\n      // Write your code here.\n    }\n\n    public int GetMin() {\n      // Write your code here.\n      return -1;\n    }\n\n    public int GetMax() {\n      // Write your code here.\n      return -1;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n  public class MinMaxStack {\n    List<Dictionary<string, int> > minMaxStack =\n      new List<Dictionary<string, int> >();\n    List<int> stack = new List<int>();\n\n    // O(1) time | O(1) space\n    public int Peek() {\n      return stack[stack.Count - 1];\n    }\n\n    // O(1) time | O(1) space\n    public int Pop() {\n      minMaxStack.RemoveAt(minMaxStack.Count - 1);\n      var val = stack[stack.Count - 1];\n      stack.RemoveAt(stack.Count - 1);\n      return val;\n    }\n\n    // O(1) time | O(1) space\n    public void Push(int number) {\n      Dictionary<string, int> newMinMax = new Dictionary<string, int>();\n      newMinMax.Add(\"min\", number);\n      newMinMax.Add(\"max\", number);\n      if (minMaxStack.Count > 0) {\n        Dictionary<string, int> lastMinMax =\n          new Dictionary<string, int>(minMaxStack[minMaxStack.Count - 1]);\n        newMinMax[\"min\"] = Math.Min(lastMinMax[\"min\"], number);\n        newMinMax[\"max\"] = Math.Max(lastMinMax[\"max\"], number);\n      }\n      minMaxStack.Add(newMinMax);\n      stack.Add(number);\n    }\n\n    // O(1) time | O(1) space\n    public int GetMin() {\n      return minMaxStack[minMaxStack.Count - 1][\"min\"];\n    }\n\n    // O(1) time | O(1) space\n    public int GetMax() {\n      return minMaxStack[minMaxStack.Count - 1][\"max\"];\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n  public void testMinMaxPeek(\n    int min, int max, int Peek, Program.MinMaxStack stack\n  ) {\n    Utils.AssertTrue(stack.GetMin() == min);\n    Utils.AssertTrue(stack.GetMax() == max);\n    Utils.AssertTrue(stack.Peek() == Peek);\n  }\n\n  [Test]\n  public void TestCase1() {\n    Program.MinMaxStack stack = new Program.MinMaxStack();\n    stack.Push(5);\n    testMinMaxPeek(5, 5, 5, stack);\n    stack.Push(7);\n    testMinMaxPeek(5, 7, 7, stack);\n    stack.Push(2);\n    testMinMaxPeek(2, 7, 2, stack);\n    Utils.AssertTrue(stack.Pop() == 2);\n    Utils.AssertTrue(stack.Pop() == 7);\n    testMinMaxPeek(5, 5, 5, stack);\n  }\n}\n",
      "unitTests": "public class ProgramTest {\n  public void testMinMaxPeek(\n    int min, int max, int Peek, Program.MinMaxStack stack\n  ) {\n    Utils.AssertTrue(stack.GetMin() == min);\n    Utils.AssertTrue(stack.GetMax() == max);\n    Utils.AssertTrue(stack.Peek() == Peek);\n  }\n\n  [Test]\n  public void TestCase1() {\n    Program.MinMaxStack stack = new Program.MinMaxStack();\n    stack.Push(5);\n    testMinMaxPeek(5, 5, 5, stack);\n    stack.Push(7);\n    testMinMaxPeek(5, 7, 7, stack);\n    stack.Push(2);\n    testMinMaxPeek(2, 7, 2, stack);\n    Utils.AssertTrue(stack.Pop() == 2);\n    Utils.AssertTrue(stack.Pop() == 7);\n    testMinMaxPeek(5, 5, 5, stack);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\ntype MinMaxStack struct {\n\t// Write your code here.\n}\n\nfunc NewMinMaxStack() *MinMaxStack {\n\t// Write your code here.\n\treturn nil\n}\n\nfunc (stack *MinMaxStack) Peek() int {\n\t// Write your code here.\n\treturn -1\n}\n\nfunc (stack *MinMaxStack) Pop() int {\n\t// Write your code here.\n\treturn -1\n}\n\nfunc (stack *MinMaxStack) Push(number int) {\n\t// Write your code here.\n}\n\nfunc (stack *MinMaxStack) GetMin() int {\n\t// Write your code here.\n\treturn -1\n}\n\nfunc (stack *MinMaxStack) GetMax() int {\n\t// Write your code here.\n\treturn -1\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype MinMaxStack struct {\n\tstack       []int\n\tminMaxStack []entry\n}\n\ntype entry struct {\n\tmin int\n\tmax int\n}\n\nfunc NewMinMaxStack() *MinMaxStack {\n\treturn &MinMaxStack{}\n}\n\n// O(1) time | O(1) space\nfunc (stack *MinMaxStack) Peek() int {\n\treturn stack.stack[len(stack.stack)-1]\n}\n\n// O(1) time | O(1) space\nfunc (stack *MinMaxStack) Pop() int {\n\tstack.minMaxStack = stack.minMaxStack[:len(stack.minMaxStack)-1]\n\tout := stack.stack[len(stack.stack)-1]\n\tstack.stack = stack.stack[:len(stack.stack)-1]\n\treturn out\n}\n\n// O(1) time | O(1) space\nfunc (stack *MinMaxStack) Push(number int) {\n\tnewMinMax := entry{min: number, max: number}\n\tif len(stack.minMaxStack) > 0 {\n\t\tlastMinMax := stack.minMaxStack[len(stack.minMaxStack)-1]\n\t\tnewMinMax.min = min(lastMinMax.min, number)\n\t\tnewMinMax.max = max(lastMinMax.max, number)\n\t}\n\tstack.minMaxStack = append(stack.minMaxStack, newMinMax)\n\tstack.stack = append(stack.stack, number)\n}\n\n// O(1) time | O(1) space\nfunc (stack *MinMaxStack) GetMin() int {\n\treturn stack.minMaxStack[len(stack.minMaxStack)-1].min\n}\n\n// O(1) time | O(1) space\nfunc (stack *MinMaxStack) GetMax() int {\n\treturn stack.minMaxStack[len(stack.minMaxStack)-1].max\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(a, b int) int {\n\tif a < b {\n\t\treturn b\n\t}\n\treturn a\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nfunc testMinMaxPeek(t *TestCase, min, max, peek int, stack *MinMaxStack) {\n\tif min != stack.GetMin() {\n\t\tt.Fail()\n\t}\n\tif max != stack.GetMax() {\n\t\tt.Fail()\n\t}\n\tif peek != stack.Peek() {\n\t\tt.Fail()\n\t}\n}\n\nfunc assertEqual(t *TestCase, a, b int) {\n\tif a != b {\n\t\tt.Fail()\n\t}\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tstack := NewMinMaxStack()\n\tstack.Push(5)\n\ttestMinMaxPeek(t, 5, 5, 5, stack)\n\tstack.Push(7)\n\ttestMinMaxPeek(t, 5, 7, 7, stack)\n\tstack.Push(2)\n\ttestMinMaxPeek(t, 2, 7, 2, stack)\n\tassertEqual(t, stack.Pop(), 2)\n\tassertEqual(t, stack.Pop(), 7)\n\ttestMinMaxPeek(t, 5, 5, 5, stack)\n}\n",
      "unitTests": "package main\n\nfunc testMinMaxPeek(t *TestCase, min, max, peek int, stack *MinMaxStack) {\n\tif min != stack.GetMin() {\n\t\tt.Fail()\n\t}\n\tif max != stack.GetMax() {\n\t\tt.Fail()\n\t}\n\tif peek != stack.Peek() {\n\t\tt.Fail()\n\t}\n}\n\nfunc assertEqual(t *TestCase, a, b int) {\n\tif a != b {\n\t\tt.Fail()\n\t}\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tstack := NewMinMaxStack()\n\tstack.Push(5)\n\ttestMinMaxPeek(t, 5, 5, 5, stack)\n\tstack.Push(7)\n\ttestMinMaxPeek(t, 5, 7, 7, stack)\n\tstack.Push(2)\n\ttestMinMaxPeek(t, 2, 7, 2, stack)\n\tassertEqual(t, stack.Pop(), 2)\n\tassertEqual(t, stack.Pop(), 7)\n\ttestMinMaxPeek(t, 5, 5, 5, stack)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // Feel free to add new properties and methods to the class.\n  static class MinMaxStack {\n    public int peek() {\n      // Write your code here.\n      return -1;\n    }\n\n    public int pop() {\n      // Write your code here.\n      return -1;\n    }\n\n    public void push(Integer number) {\n      // Write your code here.\n    }\n\n    public int getMin() {\n      // Write your code here.\n      return -1;\n    }\n\n    public int getMax() {\n      // Write your code here.\n      return -1;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  static class MinMaxStack {\n    List<Map<String, Integer>> minMaxStack =\n      new ArrayList<Map<String, Integer>>();\n    List<Integer> stack = new ArrayList<Integer>();\n\n    // O(1) time | O(1) space\n    public int peek() {\n      return stack.get(stack.size() - 1);\n    }\n\n    // O(1) time | O(1) space\n    public int pop() {\n      minMaxStack.remove(minMaxStack.size() - 1);\n      return stack.remove(stack.size() - 1);\n    }\n\n    // O(1) time | O(1) space\n    public void push(int number) {\n      Map<String, Integer> newMinMax = new HashMap<String, Integer>();\n      newMinMax.put(\"min\", number);\n      newMinMax.put(\"max\", number);\n      if (minMaxStack.size() > 0) {\n        Map<String, Integer> lastMinMax =\n          new HashMap<String, Integer>(minMaxStack.get(minMaxStack.size() - 1));\n        newMinMax.replace(\"min\", Math.min(lastMinMax.get(\"min\"), number));\n        newMinMax.replace(\"max\", Math.max(lastMinMax.get(\"max\"), number));\n      }\n      minMaxStack.add(newMinMax);\n      stack.add(number);\n    }\n\n    // O(1) time | O(1) space\n    public int getMin() {\n      return minMaxStack.get(minMaxStack.size() - 1).get(\"min\");\n    }\n\n    // O(1) time | O(1) space\n    public int getMax() {\n      return minMaxStack.get(minMaxStack.size() - 1).get(\"max\");\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  public void testMinMaxPeek(\n    int min, int max, int peek, Program.MinMaxStack stack\n  ) {\n    Utils.assertTrue(stack.getMin() == min);\n    Utils.assertTrue(stack.getMax() == max);\n    Utils.assertTrue(stack.peek() == peek);\n  }\n\n  @Test\n  public void TestCase1() {\n    Program.MinMaxStack stack = new Program.MinMaxStack();\n    stack.push(5);\n    testMinMaxPeek(5, 5, 5, stack);\n    stack.push(7);\n    testMinMaxPeek(5, 7, 7, stack);\n    stack.push(2);\n    testMinMaxPeek(2, 7, 2, stack);\n    Utils.assertTrue(stack.pop() == 2);\n    Utils.assertTrue(stack.pop() == 7);\n    testMinMaxPeek(5, 5, 5, stack);\n  }\n}\n",
      "unitTests": "class ProgramTest {\n  public void testMinMaxPeek(\n    int min, int max, int peek, Program.MinMaxStack stack\n  ) {\n    Utils.assertTrue(stack.getMin() == min);\n    Utils.assertTrue(stack.getMax() == max);\n    Utils.assertTrue(stack.peek() == peek);\n  }\n\n  @Test\n  public void TestCase1() {\n    Program.MinMaxStack stack = new Program.MinMaxStack();\n    stack.push(5);\n    testMinMaxPeek(5, 5, 5, stack);\n    stack.push(7);\n    testMinMaxPeek(5, 7, 7, stack);\n    stack.push(2);\n    testMinMaxPeek(2, 7, 2, stack);\n    Utils.assertTrue(stack.pop() == 2);\n    Utils.assertTrue(stack.pop() == 7);\n    testMinMaxPeek(5, 5, 5, stack);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// Feel free to add new properties and methods to the class.\nclass MinMaxStack {\n  peek() {\n    // Write your code here.\n  }\n\n  pop() {\n    // Write your code here.\n  }\n\n  push(number) {\n    // Write your code here.\n  }\n\n  getMin() {\n    // Write your code here.\n  }\n\n  getMax() {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.MinMaxStack = MinMaxStack;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass MinMaxStack {\n  constructor() {\n    this.minMaxStack = [];\n    this.stack = [];\n  }\n\n  // O(1) time | O(1) space\n  peek() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  // O(1) time | O(1) space\n  pop() {\n    this.minMaxStack.pop();\n    return this.stack.pop();\n  }\n\n  // O(1) time | O(1) space\n  push(number) {\n    const newMinMax = {min: number, max: number};\n    if (this.minMaxStack.length) {\n      const lastMinMax = this.minMaxStack[this.minMaxStack.length - 1];\n      newMinMax.min = Math.min(lastMinMax.min, number);\n      newMinMax.max = Math.max(lastMinMax.max, number);\n    }\n    this.minMaxStack.push(newMinMax);\n    this.stack.push(number);\n  }\n\n  // O(1) time | O(1) space\n  getMin() {\n    return this.minMaxStack[this.minMaxStack.length - 1].min;\n  }\n\n  // O(1) time | O(1) space\n  getMax() {\n    return this.minMaxStack[this.minMaxStack.length - 1].max;\n  }\n}\n\n// Do not edit the line below.\nexports.MinMaxStack = MinMaxStack;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nfunction testMinMaxPeek(min, max, peek, stack) {\n  chai.expect(stack.getMin()).to.deep.equal(min);\n  chai.expect(stack.getMax()).to.deep.equal(max);\n  chai.expect(stack.peek()).to.deep.equal(peek);\n}\n\nit('Test Case #1', function () {\n  const stack = new program.MinMaxStack();\n  stack.push(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  stack.push(7);\n  testMinMaxPeek(5, 7, 7, stack);\n  stack.push(2);\n  testMinMaxPeek(2, 7, 2, stack);\n  chai.expect(stack.pop()).to.deep.equal(2);\n  chai.expect(stack.pop()).to.deep.equal(7);\n  testMinMaxPeek(5, 5, 5, stack);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nfunction testMinMaxPeek(min, max, peek, stack) {\n  chai.expect(stack.getMin()).to.deep.equal(min);\n  chai.expect(stack.getMax()).to.deep.equal(max);\n  chai.expect(stack.peek()).to.deep.equal(peek);\n}\n\nit('Test Case #1', function () {\n  const stack = new program.MinMaxStack();\n  stack.push(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  stack.push(7);\n  testMinMaxPeek(5, 7, 7, stack);\n  stack.push(2);\n  testMinMaxPeek(2, 7, 2, stack);\n  chai.expect(stack.pop()).to.deep.equal(2);\n  chai.expect(stack.pop()).to.deep.equal(7);\n  testMinMaxPeek(5, 5, 5, stack);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// Feel free to add new properties and methods to the class.\nopen class MinMaxStack() {\n    fun peek(): Int? {\n        // Write your code here.\n        return -1\n    }\n\n    fun pop(): Int? {\n        // Write your code here.\n        return -1\n    }\n\n    fun push(number: Int) {\n        // Write your code here.\n    }\n\n    fun getMin(): Int? {\n        // Write your code here.\n        return -1\n    }\n\n    fun getMax(): Int? {\n        // Write your code here.\n        return -1\n    }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.max\nimport kotlin.math.min\n\nopen class MinMaxStack() {\n    val minMaxStack = mutableListOf<Map<String, Int>>()\n    val stack = mutableListOf<Int>()\n\n    // O(1) time | O(1) space\n    fun peek(): Int? {\n        return this.stack[this.stack.size - 1]\n    }\n\n    // O(1) time | O(1) space\n    fun pop(): Int? {\n        this.minMaxStack.removeAt(this.stack.size - 1)\n        return this.stack.removeAt(this.stack.size - 1)\n    }\n\n    // O(1) time | O(1) space\n    fun push(number: Int) {\n        val newMinMax = mutableMapOf<String, Int>(\"min\" to number, \"max\" to number)\n        if (this.minMaxStack.size > 0) {\n            val lastMinMax = this.minMaxStack[this.minMaxStack.size - 1]\n            newMinMax[\"min\"] = min(lastMinMax[\"min\"]!!, number)\n            newMinMax[\"max\"] = max(lastMinMax[\"max\"]!!, number)\n        }\n        this.minMaxStack.add(newMinMax)\n        this.stack.add(number)\n    }\n\n    // O(1) time | O(1) space\n    fun getMin(): Int? {\n        return this.minMaxStack[this.minMaxStack.size - 1][\"min\"]\n    }\n\n    // O(1) time | O(1) space\n    fun getMax(): Int? {\n        return this.minMaxStack[this.minMaxStack.size - 1][\"max\"]\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.MinMaxStack as MinMaxStack\n\nfun testMinMaxPeek(min: Int, max: Int, peek: Int, stack: MinMaxStack) {\n    assert(stack.getMin() == min)\n    assert(stack.getMax() == max)\n    assert(stack.peek() == peek)\n}\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val stack = MinMaxStack()\n        stack.push(5)\n        testMinMaxPeek(5, 5, 5, stack)\n        stack.push(7)\n        testMinMaxPeek(5, 7, 7, stack)\n        stack.push(2)\n        testMinMaxPeek(2, 7, 2, stack)\n        assert(stack.pop() == 2)\n        assert(stack.pop() == 7)\n        testMinMaxPeek(5, 5, 5, stack)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.MinMaxStack as MinMaxStack\n\nfun testMinMaxPeek(min: Int, max: Int, peek: Int, stack: MinMaxStack) {\n    assert(stack.getMin() == min)\n    assert(stack.getMax() == max)\n    assert(stack.peek() == peek)\n}\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val stack = MinMaxStack()\n        stack.push(5)\n        testMinMaxPeek(5, 5, 5, stack)\n        stack.push(7)\n        testMinMaxPeek(5, 7, 7, stack)\n        stack.push(2)\n        testMinMaxPeek(2, 7, 2, stack)\n        assert(stack.pop() == 2)\n        assert(stack.pop() == 7)\n        testMinMaxPeek(5, 5, 5, stack)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# Feel free to add new properties and methods to the class.\nclass MinMaxStack:\n    def peek(self):\n        # Write your code here.\n        pass\n\n    def pop(self):\n        # Write your code here.\n        pass\n\n    def push(self, number):\n        # Write your code here.\n        pass\n\n    def getMin(self):\n        # Write your code here.\n        pass\n\n    def getMax(self):\n        # Write your code here.\n        pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass MinMaxStack:\n    def __init__(self):\n        self.minMaxStack = []\n        self.stack = []\n\n    # O(1) time | O(1) space\n    def peek(self):\n        return self.stack[len(self.stack) - 1]\n\n    # O(1) time | O(1) space\n    def pop(self):\n        self.minMaxStack.pop()\n        return self.stack.pop()\n\n    # O(1) time | O(1) space\n    def push(self, number):\n        newMinMax = {\"min\": number, \"max\": number}\n        if len(self.minMaxStack):\n            lastMinMax = self.minMaxStack[len(self.minMaxStack) - 1]\n            newMinMax[\"min\"] = min(lastMinMax[\"min\"], number)\n            newMinMax[\"max\"] = max(lastMinMax[\"max\"], number)\n        self.minMaxStack.append(newMinMax)\n        self.stack.append(number)\n\n    # O(1) time | O(1) space\n    def getMin(self):\n        return self.minMaxStack[len(self.minMaxStack) - 1][\"min\"]\n\n    # O(1) time | O(1) space\n    def getMax(self):\n        return self.minMaxStack[len(self.minMaxStack) - 1][\"max\"]\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\ndef testMinMaxPeek(self, min, max, peek, stack):\n    self.assertEqual(stack.getMin(), min)\n    self.assertEqual(stack.getMax(), max)\n    self.assertEqual(stack.peek(), peek)\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        stack = program.MinMaxStack()\n        stack.push(5)\n        testMinMaxPeek(self, 5, 5, 5, stack)\n        stack.push(7)\n        testMinMaxPeek(self, 5, 7, 7, stack)\n        stack.push(2)\n        testMinMaxPeek(self, 2, 7, 2, stack)\n        self.assertEqual(stack.pop(), 2)\n        self.assertEqual(stack.pop(), 7)\n        testMinMaxPeek(self, 5, 5, 5, stack)\n",
      "unitTests": "import program\nimport unittest\n\n\ndef testMinMaxPeek(self, min, max, peek, stack):\n    self.assertEqual(stack.getMin(), min)\n    self.assertEqual(stack.getMax(), max)\n    self.assertEqual(stack.peek(), peek)\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        stack = program.MinMaxStack()\n        stack.push(5)\n        testMinMaxPeek(self, 5, 5, 5, stack)\n        stack.push(7)\n        testMinMaxPeek(self, 5, 7, 7, stack)\n        stack.push(2)\n        testMinMaxPeek(self, 2, 7, 2, stack)\n        self.assertEqual(stack.pop(), 2)\n        self.assertEqual(stack.pop(), 7)\n        testMinMaxPeek(self, 5, 5, 5, stack)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "class Program\n  # Feel free to add new properties and methods to the class.\n  class MinMaxStack\n    def peek\n      # Write your code here.\n    end\n\n    def pop\n      # Write your code here.\n    end\n\n    def push(number)\n      # Write your code here.\n    end\n\n    def getMin\n      # Write your code here.\n    end\n\n    def getMax\n      # Write your code here.\n    end\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  class MinMaxStack\n    def initialize\n      @minMaxStack = []\n      @stack = []\n    end\n\n    # O(1) time | O(1) space\n    def peek\n      return @stack.last\n    end\n\n    # O(1) time | O(1) space\n    def pop\n      @minMaxStack.pop\n      return @stack.pop\n    end\n\n    # O(1) time | O(1) space\n    def push(number)\n      newMinMax = { min: number, max: number }\n      if @minMaxStack.length() > 0\n        lastMinMax = @minMaxStack.last\n        newMinMax[:min] = [lastMinMax[:min], number].min\n        newMinMax[:max] = [lastMinMax[:max], number].max\n      end\n      @minMaxStack.push(newMinMax)\n      @stack.push(number)\n    end\n\n    # O(1) time | O(1) space\n    def getMin\n      return @minMaxStack.last[:min]\n    end\n\n    # O(1) time | O(1) space\n    def getMax\n      return @minMaxStack.last[:max]\n    end\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire './program.rb'\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    stack = Program::MinMaxStack.new\n    stack.push(5)\n    testMinMaxPeek(5, 5, 5, stack)\n    stack.push(7)\n    testMinMaxPeek(5, 7, 7, stack)\n    stack.push(2)\n    testMinMaxPeek(2, 7, 2, stack)\n    assert_equal(stack.pop(), 2)\n    assert_equal(stack.pop(), 7)\n    testMinMaxPeek(5, 5, 5, stack)\n  end\n\n  def testMinMaxPeek(min, max, peek, stack)\n    assert_equal(stack.getMin(), min)\n    assert_equal(stack.getMax(), max)\n    assert_equal(stack.peek(), peek)\n  end\nend",
      "unitTests": "require './program.rb'\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    stack = Program::MinMaxStack.new\n    stack.push(5)\n    testMinMaxPeek(5, 5, 5, stack)\n    stack.push(7)\n    testMinMaxPeek(5, 7, 7, stack)\n    stack.push(2)\n    testMinMaxPeek(2, 7, 2, stack)\n    assert_equal(stack.pop(), 2)\n    assert_equal(stack.pop(), 7)\n    testMinMaxPeek(5, 5, 5, stack)\n  end\n\n  def testMinMaxPeek(min, max, peek, stack)\n    assert_equal(stack.getMin(), min)\n    assert_equal(stack.getMax(), max)\n    assert_equal(stack.peek(), peek)\n  end\nend"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // Feel free to add new properties and methods to the class.\n  class MinMaxStack {\n    func peek() -> Int? {\n      // Write your code here.\n      return nil\n    }\n\n    func pop() -> Int? {\n      // Write your code here.\n      return nil\n    }\n\n    func push(number: Int) {\n      // Write your code here.\n    }\n\n    func getMin() -> Int? {\n      // Write your code here.\n      return nil\n    }\n\n    func getMax() -> Int? {\n      // Write your code here.\n      return nil\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class MinMaxStack {\n    var minMaxStack = [[String: Int]]()\n    var stack = [Int]()\n\n    // O(1) time | O(1) space\n    func peek() -> Int? {\n      return stack.last\n    }\n\n    // O(1) time | O(1) space\n    func pop() -> Int? {\n      minMaxStack.popLast()\n\n      return stack.popLast()\n    }\n\n    // O(1) time | O(1) space\n    func push(number: Int) {\n      var newMinMax = [\"min\": number, \"max\": number]\n\n      if let lastMinMax = minMaxStack.last {\n        newMinMax[\"min\"] = min(lastMinMax[\"min\"]!, newMinMax[\"min\"]!)\n        newMinMax[\"max\"] = max(lastMinMax[\"max\"]!, newMinMax[\"max\"]!)\n      }\n\n      minMaxStack.append(newMinMax)\n      stack.append(number)\n    }\n\n    // O(1) time | O(1) space\n    func getMin() -> Int? {\n      return minMaxStack.last?[\"min\"]\n    }\n\n    // O(1) | O(1) space\n    func getMax() -> Int? {\n      return minMaxStack.last?[\"max\"]\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws in\n      let stack = Program.MinMaxStack()\n      stack.push(number: 5)\n      try testMinMaxPeek(stack: stack, min: 5, max: 5, peek: 5)\n      stack.push(number: 7)\n      try testMinMaxPeek(stack: stack, min: 5, max: 7, peek: 7)\n      stack.push(number: 2)\n      try testMinMaxPeek(stack: stack, min: 2, max: 7, peek: 2)\n      try assertEqual(2, stack.pop())\n      try assertEqual(7, stack.pop())\n      try testMinMaxPeek(stack: stack, min: 5, max: 5, peek: 5)\n    }\n  }\n\n  func testMinMaxPeek(stack: Program.MinMaxStack, min: Int, max: Int, peek: Int) throws {\n    if let stackMin = stack.getMin() {\n      try assertEqual(min, stackMin)\n    }\n\n    if let stackMax = stack.getMax() {\n      try assertEqual(max, stackMax)\n    }\n\n    if let stackPeek = stack.peek() {\n      try assertEqual(peek, stackPeek)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws in\n      let stack = Program.MinMaxStack()\n      stack.push(number: 5)\n      try testMinMaxPeek(stack: stack, min: 5, max: 5, peek: 5)\n      stack.push(number: 7)\n      try testMinMaxPeek(stack: stack, min: 5, max: 7, peek: 7)\n      stack.push(number: 2)\n      try testMinMaxPeek(stack: stack, min: 2, max: 7, peek: 2)\n      try assertEqual(2, stack.pop())\n      try assertEqual(7, stack.pop())\n      try testMinMaxPeek(stack: stack, min: 5, max: 5, peek: 5)\n    }\n  }\n\n  func testMinMaxPeek(stack: Program.MinMaxStack, min: Int, max: Int, peek: Int) throws {\n    if let stackMin = stack.getMin() {\n      try assertEqual(min, stackMin)\n    }\n\n    if let stackMax = stack.getMax() {\n      try assertEqual(max, stackMax)\n    }\n\n    if let stackPeek = stack.peek() {\n      try assertEqual(peek, stackPeek)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// Feel free to add new properties and methods to the class.\nexport class MinMaxStack {\n  peek() {\n    // Write your code here.\n    return -1;\n  }\n\n  pop() {\n    // Write your code here.\n    return -1;\n  }\n\n  push(number: number) {\n    // Write your code here.\n  }\n\n  getMin() {\n    // Write your code here.\n    return -1;\n  }\n\n  getMax() {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\ninterface MinMaxItem {\n  min: number;\n  max: number;\n}\n\nexport class MinMaxStack {\n  minMaxStack: MinMaxItem[];\n  stack: number[];\n\n  constructor() {\n    this.minMaxStack = [];\n    this.stack = [];\n  }\n\n  // O(1) time | O(1) space\n  peek() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  // O(1) time | O(1) space\n  pop() {\n    this.minMaxStack.pop();\n    return this.stack.pop();\n  }\n\n  // O(1) time | O(1) space\n  push(number: number) {\n    const newMinMax = {min: number, max: number};\n    if (this.minMaxStack.length) {\n      const lastMinMax = this.minMaxStack[this.minMaxStack.length - 1];\n      newMinMax.min = Math.min(lastMinMax.min, number);\n      newMinMax.max = Math.max(lastMinMax.max, number);\n    }\n    this.minMaxStack.push(newMinMax);\n    this.stack.push(number);\n  }\n\n  // O(1) time | O(1) space\n  getMin() {\n    return this.minMaxStack[this.minMaxStack.length - 1].min;\n  }\n\n  // O(1) time | O(1) space\n  getMax() {\n    return this.minMaxStack[this.minMaxStack.length - 1].max;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nfunction testMinMaxPeek(min: number, max: number, peek: number, stack: program.MinMaxStack) {\n  chai.expect(stack.getMin()).to.deep.equal(min);\n  chai.expect(stack.getMax()).to.deep.equal(max);\n  chai.expect(stack.peek()).to.deep.equal(peek);\n}\n\nit('Test Case #1', function () {\n  const stack = new program.MinMaxStack();\n  stack.push(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  stack.push(7);\n  testMinMaxPeek(5, 7, 7, stack);\n  stack.push(2);\n  testMinMaxPeek(2, 7, 2, stack);\n  chai.expect(stack.pop()).to.deep.equal(2);\n  chai.expect(stack.pop()).to.deep.equal(7);\n  testMinMaxPeek(5, 5, 5, stack);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nfunction testMinMaxPeek(min: number, max: number, peek: number, stack: program.MinMaxStack) {\n  chai.expect(stack.getMin()).to.deep.equal(min);\n  chai.expect(stack.getMax()).to.deep.equal(max);\n  chai.expect(stack.peek()).to.deep.equal(peek);\n}\n\nit('Test Case #1', function () {\n  const stack = new program.MinMaxStack();\n  stack.push(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  stack.push(7);\n  testMinMaxPeek(5, 7, 7, stack);\n  stack.push(2);\n  testMinMaxPeek(2, 7, 2, stack);\n  chai.expect(stack.pop()).to.deep.equal(2);\n  chai.expect(stack.pop()).to.deep.equal(7);\n  testMinMaxPeek(5, 5, 5, stack);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "classMethodsToCall",
      "example": [
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            7
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            2
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        }
      ],
      "schema": {
        "description": "These methods will be called in the order that they appear in below\non a <span>MinMaxStack</span> and with their respective arguments.\n",
        "items": {
          "properties": {
            "arguments": {
              "maxItems": 1,
              "type": "array"
            },
            "method": {
              "enum": [
                "getMax",
                "getMin",
                "peek",
                "pop",
                "push"
              ],
              "type": "string"
            }
          },
          "required": [
            "method",
            "arguments"
          ],
          "type": "object"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            7
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            2
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            2
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            7
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            1
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            8
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            3
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            9
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            8
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            8
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            0
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            8
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            9
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            2
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            0
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            4
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            4
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            11
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            -11
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [
            6
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        }
      ]
    }
  ],
  "jsonTests": [
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            7
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            2
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            2
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            7
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            1
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            8
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            3
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            9
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            8
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            8
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            0
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            8
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            9
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            2
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            0
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            4
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            4
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            11
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            -11
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [
            6
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        }
      ]
    }
  ],
  "changelog": []
}