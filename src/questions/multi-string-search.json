{
  "uid": "multi-string-search",
  "testStrategy": "JSON",
  "name": "Multi String Search",
  "version": 0,
  "releaseDate": "2000-05-04T00:00:00Z",
  "category": "Tries",
  "difficulty": 3,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 9519,
    "failureCount": 2867
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "264054526",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 2596
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in a big string and an array of small strings,\n  all of which are smaller in length than the big string. The function should\n  return an array of booleans, where each boolean represents whether the small\n  string at that index in the array of small strings is contained in the big\n  string.\n</p>\n<p>Note that you can't use language-built-in string-matching methods.</p>\n<h3>Sample Input #1</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">bigString</span> = \"this is a big string\"\n<span class=\"CodeEditor-promptParameter\">smallStrings</span> = [\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"]\n</pre>\n<h3>Sample Output #1</h3>\n<pre>\n[true, false, true, true, false, true, false]\n</pre>\n<h3>Sample Input #2</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">bigString</span> = \"abcdefghijklmnopqrstuvwxyz\"\n<span class=\"CodeEditor-promptParameter\">smallStrings</span> = [\"abc\", \"mnopqr\", \"wyz\", \"no\", \"e\", \"tuuv\"]\n</pre>\n<h3>Sample Output #2</h3>\n<pre>\n[true, true, false, true, true, false]\n</pre>\n</div>",
  "hints": [
    "<p>\nA simple way to solve this problem is to iterate through all of the small strings, checking if each of them is contained in the big string by iterating through the big string's characters and comparing them to the given small string's characters with a couple of loops. Is this approach efficient from a time-complexity point of view?\n</p>\n",
    "\n<p>\nTry building a suffix-trie-like data structure containing all of the big string's suffixes. Then, iterate through all of the small strings and check if each of them is contained in the data structure you've created. What are the time-complexity ramifications of this approach?\n</p>\n",
    "\n<p>\nTry building a trie containing all of the small strings. Then, iterate through the big string's characters and check if any part of the big string is a string contained in the trie you've created. Is this approach better than the one described in Hint #2 from a time-complexity point of view?\n</p>"
  ],
  "spaceTime": "O(ns + bs) time | O(ns) space - where n is the number of small strings, s is the length of longest small string, and b is the length of the big string",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nvector<bool> multiStringSearch(string bigString, vector<string> smallStrings) {\n  // Write your code here.\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nbool isInBigString(string bigString, string smallString);\nbool isInBigStringHelper(string bigString, string smallString, int startIdx);\n\n// O(bns) time | O(n) space\nvector<bool> multiStringSearch(string bigString, vector<string> smallStrings) {\n  vector<bool> solution;\n  for (string smallString : smallStrings) {\n    solution.push_back(isInBigString(bigString, smallString));\n  }\n  return solution;\n}\n\nbool isInBigString(string bigString, string smallString) {\n  for (int i = 0; i < bigString.length(); i++) {\n    if (i + smallString.length() > bigString.length()) {\n      break;\n    }\n    if (isInBigStringHelper(bigString, smallString, i)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nbool isInBigStringHelper(string bigString, string smallString, int startIdx) {\n  int leftBigIdx = startIdx;\n  int rightBigIdx = startIdx + smallString.length() - 1;\n  int leftSmallIdx = 0;\n  int rightSmallIdx = smallString.length() - 1;\n  while (leftBigIdx <= rightBigIdx) {\n    if (bigString[leftBigIdx] != smallString[leftSmallIdx] || bigString[rightBigIdx] != smallString[rightSmallIdx]) {\n      return false;\n    }\n    leftBigIdx++;\n    rightBigIdx--;\n    leftSmallIdx++;\n    rightSmallIdx--;\n  }\n  return true;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nclass TrieNode {\n public:\n  unordered_map<char, TrieNode*> children;\n};\n\nclass ModifiedSuffixTrie {\n public:\n  TrieNode* root;\n\n  ModifiedSuffixTrie(string str) {\n    this->root = new TrieNode();\n    this->populateModifiedSuffixTrieFrom(str);\n  }\n\n  void populateModifiedSuffixTrieFrom(string str) {\n    for (int i = 0; i < str.length(); i++) {\n      this->insertSubstringStartingAt(i, str);\n    }\n  }\n\n  void insertSubstringStartingAt(int i, string str) {\n    TrieNode* node = this->root;\n    for (int j = i; j < str.length(); j++) {\n      char letter = str[j];\n      if (node->children.find(letter) == node->children.end()) {\n        TrieNode* newNode = new TrieNode();\n        node->children.insert({letter, newNode});\n      }\n      node = node->children[letter];\n    }\n  }\n\n  bool contains(string str) {\n    TrieNode* node = this->root;\n    for (char letter : str) {\n      if (node->children.find(letter) == node->children.end()) {\n        return false;\n      }\n      node = node->children[letter];\n    }\n    return true;\n  }\n};\n\n// O(b^2 + ns) time | O(b^2 + n) space\nvector<bool> multiStringSearch(string bigString, vector<string> smallStrings) {\n  ModifiedSuffixTrie modifiedSuffixTrie(bigString);\n  vector<bool> solution;\n  for (string smallString : smallStrings) {\n    solution.push_back(modifiedSuffixTrie.contains(smallString));\n  }\n  return solution;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nclass TrieNode {\n public:\n  unordered_map<char, TrieNode*> children;\n  string word;\n};\n\nclass Trie {\n public:\n  TrieNode* root;\n  char endSymbol;\n\n  Trie() {\n    this->root = new TrieNode();\n    this->endSymbol = '*';\n  }\n\n  void insert(string str) {\n    TrieNode* current = this->root;\n    for (int i = 0; i < str.length(); i++) {\n      char letter = str[i];\n      if (current->children.find(letter) == current->children.end()) {\n        TrieNode* newNode = new TrieNode();\n        current->children.insert({letter, newNode});\n      }\n      current = current->children[letter];\n    }\n    current->children.insert({this->endSymbol, nullptr});\n    current->word = str;\n  }\n};\n\nvoid findSmallStringsIn(\n  string str,\n  int startIdx,\n  Trie* trie,\n  unordered_map<string, bool>* containedStrings\n);\n\n// O(ns + bs) time | O(ns) space\nvector<bool> multiStringSearch(string bigString, vector<string> smallStrings) {\n  Trie* trie = new Trie();\n  for (string smallString : smallStrings) {\n    trie->insert(smallString);\n  }\n  unordered_map<string, bool> containedStrings;\n  for (int i = 0; i < bigString.length(); i++) {\n    findSmallStringsIn(bigString, i, trie, &containedStrings);\n  }\n  vector<bool> solution;\n  for (string smallString : smallStrings) {\n    solution.push_back(\n      containedStrings.find(smallString) != containedStrings.end()\n    );\n  }\n  return solution;\n}\n\nvoid findSmallStringsIn(\n  string str,\n  int startIdx,\n  Trie* trie,\n  unordered_map<string, bool>* containedStrings\n) {\n  TrieNode* currentNode = trie->root;\n  for (int i = startIdx; i < str.length(); i++) {\n    if (currentNode->children.find(str[i]) == currentNode->children.end()) {\n      break;\n    }\n    currentNode = currentNode->children[str[i]];\n    if (currentNode->children.find(trie->endSymbol) != currentNode->children.end()) {\n      containedStrings->insert({currentNode->word, true});\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<bool> expected{true, false, true, true, false, true, false};\n      assert(\n        multiStringSearch(\n          \"this is a big string\",\n          {\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"}\n        ) == expected\n      );\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<bool> expected{true, false, true, true, false, true, false};\n      assert(\n        multiStringSearch(\n          \"this is a big string\",\n          {\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"}\n        ) == expected\n      );\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n  public static List<bool> MultistringSearch(\n    string bigstring, string[] smallstrings\n  ) {\n    // Write your code here.\n    return new List<bool>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(bns) time | O(n) space\n  public static List<bool> MultistringSearch(\n    string bigstring, string[] smallstrings\n  ) {\n    List<bool> solution = new List<bool>();\n    foreach (string smallstring in smallstrings) {\n      solution.Add(isInBigstring(bigstring, smallstring));\n    }\n    return solution;\n  }\n\n  public static bool isInBigstring(string bigstring, string smallstring) {\n    for (int i = 0; i < bigstring.Length; i++) {\n      if (i + smallstring.Length > bigstring.Length) {\n        break;\n      }\n      if (isInBigstring(bigstring, smallstring, i)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public static bool isInBigstring(\n    string bigstring, string smallstring, int startIdx\n  ) {\n    int leftBigIdx = startIdx;\n    int rightBigIdx = startIdx + smallstring.Length - 1;\n    int leftSmallIdx = 0;\n    int rightSmallIdx = smallstring.Length - 1;\n    while (leftBigIdx <= rightBigIdx) {\n      if (bigstring[leftBigIdx] != smallstring[leftSmallIdx] || bigstring[rightBigIdx] != smallstring[rightSmallIdx]) {\n        return false;\n      }\n      leftBigIdx++;\n      rightBigIdx--;\n      leftSmallIdx++;\n      rightSmallIdx--;\n    }\n    return true;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(b^2 + ns) time | O(b^2 + n) space\n  public static List<bool> MultistringSearch(\n    string bigstring, string[] smallstrings\n  ) {\n    ModifiedSuffixTrie modifiedSuffixTrie = new ModifiedSuffixTrie(bigstring);\n    List<bool> solution = new List<bool>();\n    foreach (string smallstring in smallstrings) {\n      solution.Add(modifiedSuffixTrie.Contains(smallstring));\n    }\n    return solution;\n  }\n\n  public class TrieNode {\n    public Dictionary<char, TrieNode> children =\n      new Dictionary<char, TrieNode>();\n  }\n\n  public class ModifiedSuffixTrie {\n    TrieNode root = new TrieNode();\n\n    public ModifiedSuffixTrie(string str) {\n      populateModifiedSuffixTrieFrom(str);\n    }\n\n    public void populateModifiedSuffixTrieFrom(string str) {\n      for (int i = 0; i < str.Length; i++) {\n        insertSubstringStartingAt(i, str);\n      }\n    }\n\n    public void insertSubstringStartingAt(int i, string str) {\n      TrieNode node = root;\n      for (int j = i; j < str.Length; j++) {\n        char letter = str[j];\n        if (!node.children.ContainsKey(letter)) {\n          TrieNode newNode = new TrieNode();\n          node.children.Add(letter, newNode);\n        }\n        node = node.children[letter];\n      }\n    }\n\n    public bool Contains(string str) {\n      TrieNode node = root;\n      for (int i = 0; i < str.Length; i++) {\n        char letter = str[i];\n        if (!node.children.ContainsKey(letter)) {\n          return false;\n        }\n        node = node.children[letter];\n      }\n      return true;\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(ns + bs) time | O(ns) space\n  public static List<bool> MultistringSearch(\n    string bigstring, string[] smallstrings\n  ) {\n    Trie trie = new Trie();\n    foreach (string smallstring in smallstrings) {\n      trie.insert(smallstring);\n    }\n    HashSet<string> containedstrings = new HashSet<string>();\n    for (int i = 0; i < bigstring.Length; i++) {\n      findSmallstringsIn(bigstring, i, trie, containedstrings);\n    }\n    List<bool> solution = new List<bool>();\n    foreach (string str in smallstrings) {\n      solution.Add(containedstrings.Contains(str));\n    }\n    return solution;\n  }\n\n  public static void findSmallstringsIn(\n    string str, int startIdx, Trie trie, HashSet<string> containedstrings\n  ) {\n    TrieNode currentNode = trie.root;\n    for (int i = startIdx; i < str.Length; i++) {\n      char currentChar = str[i];\n      if (!currentNode.children.ContainsKey(currentChar)) {\n        break;\n      }\n      currentNode = currentNode.children[currentChar];\n      if (currentNode.children.ContainsKey(trie.endSymbol)) {\n        containedstrings.Add(currentNode.word);\n      }\n    }\n  }\n\n  public class TrieNode {\n    public Dictionary<char, TrieNode> children =\n      new Dictionary<char, TrieNode>();\n    public string word;\n  }\n\n  public class Trie {\n    public TrieNode root = new TrieNode();\n    public char endSymbol = '*';\n\n    public void insert(string str) {\n      TrieNode node = root;\n      for (int i = 0; i < str.Length; i++) {\n        char letter = str[i];\n        if (!node.children.ContainsKey(letter)) {\n          TrieNode newNode = new TrieNode();\n          node.children.Add(letter, newNode);\n        }\n        node = node.children[letter];\n      }\n      node.children[endSymbol] = null;\n      node.word = str;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    bool[] expected = { true, false, true, true, false, true, false };\n    List<bool> output = Program.MultistringSearch(\n      \"this is a big string\",\n      new string[] { \"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\" }\n    );\n    Utils.AssertTrue(compare(output, expected));\n  }\n\n  public bool compare(List<bool> arr1, bool[] arr2) {\n    if (arr1.Count != arr2.Length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.Count; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    bool[] expected = { true, false, true, true, false, true, false };\n    List<bool> output = Program.MultistringSearch(\n      \"this is a big string\",\n      new string[] { \"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\" }\n    );\n    Utils.AssertTrue(compare(output, expected));\n  }\n\n  public bool compare(List<bool> arr1, bool[] arr2) {\n    if (arr1.Count != arr2.Length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.Count; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc MultiStringSearch(bigString string, smallStrings []string) []bool {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(bns) time | O(n) space\nfunc MultiStringSearch(bigString string, smallStrings []string) []bool {\n\toutput := make([]bool, len(smallStrings))\n\tfor i, smallString := range smallStrings {\n\t\toutput[i] = isInBigString(bigString, smallString)\n\t}\n\treturn output\n}\n\nfunc isInBigString(bigString, smallString string) bool {\n\tfor i := range bigString {\n\t\tif i+len(smallString) > len(bigString) {\n\t\t\tbreak\n\t\t}\n\t\tif isInBigStringHelper(bigString, smallString, i) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isInBigStringHelper(bigString, smallString string, startIdx int) bool {\n\tleftBigIdx := startIdx\n\trightBigIdx := startIdx + len(smallString) - 1\n\tleftSmallIdx := 0\n\trightSmallIdx := len(smallString) - 1\n\tfor leftBigIdx <= rightBigIdx {\n\t\tif bigString[leftBigIdx] != smallString[leftSmallIdx] ||\n\t\t\tbigString[rightBigIdx] != smallString[rightSmallIdx] {\n\t\t\treturn false\n\t\t}\n\t\tleftBigIdx += 1\n\t\trightBigIdx -= 1\n\t\tleftSmallIdx += 1\n\t\trightSmallIdx -= 1\n\t}\n\treturn true\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(b^2 + ns) time | O(b^2 + n) space\nfunc MultiStringSearch(bigString string, smallStrings []string) []bool {\n\ttrie := NewTrie(bigString)\n\toutput := make([]bool, len(smallStrings))\n\tfor i, smallString := range smallStrings {\n\t\toutput[i] = trie.Contains(smallString)\n\t}\n\treturn output\n}\n\ntype ModifiedSuffixTrie map[byte]ModifiedSuffixTrie\n\nfunc NewTrie(str string) ModifiedSuffixTrie {\n\ttrie := ModifiedSuffixTrie{}\n\tfor i := range str {\n\t\ttrie.Add(str, i)\n\t}\n\treturn trie\n}\n\nfunc (trie ModifiedSuffixTrie) Add(str string, startIndex int) {\n\tnode := trie\n\tfor j := startIndex; j < len(str); j++ {\n\t\tletter := str[j]\n\t\tif _, found := node[letter]; !found {\n\t\t\tnode[letter] = ModifiedSuffixTrie{}\n\t\t}\n\t\tnode = node[letter]\n\t}\n}\n\nfunc (trie ModifiedSuffixTrie) Contains(str string) bool {\n\tnode := trie\n\tfor i := range str {\n\t\tletter := str[i]\n\t\tif _, found := node[letter]; !found {\n\t\t\treturn false\n\t\t}\n\t\tnode = node[letter]\n\t}\n\treturn true\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(ns + bs) time | O(ns) space\nfunc MultiStringSearch(bigString string, smallStrings []string) []bool {\n\ttrie := Trie{children: map[byte]Trie{}}\n\tfor _, str := range smallStrings {\n\t\ttrie.Add(str)\n\t}\n\tcontainedStrings := map[string]bool{}\n\tfor i := range bigString {\n\t\tfindSmallStringsIn(bigString, i, trie, containedStrings)\n\t}\n\toutput := make([]bool, len(smallStrings))\n\tfor i, str := range smallStrings {\n\t\toutput[i] = containedStrings[str]\n\t}\n\treturn output\n}\n\nfunc findSmallStringsIn(str string, startIdx int, trie Trie, containedStrings map[string]bool) {\n\tcurrent := trie\n\tfor i := startIdx; i < len(str); i++ {\n\t\tcurrentChar := str[i]\n\t\tif _, found := current.children[currentChar]; !found {\n\t\t\tbreak\n\t\t}\n\t\tcurrent = current.children[currentChar]\n\t\tif end, found := current.children['*']; found {\n\t\t\tcontainedStrings[end.word] = true\n\t\t}\n\t}\n}\n\ntype Trie struct {\n\tchildren map[byte]Trie\n\n\tword string\n}\n\nfunc (t Trie) Add(word string) {\n\tcurrent := t\n\tfor i := range word {\n\t\tletter := word[i]\n\t\tif _, found := current.children[letter]; !found {\n\t\t\tcurrent.children[letter] = Trie{\n\t\t\t\tchildren: map[byte]Trie{},\n\t\t\t}\n\t\t}\n\t\tcurrent = current.children[letter]\n\t}\n\tcurrent.children['*'] = Trie{\n\t\tchildren: map[byte]Trie{},\n\t\tword:     word,\n\t}\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []bool{true, false, true, true, false, true, false}\n\toutput := MultiStringSearch(\"this is a big string\", []string{\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"})\n\trequire.Equal(t, expected, output)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []bool{true, false, true, true, false, true, false}\n\toutput := MultiStringSearch(\"this is a big string\", []string{\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"})\n\trequire.Equal(t, expected, output)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static List<Boolean> multiStringSearch(\n    String bigString, String[] smallStrings\n  ) {\n    // Write your code here.\n    return new ArrayList<Boolean>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(bns) time | O(n) space\n  public static List<Boolean> multiStringSearch(\n    String bigString, String[] smallStrings\n  ) {\n    List<Boolean> solution = new ArrayList<Boolean>();\n    for (String smallString : smallStrings) {\n      solution.add(isInBigString(bigString, smallString));\n    }\n    return solution;\n  }\n\n  public static boolean isInBigString(String bigString, String smallString) {\n    for (int i = 0; i < bigString.length(); i++) {\n      if (i + smallString.length() > bigString.length()) {\n        break;\n      }\n      if (isInBigString(bigString, smallString, i)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public static boolean isInBigString(\n    String bigString, String smallString, int startIdx\n  ) {\n    int leftBigIdx = startIdx;\n    int rightBigIdx = startIdx + smallString.length() - 1;\n    int leftSmallIdx = 0;\n    int rightSmallIdx = smallString.length() - 1;\n    while (leftBigIdx <= rightBigIdx) {\n      if (bigString.charAt(leftBigIdx) != smallString.charAt(leftSmallIdx)\n          || bigString.charAt(rightBigIdx)\n              != smallString.charAt(rightSmallIdx)) {\n        return false;\n      }\n      leftBigIdx++;\n      rightBigIdx--;\n      leftSmallIdx++;\n      rightSmallIdx--;\n    }\n    return true;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(b^2 + ns) time | O(b^2 + n) space\n  public static List<Boolean> multiStringSearch(\n    String bigString, String[] smallStrings\n  ) {\n    ModifiedSuffixTrie modifiedSuffixTrie = new ModifiedSuffixTrie(bigString);\n    List<Boolean> solution = new ArrayList<Boolean>();\n    for (String smallString : smallStrings) {\n      solution.add(modifiedSuffixTrie.contains(smallString));\n    }\n    return solution;\n  }\n\n  static class TrieNode {\n    Map<Character, TrieNode> children = new HashMap<Character, TrieNode>();\n  }\n\n  static class ModifiedSuffixTrie {\n    TrieNode root = new TrieNode();\n\n    public ModifiedSuffixTrie(String str) {\n      populateModifiedSuffixTrieFrom(str);\n    }\n\n    public void populateModifiedSuffixTrieFrom(String str) {\n      for (int i = 0; i < str.length(); i++) {\n        insertSubstringStartingAt(i, str);\n      }\n    }\n\n    public void insertSubstringStartingAt(int i, String str) {\n      TrieNode node = root;\n      for (int j = i; j < str.length(); j++) {\n        char letter = str.charAt(j);\n        if (!node.children.containsKey(letter)) {\n          TrieNode newNode = new TrieNode();\n          node.children.put(letter, newNode);\n        }\n        node = node.children.get(letter);\n      }\n    }\n\n    public boolean contains(String str) {\n      TrieNode node = root;\n      for (int i = 0; i < str.length(); i++) {\n        char letter = str.charAt(i);\n        if (!node.children.containsKey(letter)) {\n          return false;\n        }\n        node = node.children.get(letter);\n      }\n      return true;\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(ns + bs) time | O(ns) space\n  public static List<Boolean> multiStringSearch(\n    String bigString, String[] smallStrings\n  ) {\n    Trie trie = new Trie();\n    for (String smallString : smallStrings) {\n      trie.insert(smallString);\n    }\n    Set<String> containedStrings = new HashSet<String>();\n    for (int i = 0; i < bigString.length(); i++) {\n      findSmallStringsIn(bigString, i, trie, containedStrings);\n    }\n    List<Boolean> solution = new ArrayList<Boolean>();\n    for (String str : smallStrings) {\n      solution.add(containedStrings.contains(str));\n    }\n    return solution;\n  }\n\n  public static void findSmallStringsIn(\n    String str, int startIdx, Trie trie, Set<String> containedStrings\n  ) {\n    TrieNode currentNode = trie.root;\n    for (int i = startIdx; i < str.length(); i++) {\n      char currentChar = str.charAt(i);\n      if (!currentNode.children.containsKey(currentChar)) {\n        break;\n      }\n      currentNode = currentNode.children.get(currentChar);\n      if (currentNode.children.containsKey(trie.endSymbol)) {\n        containedStrings.add(currentNode.word);\n      }\n    }\n  }\n\n  static class TrieNode {\n    Map<Character, TrieNode> children = new HashMap<Character, TrieNode>();\n    String word;\n  }\n\n  static class Trie {\n    TrieNode root = new TrieNode();\n    char endSymbol = '*';\n\n    public void insert(String str) {\n      TrieNode node = root;\n      for (int i = 0; i < str.length(); i++) {\n        char letter = str.charAt(i);\n        if (!node.children.containsKey(letter)) {\n          TrieNode newNode = new TrieNode();\n          node.children.put(letter, newNode);\n        }\n        node = node.children.get(letter);\n      }\n      node.children.put(endSymbol, null);\n      node.word = str;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    boolean[] expected = {true, false, true, true, false, true, false};\n    List<Boolean> output = Program.multiStringSearch(\n      \"this is a big string\",\n      new String[] {\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"}\n    );\n    Utils.assertTrue(compare(output, expected));\n  }\n\n  public boolean compare(List<Boolean> arr1, boolean[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    boolean[] expected = {true, false, true, true, false, true, false};\n    List<Boolean> output = Program.multiStringSearch(\n      \"this is a big string\",\n      new String[] {\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"}\n    );\n    Utils.assertTrue(compare(output, expected));\n  }\n\n  public boolean compare(List<Boolean> arr1, boolean[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function multiStringSearch(bigString, smallStrings) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.multiStringSearch = multiStringSearch;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(bns) time | O(n) space\nfunction multiStringSearch(bigString, smallStrings) {\n  return smallStrings.map(smallString => isInBigString(bigString, smallString));\n}\n\nfunction isInBigString(bigString, smallString) {\n  for (let i = 0; i < bigString.length; i++) {\n    if (i + smallString.length > bigString.length) break;\n    if (isInBigStringHelper(bigString, smallString, i)) return true;\n  }\n  return false;\n}\n\nfunction isInBigStringHelper(bigString, smallString, startIdx) {\n  let leftBigIdx = startIdx;\n  let rightBigIdx = startIdx + smallString.length - 1;\n  let leftSmallIdx = 0;\n  let rightSmallIdx = smallString.length - 1;\n  while (leftBigIdx <= rightBigIdx) {\n    if (\n      bigString[leftBigIdx] != smallString[leftSmallIdx] ||\n      bigString[rightBigIdx] != smallString[rightSmallIdx]\n    ) {\n      return false;\n    }\n    leftBigIdx++;\n    rightBigIdx--;\n    leftSmallIdx++;\n    rightSmallIdx--;\n  }\n  return true;\n}\n\nexports.multiStringSearch = multiStringSearch;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(b^2 + ns) time | O(b^2 + n) space\nfunction multiStringSearch(bigString, smallStrings) {\n  const modifiedSuffixTrie = new ModifiedSuffixTrie(bigString);\n  return smallStrings.map(string => modifiedSuffixTrie.contains(string));\n}\n\nclass ModifiedSuffixTrie {\n  constructor(string) {\n    this.root = {};\n    this.populateModifiedSuffixTrieFrom(string);\n  }\n\n  populateModifiedSuffixTrieFrom(string) {\n    for (let i = 0; i < string.length; i++) {\n      this.insertSubstringStartingAt(i, string);\n    }\n  }\n\n  insertSubstringStartingAt(i, string) {\n    let node = this.root;\n    for (let j = i; j < string.length; j++) {\n      const letter = string[j];\n      if (!(letter in node)) node[letter] = {};\n      node = node[letter];\n    }\n  }\n\n  contains(string) {\n    let node = this.root;\n    for (const letter of string) {\n      if (!(letter in node)) return false;\n      node = node[letter];\n    }\n    return true;\n  }\n}\n\nexports.multiStringSearch = multiStringSearch;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(ns + bs) time | O(ns) space\nfunction multiStringSearch(bigString, smallStrings) {\n  const trie = new Trie();\n  for (const string of smallStrings) {\n    trie.insert(string);\n  }\n  const containedStrings = {};\n  for (let i = 0; i < bigString.length; i++) {\n    findSmallStringsIn(bigString, i, trie, containedStrings);\n  }\n  return smallStrings.map(string => string in containedStrings);\n}\n\nfunction findSmallStringsIn(string, startIdx, trie, containedStrings) {\n  let currentNode = trie.root;\n  for (let i = startIdx; i < string.length; i++) {\n    const currentChar = string[i];\n    if (!(currentChar in currentNode)) break;\n    currentNode = currentNode[currentChar];\n    if (trie.endSymbol in currentNode) containedStrings[currentNode[trie.endSymbol]] = true;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = {};\n    this.endSymbol = '*';\n  }\n\n  insert(string) {\n    let current = this.root;\n    for (let i = 0; i < string.length; i++) {\n      if (!(string[i] in current)) {\n        current[string[i]] = {};\n      }\n      current = current[string[i]];\n    }\n    current[this.endSymbol] = string;\n  }\n}\n\nexports.multiStringSearch = multiStringSearch;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(\n      program.multiStringSearch('this is a big string', [\n        'this',\n        'yo',\n        'is',\n        'a',\n        'bigger',\n        'string',\n        'kappa',\n      ]),\n    )\n    .to.deep.equal([true, false, true, true, false, true, false]);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(\n      program.multiStringSearch('this is a big string', [\n        'this',\n        'yo',\n        'is',\n        'a',\n        'bigger',\n        'string',\n        'kappa',\n      ]),\n    )\n    .to.deep.equal([true, false, true, true, false, true, false]);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun multiStringSearch(bigString: String, smallStrings: List<String>): List<Boolean> {\n    // Write your code here.\n    return listOf()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(bns) time | O(n) space\nfun multiStringSearch(bigString: String, smallStrings: List<String>): List<Boolean> {\n    return smallStrings.map { smallString -> isInBigString(bigString, smallString) }\n}\n\nfun isInBigString(bigString: String, smallString: String): Boolean {\n    for (i in 0 until bigString.length) {\n        if (i + smallString.length > bigString.length) break\n        if (isInBigStringHelper(bigString, smallString, i)) return true\n    }\n    return false\n}\n\nfun isInBigStringHelper(bigString: String, smallString: String, startIdx: Int): Boolean {\n    var leftBigIdx = startIdx\n    var rightBigIdx = startIdx + smallString.length - 1\n    var leftSmallIdx = 0\n    var rightSmallIdx = smallString.length - 1\n    while (leftBigIdx <= rightBigIdx) {\n        if (bigString[leftBigIdx] != smallString[leftSmallIdx] || bigString[rightBigIdx] != smallString[rightSmallIdx]) {\n            return false\n        }\n        leftBigIdx++\n        rightBigIdx--\n        leftSmallIdx++\n        rightSmallIdx--\n    }\n    return true\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(b^2 + ns) time | O(b^2 + n) space\nfun multiStringSearch(bigString: String, smallStrings: List<String>): List<Boolean> {\n    val modifiedSuffixTrie = ModifiedSuffixTrie(bigString)\n    return smallStrings.map { string -> modifiedSuffixTrie.contains(string) }\n}\n\ndata class TrieNode(\n    val children: MutableMap<Char, TrieNode> = mutableMapOf(),\n)\n\nclass ModifiedSuffixTrie(string: String) {\n    var root = TrieNode()\n\n    init {\n        populateModifiedSuffixTrieFrom(string)\n    }\n\n    fun populateModifiedSuffixTrieFrom(string: String) {\n        for (i in 0 until string.length) {\n            insertSubstringStartingAt(i, string)\n        }\n    }\n\n    fun insertSubstringStartingAt(i: Int, string: String) {\n        var node = root\n        for (j in i until string.length) {\n            val letter = string[j]\n            if (!node.children.containsKey(letter)) node.children[letter] = TrieNode()\n            node = node.children[letter]!!\n        }\n    }\n\n    fun contains(string: String): Boolean {\n        var node = root\n        for (letter in string) {\n            if (!node.children.containsKey(letter)) return false\n            node = node.children[letter]!!\n        }\n        return true\n    }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(ns + bs) time | O(ns) space\nfun multiStringSearch(bigString: String, smallStrings: List<String>): List<Boolean> {\n    val trie = Trie()\n    for (string in smallStrings) {\n        trie.insert(string)\n    }\n    val containedStrings = mutableMapOf<String, Boolean>()\n    for (i in 0 until bigString.length) {\n        findSmallStringsIn(bigString, i, trie, containedStrings)\n    }\n    return smallStrings.map { string -> containedStrings.containsKey(string) }\n}\n\nfun findSmallStringsIn(string: String, startIdx: Int, trie: Trie, containedStrings: MutableMap<String, Boolean>) {\n    var currentNode = trie.root\n    for (i in startIdx until string.length) {\n        val currentChar = string[i]\n        if (!currentNode.children.containsKey(currentChar)) break\n        currentNode = currentNode.children[currentChar]!!\n        if (currentNode.children.containsKey(\n                trie.endSymbol,\n            )\n        ) {\n            containedStrings[currentNode.word] = true\n        }\n    }\n}\n\ndata class TrieNode(\n    val children: MutableMap<Char, TrieNode?> = mutableMapOf(),\n    var word: String = \"\",\n)\n\nclass Trie {\n    val root = TrieNode()\n    val endSymbol = '*'\n\n    fun insert(string: String) {\n        var current = root\n        for (i in 0 until string.length) {\n            if (!current.children.containsKey(string[i])) {\n                current.children[string[i]] = TrieNode()\n            }\n            current = current.children[string[i]]!!\n        }\n        current.children[endSymbol] = null\n        current.word = string\n    }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.multiStringSearch as multiStringSearch\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val bigString = \"this is a big string\"\n        val smallStrings = listOf(\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\")\n        val expected = listOf(true, false, true, true, false, true, false)\n        val output = multiStringSearch(bigString, smallStrings)\n        assert(output.equals(expected))\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.multiStringSearch as multiStringSearch\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val bigString = \"this is a big string\"\n        val smallStrings = listOf(\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\")\n        val expected = listOf(true, false, true, true, false, true, false)\n        val output = multiStringSearch(bigString, smallStrings)\n        assert(output.equals(expected))\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def multiStringSearch(bigString, smallStrings):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(bns) time | O(n) space\ndef multiStringSearch(bigString, smallStrings):\n    return [isInBigString(bigString, smallString) for smallString in smallStrings]\n\n\ndef isInBigString(bigString, smallString):\n    for i in range(len(bigString)):\n        if i + len(smallString) > len(bigString):\n            break\n        if isInBigStringHelper(bigString, smallString, i):\n            return True\n    return False\n\n\ndef isInBigStringHelper(bigString, smallString, startIdx):\n    leftBigIdx = startIdx\n    rightBigIdx = startIdx + len(smallString) - 1\n    leftSmallIdx = 0\n    rightSmallIdx = len(smallString) - 1\n    while leftBigIdx <= rightBigIdx:\n        if (\n            bigString[leftBigIdx] != smallString[leftSmallIdx]\n            or bigString[rightBigIdx] != smallString[rightSmallIdx]\n        ):\n            return False\n        leftBigIdx += 1\n        rightBigIdx -= 1\n        leftSmallIdx += 1\n        rightSmallIdx -= 1\n    return True\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(b^2 + ns) time | O(b^2 + n) space\ndef multiStringSearch(bigString, smallStrings):\n    modifiedSuffixTrie = ModifiedSuffixTrie(bigString)\n    return [modifiedSuffixTrie.contains(string) for string in smallStrings]\n\n\nclass ModifiedSuffixTrie:\n    def __init__(self, string):\n        self.root = {}\n        self.populateModifiedSuffixTrieFrom(string)\n\n    def populateModifiedSuffixTrieFrom(self, string):\n        for i in range(len(string)):\n            self.insertSubstringStartingAt(i, string)\n\n    def insertSubstringStartingAt(self, i, string):\n        node = self.root\n        for j in range(i, len(string)):\n            letter = string[j]\n            if letter not in node:\n                node[letter] = {}\n            node = node[letter]\n\n    def contains(self, string):\n        node = self.root\n        for letter in string:\n            if letter not in node:\n                return False\n            node = node[letter]\n        return True\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(ns + bs) time | O(ns) space\ndef multiStringSearch(bigString, smallStrings):\n    trie = Trie()\n    for string in smallStrings:\n        trie.insert(string)\n    containedStrings = {}\n    for i in range(len(bigString)):\n        findSmallStringsIn(bigString, i, trie, containedStrings)\n    return [string in containedStrings for string in smallStrings]\n\n\ndef findSmallStringsIn(string, startIdx, trie, containedStrings):\n    currentNode = trie.root\n    for i in range(startIdx, len(string)):\n        currentChar = string[i]\n        if currentChar not in currentNode:\n            break\n        currentNode = currentNode[currentChar]\n        if trie.endSymbol in currentNode:\n            containedStrings[currentNode[trie.endSymbol]] = True\n\n\nclass Trie:\n    def __init__(self):\n        self.root = {}\n        self.endSymbol = \"*\"\n\n    def insert(self, string):\n        current = self.root\n        for i in range(len(string)):\n            if string[i] not in current:\n                current[string[i]] = {}\n            current = current[string[i]]\n        current[self.endSymbol] = string\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(\n            program.multiStringSearch(\n                \"this is a big string\", [\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"]\n            ),\n            [True, False, True, True, False, True, False],\n        )\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(\n            program.multiStringSearch(\n                \"this is a big string\", [\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"]\n            ),\n            [True, False, True, True, False, True, False],\n        )\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def multiStringSearch(bigString, smallStrings)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def multiStringSearch(bigString, smallStrings)\n    # Write your code here.\n    return []\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def multiStringSearch(bigString, smallStrings)\n    # Write your code here.\n    return []\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def multiStringSearch(bigString, smallStrings)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.multiStringSearch\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.multiStringSearch\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func multiStringSearch(_ bigString: String, _ smallStrings: [String]) -> [Bool] {\n    // Write your code here.\n    return []\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(bns) time | O(n) space\n  func multiStringSearch(_ bigString: String, _ smallStrings: [String]) -> [Bool] {\n    return smallStrings.map { isInBigString($0, bigString) }\n  }\n\n  func isInBigString(_ smallString: String, _ bigString: String) -> Bool {\n    for i in 0 ..< bigString.count {\n      if i + smallString.count > bigString.count {\n        break\n      }\n\n      if isInBigStringHelper(i, smallString, bigString) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  func isInBigStringHelper(_ startIndex: Int, _ smallString: String, _ bigString: String) -> Bool {\n    var leftSmallIndex = 0\n    var rightSmallIndex = smallString.count - 1\n\n    var leftBigIndex = startIndex\n    var rightBigIndex = startIndex + smallString.count - 1\n\n    while leftBigIndex < rightBigIndex {\n      let leftSmallStringIndex = smallString.index(smallString.startIndex, offsetBy: leftSmallIndex)\n      let rightSmallStringIndex = smallString.index(smallString.startIndex, offsetBy: rightSmallIndex)\n\n      let leftBigStringIndex = bigString.index(bigString.startIndex, offsetBy: leftBigIndex)\n      let rightBigStringIndex = bigString.index(bigString.startIndex, offsetBy: rightBigIndex)\n\n      if smallString[leftSmallStringIndex] != bigString[leftBigStringIndex] || smallString[rightSmallStringIndex] != bigString[rightBigStringIndex] {\n        return false\n      }\n\n      leftSmallIndex += 1\n      rightSmallIndex -= 1\n      leftBigIndex += 1\n      rightBigIndex -= 1\n    }\n\n    return true\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(b ^ 2 + ns) time | O(b ^ 2 + n) space\n  func multiStringSearch(_ bigString: String, _ smallStrings: [String]) -> [Bool] {\n    let modifiedSuffixTrie = ModifiedSuffixTrie(string: bigString)\n\n    return smallStrings.map { modifiedSuffixTrie.contains($0) }\n  }\n\n  class TrieNode {\n    var children: [String: Any] = [:]\n  }\n\n  class ModifiedSuffixTrie {\n    var root = TrieNode()\n\n    init(string: String) {\n      populateModifiedSuffixTrieFrom(string)\n    }\n\n    func populateModifiedSuffixTrieFrom(_ string: String) {\n      for i in 0 ..< string.count {\n        insertSubstringStartingAt(i, string, root)\n      }\n    }\n\n    func insertSubstringStartingAt(_ index: Int, _ string: String, _ root: TrieNode) {\n      var node = root\n\n      for j in index ..< string.count {\n        let jStringIndex = string.index(string.startIndex, offsetBy: j)\n        let jthCharacter = String(string[jStringIndex])\n\n        if !node.children.keys.contains(jthCharacter) {\n          node.children[jthCharacter] = TrieNode()\n        }\n\n        let nextNode = node.children[jthCharacter] as! TrieNode\n        node = nextNode\n      }\n    }\n\n    func contains(_ string: String) -> Bool {\n      var node = root\n\n      for character in string {\n        let stringifiedCharacter = String(character)\n\n        if !node.children.keys.contains(stringifiedCharacter) {\n          return false\n        }\n\n        let nextNode = node.children[stringifiedCharacter] as! TrieNode\n        node = nextNode\n      }\n\n      return true\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class TrieNode {\n    var children: [String: Any] = [:]\n  }\n\n  class Trie {\n    var root = TrieNode()\n    let endSymbol = \"*\"\n\n    func insert(_ string: String) {\n      var node = root\n\n      for i in 0 ..< string.count {\n        let iStringIndex = string.index(string.startIndex, offsetBy: i)\n        let ithCharacter = String(string[iStringIndex])\n\n        if !node.children.keys.contains(ithCharacter) {\n          node.children[ithCharacter] = TrieNode()\n        }\n\n        let nextNode = node.children[ithCharacter] as! TrieNode\n        node = nextNode\n      }\n\n      node.children[endSymbol] = string\n    }\n  }\n\n  // O(ns + bs) time | O(ns) space\n  func multiStringSearch(_ bigString: String, _ smallStrings: [String]) -> [Bool] {\n    let trie = Trie()\n\n    for string in smallStrings {\n      trie.insert(string)\n    }\n\n    var containedStrings = [String: Bool]()\n\n    for i in 0 ..< bigString.count {\n      findSmallStringInBigString(bigString, i, trie, &containedStrings)\n    }\n\n    return smallStrings.map { containedStrings.keys.contains($0) }\n  }\n\n  func findSmallStringInBigString(_ string: String, _ startIndex: Int, _ trie: Trie, _ containedStrings: inout [String: Bool]) {\n    var currentNode = trie.root\n\n    for i in startIndex ..< string.count {\n      let currentStringIndex = string.index(string.startIndex, offsetBy: i)\n      let currentCharacter = String(string[currentStringIndex])\n\n      if !currentNode.children.keys.contains(currentCharacter) {\n        break\n      }\n\n      let nextNode = currentNode.children[currentCharacter] as! TrieNode\n      currentNode = nextNode\n\n      if currentNode.children.keys.contains(trie.endSymbol) {\n        let resultString = currentNode.children[trie.endSymbol] as! String\n        containedStrings[resultString] = true\n      }\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      try assertEqual([true, false, true, true, false, true, false], program.multiStringSearch(\"this is a big string\", [\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"]))\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      try assertEqual([true, false, true, true, false, true, false], program.multiStringSearch(\"this is a big string\", [\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"]))\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function multiStringSearch(bigString: string, smallStrings: string[]) {\n  // Write your code here.\n  return [false];\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(bns) time | O(n) space\nexport function multiStringSearch(bigString: string, smallStrings: string[]) {\n  return smallStrings.map(smallString => isInBigString(bigString, smallString));\n}\n\nfunction isInBigString(bigString: string, smallString: string) {\n  for (let i = 0; i < bigString.length; i++) {\n    if (i + smallString.length > bigString.length) break;\n    if (isInBigStringHelper(bigString, smallString, i)) return true;\n  }\n  return false;\n}\n\nfunction isInBigStringHelper(bigString: string, smallString: string, startIdx: number) {\n  let leftBigIdx = startIdx;\n  let rightBigIdx = startIdx + smallString.length - 1;\n  let leftSmallIdx = 0;\n  let rightSmallIdx = smallString.length - 1;\n  while (leftBigIdx <= rightBigIdx) {\n    if (\n      bigString[leftBigIdx] != smallString[leftSmallIdx] ||\n      bigString[rightBigIdx] != smallString[rightSmallIdx]\n    ) {\n      return false;\n    }\n    leftBigIdx++;\n    rightBigIdx--;\n    leftSmallIdx++;\n    rightSmallIdx--;\n  }\n  return true;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(b^2 + ns) time | O(b^2 + n) space\nexport function multiStringSearch(bigString: string, smallStrings: string[]) {\n  const modifiedSuffixTrie = new ModifiedSuffixTrie(bigString);\n  return smallStrings.map(string => modifiedSuffixTrie.contains(string));\n}\n\ninterface TrieNode {\n  [key: string]: TrieNode;\n}\n\nclass ModifiedSuffixTrie {\n  root: TrieNode;\n\n  constructor(string: string) {\n    this.root = {};\n    this.populateModifiedSuffixTrieFrom(string);\n  }\n\n  populateModifiedSuffixTrieFrom(string: string) {\n    for (let i = 0; i < string.length; i++) {\n      this.insertSubstringStartingAt(i, string);\n    }\n  }\n\n  insertSubstringStartingAt(i: number, string: string) {\n    let node = this.root;\n    for (let j = i; j < string.length; j++) {\n      const letter = string[j];\n      if (!(letter in node)) node[letter] = {};\n      node = node[letter];\n    }\n  }\n\n  contains(string: string) {\n    let node = this.root;\n    for (const letter of string) {\n      if (!(letter in node)) return false;\n      node = node[letter];\n    }\n    return true;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\ninterface ContainedStrings {\n  [key: string]: boolean;\n}\n\n// O(ns + bs) time | O(ns) space\nexport function multiStringSearch(bigString: string, smallStrings: string[]) {\n  const trie = new Trie();\n  for (const string of smallStrings) {\n    trie.insert(string);\n  }\n  const containedStrings: ContainedStrings = {};\n  for (let i = 0; i < bigString.length; i++) {\n    findSmallStringsIn(bigString, i, trie, containedStrings);\n  }\n  return smallStrings.map(string => string in containedStrings);\n}\n\nfunction findSmallStringsIn(\n  string: string,\n  startIdx: number,\n  trie: Trie,\n  containedStrings: ContainedStrings,\n) {\n  let currentNode = trie.root;\n  for (let i = startIdx; i < string.length; i++) {\n    const currentChar = string[i];\n    if (!(currentChar in currentNode)) break;\n    currentNode = currentNode[currentChar] as TrieNode;\n    if (trie.endSymbol in currentNode)\n      containedStrings[currentNode[trie.endSymbol] as string] = true;\n  }\n}\n\ninterface TrieNode {\n  [key: string]: TrieNode | string;\n}\n\nclass Trie {\n  root: TrieNode;\n  endSymbol: string;\n\n  constructor() {\n    this.root = {};\n    this.endSymbol = '*';\n  }\n\n  insert(string: string) {\n    let current = this.root;\n    for (let i = 0; i < string.length; i++) {\n      if (!(string[i] in current)) {\n        current[string[i]] = {};\n      }\n      current = current[string[i]] as TrieNode;\n    }\n    current[this.endSymbol] = string;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai\n    .expect(\n      program.multiStringSearch('this is a big string', [\n        'this',\n        'yo',\n        'is',\n        'a',\n        'bigger',\n        'string',\n        'kappa',\n      ]),\n    )\n    .to.deep.equal([true, false, true, true, false, true, false]);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai\n    .expect(\n      program.multiStringSearch('this is a big string', [\n        'this',\n        'yo',\n        'is',\n        'a',\n        'bigger',\n        'string',\n        'kappa',\n      ]),\n    )\n    .to.deep.equal([true, false, true, true, false, true, false]);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "bigString",
      "example": "this is a big string",
      "schema": {
        "type": "string"
      }
    },
    {
      "name": "smallStrings",
      "example": [
        "this",
        "yo",
        "is",
        "a",
        "bigger",
        "string",
        "kappa"
      ],
      "schema": {
        "items": {
          "type": "string"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "bigString": "this is a big string",
      "smallStrings": [
        "this",
        "yo",
        "is",
        "a",
        "bigger",
        "string",
        "kappa"
      ]
    },
    {
      "bigString": "abcdefghijklmnopqrstuvwxyz",
      "smallStrings": [
        "abc",
        "mnopqr",
        "wyz",
        "no",
        "e",
        "tuuv"
      ]
    },
    {
      "bigString": "abcdefghijklmnopqrstuvwxyz",
      "smallStrings": [
        "abcdefghijklmnopqrstuvwxyz",
        "abc",
        "j",
        "mnopqr",
        "pqrstuvwxyz",
        "xyzz",
        "defh"
      ]
    },
    {
      "bigString": "hj!)!%Hj1jh8f1985n!)51",
      "smallStrings": [
        "%Hj7",
        "8f198",
        "!)5",
        "!)!",
        "!!",
        "jh81",
        "j181hf"
      ]
    },
    {
      "bigString": "Mary goes to the shopping center every week.",
      "smallStrings": [
        "to",
        "Mary",
        "centers",
        "shop",
        "shopping",
        "string",
        "kappa"
      ]
    },
    {
      "bigString": "adcb akfkw afnmc fkadn vkaca jdaf dacb cdba cbda",
      "smallStrings": [
        "abcd",
        "acbd",
        "adbc",
        "dabc",
        "cbda",
        "cabd",
        "cdab"
      ]
    },
    {
      "bigString": "test testing testings tests testers test-takers",
      "smallStrings": [
        "tests",
        "testatk",
        "testiing",
        "trsatii",
        "test-taker",
        "test"
      ]
    },
    {
      "bigString": "ndbajwhfawkjljkfaopwdlaawjk dawkj awjkawkfjhkawk ahjwkjad jadfljawd",
      "smallStrings": [
        "abc",
        "akwbc",
        "awbc",
        "abafac",
        "ajjfbc",
        "abac",
        "jadfl"
      ]
    },
    {
      "bigString": "Is this particular test going to pass or is it going to fail? That is the question.",
      "smallStrings": [
        "that",
        "the",
        "questions",
        "goes",
        "mountain",
        "passes",
        "passed",
        "going",
        "is"
      ]
    },
    {
      "bigString": "Everything in this test should fail.",
      "smallStrings": [
        "everything",
        "inn",
        "that",
        "testers",
        "shall",
        "failure"
      ]
    },
    {
      "bigString": "this ain't a big string",
      "smallStrings": [
        "this",
        "is",
        "yo",
        "a",
        "bigger"
      ]
    },
    {
      "bigString": "bbbabb",
      "smallStrings": [
        "bbabb"
      ]
    }
  ],
  "jsonTests": [
    {
      "bigString": "this is a big string",
      "smallStrings": [
        "this",
        "yo",
        "is",
        "a",
        "bigger",
        "string",
        "kappa"
      ]
    },
    {
      "bigString": "abcdefghijklmnopqrstuvwxyz",
      "smallStrings": [
        "abc",
        "mnopqr",
        "wyz",
        "no",
        "e",
        "tuuv"
      ]
    },
    {
      "bigString": "abcdefghijklmnopqrstuvwxyz",
      "smallStrings": [
        "abcdefghijklmnopqrstuvwxyz",
        "abc",
        "j",
        "mnopqr",
        "pqrstuvwxyz",
        "xyzz",
        "defh"
      ]
    },
    {
      "bigString": "hj!)!%Hj1jh8f1985n!)51",
      "smallStrings": [
        "%Hj7",
        "8f198",
        "!)5",
        "!)!",
        "!!",
        "jh81",
        "j181hf"
      ]
    },
    {
      "bigString": "Mary goes to the shopping center every week.",
      "smallStrings": [
        "to",
        "Mary",
        "centers",
        "shop",
        "shopping",
        "string",
        "kappa"
      ]
    },
    {
      "bigString": "adcb akfkw afnmc fkadn vkaca jdaf dacb cdba cbda",
      "smallStrings": [
        "abcd",
        "acbd",
        "adbc",
        "dabc",
        "cbda",
        "cabd",
        "cdab"
      ]
    },
    {
      "bigString": "test testing testings tests testers test-takers",
      "smallStrings": [
        "tests",
        "testatk",
        "testiing",
        "trsatii",
        "test-taker",
        "test"
      ]
    },
    {
      "bigString": "ndbajwhfawkjljkfaopwdlaawjk dawkj awjkawkfjhkawk ahjwkjad jadfljawd",
      "smallStrings": [
        "abc",
        "akwbc",
        "awbc",
        "abafac",
        "ajjfbc",
        "abac",
        "jadfl"
      ]
    },
    {
      "bigString": "Is this particular test going to pass or is it going to fail? That is the question.",
      "smallStrings": [
        "that",
        "the",
        "questions",
        "goes",
        "mountain",
        "passes",
        "passed",
        "going",
        "is"
      ]
    },
    {
      "bigString": "Everything in this test should fail.",
      "smallStrings": [
        "everything",
        "inn",
        "that",
        "testers",
        "shall",
        "failure"
      ]
    },
    {
      "bigString": "this ain't a big string",
      "smallStrings": [
        "this",
        "is",
        "yo",
        "a",
        "bigger"
      ]
    },
    {
      "bigString": "bbbabb",
      "smallStrings": [
        "bbabb"
      ]
    }
  ],
  "changelog": []
}