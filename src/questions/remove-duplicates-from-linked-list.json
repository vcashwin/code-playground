{
  "uid": "remove-duplicates-from-linked-list",
  "testStrategy": "JSON",
  "name": "Remove Duplicates From Linked List",
  "version": 0,
  "releaseDate": "2021-01-31T00:00:00Z",
  "category": "Linked Lists",
  "difficulty": 1,
  "acl": {
    "isFree": false,
    "isFreeForStudents": true,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 53473,
    "failureCount": 16367
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "503283758",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 942
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given the head of a Singly Linked List whose nodes are in sorted order\n  with respect to their values. Write a function that returns a modified version\n  of the Linked List that doesn't contain any nodes with duplicate values. The\n  Linked List should be modified in place (i.e., you shouldn't create a brand\n  new list), and the modified Linked List should still have its nodes sorted\n  with respect to their values.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it's the tail of the list.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">linkedList</span> = 1 -> 1 -> 3 -> 4 -> 4 -> 4 -> 5 -> 6 -> 6 <span class=\"CodeEditor-promptComment\">// the head node with value 1</span>\n</pre>\n<h3>Sample Output</h3>\n<pre>\n1 -> 3 -> 4 -> 5 -> 6 <span class=\"CodeEditor-promptComment\">// the head node with value 1</span>\n</pre>\n</div>",
  "hints": [
    "<p>\n  The brute-force approach to this problem is to use a hash table or a set to\n  keep track of all node values that exist while traversing the linked list and\n  to simply remove nodes that have a value that already exists. This approach\n  works, but can you solve this problem without using an auxiliary data\n  structure?\n</p>\n",
    "\n<p>\n  What does the fact that the nodes are sorted tell you about the location of\n  all duplicate nodes? How can you use this fact to solve this problem with\n  constant space?\n</p>\n",
    "\n<p>\n  Since the linked list's nodes are sorted, you can loop through them and, at\n  each iteration, simply remove all successive nodes that have the same value as\n  the current node. For each node, change its next pointer to the next node in\n  the linked list that has a different value. This will remove all\n  duplicate-value nodes.\n</p>"
  ],
  "spaceTime": "O(n) time | O(1) space - where n is the number of nodes in the Linked List",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": "linkedlist",
    "outputType": "linkedlist"
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is an input struct. Do not edit.\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next = nullptr;\n\n  LinkedList(int value) { this->value = value; }\n};\n\nLinkedList* removeDuplicatesFromLinkedList(LinkedList* linkedList) {\n  // Write your code here.\n  return nullptr;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// This is an input struct. Do not edit.\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next = nullptr;\n\n  LinkedList(int value) { this->value = value; }\n};\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nLinkedList* removeDuplicatesFromLinkedList(LinkedList* linkedList) {\n  LinkedList* currentNode = linkedList;\n  while (currentNode != nullptr) {\n    LinkedList* nextDistinctNode = currentNode->next;\n    while (nextDistinctNode != nullptr &&\n           nextDistinctNode->value == currentNode->value) {\n      nextDistinctNode = nextDistinctNode->next;\n    }\n\n    currentNode->next = nextDistinctNode;\n    currentNode = nextDistinctNode;\n  }\n\n  return linkedList;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nLinkedList* addMany(LinkedList* linkedList, vector<int> values);\nvector<int> getNodesInArray(LinkedList* linkedList);\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto input =\n        addMany(new LinkedList(1), vector<int>{1, 3, 4, 4, 4, 5, 6, 6});\n      auto expected = addMany(new LinkedList(1), vector<int>{3, 4, 5, 6});\n      auto actual = removeDuplicatesFromLinkedList(input);\n      assert(getNodesInArray(actual) == getNodesInArray(expected));\n    });\n  }\n};\n\nLinkedList* addMany(LinkedList* linkedList, vector<int> values) {\n  LinkedList* current = linkedList;\n  while (current->next != nullptr) {\n    current = current->next;\n  }\n  for (auto value : values) {\n    current->next = new LinkedList(value);\n    current = current->next;\n  }\n  return linkedList;\n}\n\nvector<int> getNodesInArray(LinkedList* linkedList) {\n  vector<int> nodes;\n  LinkedList* current = linkedList;\n  while (current != nullptr) {\n    nodes.push_back(current->value);\n    current = current->next;\n  }\n  return nodes;\n}",
      "unitTests": "LinkedList* addMany(LinkedList* linkedList, vector<int> values);\nvector<int> getNodesInArray(LinkedList* linkedList);\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      auto input =\n        addMany(new LinkedList(1), vector<int>{1, 3, 4, 4, 4, 5, 6, 6});\n      auto expected = addMany(new LinkedList(1), vector<int>{3, 4, 5, 6});\n      auto actual = removeDuplicatesFromLinkedList(input);\n      assert(getNodesInArray(actual) == getNodesInArray(expected));\n    });\n  }\n};\n\nLinkedList* addMany(LinkedList* linkedList, vector<int> values) {\n  LinkedList* current = linkedList;\n  while (current->next != nullptr) {\n    current = current->next;\n  }\n  for (auto value : values) {\n    current->next = new LinkedList(value);\n    current = current->next;\n  }\n  return linkedList;\n}\n\nvector<int> getNodesInArray(LinkedList* linkedList) {\n  vector<int> nodes;\n  LinkedList* current = linkedList;\n  while (current != nullptr) {\n    nodes.push_back(current->value);\n    current = current->next;\n  }\n  return nodes;\n}"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  public LinkedList RemoveDuplicatesFromLinkedList(LinkedList linkedList) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  // O(n) time | O(1) space - where n is the number of nodes in the Linked List\n  public LinkedList RemoveDuplicatesFromLinkedList(LinkedList linkedList) {\n    LinkedList currentNode = linkedList;\n    while (currentNode != null) {\n      LinkedList nextDistinctNode = currentNode.next;\n      while (nextDistinctNode != null &&\n             nextDistinctNode.value == currentNode.value) {\n        nextDistinctNode = nextDistinctNode.next;\n      }\n\n      currentNode.next = nextDistinctNode;\n      currentNode = nextDistinctNode;\n    }\n\n    return linkedList;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class ProgramTest {\n  public Program.LinkedList addMany(Program.LinkedList ll, List<int> values) {\n    Program.LinkedList current = ll;\n    while (current.next != null) {\n      current = current.next;\n    }\n    foreach (var value in values) {\n      current.next = new Program.LinkedList(value);\n      current = current.next;\n    }\n    return ll;\n  }\n\n  public List<int> getNodesInArray(Program.LinkedList ll) {\n    List<int> nodes = new List<int>();\n    Program.LinkedList current = ll;\n    while (current != null) {\n      nodes.Add(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n\n  [Test]\n  public void TestCase1() {\n    Program.LinkedList input = new Program.LinkedList(1);\n    addMany(input, new List<int> { 1, 3, 4, 4, 4, 5, 6, 6 });\n    List<int> expectedNodes = new List<int> { 1, 3, 4, 5, 6 };\n    Program.LinkedList output =\n      new Program().RemoveDuplicatesFromLinkedList(input);\n    Utils.AssertTrue(\n      Enumerable.SequenceEqual(getNodesInArray(output), expectedNodes)\n    );\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class ProgramTest {\n  public Program.LinkedList addMany(Program.LinkedList ll, List<int> values) {\n    Program.LinkedList current = ll;\n    while (current.next != null) {\n      current = current.next;\n    }\n    foreach (var value in values) {\n      current.next = new Program.LinkedList(value);\n      current = current.next;\n    }\n    return ll;\n  }\n\n  public List<int> getNodesInArray(Program.LinkedList ll) {\n    List<int> nodes = new List<int>();\n    Program.LinkedList current = ll;\n    while (current != null) {\n      nodes.Add(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n\n  [Test]\n  public void TestCase1() {\n    Program.LinkedList input = new Program.LinkedList(1);\n    addMany(input, new List<int> { 1, 3, 4, 4, 4, 5, 6, 6 });\n    List<int> expectedNodes = new List<int> { 1, 3, 4, 5, 6 };\n    Program.LinkedList output =\n      new Program().RemoveDuplicatesFromLinkedList(input);\n    Utils.AssertTrue(\n      Enumerable.SequenceEqual(getNodesInArray(output), expectedNodes)\n    );\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is an input struct. Do not edit.\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\nfunc RemoveDuplicatesFromLinkedList(linkedList *LinkedList) *LinkedList {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input struct. Do not edit.\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfunc RemoveDuplicatesFromLinkedList(linkedList *LinkedList) *LinkedList {\n\tcurrentNode := linkedList\n\tfor currentNode != nil {\n\t\tnextDistinctNode := currentNode.Next\n\t\tfor nextDistinctNode != nil && nextDistinctNode.Value == currentNode.Value {\n\t\t\tnextDistinctNode = nextDistinctNode.Next\n\t\t}\n\t\tcurrentNode.Next = nextDistinctNode\n\t\tcurrentNode = nextDistinctNode\n\t}\n\treturn linkedList\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := addMany(&LinkedList{Value: 1}, []int{1, 3, 4, 4, 4, 5, 6, 6})\n\texpected := addMany(&LinkedList{Value: 1}, []int{3, 4, 5, 6})\n\tactual := RemoveDuplicatesFromLinkedList(input)\n\trequire.Equal(t, getValues(expected), getValues(actual))\n}\n\nfunc addMany(linkedList *LinkedList, values []int) *LinkedList {\n\tcurrent := linkedList\n\tfor current.Next != nil {\n\t\tcurrent = current.Next\n\t}\n\tfor _, value := range values {\n\t\tcurrent.Next = &LinkedList{Value: value}\n\t\tcurrent = current.Next\n\t}\n\treturn linkedList\n}\n\nfunc getValues(linkedList *LinkedList) []int {\n\tvalues := []int{}\n\tcurrent := linkedList\n\tfor current != nil {\n\t\tvalues = append(values, current.Value)\n\t\tcurrent = current.Next\n\t}\n\treturn values\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := addMany(&LinkedList{Value: 1}, []int{1, 3, 4, 4, 4, 5, 6, 6})\n\texpected := addMany(&LinkedList{Value: 1}, []int{3, 4, 5, 6})\n\tactual := RemoveDuplicatesFromLinkedList(input)\n\trequire.Equal(t, getValues(expected), getValues(actual))\n}\n\nfunc addMany(linkedList *LinkedList, values []int) *LinkedList {\n\tcurrent := linkedList\n\tfor current.Next != nil {\n\t\tcurrent = current.Next\n\t}\n\tfor _, value := range values {\n\t\tcurrent.Next = &LinkedList{Value: value}\n\t\tcurrent = current.Next\n\t}\n\treturn linkedList\n}\n\nfunc getValues(linkedList *LinkedList) []int {\n\tvalues := []int{}\n\tcurrent := linkedList\n\tfor current != nil {\n\t\tvalues = append(values, current.Value)\n\t\tcurrent = current.Next\n\t}\n\treturn values\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  public static class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  public LinkedList removeDuplicatesFromLinkedList(LinkedList linkedList) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  public static class LinkedList {\n    public int value;\n    public LinkedList next;\n\n    public LinkedList(int value) {\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  // O(n) time | O(1) space - where n is the number of nodes in the Linked List\n  public LinkedList removeDuplicatesFromLinkedList(LinkedList linkedList) {\n    LinkedList currentNode = linkedList;\n    while (currentNode != null) {\n      LinkedList nextDistinctNode = currentNode.next;\n      while (nextDistinctNode != null\n             && nextDistinctNode.value == currentNode.value) {\n        nextDistinctNode = nextDistinctNode.next;\n      }\n\n      currentNode.next = nextDistinctNode;\n      currentNode = nextDistinctNode;\n    }\n\n    return linkedList;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  public Program.LinkedList addMany(\n    Program.LinkedList ll, List<Integer> values\n  ) {\n    Program.LinkedList current = ll;\n    while (current.next != null) {\n      current = current.next;\n    }\n    for (int value : values) {\n      current.next = new Program.LinkedList(value);\n      current = current.next;\n    }\n    return ll;\n  }\n\n  public List<Integer> getNodesInArray(Program.LinkedList ll) {\n    List<Integer> nodes = new ArrayList<Integer>();\n    Program.LinkedList current = ll;\n    while (current != null) {\n      nodes.add(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n\n  @Test\n  public void TestCase1() {\n    Program.LinkedList input = new Program.LinkedList(1);\n    addMany(\n      input, new ArrayList<Integer>(Arrays.asList(1, 3, 4, 4, 4, 5, 6, 6))\n    );\n    List<Integer> expectedNodes =\n      new ArrayList<Integer>(Arrays.asList(1, 3, 4, 5, 6));\n    Program.LinkedList output =\n      new Program().removeDuplicatesFromLinkedList(input);\n    Utils.assertTrue(getNodesInArray(output).equals(expectedNodes));\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  public Program.LinkedList addMany(\n    Program.LinkedList ll, List<Integer> values\n  ) {\n    Program.LinkedList current = ll;\n    while (current.next != null) {\n      current = current.next;\n    }\n    for (int value : values) {\n      current.next = new Program.LinkedList(value);\n      current = current.next;\n    }\n    return ll;\n  }\n\n  public List<Integer> getNodesInArray(Program.LinkedList ll) {\n    List<Integer> nodes = new ArrayList<Integer>();\n    Program.LinkedList current = ll;\n    while (current != null) {\n      nodes.add(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n\n  @Test\n  public void TestCase1() {\n    Program.LinkedList input = new Program.LinkedList(1);\n    addMany(\n      input, new ArrayList<Integer>(Arrays.asList(1, 3, 4, 4, 4, 5, 6, 6))\n    );\n    List<Integer> expectedNodes =\n      new ArrayList<Integer>(Arrays.asList(1, 3, 4, 5, 6));\n    Program.LinkedList output =\n      new Program().removeDuplicatesFromLinkedList(input);\n    Utils.assertTrue(getNodesInArray(output).equals(expectedNodes));\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction removeDuplicatesFromLinkedList(linkedList) {\n  // Write your code here.\n  return null;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.removeDuplicatesFromLinkedList = removeDuplicatesFromLinkedList;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfunction removeDuplicatesFromLinkedList(linkedList) {\n  let currentNode = linkedList;\n  while (currentNode !== null) {\n    let nextDistinctNode = currentNode.next;\n    while (nextDistinctNode !== null && nextDistinctNode.value === currentNode.value) {\n      nextDistinctNode = nextDistinctNode.next;\n    }\n\n    currentNode.next = nextDistinctNode;\n    currentNode = nextDistinctNode;\n  }\n\n  return linkedList;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.removeDuplicatesFromLinkedList = removeDuplicatesFromLinkedList;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const input = new LinkedList(1).addMany([1, 3, 4, 4, 4, 5, 6, 6]);\n  const expected = new LinkedList(1).addMany([3, 4, 5, 6]);\n  const actual = program.removeDuplicatesFromLinkedList(input);\n  chai.expect(actual.getNodesInArray()).to.deep.equal(expected.getNodesInArray());\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const input = new LinkedList(1).addMany([1, 3, 4, 4, 4, 5, 6, 6]);\n  const expected = new LinkedList(1).addMany([3, 4, 5, 6]);\n  const actual = program.removeDuplicatesFromLinkedList(input);\n  chai.expect(actual.getNodesInArray()).to.deep.equal(expected.getNodesInArray());\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\nfun removeDuplicatesFromLinkedList(linkedList: LinkedList): LinkedList {\n    // Write your code here.\n    return linkedList\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfun removeDuplicatesFromLinkedList(linkedList: LinkedList): LinkedList {\n    var currentNode: LinkedList? = linkedList\n    while (currentNode != null) {\n        var nextDistinctNode = currentNode.next\n        while (nextDistinctNode != null && nextDistinctNode.value == currentNode.value) {\n            nextDistinctNode = nextDistinctNode.next\n        }\n\n        currentNode.next = nextDistinctNode\n        currentNode = nextDistinctNode\n    }\n\n    return linkedList\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.LinkedList\nimport com.algoexpert.program.removeDuplicatesFromLinkedList\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = addMany(LinkedList(1), listOf(1, 3, 4, 4, 4, 5, 6, 6))\n        val expected = addMany(LinkedList(1), listOf(3, 4, 5, 6))\n        val output = removeDuplicatesFromLinkedList(input)\n        assert(getNodesInArray(expected) == getNodesInArray(output))\n    }\n}\n\nfun addMany(linkedList: LinkedList, values: List<Int>): LinkedList {\n    var current = linkedList\n    while (current.next != null) {\n        current = current.next!!\n    }\n    for (value in values) {\n        current.next = LinkedList(value)\n        current = current.next!!\n    }\n    return linkedList\n}\n\nfun getNodesInArray(linkedList: LinkedList?): List<Int> {\n    val nodes = mutableListOf<Int>()\n    var current: LinkedList? = linkedList\n    while (current != null) {\n        nodes.add(current.value)\n        current = current.next\n    }\n    return nodes\n}\n",
      "unitTests": "import com.algoexpert.program.LinkedList\nimport com.algoexpert.program.removeDuplicatesFromLinkedList\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = addMany(LinkedList(1), listOf(1, 3, 4, 4, 4, 5, 6, 6))\n        val expected = addMany(LinkedList(1), listOf(3, 4, 5, 6))\n        val output = removeDuplicatesFromLinkedList(input)\n        assert(getNodesInArray(expected) == getNodesInArray(output))\n    }\n}\n\nfun addMany(linkedList: LinkedList, values: List<Int>): LinkedList {\n    var current = linkedList\n    while (current.next != null) {\n        current = current.next!!\n    }\n    for (value in values) {\n        current.next = LinkedList(value)\n        current = current.next!!\n    }\n    return linkedList\n}\n\nfun getNodesInArray(linkedList: LinkedList?): List<Int> {\n    val nodes = mutableListOf<Int>()\n    var current: LinkedList? = linkedList\n    while (current != null) {\n        nodes.add(current.value)\n        current = current.next\n    }\n    return nodes\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\ndef removeDuplicatesFromLinkedList(linkedList):\n    # Write your code here.\n    return None\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\n# O(n) time | O(1) space - where n is the number of nodes in the Linked List\ndef removeDuplicatesFromLinkedList(linkedList):\n    currentNode = linkedList\n    while currentNode is not None:\n        nextDistinctNode = currentNode.next\n        while nextDistinctNode is not None and nextDistinctNode.value == currentNode.value:\n            nextDistinctNode = nextDistinctNode.next\n\n        currentNode.next = nextDistinctNode\n        currentNode = nextDistinctNode\n\n    return linkedList\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass LinkedList(program.LinkedList):\n    def addMany(self, values):\n        current = self\n        while current.next is not None:\n            current = current.next\n        for value in values:\n            current.next = LinkedList(value)\n            current = current.next\n        return self\n\n    def getNodesInArray(self):\n        nodes = []\n        current = self\n        while current is not None:\n            nodes.append(current.value)\n            current = current.next\n        return nodes\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        test = LinkedList(1).addMany([1, 3, 4, 4, 4, 5, 6, 6])\n        expected = LinkedList(1).addMany([3, 4, 5, 6])\n        actual = program.removeDuplicatesFromLinkedList(test)\n        self.assertEqual(actual.getNodesInArray(), expected.getNodesInArray())\n",
      "unitTests": "import program\nimport unittest\n\n\nclass LinkedList(program.LinkedList):\n    def addMany(self, values):\n        current = self\n        while current.next is not None:\n            current = current.next\n        for value in values:\n            current.next = LinkedList(value)\n            current = current.next\n        return self\n\n    def getNodesInArray(self):\n        nodes = []\n        current = self\n        while current is not None:\n            nodes.append(current.value)\n            current = current.next\n        return nodes\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        test = LinkedList(1).addMany([1, 3, 4, 4, 4, 5, 6, 6])\n        expected = LinkedList(1).addMany([3, 4, 5, 6])\n        actual = program.removeDuplicatesFromLinkedList(test)\n        self.assertEqual(actual.getNodesInArray(), expected.getNodesInArray())\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "# This is an input struct. Do not edit.\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\nclass Program\n  def removeDuplicatesFromLinkedList(linkedList)\n    # Write your code here.\n    return nil\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\nclass Program\n  def removeDuplicatesFromLinkedList(linkedList)\n    # Write your code here.\n    return nil\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.removeDuplicatesFromLinkedList\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.removeDuplicatesFromLinkedList\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class LinkedList {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  func removeDuplicatesFromLinkedList(_ linkedList: LinkedList) -> LinkedList {\n    // Write your code here.\n    return linkedList\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class LinkedList {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  // O(n) time | O(1) space - where n is the number of nodes in the Linked List\n  func removeDuplicatesFromLinkedList(_ linkedList: LinkedList) -> LinkedList {\n    var currentNode: LinkedList? = linkedList\n    while currentNode != nil {\n      var nextDistinctNode = currentNode!.next\n      while nextDistinctNode != nil, nextDistinctNode!.value == currentNode!.value {\n        nextDistinctNode = nextDistinctNode!.next\n      }\n      currentNode!.next = nextDistinctNode\n      currentNode = nextDistinctNode\n    }\n    return linkedList\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var input = addMany(Program.LinkedList(value: 1), [1, 3, 4, 4, 4, 5, 6, 6])\n      var expected = addMany(Program.LinkedList(value: 1), [3, 4, 5, 6])\n      var actual = Program().removeDuplicatesFromLinkedList(input)\n      try assertEqual(getValues(expected), getValues(actual))\n    }\n  }\n\n  func addMany(_ linkedList: Program.LinkedList, _ values: [Int]) -> Program.LinkedList {\n    var current: Program.LinkedList = linkedList\n    while current.next != nil {\n      current = current.next!\n    }\n    for value in values {\n      current.next = Program.LinkedList(value: value)\n      current = current.next!\n    }\n    return linkedList\n  }\n\n  func getValues(_ linkedList: Program.LinkedList) -> [Int] {\n    var values = [Int]()\n    var current: Program.LinkedList? = linkedList\n    while current != nil {\n      values.append(current!.value)\n      current = current!.next\n    }\n    return values\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var input = addMany(Program.LinkedList(value: 1), [1, 3, 4, 4, 4, 5, 6, 6])\n      var expected = addMany(Program.LinkedList(value: 1), [3, 4, 5, 6])\n      var actual = Program().removeDuplicatesFromLinkedList(input)\n      try assertEqual(getValues(expected), getValues(actual))\n    }\n  }\n\n  func addMany(_ linkedList: Program.LinkedList, _ values: [Int]) -> Program.LinkedList {\n    var current: Program.LinkedList = linkedList\n    while current.next != nil {\n      current = current.next!\n    }\n    for value in values {\n      current.next = Program.LinkedList(value: value)\n      current = current.next!\n    }\n    return linkedList\n  }\n\n  func getValues(_ linkedList: Program.LinkedList) -> [Int] {\n    var values = [Int]()\n    var current: Program.LinkedList? = linkedList\n    while current != nil {\n      values.append(current!.value)\n      current = current!.next\n    }\n    return values\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nexport function removeDuplicatesFromLinkedList(linkedList: LinkedList) {\n  // Write your code here.\n  return linkedList;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nexport function removeDuplicatesFromLinkedList(linkedList: LinkedList) {\n  let currentNode: LinkedList | null = linkedList;\n  while (currentNode !== null) {\n    let nextDistinctNode: LinkedList | null = currentNode.next;\n    while (nextDistinctNode !== null && nextDistinctNode.value === currentNode.value) {\n      nextDistinctNode = nextDistinctNode.next;\n    }\n\n    currentNode.next = nextDistinctNode;\n    currentNode = nextDistinctNode;\n  }\n\n  return linkedList;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = addMany(new program.LinkedList(1), [1, 3, 4, 4, 4, 5, 6, 6]);\n  const expected = addMany(new program.LinkedList(1), [3, 4, 5, 6]);\n  const actual = program.removeDuplicatesFromLinkedList(input);\n  chai.expect(getNodesInArray(actual)).to.deep.equal(getNodesInArray(expected));\n});\n\nfunction addMany(linkedList: program.LinkedList, values: number[]) {\n  let current = linkedList;\n  while (current.next !== null) {\n    current = current.next;\n  }\n  for (const value of values) {\n    current.next = new program.LinkedList(value);\n    current = current.next;\n  }\n  return linkedList;\n}\n\nfunction getNodesInArray(linkedList: program.LinkedList) {\n  const nodes: number[] = [];\n  let current: program.LinkedList | null = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = addMany(new program.LinkedList(1), [1, 3, 4, 4, 4, 5, 6, 6]);\n  const expected = addMany(new program.LinkedList(1), [3, 4, 5, 6]);\n  const actual = program.removeDuplicatesFromLinkedList(input);\n  chai.expect(getNodesInArray(actual)).to.deep.equal(getNodesInArray(expected));\n});\n\nfunction addMany(linkedList: program.LinkedList, values: number[]) {\n  let current = linkedList;\n  while (current.next !== null) {\n    current = current.next;\n  }\n  for (const value of values) {\n    current.next = new program.LinkedList(value);\n    current = current.next;\n  }\n  return linkedList;\n}\n\nfunction getNodesInArray(linkedList: program.LinkedList) {\n  const nodes: number[] = [];\n  let current: program.LinkedList | null = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n"
    }
  },
  "customInputVars": [
    {
      "name": "linkedList",
      "example": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "1-2",
            "value": 1
          },
          {
            "id": "1-2",
            "next": "1-3",
            "value": 1
          },
          {
            "id": "1-3",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 3
          },
          {
            "id": "3",
            "next": "3-2",
            "value": 4
          },
          {
            "id": "3-2",
            "next": "3-3",
            "value": 4
          },
          {
            "id": "3-3",
            "next": "4",
            "value": 4
          },
          {
            "id": "4",
            "next": "5",
            "value": 5
          },
          {
            "id": "5",
            "next": "5-2",
            "value": 6
          },
          {
            "id": "5-2",
            "next": null,
            "value": 6
          }
        ]
      },
      "schema": {
        "description": "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
        "properties": {
          "head": {
            "type": "string"
          },
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "next": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "next"
              ],
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "head",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "1-2",
            "value": 1
          },
          {
            "id": "1-2",
            "next": "1-3",
            "value": 1
          },
          {
            "id": "1-3",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 3
          },
          {
            "id": "3",
            "next": "3-2",
            "value": 4
          },
          {
            "id": "3-2",
            "next": "3-3",
            "value": 4
          },
          {
            "id": "3-3",
            "next": "4",
            "value": 4
          },
          {
            "id": "4",
            "next": "5",
            "value": 5
          },
          {
            "id": "5",
            "next": "5-2",
            "value": 6
          },
          {
            "id": "5-2",
            "next": null,
            "value": 6
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "1-2",
            "value": 1
          },
          {
            "id": "1-2",
            "next": "1-3",
            "value": 1
          },
          {
            "id": "1-3",
            "next": "1-4",
            "value": 1
          },
          {
            "id": "1-4",
            "next": "1-5",
            "value": 1
          },
          {
            "id": "1-5",
            "next": "4",
            "value": 1
          },
          {
            "id": "4",
            "next": "4-2",
            "value": 4
          },
          {
            "id": "4-2",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "6-2",
            "value": 6
          },
          {
            "id": "6-2",
            "next": null,
            "value": 6
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "1-2",
            "value": 1
          },
          {
            "id": "1-2",
            "next": "1-3",
            "value": 1
          },
          {
            "id": "1-3",
            "next": "1-4",
            "value": 1
          },
          {
            "id": "1-4",
            "next": "1-5",
            "value": 1
          },
          {
            "id": "1-5",
            "next": "1-6",
            "value": 1
          },
          {
            "id": "1-6",
            "next": "1-7",
            "value": 1
          },
          {
            "id": "1-7",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "9",
            "value": 1
          },
          {
            "id": "9",
            "next": "11",
            "value": 9
          },
          {
            "id": "11",
            "next": "15",
            "value": 11
          },
          {
            "id": "15",
            "next": "15-2",
            "value": 15
          },
          {
            "id": "15-2",
            "next": "16",
            "value": 15
          },
          {
            "id": "16",
            "next": "17",
            "value": 16
          },
          {
            "id": "17",
            "next": null,
            "value": 17
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "-5",
        "nodes": [
          {
            "id": "-5",
            "next": "-1",
            "value": -5
          },
          {
            "id": "-1",
            "next": "-1-2",
            "value": -1
          },
          {
            "id": "-1-2",
            "next": "-1-3",
            "value": -1
          },
          {
            "id": "-1-3",
            "next": "5",
            "value": -1
          },
          {
            "id": "5",
            "next": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "next": "5-3",
            "value": 5
          },
          {
            "id": "5-3",
            "next": "8",
            "value": 5
          },
          {
            "id": "8",
            "next": "8-2",
            "value": 8
          },
          {
            "id": "8-2",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": "10",
            "value": 9
          },
          {
            "id": "10",
            "next": "11",
            "value": 10
          },
          {
            "id": "11",
            "next": "11-2",
            "value": 11
          },
          {
            "id": "11-2",
            "next": null,
            "value": 11
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": "10",
            "value": 9
          },
          {
            "id": "10",
            "next": "11",
            "value": 10
          },
          {
            "id": "11",
            "next": "12",
            "value": 11
          },
          {
            "id": "12",
            "next": "12-2",
            "value": 12
          },
          {
            "id": "12-2",
            "next": null,
            "value": 12
          }
        ]
      }
    }
  ],
  "jsonTests": [
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "1-2",
            "value": 1
          },
          {
            "id": "1-2",
            "next": "1-3",
            "value": 1
          },
          {
            "id": "1-3",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 3
          },
          {
            "id": "3",
            "next": "3-2",
            "value": 4
          },
          {
            "id": "3-2",
            "next": "3-3",
            "value": 4
          },
          {
            "id": "3-3",
            "next": "4",
            "value": 4
          },
          {
            "id": "4",
            "next": "5",
            "value": 5
          },
          {
            "id": "5",
            "next": "5-2",
            "value": 6
          },
          {
            "id": "5-2",
            "next": null,
            "value": 6
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "1-2",
            "value": 1
          },
          {
            "id": "1-2",
            "next": "1-3",
            "value": 1
          },
          {
            "id": "1-3",
            "next": "1-4",
            "value": 1
          },
          {
            "id": "1-4",
            "next": "1-5",
            "value": 1
          },
          {
            "id": "1-5",
            "next": "4",
            "value": 1
          },
          {
            "id": "4",
            "next": "4-2",
            "value": 4
          },
          {
            "id": "4-2",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "6-2",
            "value": 6
          },
          {
            "id": "6-2",
            "next": null,
            "value": 6
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "1-2",
            "value": 1
          },
          {
            "id": "1-2",
            "next": "1-3",
            "value": 1
          },
          {
            "id": "1-3",
            "next": "1-4",
            "value": 1
          },
          {
            "id": "1-4",
            "next": "1-5",
            "value": 1
          },
          {
            "id": "1-5",
            "next": "1-6",
            "value": 1
          },
          {
            "id": "1-6",
            "next": "1-7",
            "value": 1
          },
          {
            "id": "1-7",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "9",
            "value": 1
          },
          {
            "id": "9",
            "next": "11",
            "value": 9
          },
          {
            "id": "11",
            "next": "15",
            "value": 11
          },
          {
            "id": "15",
            "next": "15-2",
            "value": 15
          },
          {
            "id": "15-2",
            "next": "16",
            "value": 15
          },
          {
            "id": "16",
            "next": "17",
            "value": 16
          },
          {
            "id": "17",
            "next": null,
            "value": 17
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": null,
            "value": 1
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "-5",
        "nodes": [
          {
            "id": "-5",
            "next": "-1",
            "value": -5
          },
          {
            "id": "-1",
            "next": "-1-2",
            "value": -1
          },
          {
            "id": "-1-2",
            "next": "-1-3",
            "value": -1
          },
          {
            "id": "-1-3",
            "next": "5",
            "value": -1
          },
          {
            "id": "5",
            "next": "5-2",
            "value": 5
          },
          {
            "id": "5-2",
            "next": "5-3",
            "value": 5
          },
          {
            "id": "5-3",
            "next": "8",
            "value": 5
          },
          {
            "id": "8",
            "next": "8-2",
            "value": 8
          },
          {
            "id": "8-2",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": "10",
            "value": 9
          },
          {
            "id": "10",
            "next": "11",
            "value": 10
          },
          {
            "id": "11",
            "next": "11-2",
            "value": 11
          },
          {
            "id": "11-2",
            "next": null,
            "value": 11
          }
        ]
      }
    },
    {
      "linkedList": {
        "head": "1",
        "nodes": [
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": "10",
            "value": 9
          },
          {
            "id": "10",
            "next": "11",
            "value": 10
          },
          {
            "id": "11",
            "next": "12",
            "value": 11
          },
          {
            "id": "12",
            "next": "12-2",
            "value": 12
          },
          {
            "id": "12-2",
            "next": null,
            "value": 12
          }
        ]
      }
    }
  ],
  "changelog": []
}