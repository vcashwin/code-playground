{
  "uid": "remove-kth-node-from-end",
  "testStrategy": "JSON",
  "name": "Remove Kth Node From End",
  "version": 0,
  "releaseDate": "2000-05-04T00:00:00Z",
  "category": "Linked Lists",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 31044,
    "failureCount": 14752
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "243485333",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 751
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in the head of a Singly Linked List and an integer\n  <span>k</span> and removes the kth node from the end of the list.\n</p>\n<p>\n  The removal should be done in place, meaning that the original data structure\n  should be mutated (no new structure should be created).\n</p>\n<p>\n  Furthermore, the input head of the linked list should remain the head of the\n  linked list after the removal is done, even if the head is the node that's\n  supposed to be removed. In other words, if the head is the node that's\n  supposed to be removed, your function should simply mutate its\n  <span>value</span> and <span>next</span> pointer.\n</p>\n<p>Note that your function doesn't need to return anything.</p>\n<p>\n  You can assume that the input Linked List will always have at least two nodes\n  and, more specifically, at least k nodes.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it's the tail of the list.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">head</span> = 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 <span class=\"CodeEditor-promptComment\">// the head node with value 0</span>\n<span class=\"CodeEditor-promptParameter\">k</span> = 4\n</pre>\n<h3>Sample Output</h3>\n<pre>\n<span class=\"CodeEditor-promptComment\">// No output required.</span>\n<span class=\"CodeEditor-promptComment\">// The 4th node from the end of the list (the node with value 6) is removed.</span>\n0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 7 -> 8 -> 9\n</pre>\n</div>",
  "hints": [
    "<p>\nSince you are given a Singly Linked List, you do not have access to any of the list's nodes' previous nodes. Thus, traversing the entire list and then counting k nodes back isn't an option. Is there a way for you to traverse the entire list and to know which node is the kth node from the end by the time you reach the final node in the list?\n</p>\n",
    "\n<p>\nCan you accomplish the task mentioned in Hint #1 by traversing the list all the while keeping track of two nodes at a time. How could this work?\n</p>\n",
    "\n<p>\nInitialize two variables pointing to the first node in the list. Traverse k nodes in the list, updating the second variable at every node (that is, take k steps with the second variable). Then, traverse the remainder of the list, this time updating both the second and the first variables (that is take as many steps with the first variable as the number of steps between the kth node from the start and the end of the list). Once you reach the end of the list, the first variable should point to the kth node from the end.\n</p>"
  ],
  "spaceTime": "O(n) time | O(1) space - where n is the number of nodes in the Linked List",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": "linkedlist",
    "outputType": "linkedlist"
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next;\n\n  LinkedList(int value);\n  void addMany(vector<int> values);\n  vector<int> getNodesInArray();\n};\n\nvoid removeKthNodeFromEnd(LinkedList* head, int k) {\n  // Write your code here.\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nclass LinkedList {\n public:\n  int value;\n  LinkedList* next;\n\n  LinkedList(int value);\n};\n\n// O(n) time | O(1) space\nvoid removeKthNodeFromEnd(LinkedList* head, int k) {\n  int counter = 1;\n  LinkedList* first = head;\n  LinkedList* second = head;\n  while (counter <= k) {\n    second = second->next;\n    counter++;\n  }\n  if (second == nullptr) {\n    head->value = head->next->value;\n    head->next = head->next->next;\n    return;\n  }\n  while (second->next != nullptr) {\n    second = second->next;\n    first = first->next;\n  }\n  first->next = first->next->next;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass TestLinkedList : public LinkedList {\n public:\n  TestLinkedList(int value);\n  void addMany(vector<int> values);\n  vector<int> getNodesInArray();\n};\n\nLinkedList::LinkedList(int value) {\n  this->value = value;\n  this->next = nullptr;\n}\n\nTestLinkedList::TestLinkedList(int value) : LinkedList(value) {\n  this->value = value;\n  this->next = nullptr;\n}\n\nvoid TestLinkedList::addMany(vector<int> values) {\n  LinkedList* current = this;\n  while (current->next != nullptr) {\n    current = current->next;\n  }\n  for (int value : values) {\n    current->next = new LinkedList(value);\n    current = current->next;\n  }\n}\n\nvector<int> TestLinkedList::getNodesInArray() {\n  vector<int> nodes{};\n  LinkedList* current = this;\n  while (current != nullptr) {\n    nodes.push_back(current->value);\n    current = current->next;\n  }\n  return nodes;\n}\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      TestLinkedList test(0);\n      test.addMany({1, 2, 3, 4, 5, 6, 7, 8, 9});\n      TestLinkedList expected(0);\n      expected.addMany({1, 2, 3, 4, 5, 7, 8, 9});\n      removeKthNodeFromEnd(&test, 4);\n      assert(test.getNodesInArray() == expected.getNodesInArray());\n    });\n  }\n};\n",
      "unitTests": "class TestLinkedList : public LinkedList {\n public:\n  TestLinkedList(int value);\n  void addMany(vector<int> values);\n  vector<int> getNodesInArray();\n};\n\nLinkedList::LinkedList(int value) {\n  this->value = value;\n  this->next = nullptr;\n}\n\nTestLinkedList::TestLinkedList(int value) : LinkedList(value) {\n  this->value = value;\n  this->next = nullptr;\n}\n\nvoid TestLinkedList::addMany(vector<int> values) {\n  LinkedList* current = this;\n  while (current->next != nullptr) {\n    current = current->next;\n  }\n  for (int value : values) {\n    current->next = new LinkedList(value);\n    current = current->next;\n  }\n}\n\nvector<int> TestLinkedList::getNodesInArray() {\n  vector<int> nodes{};\n  LinkedList* current = this;\n  while (current != nullptr) {\n    nodes.push_back(current->value);\n    current = current->next;\n  }\n  return nodes;\n}\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      TestLinkedList test(0);\n      test.addMany({1, 2, 3, 4, 5, 6, 7, 8, 9});\n      TestLinkedList expected(0);\n      expected.addMany({1, 2, 3, 4, 5, 7, 8, 9});\n      removeKthNodeFromEnd(&test, 4);\n      assert(test.getNodesInArray() == expected.getNodesInArray());\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public static void RemoveKthNodeFromEnd(LinkedList head, int k) {\n    // Write your code here.\n  }\n\n  public class LinkedList {\n    public int Value;\n    public LinkedList Next = null;\n\n    public LinkedList(int value) {\n      this.Value = value;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n\npublic class Program {\n  // O(n) time | O(1) space\n  public static void RemoveKthNodeFromEnd(LinkedList head, int k) {\n    int counter = 1;\n    LinkedList first = head;\n    LinkedList second = head;\n    while (counter <= k) {\n      second = second.Next;\n      counter++;\n    }\n    if (second == null) {\n      head.Value = head.Next.Value;\n      head.Next = head.Next.Next;\n      return;\n    }\n    while (second.Next != null) {\n      second = second.Next;\n      first = first.Next;\n    }\n    first.Next = first.Next.Next;\n  }\n\n  public class LinkedList {\n    public int Value;\n    public LinkedList Next = null;\n\n    public LinkedList(int value) {\n      this.Value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    TestLinkedList test = new TestLinkedList(0);\n    test.addMany(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });\n    int[] expected = { 0, 1, 2, 3, 4, 5, 7, 8, 9 };\n    Program.RemoveKthNodeFromEnd(test, 4);\n    Utils.AssertTrue(compare(test.getNodesInArray(), expected));\n  }\n\n  public bool compare(List<int> arr1, int[] arr2) {\n    if (arr1.Count != arr2.Length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.Count; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public class TestLinkedList : Program.LinkedList {\n    public TestLinkedList(int value) : base(value) {}\n\n    public void addMany(int[] values) {\n      Program.LinkedList current = this;\n      while (current.Next != null) {\n        current = current.Next;\n      }\n      foreach (int value in values) {\n        current.Next = new Program.LinkedList(value);\n        current = current.Next;\n      }\n    }\n\n    public List<int> getNodesInArray() {\n      List<int> nodes = new List<int>();\n      Program.LinkedList current = this;\n      while (current != null) {\n        nodes.Add(current.Value);\n        current = current.Next;\n      }\n      return nodes;\n    }\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    TestLinkedList test = new TestLinkedList(0);\n    test.addMany(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });\n    int[] expected = { 0, 1, 2, 3, 4, 5, 7, 8, 9 };\n    Program.RemoveKthNodeFromEnd(test, 4);\n    Utils.AssertTrue(compare(test.getNodesInArray(), expected));\n  }\n\n  public bool compare(List<int> arr1, int[] arr2) {\n    if (arr1.Count != arr2.Length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.Count; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public class TestLinkedList : Program.LinkedList {\n    public TestLinkedList(int value) : base(value) {}\n\n    public void addMany(int[] values) {\n      Program.LinkedList current = this;\n      while (current.Next != null) {\n        current = current.Next;\n      }\n      foreach (int value in values) {\n        current.Next = new Program.LinkedList(value);\n        current = current.Next;\n      }\n    }\n\n    public List<int> getNodesInArray() {\n      List<int> nodes = new List<int>();\n      Program.LinkedList current = this;\n      while (current != null) {\n        nodes.Add(current.Value);\n        current = current.Next;\n      }\n      return nodes;\n    }\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\nfunc RemoveKthNodeFromEnd(head *LinkedList, k int) {\n\t// Write your code here.\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\n// O(n) time | O(1) space\nfunc RemoveKthNodeFromEnd(head *LinkedList, k int) {\n\tcounter, first, second := 1, head, head\n\tfor counter <= k {\n\t\tsecond = second.Next\n\t\tcounter += 1\n\t}\n\tif second == nil {\n\t\thead.Value = head.Next.Value\n\t\thead.Next = head.Next.Next\n\t\treturn\n\t}\n\tfor second.Next != nil {\n\t\tsecond = second.Next\n\t\tfirst = first.Next\n\t}\n\tfirst.Next = first.Next.Next\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc NewLinkedList(root int, children ...int) *LinkedList {\n\tll := &LinkedList{root, nil}\n\tll.Add(children...)\n\treturn ll\n}\n\nfunc (ll *LinkedList) Add(values ...int) {\n\tcurrent := ll\n\tfor current.Next != nil {\n\t\tcurrent = current.Next\n\t}\n\tfor _, value := range values {\n\t\tcurrent.Next = &LinkedList{value, nil}\n\t\tcurrent = current.Next\n\t}\n}\n\nfunc (ll *LinkedList) ToArray() []int {\n\toutput, current := []int{ll.Value}, ll\n\tfor current.Next != nil {\n\t\tcurrent = current.Next\n\t\toutput = append(output, current.Value)\n\t}\n\treturn output\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tll := NewLinkedList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n\tRemoveKthNodeFromEnd(ll, 4)\n\toutput, expected := ll.ToArray(), []int{0, 1, 2, 3, 4, 5, 7, 8, 9}\n\trequire.Equal(t, expected, output)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc NewLinkedList(root int, children ...int) *LinkedList {\n\tll := &LinkedList{root, nil}\n\tll.Add(children...)\n\treturn ll\n}\n\nfunc (ll *LinkedList) Add(values ...int) {\n\tcurrent := ll\n\tfor current.Next != nil {\n\t\tcurrent = current.Next\n\t}\n\tfor _, value := range values {\n\t\tcurrent.Next = &LinkedList{value, nil}\n\t\tcurrent = current.Next\n\t}\n}\n\nfunc (ll *LinkedList) ToArray() []int {\n\toutput, current := []int{ll.Value}, ll\n\tfor current.Next != nil {\n\t\tcurrent = current.Next\n\t\toutput = append(output, current.Value)\n\t}\n\treturn output\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tll := NewLinkedList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n\tRemoveKthNodeFromEnd(ll, 4)\n\toutput, expected := ll.ToArray(), []int{0, 1, 2, 3, 4, 5, 7, 8, 9}\n\trequire.Equal(t, expected, output)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static void removeKthNodeFromEnd(LinkedList head, int k) {\n    // Write your code here.\n  }\n\n  static class LinkedList {\n    int value;\n    LinkedList next = null;\n\n    public LinkedList(int value) {\n      this.value = value;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space\n  public static void removeKthNodeFromEnd(LinkedList head, int k) {\n    int counter = 1;\n    LinkedList first = head;\n    LinkedList second = head;\n    while (counter <= k) {\n      second = second.next;\n      counter++;\n    }\n    if (second == null) {\n      head.value = head.next.value;\n      head.next = head.next.next;\n      return;\n    }\n    while (second.next != null) {\n      second = second.next;\n      first = first.next;\n    }\n    first.next = first.next.next;\n  }\n\n  static class LinkedList {\n    int value;\n    LinkedList next = null;\n\n    public LinkedList(int value) {\n      this.value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    TestLinkedList test = new TestLinkedList(0);\n    test.addMany(new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9});\n    int[] expected = {0, 1, 2, 3, 4, 5, 7, 8, 9};\n    Program.removeKthNodeFromEnd(test, 4);\n    Utils.assertTrue(compare(test.getNodesInArray(), expected));\n  }\n\n  public boolean compare(List<Integer> arr1, int[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  class TestLinkedList extends Program.LinkedList {\n    public TestLinkedList(int value) {\n      super(value);\n    }\n\n    public void addMany(int[] values) {\n      Program.LinkedList current = this;\n      while (current.next != null) {\n        current = current.next;\n      }\n      for (int value : values) {\n        current.next = new Program.LinkedList(value);\n        current = current.next;\n      }\n    }\n\n    public List<Integer> getNodesInArray() {\n      List<Integer> nodes = new ArrayList<Integer>();\n      Program.LinkedList current = this;\n      while (current != null) {\n        nodes.add(current.value);\n        current = current.next;\n      }\n      return nodes;\n    }\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    TestLinkedList test = new TestLinkedList(0);\n    test.addMany(new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9});\n    int[] expected = {0, 1, 2, 3, 4, 5, 7, 8, 9};\n    Program.removeKthNodeFromEnd(test, 4);\n    Utils.assertTrue(compare(test.getNodesInArray(), expected));\n  }\n\n  public boolean compare(List<Integer> arr1, int[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  class TestLinkedList extends Program.LinkedList {\n    public TestLinkedList(int value) {\n      super(value);\n    }\n\n    public void addMany(int[] values) {\n      Program.LinkedList current = this;\n      while (current.next != null) {\n        current = current.next;\n      }\n      for (int value : values) {\n        current.next = new Program.LinkedList(value);\n        current = current.next;\n      }\n    }\n\n    public List<Integer> getNodesInArray() {\n      List<Integer> nodes = new ArrayList<Integer>();\n      Program.LinkedList current = this;\n      while (current != null) {\n        nodes.add(current.value);\n        current = current.next;\n      }\n      return nodes;\n    }\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction removeKthNodeFromEnd(head, k) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.removeKthNodeFromEnd = removeKthNodeFromEnd;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space\nfunction removeKthNodeFromEnd(head, k) {\n  let counter = 1;\n  let first = head;\n  let second = head;\n  while (counter <= k) {\n    second = second.next;\n    counter++;\n  }\n  if (second === null) {\n    head.value = head.next.value;\n    head.next = head.next.next;\n    return;\n  }\n  while (second.next !== null) {\n    second = second.next;\n    first = first.next;\n  }\n  first.next = first.next.next;\n}\n\nexports.LinkedList = LinkedList;\nexports.removeKthNodeFromEnd = removeKthNodeFromEnd;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const test = new LinkedList(0).addMany([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n  const expected = new LinkedList(0).addMany([1, 2, 3, 4, 5, 7, 8, 9]);\n  program.removeKthNodeFromEnd(test, 4);\n  chai.expect(test.getNodesInArray()).to.deep.equal(expected.getNodesInArray());\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const test = new LinkedList(0).addMany([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n  const expected = new LinkedList(0).addMany([1, 2, 3, 4, 5, 7, 8, 9]);\n  program.removeKthNodeFromEnd(test, 4);\n  chai.expect(test.getNodesInArray()).to.deep.equal(expected.getNodesInArray());\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\nfun removeKthNodeFromEnd(head: LinkedList, k: Int) {\n    // Write your code here.\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfun removeKthNodeFromEnd(head: LinkedList, k: Int) {\n    var counter = 1\n    var first = head\n    var second: LinkedList? = head\n    while (counter <= k) {\n        second = second!!.next\n        counter++\n    }\n    if (second == null) {\n        head.value = head.next!!.value\n        head.next = head.next!!.next\n        return\n    }\n    while (second!!.next != null) {\n        second = second.next\n        first = first.next!!\n    }\n    first.next = first.next!!.next\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.LinkedList as LinkedList\nimport com.algoexpert.program.removeKthNodeFromEnd as removeKthNodeFromEnd\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        var linkedList = LinkedList(0)\n        addAll(linkedList, listOf(1, 2, 3, 4, 5, 6, 7, 8, 9))\n\n        removeKthNodeFromEnd(linkedList, 4)\n        var result = getNodeValuesInArray(linkedList)\n        var expected = listOf(0, 1, 2, 3, 4, 5, 7, 8, 9)\n\n        assert(result == expected)\n    }\n}\n\nfun addAll(ll: LinkedList, values: List<Int>) {\n    var current = ll\n    for (value in values) {\n        val newLL = LinkedList(value)\n        current.next = newLL\n        current = newLL\n    }\n}\n\nfun getNodeValuesInArray(linkedList: LinkedList): List<Int> {\n    var values = mutableListOf<Int>()\n    var current: LinkedList? = linkedList\n    while (current != null) {\n        values.add(current.value)\n        current = current.next\n    }\n    return values\n}\n",
      "unitTests": "import com.algoexpert.program.LinkedList as LinkedList\nimport com.algoexpert.program.removeKthNodeFromEnd as removeKthNodeFromEnd\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        var linkedList = LinkedList(0)\n        addAll(linkedList, listOf(1, 2, 3, 4, 5, 6, 7, 8, 9))\n\n        removeKthNodeFromEnd(linkedList, 4)\n        var result = getNodeValuesInArray(linkedList)\n        var expected = listOf(0, 1, 2, 3, 4, 5, 7, 8, 9)\n\n        assert(result == expected)\n    }\n}\n\nfun addAll(ll: LinkedList, values: List<Int>) {\n    var current = ll\n    for (value in values) {\n        val newLL = LinkedList(value)\n        current.next = newLL\n        current = newLL\n    }\n}\n\nfun getNodeValuesInArray(linkedList: LinkedList): List<Int> {\n    var values = mutableListOf<Int>()\n    var current: LinkedList? = linkedList\n    while (current != null) {\n        values.add(current.value)\n        current = current.next\n    }\n    return values\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\ndef removeKthNodeFromEnd(head, k):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\n# O(n) time | O(1) space\ndef removeKthNodeFromEnd(head, k):\n    counter = 1\n    first = head\n    second = head\n    while counter <= k:\n        second = second.next\n        counter += 1\n    if second is None:\n        head.value = head.next.value\n        head.next = head.next.next\n        return\n    while second.next is not None:\n        second = second.next\n        first = first.next\n    first.next = first.next.next\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass StartLinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\nlinkedListClass = StartLinkedList\nif hasattr(program, \"LinkedList\"):\n    linkedListClass = program.LinkedList\n\n\nclass LinkedList(linkedListClass):\n    def addMany(self, values):\n        current = self\n        while current.next is not None:\n            current = current.next\n        for value in values:\n            current.next = LinkedList(value)\n            current = current.next\n        return self\n\n    def getNodesInArray(self):\n        nodes = []\n        current = self\n        while current is not None:\n            nodes.append(current.value)\n            current = current.next\n        return nodes\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        test = LinkedList(0).addMany([1, 2, 3, 4, 5, 6, 7, 8, 9])\n        expected = LinkedList(0).addMany([1, 2, 3, 4, 5, 7, 8, 9])\n        program.removeKthNodeFromEnd(test, 4)\n        self.assertEqual(test.getNodesInArray(), expected.getNodesInArray())\n",
      "unitTests": "import program\nimport unittest\n\n\nclass StartLinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\nlinkedListClass = StartLinkedList\nif hasattr(program, \"LinkedList\"):\n    linkedListClass = program.LinkedList\n\n\nclass LinkedList(linkedListClass):\n    def addMany(self, values):\n        current = self\n        while current.next is not None:\n            current = current.next\n        for value in values:\n            current.next = LinkedList(value)\n            current = current.next\n        return self\n\n    def getNodesInArray(self):\n        nodes = []\n        current = self\n        while current is not None:\n            nodes.append(current.value)\n            current = current.next\n        return nodes\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        test = LinkedList(0).addMany([1, 2, 3, 4, 5, 6, 7, 8, 9])\n        expected = LinkedList(0).addMany([1, 2, 3, 4, 5, 7, 8, 9])\n        program.removeKthNodeFromEnd(test, 4)\n        self.assertEqual(test.getNodesInArray(), expected.getNodesInArray())\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "# This is an input struct. Do not edit.\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\nclass Program\n  def removeKthNodeFromEnd(linkedList, k)\n    # Write your code here.\n    return nil\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\nclass Program\n  def removeKthNodeFromEnd(linkedList, k)\n    # Write your code here.\n    return nil\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.removeKthNodeFromEnd\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.removeKthNodeFromEnd\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class LinkedList {\n    var value: Int?\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n      next = nil\n    }\n  }\n\n  func removeKthNodeFromEnd(head: LinkedList, k: Int) {\n    // Write your code here.\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class LinkedList {\n    var value: Int?\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n      next = nil\n    }\n  }\n\n  // O(n) time | O(1) space\n  func removeKthNodeFromEnd(head: LinkedList, k: Int) {\n    var counter = 1\n\n    var firstPointer: LinkedList? = head\n    var secondPointer: LinkedList? = head\n\n    while counter <= k {\n      secondPointer = secondPointer?.next\n      counter += 1\n    }\n\n    if secondPointer == nil {\n      head.value = head.next?.value\n      head.next = head.next?.next\n\n      return\n    }\n\n    while secondPointer?.next != nil {\n      firstPointer = firstPointer?.next\n      secondPointer = secondPointer?.next\n    }\n\n    firstPointer?.next = firstPointer?.next?.next\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var test = TestLinkedList(value: 0).addMany(values: [1, 2, 3, 4, 5, 6, 7, 8, 9])\n      var expected = TestLinkedList(value: 0).addMany(values: [1, 2, 3, 4, 5, 7, 8, 9])\n      program.removeKthNodeFromEnd(head: test as Program.LinkedList, k: 4)\n      try assertEqual(expected.getNodesInArray(), test.getNodesInArray())\n    }\n  }\n}\n\nclass TestLinkedList: Program.LinkedList {\n  func addMany(values: [Int]) -> TestLinkedList {\n    var current = self as Program.LinkedList\n\n    while current.next != nil {\n      current = current.next!\n    }\n\n    for value in values {\n      current.next = Program.LinkedList(value: value)\n      current = current.next!\n    }\n\n    return self\n  }\n\n  func getNodesInArray() -> [Int] {\n    var nodes = [Int]()\n\n    var current: Program.LinkedList? = self as Program.LinkedList?\n\n    while current != nil {\n      nodes.append(current!.value!)\n      current = current!.next\n    }\n\n    return nodes\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var test = TestLinkedList(value: 0).addMany(values: [1, 2, 3, 4, 5, 6, 7, 8, 9])\n      var expected = TestLinkedList(value: 0).addMany(values: [1, 2, 3, 4, 5, 7, 8, 9])\n      program.removeKthNodeFromEnd(head: test as Program.LinkedList, k: 4)\n      try assertEqual(expected.getNodesInArray(), test.getNodesInArray())\n    }\n  }\n}\n\nclass TestLinkedList: Program.LinkedList {\n  func addMany(values: [Int]) -> TestLinkedList {\n    var current = self as Program.LinkedList\n\n    while current.next != nil {\n      current = current.next!\n    }\n\n    for value in values {\n      current.next = Program.LinkedList(value: value)\n      current = current.next!\n    }\n\n    return self\n  }\n\n  func getNodesInArray() -> [Int] {\n    var nodes = [Int]()\n\n    var current: Program.LinkedList? = self as Program.LinkedList?\n\n    while current != nil {\n      nodes.append(current!.value!)\n      current = current!.next\n    }\n\n    return nodes\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nexport function removeKthNodeFromEnd(head: LinkedList, k: number) {\n  // Write your code here.\n  return head;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space\nexport function removeKthNodeFromEnd(head: LinkedList, k: number) {\n  let counter = 1;\n  let first: LinkedList = head;\n  let second: LinkedList | null = head;\n  while (counter <= k) {\n    second = second!.next;\n    counter++;\n  }\n  if (second === null) {\n    head.value = head.next!.value;\n    head.next = head.next!.next;\n    return;\n  }\n  while (second.next !== null) {\n    second = second.next;\n    first = first.next!;\n  }\n  first.next = first.next!.next;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nclass LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n\n  addMany(values: number[]): LinkedList {\n    let current: LinkedList = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes: number[] = [];\n    let current: LinkedList | null = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const test = new LinkedList(0).addMany([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n  const expected = new LinkedList(0).addMany([1, 2, 3, 4, 5, 7, 8, 9]);\n  program.removeKthNodeFromEnd(test, 4);\n  chai.expect(test.getNodesInArray()).to.deep.equal(expected.getNodesInArray());\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nclass LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n\n  addMany(values: number[]): LinkedList {\n    let current: LinkedList = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes: number[] = [];\n    let current: LinkedList | null = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const test = new LinkedList(0).addMany([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n  const expected = new LinkedList(0).addMany([1, 2, 3, 4, 5, 7, 8, 9]);\n  program.removeKthNodeFromEnd(test, 4);\n  chai.expect(test.getNodesInArray()).to.deep.equal(expected.getNodesInArray());\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "linkedList",
      "example": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      },
      "schema": {
        "description": "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
        "properties": {
          "head": {
            "type": "string"
          },
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "next": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "next"
              ],
              "type": "object"
            },
            "type": "array"
          }
        },
        "required": [
          "head",
          "nodes"
        ],
        "type": "object"
      }
    },
    {
      "name": "k",
      "example": 4,
      "schema": {
        "minimum": 1,
        "type": "integer"
      }
    }
  ],
  "tests": [
    {
      "k": 4,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 1,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 2,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 3,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 5,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 6,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 7,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 8,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 9,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 10,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    }
  ],
  "jsonTests": [
    {
      "k": 4,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 1,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 2,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 3,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 5,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 6,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 7,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 8,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 9,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    },
    {
      "k": 10,
      "linkedList": {
        "head": "0",
        "nodes": [
          {
            "id": "0",
            "next": "1",
            "value": 0
          },
          {
            "id": "1",
            "next": "2",
            "value": 1
          },
          {
            "id": "2",
            "next": "3",
            "value": 2
          },
          {
            "id": "3",
            "next": "4",
            "value": 3
          },
          {
            "id": "4",
            "next": "5",
            "value": 4
          },
          {
            "id": "5",
            "next": "6",
            "value": 5
          },
          {
            "id": "6",
            "next": "7",
            "value": 6
          },
          {
            "id": "7",
            "next": "8",
            "value": 7
          },
          {
            "id": "8",
            "next": "9",
            "value": 8
          },
          {
            "id": "9",
            "next": null,
            "value": 9
          }
        ]
      }
    }
  ],
  "changelog": []
}