{
  "uid": "repair-bst",
  "testStrategy": "JSON",
  "name": "Repair BST",
  "version": 0,
  "releaseDate": "2023-06-02T00:00:00Z",
  "category": "Binary Search Trees",
  "difficulty": 3,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 820,
    "failureCount": 133
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "834226497",
    "duration": 0,
    "annotations": [],
    "instructor": "Conner Ardman",
    "overviewTime": 0,
    "codeWalkthroughTime": 1179
  },
  "prompt": "<div class=\"html\">\n  <p>\n    You're given a Binary Search Tree (BST) that has at least 2 nodes and that\n    only has nodes with unique values (no duplicate values). Exactly two nodes\n    in the BST have had their values swapped, therefore breaking the BST. Write\n    a function that returns a repaired version of the tree with all values on\n    the correct nodes.\n  </p>\n  <p>\n    Your function can mutate the original tree; you do not need to create a new\n    one. Moreover, the shape of the returned tree should be exactly the same as\n    that of the original input tree.\n  </p>\n  <p>\n    Each <span>BST</span> node has an integer <span>value</span>, a\n    <span>left</span> child node, and a <span>right</span> child node. A node is\n    said to be a valid <span>BST</span> node if and only if it satisfies the BST\n    property: its <span>value</span> is strictly greater than the values of\n    every node to its left; its <span>value</span> is less than or equal to the\n    values of every node to its right; and its children nodes are either valid\n    <span>BST</span> nodes themselves or <span>None</span> / <span>null</span>.\n  </p>\n  <h3>Sample Input</h3>\n  <pre>\n<span class=\"CodeEditor-promptParameter\">tree</span> =    10\n        /     \\\n       7       20\n     /   \\    /  \\\n   3     12  8   22\n  /           \\\n2              14\n</pre>\n  <h3>Sample Output</h3>\n  <pre>\n          10\n        /     \\\n       7       20\n     /   \\    /  \\\n   3      8  12   22\n  /           \\\n2              14\n</pre\n  >\n</div>",
  "hints": [
    "<p>\n  If a binary tree is valid, an in order traversal would return all\n  of the nodes in order.\n</p>\n",
    "\n<p>\n  By doing an in order traversal, you can find the two nodes that\n  are in the incorrect places. Keep track of these nodes and\n  swap their values at the end.\n</p>\n",
    "\n<p>\n  You can keep a global to represent the previous node you saw\n  during the in order traversal. That way with each node you can\n  check if it is in the incorrect place.\n</p>"
  ],
  "spaceTime": "O(n) time | O(h) space - where n is the number of nodes in the tree and h is the height of the tree",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is an input class. Do not edit.\nclass BST {\n public:\n  int value;\n  BST* left = nullptr;\n  BST* right = nullptr;\n\n  BST(int value) { this->value = value; }\n};\n\nBST* repairBst(BST* tree) {\n  // Write your code here.\n  return nullptr;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BST {\n public:\n  int value;\n  BST* left = nullptr;\n  BST* right = nullptr;\n\n  BST(int value) { this->value = value; }\n};\n\nvoid inOrderTraversal(\n  BST* node, BST*& nodeOne, BST*& nodeTwo, BST*& previousNode\n);\n\n// O(n) time | O(h) space - where n is the number of nodes in the\n// tree and h is the height of the tree\nBST* repairBst(BST* tree) {\n  BST* nodeOne = nullptr;\n  BST* nodeTwo = nullptr;\n  BST* previousNode = nullptr;\n  inOrderTraversal(tree, nodeOne, nodeTwo, previousNode);\n  swap(nodeOne->value, nodeTwo->value);\n  return tree;\n}\n\nvoid inOrderTraversal(\n  BST* node, BST*& nodeOne, BST*& nodeTwo, BST*& previousNode\n) {\n  if (node == nullptr) {\n    return;\n  }\n\n  inOrderTraversal(node->left, nodeOne, nodeTwo, previousNode);\n  if (previousNode != nullptr && previousNode->value > node->value) {\n    if (nodeOne == nullptr) {\n      nodeOne = previousNode;\n    }\n    nodeTwo = node;\n  }\n  previousNode = node;\n  inOrderTraversal(node->right, nodeOne, nodeTwo, previousNode);\n}",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <stack>\n\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BST {\n public:\n  int value;\n  BST* left = nullptr;\n  BST* right = nullptr;\n\n  BST(int value) { this->value = value; }\n};\n\n// O(n) time | O(h) space - where n is the number of nodes in the\n// tree and h is the height of the tree\nBST* repairBst(BST* tree) {\n  BST* nodeOne = nullptr;\n  BST* nodeTwo = nullptr;\n  BST* previousNode = nullptr;\n\n  stack<BST*> st;\n  BST* currentNode = tree;\n  while (currentNode != nullptr || !st.empty()) {\n    while (currentNode != nullptr) {\n      st.push(currentNode);\n      currentNode = currentNode->left;\n    }\n    currentNode = st.top();\n    st.pop();\n\n    if (previousNode != nullptr && previousNode->value > currentNode->value) {\n      if (nodeOne == nullptr) {\n        nodeOne = previousNode;\n      }\n      nodeTwo = currentNode;\n    }\n\n    previousNode = currentNode;\n    currentNode = currentNode->right;\n  }\n\n  swap(nodeOne->value, nodeTwo->value);\n\n  return tree;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nvoid inOrderTraverse(BST* tree, vector<int>& array) {\n  if (tree->left != nullptr) {\n    inOrderTraverse(tree->left, array);\n  }\n  array.push_back(tree->value);\n  if (tree->right != nullptr) {\n    inOrderTraverse(tree->right, array);\n  }\n}\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BST* tree = new BST(2);\n      tree->left = new BST(1);\n      tree->right = new BST(3);\n      tree->left->left = new BST(4);\n      tree->right->right = new BST(0);\n      vector<int> expected = {0, 1, 2, 3, 4};\n      BST* actual = repairBst(tree);\n      vector<int> actualArray;\n      inOrderTraverse(actual, actualArray);\n      assert(actualArray == expected);\n    });\n  }\n};\n",
      "unitTests": "void inOrderTraverse(BST* tree, vector<int>& array) {\n  if (tree->left != nullptr) {\n    inOrderTraverse(tree->left, array);\n  }\n  array.push_back(tree->value);\n  if (tree->right != nullptr) {\n    inOrderTraverse(tree->right, array);\n  }\n}\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BST* tree = new BST(2);\n      tree->left = new BST(1);\n      tree->right = new BST(3);\n      tree->left->left = new BST(4);\n      tree->right->right = new BST(0);\n      vector<int> expected = {0, 1, 2, 3, 4};\n      BST* actual = repairBst(tree);\n      vector<int> actualArray;\n      inOrderTraverse(actual, actualArray);\n      assert(actualArray == expected);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  public BST RepairBst(BST tree) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  private BST nodeOne = null, nodeTwo = null, previousNode = null;\n\n  // O(n) time | O(h) space - where n is the number of nodes in the\n  // tree and h is the height of the tree\n  public BST RepairBst(BST tree) {\n    this.inOrderTraversal(tree);\n    int tempNodeOneValue = nodeOne.value;\n    nodeOne.value = nodeTwo.value;\n    nodeTwo.value = tempNodeOneValue;\n\n    return tree;\n  }\n\n  private void inOrderTraversal(BST node) {\n    if (node == null) {\n      return;\n    }\n\n    inOrderTraversal(node.left);\n\n    if (this.previousNode != null && this.previousNode.value > node.value) {\n      if (this.nodeOne == null) {\n        this.nodeOne = this.previousNode;\n      }\n      this.nodeTwo = node;\n    }\n\n    this.previousNode = node;\n    inOrderTraversal(node.right);\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the\n  // tree and h is the height of the tree\n  public BST RepairBst(BST tree) {\n    BST nodeOne = null, nodeTwo = null, previousNode = null;\n\n    Stack<BST> stack = new Stack<BST>();\n    BST currentNode = tree;\n    while (currentNode != null || stack.Count > 0) {\n      while (currentNode != null) {\n        stack.Push(currentNode);\n        currentNode = currentNode.left;\n      }\n      currentNode = stack.Pop();\n\n      if (previousNode != null && previousNode.value > currentNode.value) {\n        if (nodeOne == null) {\n          nodeOne = previousNode;\n        }\n        nodeTwo = currentNode;\n      }\n\n      previousNode = currentNode;\n      currentNode = currentNode.right;\n    }\n\n    int tempNodeOneValue = nodeOne.value;\n    nodeOne.value = nodeTwo.value;\n    nodeTwo.value = tempNodeOneValue;\n\n    return tree;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.BST tree = new Program.BST(2);\n    tree.left = new Program.BST(1);\n    tree.right = new Program.BST(3);\n    tree.left.left = new Program.BST(4);\n    tree.right.right = new Program.BST(0);\n    List<int> expected = new List<int> { 0, 1, 2, 3, 4 };\n    List<int> actual =\n      inOrderTraverse(new Program().RepairBst(tree), new List<int>());\n    Utils.AssertTrue(Enumerable.SequenceEqual(actual, expected));\n  }\n\n  private static List<int> inOrderTraverse(Program.BST tree, List<int> array) {\n    if (tree.left != null) {\n      inOrderTraverse(tree.left, array);\n    }\n    array.Add(tree.value);\n    if (tree.right != null) {\n      inOrderTraverse(tree.right, array);\n    }\n    return array;\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.BST tree = new Program.BST(2);\n    tree.left = new Program.BST(1);\n    tree.right = new Program.BST(3);\n    tree.left.left = new Program.BST(4);\n    tree.right.right = new Program.BST(0);\n    List<int> expected = new List<int> { 0, 1, 2, 3, 4 };\n    List<int> actual =\n      inOrderTraverse(new Program().RepairBst(tree), new List<int>());\n    Utils.AssertTrue(Enumerable.SequenceEqual(actual, expected));\n  }\n\n  private static List<int> inOrderTraverse(Program.BST tree, List<int> array) {\n    if (tree.left != null) {\n      inOrderTraverse(tree.left, array);\n    }\n    array.Add(tree.value);\n    if (tree.right != null) {\n      inOrderTraverse(tree.right, array);\n    }\n    return array;\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is an input class. Do not edit.\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\nfunc RepairBst(tree *BST) *BST {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the\n// tree and h is the height of the tree\nfunc RepairBst(tree *BST) *BST {\n\tvar nodeOne *BST\n\tvar nodeTwo *BST\n\tvar previousNode *BST\n\n\tvar inOrderTraversal func(node *BST)\n\tinOrderTraversal = func(node *BST) {\n\t\tif node == nil {\n\t\t\treturn\n\t\t}\n\n\t\tinOrderTraversal(node.Left)\n\t\tif previousNode != nil && previousNode.Value > node.Value {\n\t\t\tif nodeOne == nil {\n\t\t\t\tnodeOne = previousNode\n\t\t\t}\n\t\t\tnodeTwo = node\n\t\t}\n\n\t\tpreviousNode = node\n\t\tinOrderTraversal(node.Right)\n\t}\n\n\tinOrderTraversal(tree)\n\n\tnodeOne.Value, nodeTwo.Value = nodeTwo.Value, nodeOne.Value\n\treturn tree\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the\n// tree and h is the height of the tree\nfunc RepairBst(tree *BST) *BST {\n\tvar nodeOne *BST\n\tvar nodeTwo *BST\n\tvar previousNode *BST\n\n\tstack := []*BST{}\n\tcurrentNode := tree\n\tfor currentNode != nil || len(stack) > 0 {\n\t\tfor currentNode != nil {\n\t\t\tstack = append(stack, currentNode)\n\t\t\tcurrentNode = currentNode.Left\n\t\t}\n\t\tcurrentNode = stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\n\t\tif previousNode != nil && previousNode.Value > currentNode.Value {\n\t\t\tif nodeOne == nil {\n\t\t\t\tnodeOne = previousNode\n\t\t\t}\n\t\t\tnodeTwo = currentNode\n\t\t}\n\n\t\tpreviousNode = currentNode\n\t\tcurrentNode = currentNode.Right\n\t}\n\n\tnodeOne.Value, nodeTwo.Value = nodeTwo.Value, nodeOne.Value\n\treturn tree\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\ttree := &BST{Value: 2}\n\ttree.Left = &BST{Value: 1}\n\ttree.Right = &BST{Value: 3}\n\ttree.Left.Left = &BST{Value: 4}\n\ttree.Right.Right = &BST{Value: 0}\n\texpected := []int{0, 1, 2, 3, 4}\n\tactual := inOrderTraverse(RepairBst(tree), nil)\n\trequire.Equal(t, expected, actual)\n}\n\nfunc inOrderTraverse(tree *BST, array []int) []int {\n\tif tree == nil {\n\t\treturn array\n\t}\n\tarray = inOrderTraverse(tree.Left, array)\n\tarray = append(array, tree.Value)\n\tarray = inOrderTraverse(tree.Right, array)\n\treturn array\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\ttree := &BST{Value: 2}\n\ttree.Left = &BST{Value: 1}\n\ttree.Right = &BST{Value: 3}\n\ttree.Left.Left = &BST{Value: 4}\n\ttree.Right.Right = &BST{Value: 0}\n\texpected := []int{0, 1, 2, 3, 4}\n\tactual := inOrderTraverse(RepairBst(tree), nil)\n\trequire.Equal(t, expected, actual)\n}\n\nfunc inOrderTraverse(tree *BST, array []int) []int {\n\tif tree == nil {\n\t\treturn array\n\t}\n\tarray = inOrderTraverse(tree.Left, array)\n\tarray = append(array, tree.Value)\n\tarray = inOrderTraverse(tree.Right, array)\n\treturn array\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  public BST repairBst(BST tree) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  private BST nodeOne = null, nodeTwo = null, previousNode = null;\n\n  // O(n) time | O(h) space - where n is the number of nodes in the\n  // tree and h is the height of the tree\n  public BST repairBst(BST tree) {\n    this.inOrderTraversal(tree);\n    int tempNodeOneValue = nodeOne.value;\n    nodeOne.value = nodeTwo.value;\n    nodeTwo.value = tempNodeOneValue;\n\n    return tree;\n  }\n\n  private void inOrderTraversal(BST node) {\n    if (node == null) {\n      return;\n    }\n\n    inOrderTraversal(node.left);\n\n    if (this.previousNode != null && this.previousNode.value > node.value) {\n      if (this.nodeOne == null) {\n        this.nodeOne = this.previousNode;\n      }\n      this.nodeTwo = node;\n    }\n\n    this.previousNode = node;\n    inOrderTraversal(node.right);\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the\n  // tree and h is the height of the tree\n  public BST repairBst(BST tree) {\n    BST nodeOne = null, nodeTwo = null, previousNode = null;\n\n    Stack<BST> stack = new Stack<BST>();\n    BST currentNode = tree;\n    while (currentNode != null || !stack.isEmpty()) {\n      while (currentNode != null) {\n        stack.push(currentNode);\n        currentNode = currentNode.left;\n      }\n      currentNode = stack.pop();\n\n      if (previousNode != null && previousNode.value > currentNode.value) {\n        if (nodeOne == null) {\n          nodeOne = previousNode;\n        }\n        nodeTwo = currentNode;\n      }\n\n      previousNode = currentNode;\n      currentNode = currentNode.right;\n    }\n\n    int tempNodeOneValue = nodeOne.value;\n    nodeOne.value = nodeTwo.value;\n    nodeTwo.value = tempNodeOneValue;\n\n    return tree;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.BST tree = new Program.BST(2);\n    tree.left = new Program.BST(1);\n    tree.right = new Program.BST(3);\n    tree.left.left = new Program.BST(4);\n    tree.right.right = new Program.BST(0);\n    List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4);\n    List<Integer> actual =\n      inOrderTraverse(new Program().repairBst(tree), new ArrayList<Integer>());\n    Utils.assertEquals(actual, expected);\n  }\n\n  private static List<Integer> inOrderTraverse(\n    Program.BST tree, List<Integer> array\n  ) {\n    if (tree.left != null) {\n      inOrderTraverse(tree.left, array);\n    }\n    array.add(tree.value);\n    if (tree.right != null) {\n      inOrderTraverse(tree.right, array);\n    }\n    return array;\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.BST tree = new Program.BST(2);\n    tree.left = new Program.BST(1);\n    tree.right = new Program.BST(3);\n    tree.left.left = new Program.BST(4);\n    tree.right.right = new Program.BST(0);\n    List<Integer> expected = Arrays.asList(0, 1, 2, 3, 4);\n    List<Integer> actual =\n      inOrderTraverse(new Program().repairBst(tree), new ArrayList<Integer>());\n    Utils.assertEquals(actual, expected);\n  }\n\n  private static List<Integer> inOrderTraverse(\n    Program.BST tree, List<Integer> array\n  ) {\n    if (tree.left != null) {\n      inOrderTraverse(tree.left, array);\n    }\n    array.add(tree.value);\n    if (tree.right != null) {\n      inOrderTraverse(tree.right, array);\n    }\n    return array;\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.BST = BST;\n\nfunction repairBst(tree) {\n  // Write your code here.\n  return null;\n}\n\n// Do not edit the line below.\nexports.repairBst = repairBst;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the\n// tree and h is the height of the tree\nfunction repairBst(tree) {\n  let nodeOne = null;\n  let nodeTwo = null;\n  let previousNode = null;\n\n  function inOrderTraversal(node) {\n    if (node === null) return;\n\n    inOrderTraversal(node.left);\n\n    if (previousNode !== null && previousNode.value > node.value) {\n      if (nodeOne === null) nodeOne = previousNode;\n      nodeTwo = node;\n    }\n\n    previousNode = node;\n    inOrderTraversal(node.right);\n  }\n\n  inOrderTraversal(tree);\n\n  const temp = nodeOne.value;\n  nodeOne.value = nodeTwo.value;\n  nodeTwo.value = temp;\n  return tree;\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.repairBst = repairBst;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the\n// tree and h is the height of the tree\nfunction repairBst(tree) {\n  let nodeOne = null;\n  let nodeTwo = null;\n  let previousNode = null;\n\n  const stack = [];\n  let currentNode = tree;\n  while (currentNode !== null || stack.length > 0) {\n    while (currentNode !== null) {\n      stack.push(currentNode);\n      currentNode = currentNode.left;\n    }\n    currentNode = stack.pop();\n\n    if (previousNode !== null && previousNode.value > currentNode.value) {\n      if (nodeOne === null) nodeOne = previousNode;\n      nodeTwo = currentNode;\n    }\n\n    previousNode = currentNode;\n    currentNode = currentNode.right;\n  }\n\n  const temp = nodeOne.value;\n  nodeOne.value = nodeTwo.value;\n  nodeTwo.value = temp;\n  return tree;\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.repairBst = repairBst;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree = new program.BST(2);\n  tree.left = new program.BST(1);\n  tree.right = new program.BST(3);\n  tree.left.left = new program.BST(4);\n  tree.right.right = new program.BST(0);\n  const expected = [0, 1, 2, 3, 4];\n  const actual = inOrderTraverse(program.repairBst(tree), []);\n  chai.expect(actual).to.deep.equal(expected);\n});\n\nfunction inOrderTraverse(tree, array) {\n  if (tree !== null) {\n    inOrderTraverse(tree.left, array);\n    array.push(tree.value);\n    inOrderTraverse(tree.right, array);\n  }\n  return array;\n}\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree = new program.BST(2);\n  tree.left = new program.BST(1);\n  tree.right = new program.BST(3);\n  tree.left.left = new program.BST(4);\n  tree.right.right = new program.BST(0);\n  const expected = [0, 1, 2, 3, 4];\n  const actual = inOrderTraverse(program.repairBst(tree), []);\n  chai.expect(actual).to.deep.equal(expected);\n});\n\nfunction inOrderTraverse(tree, array) {\n  if (tree !== null) {\n    inOrderTraverse(tree.left, array);\n    array.push(tree.value);\n    inOrderTraverse(tree.right, array);\n  }\n  return array;\n}\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BST(value: Int) {\n    var value = value\n    var left: BST? = null\n    var right: BST? = null\n}\n\nfun repairBst(tree: BST): BST {\n    // Write your code here.\n    return BST(-1)\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BST(value: Int) {\n    var value = value\n    var left: BST? = null\n    var right: BST? = null\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the\n// tree and h is the height of the tree\nfun repairBst(tree: BST): BST {\n    var nodeOne: BST? = null\n    var nodeTwo: BST? = null\n    var previousNode: BST? = null\n\n    fun inOrderTraversal(node: BST?) {\n        if (node == null) return\n\n        inOrderTraversal(node.left)\n\n        if (previousNode != null && previousNode!!.value > node.value) {\n            if (nodeOne == null) nodeOne = previousNode\n            nodeTwo = node\n        }\n\n        previousNode = node\n        inOrderTraversal(node.right)\n    }\n\n    inOrderTraversal(tree)\n\n    val temp = nodeOne!!.value\n    nodeOne!!.value = nodeTwo!!.value\n    nodeTwo!!.value = temp\n    return tree\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport java.util.Stack\n\n// This is an input class. Do not edit.\nopen class BST(value: Int) {\n    var value = value\n    var left: BST? = null\n    var right: BST? = null\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the\n// tree and h is the height of the tree\nfun repairBst(tree: BST): BST {\n    var nodeOne: BST? = null\n    var nodeTwo: BST? = null\n    var previousNode: BST? = null\n\n    val stack = Stack<BST>()\n    var currentNode: BST? = tree\n    while (currentNode != null || stack.size > 0) {\n        while (currentNode != null) {\n            stack.push(currentNode)\n            currentNode = currentNode.left\n        }\n        currentNode = stack.pop()\n\n        if (previousNode != null && previousNode.value > currentNode.value) {\n            if (nodeOne === null) nodeOne = previousNode\n            nodeTwo = currentNode\n        }\n\n        previousNode = currentNode\n        currentNode = currentNode.right\n    }\n\n    val temp = nodeOne!!.value\n    nodeOne!!.value = nodeTwo!!.value\n    nodeTwo!!.value = temp\n    return tree\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.repairBst\nimport com.algoexpert.program.BST as BST\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree = BST(2)\n        tree.left = BST(1)\n        tree.right = BST(3)\n        tree.left!!.left = BST(4)\n        tree.right!!.right = BST(0)\n        val expected = listOf(0, 1, 2, 3, 4)\n        val output = inOrderTraverse(repairBst(tree), mutableListOf<Int>())\n        assert(expected == output)\n    }\n}\n\nfun inOrderTraverse(tree: BST?, array: MutableList<Int>): List<Int> {\n    if (tree != null) {\n        inOrderTraverse(tree.left, array)\n        array.add(tree.value)\n        inOrderTraverse(tree.right, array)\n    }\n    return array\n}\n",
      "unitTests": "import com.algoexpert.program.repairBst\nimport com.algoexpert.program.BST as BST\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree = BST(2)\n        tree.left = BST(1)\n        tree.right = BST(3)\n        tree.left!!.left = BST(4)\n        tree.right!!.right = BST(0)\n        val expected = listOf(0, 1, 2, 3, 4)\n        val output = inOrderTraverse(repairBst(tree), mutableListOf<Int>())\n        assert(expected == output)\n    }\n}\n\nfun inOrderTraverse(tree: BST?, array: MutableList<Int>): List<Int> {\n    if (tree != null) {\n        inOrderTraverse(tree.left, array)\n        array.add(tree.value)\n        inOrderTraverse(tree.right, array)\n    }\n    return array\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass BST:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef repairBst(tree):\n    # Write your code here.\n    return None\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BST:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# O(n) time | O(h) space - where n is the number of nodes in the\n# tree and h is the height of the tree\ndef repairBst(tree):\n    nodeOne = nodeTwo = previousNode = None\n\n    def inOrderTraversal(node):\n        nonlocal nodeOne, nodeTwo, previousNode\n        if node is None:\n            return\n\n        inOrderTraversal(node.left)\n\n        if previousNode is not None and previousNode.value > node.value:\n            if nodeOne is None:\n                nodeOne = previousNode\n            nodeTwo = node\n\n        previousNode = node\n        inOrderTraversal(node.right)\n\n    inOrderTraversal(tree)\n\n    nodeOne.value, nodeTwo.value = nodeTwo.value, nodeOne.value\n    return tree\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BST:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# O(n) time | O(h) space - where n is the number of nodes in the\n# tree and h is the height of the tree\ndef repairBst(tree):\n    nodeOne = nodeTwo = previousNode = None\n\n    stack = []\n    currentNode = tree\n    while currentNode is not None or len(stack) > 0:\n        while currentNode is not None:\n            stack.append(currentNode)\n            currentNode = currentNode.left\n        currentNode = stack.pop()\n\n        if previousNode is not None and previousNode.value > currentNode.value:\n            if nodeOne is None:\n                nodeOne = previousNode\n            nodeTwo = currentNode\n\n        previousNode = currentNode\n        currentNode = currentNode.right\n\n    nodeOne.value, nodeTwo.value = nodeTwo.value, nodeOne.value\n    return tree\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass BST:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        tree = BST(2)\n        tree.left = BST(1)\n        tree.right = BST(3)\n        tree.left.left = BST(4)\n        tree.right.right = BST(0)\n        expected = [0, 1, 2, 3, 4]\n        actual = inOrderTraverse(program.repairBst(tree), [])\n        self.assertEqual(actual, expected)\n\n\ndef inOrderTraverse(tree, array):\n    if tree is not None:\n        inOrderTraverse(tree.left, array)\n        array.append(tree.value)\n        inOrderTraverse(tree.right, array)\n    return array\n",
      "unitTests": "import program\nimport unittest\n\n\nclass BST:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        tree = BST(2)\n        tree.left = BST(1)\n        tree.right = BST(3)\n        tree.left.left = BST(4)\n        tree.right.right = BST(0)\n        expected = [0, 1, 2, 3, 4]\n        actual = inOrderTraverse(program.repairBst(tree), [])\n        self.assertEqual(actual, expected)\n\n\ndef inOrderTraverse(tree, array):\n    if tree is not None:\n        inOrderTraverse(tree.left, array)\n        array.append(tree.value)\n        inOrderTraverse(tree.right, array)\n    return array\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "# This is an input struct. Do not edit.\nclass BST\n    attr_accessor :value\n    attr_accessor :left\n    attr_accessor :right\n\n    def initialize(value)\n        @value = value\n        @left = nil\n        @right = nil\n    end\nend\n\n\nclass Program\n    def repairBst(tree)\n        # Write your code here.\n        return nil\n    end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BST\n    attr_accessor :value\n    attr_accessor :left\n    attr_accessor :right\n\n    def initialize(value)\n        @value = value\n        @left = nil\n        @right = nil\n    end\nend\n\n\nclass Program\n    def repairBst(tree)\n        # Write your code here.\n        return nil\n    end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire './program.rb'\n\nclass TestSuite\n    include Assertions\n    def test_1\n        # inputs = ...\n        # output = Program.new.repairBst\n        # expected = ...\n        # assertEqual(expected, output)\n    end\nend\n\n",
      "unitTests": "require './program.rb'\n\nclass TestSuite\n    include Assertions\n    def test_1\n        # inputs = ...\n        # output = Program.new.repairBst\n        # expected = ...\n        # assertEqual(expected, output)\n    end\nend\n\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  func repairBst(_ tree: BST) -> BST {\n    // Write your code here.\n    return BST(value: -1)\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the\n  // tree and h is the height of the tree\n  func repairBst(_ tree: BST) -> BST {\n    var nodeOne: BST?\n    var nodeTwo: BST?\n    var previousNode: BST?\n\n    func inOrderTraversal(_ node: BST?) {\n      guard let node = node else { return }\n\n      inOrderTraversal(node.left)\n\n      if let previous = previousNode, previous.value > node.value {\n        if nodeOne == nil {\n          nodeOne = previous\n        }\n        nodeTwo = node\n      }\n\n      previousNode = node\n      inOrderTraversal(node.right)\n    }\n\n    inOrderTraversal(tree)\n\n    let temp = nodeOne!.value\n    nodeOne!.value = nodeTwo!.value\n    nodeTwo!.value = temp\n    return tree\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the\n  // tree and h is the height of the tree\n  func repairBst(_ tree: BST) -> BST {\n    var nodeOne: BST?\n    var nodeTwo: BST?\n    var previousNode: BST?\n\n    var stack: [BST] = []\n    var currentNode: BST? = tree\n    while currentNode != nil || !stack.isEmpty {\n      while currentNode != nil {\n        stack.append(currentNode!)\n        currentNode = currentNode!.left\n      }\n      currentNode = stack.removeLast()\n\n      if let previous = previousNode, previous.value > currentNode!.value {\n        if nodeOne == nil {\n          nodeOne = previous\n        }\n        nodeTwo = currentNode\n      }\n\n      previousNode = currentNode\n      currentNode = currentNode!.right\n    }\n\n    (nodeOne!.value, nodeTwo!.value) = (nodeTwo!.value, nodeOne!.value)\n    return tree\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      var tree = Program.BST(value: 2)\n      tree.left = Program.BST(value: 1)\n      tree.right = Program.BST(value: 3)\n      tree.left!.left = Program.BST(value: 4)\n      tree.right!.right = Program.BST(value: 0)\n      var expected = [0, 1, 2, 3, 4]\n      var actual = inOrderTraverse(Program().repairBst(tree), [])\n      try assertEqual(expected, actual)\n    }\n  }\n\n  func inOrderTraverse(_ tree: Program.BST?, _ array: [Int]) -> [Int] {\n    if tree == nil {\n      return array\n    }\n    var array = inOrderTraverse(tree!.left, array)\n    array.append(tree!.value)\n    array = inOrderTraverse(tree!.right, array)\n    return array\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      var tree = Program.BST(value: 2)\n      tree.left = Program.BST(value: 1)\n      tree.right = Program.BST(value: 3)\n      tree.left!.left = Program.BST(value: 4)\n      tree.right!.right = Program.BST(value: 0)\n      var expected = [0, 1, 2, 3, 4]\n      var actual = inOrderTraverse(Program().repairBst(tree), [])\n      try assertEqual(expected, actual)\n    }\n  }\n\n  func inOrderTraverse(_ tree: Program.BST?, _ array: [Int]) -> [Int] {\n    if tree == nil {\n      return array\n    }\n    var array = inOrderTraverse(tree!.left, array)\n    array.append(tree!.value)\n    array = inOrderTraverse(tree!.right, array)\n    return array\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport function repairBst(tree: BST) {\n  // Write your code here.\n  return null;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the\n// tree and h is the height of the tree\nexport function repairBst(tree: BST) {\n  let nodeOne: BST | null = null;\n  let nodeTwo: BST | null = null;\n  let previousNode: BST | null = null;\n\n  function inOrderTraversal(node: BST | null) {\n    if (node === null) return;\n\n    inOrderTraversal(node.left);\n\n    if (previousNode !== null && previousNode.value > node.value) {\n      if (nodeOne === null) nodeOne = previousNode;\n      nodeTwo = node;\n    }\n\n    previousNode = node;\n    inOrderTraversal(node.right);\n  }\n\n  inOrderTraversal(tree);\n\n  const temp = nodeOne!.value;\n  nodeOne!.value = nodeTwo!.value;\n  nodeTwo!.value = temp;\n  return tree;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the\n// tree and h is the height of the tree\nexport function repairBst(tree: BST) {\n  let nodeOne: BST | null = null;\n  let nodeTwo: BST | null = null;\n  let previousNode: BST | null = null;\n\n  const stack: BST[] = [];\n  let currentNode: BST | null = tree;\n  while (currentNode !== null || stack.length > 0) {\n    while (currentNode !== null) {\n      stack.push(currentNode);\n      currentNode = currentNode.left;\n    }\n    currentNode = stack.pop()!;\n\n    if (previousNode !== null && previousNode.value > currentNode.value) {\n      if (nodeOne === null) nodeOne = previousNode;\n      nodeTwo = currentNode;\n    }\n\n    previousNode = currentNode;\n    currentNode = currentNode.right;\n  }\n\n  const temp = nodeOne!.value;\n  nodeOne!.value = nodeTwo!.value;\n  nodeTwo!.value = temp;\n  return tree;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const tree = new program.BST(2);\n  tree.left = new program.BST(1);\n  tree.right = new program.BST(3);\n  tree.left.left = new program.BST(4);\n  tree.right.right = new program.BST(0);\n  const expected = [0, 1, 2, 3, 4];\n  const actual = inOrderTraverse(program.repairBst(tree), []);\n  chai.expect(actual).to.deep.equal(expected);\n});\n\nfunction inOrderTraverse(tree: program.BST | null, array: number[]) {\n  if (tree !== null) {\n    inOrderTraverse(tree.left, array);\n    array.push(tree.value);\n    inOrderTraverse(tree.right, array);\n  }\n  return array;\n}\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const tree = new program.BST(2);\n  tree.left = new program.BST(1);\n  tree.right = new program.BST(3);\n  tree.left.left = new program.BST(4);\n  tree.right.right = new program.BST(0);\n  const expected = [0, 1, 2, 3, 4];\n  const actual = inOrderTraverse(program.repairBst(tree), []);\n  chai.expect(actual).to.deep.equal(expected);\n});\n\nfunction inOrderTraverse(tree: program.BST | null, array: number[]) {\n  if (tree !== null) {\n    inOrderTraverse(tree.left, array);\n    array.push(tree.value);\n    inOrderTraverse(tree.right, array);\n  }\n  return array;\n}\n"
    }
  },
  "customInputVars": [
    {
      "name": "tree",
      "example": {
        "nodes": [
          {
            "id": "2",
            "left": null,
            "right": "1",
            "value": 2
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "2"
      },
      "schema": {
        "description": "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "left": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "right": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "left",
                "right"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "root": {
            "type": "string"
          }
        },
        "required": [
          "root",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "tree": {
        "nodes": [
          {
            "id": "2",
            "left": null,
            "right": "1",
            "value": 2
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "2"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "2",
            "value": 3
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "2",
            "left": "3",
            "right": "1",
            "value": 2
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "2"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "0",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "1",
            "left": "4",
            "right": null,
            "value": 1
          },
          {
            "id": "0",
            "left": null,
            "right": null,
            "value": 0
          }
        ],
        "root": "2"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "10",
            "left": "5",
            "right": "13",
            "value": 10
          },
          {
            "id": "13",
            "left": "15",
            "right": "22",
            "value": 13
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          },
          {
            "id": "15",
            "left": null,
            "right": "14",
            "value": 15
          },
          {
            "id": "14",
            "left": null,
            "right": null,
            "value": 14
          },
          {
            "id": "5",
            "left": "2",
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "10"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "10",
            "left": "5",
            "right": "15",
            "value": 10
          },
          {
            "id": "15",
            "left": null,
            "right": "22",
            "value": 15
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          },
          {
            "id": "5",
            "left": "2",
            "right": "-15",
            "value": 5
          },
          {
            "id": "-15",
            "left": null,
            "right": null,
            "value": -15
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "1",
            "left": "-5",
            "right": null,
            "value": 1
          },
          {
            "id": "-5",
            "left": "7",
            "right": "-4",
            "value": -5
          },
          {
            "id": "-4",
            "left": null,
            "right": "-2",
            "value": -4
          },
          {
            "id": "-2",
            "left": null,
            "right": "-1",
            "value": -2
          },
          {
            "id": "-1",
            "left": null,
            "right": null,
            "value": -1
          },
          {
            "id": "7",
            "left": "-22",
            "right": null,
            "value": 7
          },
          {
            "id": "-22",
            "left": null,
            "right": null,
            "value": -22
          }
        ],
        "root": "10"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "10",
            "left": "-5",
            "right": "15",
            "value": 10
          },
          {
            "id": "15",
            "left": null,
            "right": "22",
            "value": 15
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          },
          {
            "id": "-5",
            "left": "2",
            "right": "6",
            "value": -5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "1",
            "left": "5",
            "right": null,
            "value": 1
          },
          {
            "id": "5",
            "left": "-15",
            "right": "-4",
            "value": 5
          },
          {
            "id": "-4",
            "left": null,
            "right": "-2",
            "value": -4
          },
          {
            "id": "-2",
            "left": null,
            "right": "-1",
            "value": -2
          },
          {
            "id": "-1",
            "left": null,
            "right": null,
            "value": -1
          },
          {
            "id": "-15",
            "left": "-22",
            "right": null,
            "value": -15
          },
          {
            "id": "-22",
            "left": null,
            "right": null,
            "value": -22
          }
        ],
        "root": "10"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "5",
            "right": "15",
            "value": 1
          },
          {
            "id": "15",
            "left": null,
            "right": "22",
            "value": 15
          },
          {
            "id": "22",
            "left": null,
            "right": "500",
            "value": 22
          },
          {
            "id": "500",
            "left": "50",
            "right": "1500",
            "value": 500
          },
          {
            "id": "1500",
            "left": null,
            "right": "10000",
            "value": 1500
          },
          {
            "id": "10000",
            "left": "2200",
            "right": null,
            "value": 10000
          },
          {
            "id": "2200",
            "left": null,
            "right": null,
            "value": 2200
          },
          {
            "id": "50",
            "left": null,
            "right": "200",
            "value": 50
          },
          {
            "id": "200",
            "left": null,
            "right": null,
            "value": 200
          },
          {
            "id": "5",
            "left": "2",
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "10",
            "right": null,
            "value": 2
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "5000",
            "left": "5",
            "right": "55000",
            "value": 5000
          },
          {
            "id": "55000",
            "left": null,
            "right": null,
            "value": 55000
          },
          {
            "id": "5",
            "left": "2",
            "right": "15",
            "value": 5
          },
          {
            "id": "15",
            "left": "14",
            "right": "22",
            "value": 15
          },
          {
            "id": "22",
            "left": null,
            "right": "502",
            "value": 22
          },
          {
            "id": "502",
            "left": "1",
            "right": null,
            "value": 502
          },
          {
            "id": "1",
            "left": "203",
            "right": "205",
            "value": 1
          },
          {
            "id": "205",
            "left": null,
            "right": "207",
            "value": 205
          },
          {
            "id": "207",
            "left": "206",
            "right": "208",
            "value": 207
          },
          {
            "id": "208",
            "left": null,
            "right": null,
            "value": 208
          },
          {
            "id": "206",
            "left": null,
            "right": null,
            "value": 206
          },
          {
            "id": "203",
            "left": null,
            "right": null,
            "value": 203
          },
          {
            "id": "14",
            "left": null,
            "right": null,
            "value": 14
          },
          {
            "id": "2",
            "left": "-3",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "-3",
            "left": null,
            "right": "-2",
            "value": -3
          },
          {
            "id": "-2",
            "left": null,
            "right": "-1",
            "value": -2
          },
          {
            "id": "-1",
            "left": null,
            "right": "204",
            "value": -1
          },
          {
            "id": "204",
            "left": null,
            "right": null,
            "value": 204
          }
        ],
        "root": "5000"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "5000",
            "left": "8",
            "right": "203",
            "value": 5000
          },
          {
            "id": "203",
            "left": null,
            "right": null,
            "value": 203
          },
          {
            "id": "8",
            "left": "6",
            "right": "15",
            "value": 8
          },
          {
            "id": "15",
            "left": "10",
            "right": "22",
            "value": 15
          },
          {
            "id": "22",
            "left": null,
            "right": "502",
            "value": 22
          },
          {
            "id": "502",
            "left": "204",
            "right": null,
            "value": 502
          },
          {
            "id": "204",
            "left": "55000",
            "right": "205",
            "value": 204
          },
          {
            "id": "205",
            "left": null,
            "right": "207",
            "value": 205
          },
          {
            "id": "207",
            "left": "206",
            "right": "208",
            "value": 207
          },
          {
            "id": "208",
            "left": null,
            "right": null,
            "value": 208
          },
          {
            "id": "206",
            "left": null,
            "right": null,
            "value": 206
          },
          {
            "id": "55000",
            "left": null,
            "right": null,
            "value": 55000
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "6",
            "left": "1",
            "right": "7",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "1",
            "left": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "5000"
      }
    }
  ],
  "jsonTests": [
    {
      "tree": {
        "nodes": [
          {
            "id": "2",
            "left": null,
            "right": "1",
            "value": 2
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "2"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "2",
            "value": 3
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "2",
            "left": "3",
            "right": "1",
            "value": 2
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "2"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "0",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "1",
            "left": "4",
            "right": null,
            "value": 1
          },
          {
            "id": "0",
            "left": null,
            "right": null,
            "value": 0
          }
        ],
        "root": "2"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "10",
            "left": "5",
            "right": "13",
            "value": 10
          },
          {
            "id": "13",
            "left": "15",
            "right": "22",
            "value": 13
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          },
          {
            "id": "15",
            "left": null,
            "right": "14",
            "value": 15
          },
          {
            "id": "14",
            "left": null,
            "right": null,
            "value": 14
          },
          {
            "id": "5",
            "left": "2",
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "10"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "10",
            "left": "5",
            "right": "15",
            "value": 10
          },
          {
            "id": "15",
            "left": null,
            "right": "22",
            "value": 15
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          },
          {
            "id": "5",
            "left": "2",
            "right": "-15",
            "value": 5
          },
          {
            "id": "-15",
            "left": null,
            "right": null,
            "value": -15
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "1",
            "left": "-5",
            "right": null,
            "value": 1
          },
          {
            "id": "-5",
            "left": "7",
            "right": "-4",
            "value": -5
          },
          {
            "id": "-4",
            "left": null,
            "right": "-2",
            "value": -4
          },
          {
            "id": "-2",
            "left": null,
            "right": "-1",
            "value": -2
          },
          {
            "id": "-1",
            "left": null,
            "right": null,
            "value": -1
          },
          {
            "id": "7",
            "left": "-22",
            "right": null,
            "value": 7
          },
          {
            "id": "-22",
            "left": null,
            "right": null,
            "value": -22
          }
        ],
        "root": "10"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "10",
            "left": "-5",
            "right": "15",
            "value": 10
          },
          {
            "id": "15",
            "left": null,
            "right": "22",
            "value": 15
          },
          {
            "id": "22",
            "left": null,
            "right": null,
            "value": 22
          },
          {
            "id": "-5",
            "left": "2",
            "right": "6",
            "value": -5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "1",
            "left": "5",
            "right": null,
            "value": 1
          },
          {
            "id": "5",
            "left": "-15",
            "right": "-4",
            "value": 5
          },
          {
            "id": "-4",
            "left": null,
            "right": "-2",
            "value": -4
          },
          {
            "id": "-2",
            "left": null,
            "right": "-1",
            "value": -2
          },
          {
            "id": "-1",
            "left": null,
            "right": null,
            "value": -1
          },
          {
            "id": "-15",
            "left": "-22",
            "right": null,
            "value": -15
          },
          {
            "id": "-22",
            "left": null,
            "right": null,
            "value": -22
          }
        ],
        "root": "10"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "5",
            "right": "15",
            "value": 1
          },
          {
            "id": "15",
            "left": null,
            "right": "22",
            "value": 15
          },
          {
            "id": "22",
            "left": null,
            "right": "500",
            "value": 22
          },
          {
            "id": "500",
            "left": "50",
            "right": "1500",
            "value": 500
          },
          {
            "id": "1500",
            "left": null,
            "right": "10000",
            "value": 1500
          },
          {
            "id": "10000",
            "left": "2200",
            "right": null,
            "value": 10000
          },
          {
            "id": "2200",
            "left": null,
            "right": null,
            "value": 2200
          },
          {
            "id": "50",
            "left": null,
            "right": "200",
            "value": 50
          },
          {
            "id": "200",
            "left": null,
            "right": null,
            "value": 200
          },
          {
            "id": "5",
            "left": "2",
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "10",
            "right": null,
            "value": 2
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "5000",
            "left": "5",
            "right": "55000",
            "value": 5000
          },
          {
            "id": "55000",
            "left": null,
            "right": null,
            "value": 55000
          },
          {
            "id": "5",
            "left": "2",
            "right": "15",
            "value": 5
          },
          {
            "id": "15",
            "left": "14",
            "right": "22",
            "value": 15
          },
          {
            "id": "22",
            "left": null,
            "right": "502",
            "value": 22
          },
          {
            "id": "502",
            "left": "1",
            "right": null,
            "value": 502
          },
          {
            "id": "1",
            "left": "203",
            "right": "205",
            "value": 1
          },
          {
            "id": "205",
            "left": null,
            "right": "207",
            "value": 205
          },
          {
            "id": "207",
            "left": "206",
            "right": "208",
            "value": 207
          },
          {
            "id": "208",
            "left": null,
            "right": null,
            "value": 208
          },
          {
            "id": "206",
            "left": null,
            "right": null,
            "value": 206
          },
          {
            "id": "203",
            "left": null,
            "right": null,
            "value": 203
          },
          {
            "id": "14",
            "left": null,
            "right": null,
            "value": 14
          },
          {
            "id": "2",
            "left": "-3",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "-3",
            "left": null,
            "right": "-2",
            "value": -3
          },
          {
            "id": "-2",
            "left": null,
            "right": "-1",
            "value": -2
          },
          {
            "id": "-1",
            "left": null,
            "right": "204",
            "value": -1
          },
          {
            "id": "204",
            "left": null,
            "right": null,
            "value": 204
          }
        ],
        "root": "5000"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "5000",
            "left": "8",
            "right": "203",
            "value": 5000
          },
          {
            "id": "203",
            "left": null,
            "right": null,
            "value": 203
          },
          {
            "id": "8",
            "left": "6",
            "right": "15",
            "value": 8
          },
          {
            "id": "15",
            "left": "10",
            "right": "22",
            "value": 15
          },
          {
            "id": "22",
            "left": null,
            "right": "502",
            "value": 22
          },
          {
            "id": "502",
            "left": "204",
            "right": null,
            "value": 502
          },
          {
            "id": "204",
            "left": "55000",
            "right": "205",
            "value": 204
          },
          {
            "id": "205",
            "left": null,
            "right": "207",
            "value": 205
          },
          {
            "id": "207",
            "left": "206",
            "right": "208",
            "value": 207
          },
          {
            "id": "208",
            "left": null,
            "right": null,
            "value": 208
          },
          {
            "id": "206",
            "left": null,
            "right": null,
            "value": 206
          },
          {
            "id": "55000",
            "left": null,
            "right": null,
            "value": 55000
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "6",
            "left": "1",
            "right": "7",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "1",
            "left": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "5000"
      }
    }
  ],
  "changelog": []
}