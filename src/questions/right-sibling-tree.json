{
  "uid": "right-sibling-tree",
  "testStrategy": "JSON",
  "name": "Right Sibling Tree",
  "version": 0,
  "releaseDate": "2020-03-29T00:00:00Z",
  "category": "Binary Trees",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 5830,
    "failureCount": 1528
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "401287346",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1658
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in a Binary Tree, transforms it into a Right\n  Sibling Tree, and returns its root.\n</p>\n<p>\n  A Right Sibling Tree is obtained by making every node in a Binary Tree have\n  its <span>right</span> property point to its right sibling instead of its\n  right child. A node's right sibling is the node immediately to its right on\n  the same level or <span>None</span> / <span>null</span> if there is no node\n  immediately to its right.\n</p>\n<p>\n  Note that once the transformation is complete, some nodes might no longer have\n  a node pointing to them. For example, in the sample output below, the node\n  with value <span>10</span> no longer has any inbound pointers and is\n  effectively unreachable.\n</p>\n<p>\n  The transformation should be done in place, meaning that the original data\n  structure should be mutated (no new structure should be created).\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">tree</span> =     1\n      /         \\\n     2           3\n   /   \\       /   \\\n  4     5     6     7\n / \\     \\   /     / \\\n8   9    10 11    12 13\n           /\n          14\n</pre>\n<h3>Sample Output</h3>\n<pre>\n           1 <span class=\"CodeEditor-promptComment\">// the root node with value 1</span>\n      /\n     2-----------3\n   /           /\n  4-----5-----6-----7\n /           /     /\n8---9    10-11    12-13 <span class=\"CodeEditor-promptComment\">// the node with value 10 no longer has a node pointing to it</span>\n           /\n          14\n</pre>\n</div>",
  "hints": [
    "<p>\nTry to identify a pattern or formula that determines how to reach a given node's right sibling.\n</p>\n",
    "\n<p>\nThere are two patterns: if a node is the left child of another node, its right sibling is its parent's right child; if a node is the right child of another node, its right sibling is its parent's right sibling's left child.\n</p>\n",
    "\n<p>\nYou'll need to a find a way to quickly access a node's parent's right child and a node's parent's right sibling; this won't be trivial because the second one implies that the parent node's original right pointer has been overwritten.\n</p>\n",
    "\n<p>\nRecursively traverse the binary tree and sequence the transformation operations as follows: at any given node, recursively transform its left subtree into a right sibling tree, then edit the given node's right pointer to point to its right sibling, and then finally recursively transform its right subtree into a right sibling tree. This sequencing of operations will allow left child nodes to always access their parent's right child (before their parent's right pointer gets overwritten to point to the parent's right sibling) and will allow right child nodes to always access their parent's right sibling (after their parent's right pointer has gotten overwritten to point to the parent's right sibling).\n</p>"
  ],
  "spaceTime": "O(n) time | O(d) space - where n is the number of nodes in the Binary Tree and d is the depth (height) of the Binary Tree",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": "tree",
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\n// This is the class of the input root. Do not edit it.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left = nullptr;\n  BinaryTree* right = nullptr;\n\n  BinaryTree(int value);\n};\n\nBinaryTree* rightSiblingTree(BinaryTree* root) {\n  // Write your code here.\n  return root;\n}\n",
      "solutions": [
        "// Copyright Â© 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left = nullptr;\n  BinaryTree* right = nullptr;\n\n  BinaryTree(int value);\n};\n\nvoid mutate(BinaryTree* node, BinaryTree* parent, bool isLeftChild);\n\n// O(n) time | O(d) space - where n is the number of nodes in the Binary Tree\n// and d is the depth (height) of the Binary Tree\nBinaryTree* rightSiblingTree(BinaryTree* root) {\n  mutate(root, nullptr, false);\n  return root;\n}\n\nvoid mutate(BinaryTree* node, BinaryTree* parent, bool isLeftChild) {\n  if (node == nullptr) return;\n\n  auto left = node->left;\n  auto right = node->right;\n  mutate(left, node, true);\n  if (parent == nullptr) {\n    node->right = nullptr;\n  } else if (isLeftChild) {\n    node->right = parent->right;\n  } else {\n    if (parent->right == nullptr) {\n      node->right = nullptr;\n    } else {\n      node->right = parent->right->left;\n    }\n  }\n  mutate(right, node, false);\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include <queue>\n\nBinaryTree::BinaryTree(int value) { this->value = value; }\n\nBinaryTree* insertBinaryTree(BinaryTree* tree, vector<int> values);\nvector<int> getDfsOrder(BinaryTree* tree);\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree* root = new BinaryTree(1);\n      insertBinaryTree(root, {2, 3, 4, 5, 6, 7, 8, 9});\n      root->left->right->right = new BinaryTree(10);\n      root->right->left->left = new BinaryTree(11);\n      root->right->right->left = new BinaryTree(12);\n      root->right->right->right = new BinaryTree(13);\n      root->right->left->left->left = new BinaryTree(14);\n      BinaryTree* mutatedRoot = rightSiblingTree(root);\n      vector<int> actual = getDfsOrder(mutatedRoot);\n      vector<int> expected = {\n        1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13};\n      assert(expected == actual);\n    });\n  }\n};\n\nBinaryTree* insertBinaryTree(BinaryTree* tree, vector<int> values) {\n  if (values.size() == 0) return tree;\n\n  queue<BinaryTree*> nodesQueue({tree});\n  while (nodesQueue.size() > 0) {\n    BinaryTree* current = nodesQueue.front();\n    nodesQueue.pop();\n    if (current->left == nullptr) {\n      current->left = new BinaryTree(values[0]);\n      break;\n    }\n    nodesQueue.push(current->left);\n    if (current->right == nullptr) {\n      current->right = new BinaryTree(values[0]);\n      break;\n    }\n    nodesQueue.push(current->right);\n  }\n\n  values.erase(values.begin());\n  return insertBinaryTree(tree, values);\n}\n\nvector<int> getDfsOrder(BinaryTree* tree) {\n  vector<int> values = {tree->value};\n  if (tree->left != nullptr) {\n    auto sub = getDfsOrder(tree->left);\n    values.insert(values.end(), sub.begin(), sub.end());\n  }\n  if (tree->right != nullptr) {\n    auto sub = getDfsOrder(tree->right);\n    values.insert(values.end(), sub.begin(), sub.end());\n  }\n  return values;\n}\n",
      "unitTests": "#include <queue>\n\nBinaryTree::BinaryTree(int value) { this->value = value; }\n\nBinaryTree* insertBinaryTree(BinaryTree* tree, vector<int> values);\nvector<int> getDfsOrder(BinaryTree* tree);\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree* root = new BinaryTree(1);\n      insertBinaryTree(root, {2, 3, 4, 5, 6, 7, 8, 9});\n      root->left->right->right = new BinaryTree(10);\n      root->right->left->left = new BinaryTree(11);\n      root->right->right->left = new BinaryTree(12);\n      root->right->right->right = new BinaryTree(13);\n      root->right->left->left->left = new BinaryTree(14);\n      BinaryTree* mutatedRoot = rightSiblingTree(root);\n      vector<int> actual = getDfsOrder(mutatedRoot);\n      vector<int> expected = {\n        1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13};\n      assert(expected == actual);\n    });\n  }\n};\n\nBinaryTree* insertBinaryTree(BinaryTree* tree, vector<int> values) {\n  if (values.size() == 0) return tree;\n\n  queue<BinaryTree*> nodesQueue({tree});\n  while (nodesQueue.size() > 0) {\n    BinaryTree* current = nodesQueue.front();\n    nodesQueue.pop();\n    if (current->left == nullptr) {\n      current->left = new BinaryTree(values[0]);\n      break;\n    }\n    nodesQueue.push(current->left);\n    if (current->right == nullptr) {\n      current->right = new BinaryTree(values[0]);\n      break;\n    }\n    nodesQueue.push(current->right);\n  }\n\n  values.erase(values.begin());\n  return insertBinaryTree(tree, values);\n}\n\nvector<int> getDfsOrder(BinaryTree* tree) {\n  vector<int> values = {tree->value};\n  if (tree->left != nullptr) {\n    auto sub = getDfsOrder(tree->left);\n    values.insert(values.end(), sub.begin(), sub.end());\n  }\n  if (tree->right != nullptr) {\n    auto sub = getDfsOrder(tree->right);\n    values.insert(values.end(), sub.begin(), sub.end());\n  }\n  return values;\n}\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public static BinaryTree RightSiblingTree(BinaryTree root) {\n    // Write your code here.\n    return root;\n  }\n\n  // This is the class of the input root. Do not edit it.\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright Â© 2023 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n  // O(n) time | O(d) space - where n is the number of nodes in\n  // the Binary Tree and d is the depth (height) of the Binary Tree\n  public static BinaryTree RightSiblingTree(BinaryTree root) {\n    mutate(root, null, false);\n    return root;\n  }\n\n  public static void mutate(\n    BinaryTree node, BinaryTree parent, bool isLeftChild\n  ) {\n    if (node == null) return;\n\n    var left = node.left;\n    var right = node.right;\n    mutate(left, node, true);\n    if (parent == null) {\n      node.right = null;\n    } else if (isLeftChild) {\n      node.right = parent.right;\n    } else {\n      if (parent.right == null) {\n        node.right = null;\n      } else {\n        node.right = parent.right.left;\n      }\n    }\n    mutate(right, node, false);\n  }\n\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.BinaryTree root = new Program.BinaryTree(1);\n    insert(root, new int[] { 2, 3, 4, 5, 6, 7, 8, 9 });\n    root.left.right.right = new Program.BinaryTree(10);\n    root.right.left.left = new Program.BinaryTree(11);\n    root.right.right.left = new Program.BinaryTree(12);\n    root.right.right.right = new Program.BinaryTree(13);\n    root.right.left.left.left = new Program.BinaryTree(14);\n    Program.BinaryTree mutatedRoot = Program.RightSiblingTree(root);\n    List<int> actual = getDfsOrder(mutatedRoot);\n    var expected = new List<int> {\n      1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13\n    };\n    Utils.AssertTrue(expected.SequenceEqual(actual));\n  }\n\n  public void insert(Program.BinaryTree root, int[] values) {\n    insert(root, values, 0);\n  }\n\n  public void insert(Program.BinaryTree root, int[] values, int i) {\n    if (i >= values.Length) {\n      return;\n    }\n    Queue<Program.BinaryTree> queue = new Queue<Program.BinaryTree>();\n    queue.Enqueue(root);\n    while (queue.Count > 0) {\n      Program.BinaryTree current = queue.Dequeue();\n      if (current.left == null) {\n        current.left = new Program.BinaryTree(values[i]);\n        break;\n      }\n      queue.Enqueue(current.left);\n      if (current.right == null) {\n        current.right = new Program.BinaryTree(values[i]);\n        break;\n      }\n      queue.Enqueue(current.right);\n    }\n    insert(root, values, i + 1);\n  }\n\n  public List<int> getDfsOrder(Program.BinaryTree tree) {\n    List<int> values = new List<int>();\n    values.Add(tree.value);\n    if (tree.left != null) {\n      values.AddRange(getDfsOrder(tree.left));\n    }\n    if (tree.right != null) {\n      values.AddRange(getDfsOrder(tree.right));\n    }\n    return values;\n  }\n}\n",
      "unitTests": "using System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.BinaryTree root = new Program.BinaryTree(1);\n    insert(root, new int[] { 2, 3, 4, 5, 6, 7, 8, 9 });\n    root.left.right.right = new Program.BinaryTree(10);\n    root.right.left.left = new Program.BinaryTree(11);\n    root.right.right.left = new Program.BinaryTree(12);\n    root.right.right.right = new Program.BinaryTree(13);\n    root.right.left.left.left = new Program.BinaryTree(14);\n    Program.BinaryTree mutatedRoot = Program.RightSiblingTree(root);\n    List<int> actual = getDfsOrder(mutatedRoot);\n    var expected = new List<int> {\n      1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13\n    };\n    Utils.AssertTrue(expected.SequenceEqual(actual));\n  }\n\n  public void insert(Program.BinaryTree root, int[] values) {\n    insert(root, values, 0);\n  }\n\n  public void insert(Program.BinaryTree root, int[] values, int i) {\n    if (i >= values.Length) {\n      return;\n    }\n    Queue<Program.BinaryTree> queue = new Queue<Program.BinaryTree>();\n    queue.Enqueue(root);\n    while (queue.Count > 0) {\n      Program.BinaryTree current = queue.Dequeue();\n      if (current.left == null) {\n        current.left = new Program.BinaryTree(values[i]);\n        break;\n      }\n      queue.Enqueue(current.left);\n      if (current.right == null) {\n        current.right = new Program.BinaryTree(values[i]);\n        break;\n      }\n      queue.Enqueue(current.right);\n    }\n    insert(root, values, i + 1);\n  }\n\n  public List<int> getDfsOrder(Program.BinaryTree tree) {\n    List<int> values = new List<int>();\n    values.Add(tree.value);\n    if (tree.left != null) {\n      values.AddRange(getDfsOrder(tree.left));\n    }\n    if (tree.right != null) {\n      values.AddRange(getDfsOrder(tree.right));\n    }\n    return values;\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is the class of the input root. Do not edit it.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\nfunc RightSiblingTree(root *BinaryTree) *BinaryTree {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright Â© 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\n// O(n) time | O(d) space - where n is the number of nodes in\n// the Binary Tree and d is the depth (height) of the Binary Tree\nfunc RightSiblingTree(root *BinaryTree) *BinaryTree {\n\tmutate(root, nil, false)\n\treturn root\n}\n\nfunc mutate(node, parent *BinaryTree, isLeftChild bool) {\n\tif node == nil {\n\t\treturn\n\t}\n\n\tleft, right := node.Left, node.Right\n\tmutate(left, node, true)\n\tif parent == nil {\n\t\tnode.Right = nil\n\t} else if isLeftChild {\n\t\tnode.Right = parent.Right\n\t} else {\n\t\tif parent.Right == nil {\n\t\t\tnode.Right = nil\n\t\t} else {\n\t\t\tnode.Right = parent.Right.Left\n\t\t}\n\t}\n\tmutate(right, node, false)\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc NewBinaryTree(value int) *BinaryTree {\n\treturn &BinaryTree{Value: value}\n}\n\nfunc (tree *BinaryTree) insert(value int) *BinaryTree {\n\tqueue := []*BinaryTree{tree}\n\tfor len(queue) > 0 {\n\t\tvar current *BinaryTree\n\t\tqueue, current = queue[1:], queue[0]\n\t\tif current.Left == nil {\n\t\t\tcurrent.Left = NewBinaryTree(value)\n\t\t\treturn tree\n\t\t}\n\t\tqueue = append(queue, current.Left)\n\n\t\tif current.Right == nil {\n\t\t\tcurrent.Right = NewBinaryTree(value)\n\t\t\treturn tree\n\t\t}\n\t\tqueue = append(queue, current.Right)\n\t}\n\treturn tree\n}\n\nfunc (tree *BinaryTree) insertAll(values ...int) *BinaryTree {\n\tfor _, value := range values {\n\t\ttree.insert(value)\n\t}\n\treturn tree\n}\n\nfunc (tree *BinaryTree) getDfsOrder() []int {\n\tvals := []int{tree.Value}\n\tif tree.Left != nil {\n\t\tvals = append(vals, tree.Left.getDfsOrder()...)\n\t}\n\tif tree.Right != nil {\n\t\tvals = append(vals, tree.Right.getDfsOrder()...)\n\t}\n\treturn vals\n}\n\nfunc TestCase1(t *TestCase) {\n\troot := NewBinaryTree(1).insertAll(2, 3, 4, 5, 6, 7, 8, 9)\n\troot.Left.Right.Right = NewBinaryTree(10)\n\troot.Right.Left.Left = NewBinaryTree(11)\n\troot.Right.Right.Left = NewBinaryTree(12)\n\troot.Right.Right.Right = NewBinaryTree(13)\n\troot.Right.Left.Left.Left = NewBinaryTree(14)\n\tmutatedRoot := RightSiblingTree(root)\n\tactual := mutatedRoot.getDfsOrder()\n\texpected := []int{1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13}\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc NewBinaryTree(value int) *BinaryTree {\n\treturn &BinaryTree{Value: value}\n}\n\nfunc (tree *BinaryTree) insert(value int) *BinaryTree {\n\tqueue := []*BinaryTree{tree}\n\tfor len(queue) > 0 {\n\t\tvar current *BinaryTree\n\t\tqueue, current = queue[1:], queue[0]\n\t\tif current.Left == nil {\n\t\t\tcurrent.Left = NewBinaryTree(value)\n\t\t\treturn tree\n\t\t}\n\t\tqueue = append(queue, current.Left)\n\n\t\tif current.Right == nil {\n\t\t\tcurrent.Right = NewBinaryTree(value)\n\t\t\treturn tree\n\t\t}\n\t\tqueue = append(queue, current.Right)\n\t}\n\treturn tree\n}\n\nfunc (tree *BinaryTree) insertAll(values ...int) *BinaryTree {\n\tfor _, value := range values {\n\t\ttree.insert(value)\n\t}\n\treturn tree\n}\n\nfunc (tree *BinaryTree) getDfsOrder() []int {\n\tvals := []int{tree.Value}\n\tif tree.Left != nil {\n\t\tvals = append(vals, tree.Left.getDfsOrder()...)\n\t}\n\tif tree.Right != nil {\n\t\tvals = append(vals, tree.Right.getDfsOrder()...)\n\t}\n\treturn vals\n}\n\nfunc TestCase1(t *TestCase) {\n\troot := NewBinaryTree(1).insertAll(2, 3, 4, 5, 6, 7, 8, 9)\n\troot.Left.Right.Right = NewBinaryTree(10)\n\troot.Right.Left.Left = NewBinaryTree(11)\n\troot.Right.Right.Left = NewBinaryTree(12)\n\troot.Right.Right.Right = NewBinaryTree(13)\n\troot.Right.Left.Left.Left = NewBinaryTree(14)\n\tmutatedRoot := RightSiblingTree(root)\n\tactual := mutatedRoot.getDfsOrder()\n\texpected := []int{1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13}\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static BinaryTree rightSiblingTree(BinaryTree root) {\n    // Write your code here.\n    return root;\n  }\n\n  // This is the class of the input root. Do not edit it.\n  static class BinaryTree {\n    int value;\n    BinaryTree left = null;\n    BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n",
      "solutions": [
        "// Copyright Â© 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n) time | O(d) space - where n is the number of nodes in\n  // the Binary Tree and d is the depth (height) of the Binary Tree\n  public static BinaryTree rightSiblingTree(BinaryTree root) {\n    mutate(root, null, false);\n    return root;\n  }\n\n  public static void mutate(\n    BinaryTree node, BinaryTree parent, boolean isLeftChild\n  ) {\n    if (node == null) return;\n\n    var left = node.left;\n    var right = node.right;\n    mutate(left, node, true);\n    if (parent == null) {\n      node.right = null;\n    } else if (isLeftChild) {\n      node.right = parent.right;\n    } else {\n      if (parent.right == null) {\n        node.right = null;\n      } else {\n        node.right = parent.right.left;\n      }\n    }\n    mutate(right, node, false);\n  }\n\n  static class BinaryTree {\n    int value;\n    BinaryTree left = null;\n    BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.BinaryTree root = new Program.BinaryTree(1);\n    insert(root, new int[] {2, 3, 4, 5, 6, 7, 8, 9});\n    root.left.right.right = new Program.BinaryTree(10);\n    root.right.left.left = new Program.BinaryTree(11);\n    root.right.right.left = new Program.BinaryTree(12);\n    root.right.right.right = new Program.BinaryTree(13);\n    root.right.left.left.left = new Program.BinaryTree(14);\n    Program.BinaryTree mutatedRoot = Program.rightSiblingTree(root);\n    List<Integer> actual = getDfsOrder(mutatedRoot);\n    var expected = Arrays.asList(\n      1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13\n    );\n    Utils.assertTrue(expected.equals(actual));\n  }\n\n  public void insert(Program.BinaryTree root, int[] values) {\n    insert(root, values, 0);\n  }\n\n  public void insert(Program.BinaryTree root, int[] values, int i) {\n    if (i >= values.length) {\n      return;\n    }\n    Deque<Program.BinaryTree> queue = new ArrayDeque<Program.BinaryTree>();\n    queue.addLast(root);\n    while (queue.size() > 0) {\n      Program.BinaryTree current = queue.pollFirst();\n      if (current.left == null) {\n        current.left = new Program.BinaryTree(values[i]);\n        break;\n      }\n      queue.addLast(current.left);\n      if (current.right == null) {\n        current.right = new Program.BinaryTree(values[i]);\n        break;\n      }\n      queue.addLast(current.right);\n    }\n    insert(root, values, i + 1);\n  }\n\n  public List<Integer> getDfsOrder(Program.BinaryTree tree) {\n    List<Integer> values = new ArrayList<Integer>();\n    values.add(tree.value);\n    if (tree.left != null) {\n      values.addAll(getDfsOrder(tree.left));\n    }\n    if (tree.right != null) {\n      values.addAll(getDfsOrder(tree.right));\n    }\n    return values;\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.BinaryTree root = new Program.BinaryTree(1);\n    insert(root, new int[] {2, 3, 4, 5, 6, 7, 8, 9});\n    root.left.right.right = new Program.BinaryTree(10);\n    root.right.left.left = new Program.BinaryTree(11);\n    root.right.right.left = new Program.BinaryTree(12);\n    root.right.right.right = new Program.BinaryTree(13);\n    root.right.left.left.left = new Program.BinaryTree(14);\n    Program.BinaryTree mutatedRoot = Program.rightSiblingTree(root);\n    List<Integer> actual = getDfsOrder(mutatedRoot);\n    var expected = Arrays.asList(\n      1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13\n    );\n    Utils.assertTrue(expected.equals(actual));\n  }\n\n  public void insert(Program.BinaryTree root, int[] values) {\n    insert(root, values, 0);\n  }\n\n  public void insert(Program.BinaryTree root, int[] values, int i) {\n    if (i >= values.length) {\n      return;\n    }\n    Deque<Program.BinaryTree> queue = new ArrayDeque<Program.BinaryTree>();\n    queue.addLast(root);\n    while (queue.size() > 0) {\n      Program.BinaryTree current = queue.pollFirst();\n      if (current.left == null) {\n        current.left = new Program.BinaryTree(values[i]);\n        break;\n      }\n      queue.addLast(current.left);\n      if (current.right == null) {\n        current.right = new Program.BinaryTree(values[i]);\n        break;\n      }\n      queue.addLast(current.right);\n    }\n    insert(root, values, i + 1);\n  }\n\n  public List<Integer> getDfsOrder(Program.BinaryTree tree) {\n    List<Integer> values = new ArrayList<Integer>();\n    values.add(tree.value);\n    if (tree.left != null) {\n      values.addAll(getDfsOrder(tree.left));\n    }\n    if (tree.right != null) {\n      values.addAll(getDfsOrder(tree.right));\n    }\n    return values;\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is the class of the input root. Do not edit it.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction rightSiblingTree(root) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.rightSiblingTree = rightSiblingTree;\n",
      "solutions": [
        "// Copyright Â© 2023 AlgoExpert LLC. All rights reserved.\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(d) space - where n is the number of nodes in the Binary Tree and d is the depth (height) of the Binary Tree\nfunction rightSiblingTree(root) {\n  mutate(root, null, null);\n  return root;\n}\n\nfunction mutate(node, parent, isLeftChild) {\n  if (node === null) return;\n  const {left, right} = node;\n  mutate(left, node, true);\n  if (parent === null) {\n    node.right = null;\n  } else if (isLeftChild) {\n    node.right = parent.right;\n  } else {\n    if (parent.right === null) {\n      node.right = null;\n    } else {\n      node.right = parent.right.left;\n    }\n  }\n  mutate(right, node, false);\n}\n\nexports.BinaryTree = BinaryTree;\nexports.rightSiblingTree = rightSiblingTree;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9]);\n  root.left.right.right = new BinaryTree(10);\n  root.right.left.left = new BinaryTree(11);\n  root.right.right.left = new BinaryTree(12);\n  root.right.right.right = new BinaryTree(13);\n  root.right.left.left.left = new BinaryTree(14);\n  const mutatedRoot = program.rightSiblingTree(root);\n  const dfsOrder = mutatedRoot.getDfsOrder([]);\n  const expected = [1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13];\n  chai.expect(dfsOrder).to.deep.equal(expected);\n});\n\nclass BinaryTree extends program.BinaryTree {\n  constructor(value) {\n    super(value);\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n\n  getDfsOrder(values) {\n    values.push(this.value);\n    if (this.left !== null) {\n      this.left.getDfsOrder(values);\n    }\n    if (this.right !== null) {\n      this.right.getDfsOrder(values);\n    }\n    return values;\n  }\n}\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9]);\n  root.left.right.right = new BinaryTree(10);\n  root.right.left.left = new BinaryTree(11);\n  root.right.right.left = new BinaryTree(12);\n  root.right.right.right = new BinaryTree(13);\n  root.right.left.left.left = new BinaryTree(14);\n  const mutatedRoot = program.rightSiblingTree(root);\n  const dfsOrder = mutatedRoot.getDfsOrder([]);\n  const expected = [1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13];\n  chai.expect(dfsOrder).to.deep.equal(expected);\n});\n\nclass BinaryTree extends program.BinaryTree {\n  constructor(value) {\n    super(value);\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n\n  getDfsOrder(values) {\n    values.push(this.value);\n    if (this.left !== null) {\n      this.left.getDfsOrder(values);\n    }\n    if (this.right !== null) {\n      this.right.getDfsOrder(values);\n    }\n    return values;\n  }\n}\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\nfun rightSiblingTree(tree: BinaryTree): BinaryTree {\n    // Write your code here.\n    return tree\n}\n",
      "solutions": [
        "// Copyright Â© 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\n// O(n) time | O(d) space - where n is the number of nodes in\n// the Binary Tree and d is the depth (height) of the Binary Tree\nfun rightSiblingTree(root: BinaryTree): BinaryTree {\n    mutate(root, null, false)\n    return root\n}\n\nfun mutate(node: BinaryTree?, parent: BinaryTree?, isLeftChild: Boolean) {\n    if (node == null) return\n\n    val left = node.left\n    val right = node.right\n    mutate(left, node, true)\n    if (parent == null) {\n        node.right = null\n    } else if (isLeftChild) {\n        node.right = parent.right\n    } else {\n        if (parent.right == null) {\n            node.right = null\n        } else {\n            node.right = parent.right!!.left\n        }\n    }\n    mutate(right, node, false)\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.BinaryTree as BinaryTree\nimport com.algoexpert.program.rightSiblingTree as rightSiblingTree\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree = BinaryTree(1)\n        tree.left = BinaryTree(2)\n        tree.right = BinaryTree(3)\n        tree.left!!.left = BinaryTree(4)\n        tree.left!!.right = BinaryTree(5)\n        tree.right!!.left = BinaryTree(6)\n        tree.right!!.right = BinaryTree(7)\n        tree.left!!.left!!.left = BinaryTree(8)\n        tree.left!!.left!!.right = BinaryTree(9)\n        tree.left!!.right!!.right = BinaryTree(10)\n        tree.right!!.left!!.left = BinaryTree(11)\n        tree.right!!.right!!.left = BinaryTree(12)\n        tree.right!!.right!!.right = BinaryTree(13)\n        tree.right!!.left!!.left!!.left = BinaryTree(14)\n\n        val mutatedRoot = rightSiblingTree(tree)\n        val dfsOrder = getDfsOrder(mutatedRoot, mutableListOf())\n        val expected = listOf(1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13)\n\n        assert(dfsOrder == expected)\n    }\n}\n\nfun getDfsOrder(tree: BinaryTree, values: MutableList<Int>): MutableList<Int> {\n    values.add(tree.value)\n    if (tree.left != null) getDfsOrder(tree.left!!, values)\n    if (tree.right != null) getDfsOrder(tree.right!!, values)\n    return values\n}\n",
      "unitTests": "import com.algoexpert.program.BinaryTree as BinaryTree\nimport com.algoexpert.program.rightSiblingTree as rightSiblingTree\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree = BinaryTree(1)\n        tree.left = BinaryTree(2)\n        tree.right = BinaryTree(3)\n        tree.left!!.left = BinaryTree(4)\n        tree.left!!.right = BinaryTree(5)\n        tree.right!!.left = BinaryTree(6)\n        tree.right!!.right = BinaryTree(7)\n        tree.left!!.left!!.left = BinaryTree(8)\n        tree.left!!.left!!.right = BinaryTree(9)\n        tree.left!!.right!!.right = BinaryTree(10)\n        tree.right!!.left!!.left = BinaryTree(11)\n        tree.right!!.right!!.left = BinaryTree(12)\n        tree.right!!.right!!.right = BinaryTree(13)\n        tree.right!!.left!!.left!!.left = BinaryTree(14)\n\n        val mutatedRoot = rightSiblingTree(tree)\n        val dfsOrder = getDfsOrder(mutatedRoot, mutableListOf())\n        val expected = listOf(1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13)\n\n        assert(dfsOrder == expected)\n    }\n}\n\nfun getDfsOrder(tree: BinaryTree, values: MutableList<Int>): MutableList<Int> {\n    values.add(tree.value)\n    if (tree.left != null) getDfsOrder(tree.left!!, values)\n    if (tree.right != null) getDfsOrder(tree.right!!, values)\n    return values\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is the class of the input root. Do not edit it.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef rightSiblingTree(root):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright Â© 2023 AlgoExpert LLC. All rights reserved.\n\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# O(n) time | O(d) space - where n is the number of nodes in the Binary Tree and d is the depth (height) of the Binary Tree\ndef rightSiblingTree(root):\n    mutate(root, None, None)\n    return root\n\n\ndef mutate(node, parent, isLeftChild):\n    if node is None:\n        return\n    left, right = node.left, node.right\n    mutate(left, node, True)\n    if parent is None:\n        node.right = None\n    elif isLeftChild:\n        node.right = parent.right\n    else:\n        if parent.right is None:\n            node.right = None\n        else:\n            node.right = parent.right.left\n    mutate(right, node, False)\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9])\n        root.left.right.right = BinaryTree(10)\n        root.right.left.left = BinaryTree(11)\n        root.right.right.left = BinaryTree(12)\n        root.right.right.right = BinaryTree(13)\n        root.right.left.left.left = BinaryTree(14)\n        mutatedRoot = program.rightSiblingTree(root)\n        dfsOrder = mutatedRoot.getDfsOrder([])\n        expected = [1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13]\n        self.assertEqual(dfsOrder, expected)\n\n\nclass BinaryTree(program.BinaryTree):\n    def insert(self, values, i=0):\n        if i >= len(values):\n            return\n        queue = [self]\n        while len(queue) > 0:\n            current = queue.pop(0)\n            if current.left is None:\n                current.left = BinaryTree(values[i])\n                break\n            queue.append(current.left)\n            if current.right is None:\n                current.right = BinaryTree(values[i])\n                break\n            queue.append(current.right)\n        self.insert(values, i + 1)\n        return self\n\n    def getDfsOrder(self, values):\n        values.append(self.value)\n        if self.left is not None:\n            self.left.getDfsOrder(values)\n        if self.right is not None:\n            self.right.getDfsOrder(values)\n        return values\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9])\n        root.left.right.right = BinaryTree(10)\n        root.right.left.left = BinaryTree(11)\n        root.right.right.left = BinaryTree(12)\n        root.right.right.right = BinaryTree(13)\n        root.right.left.left.left = BinaryTree(14)\n        mutatedRoot = program.rightSiblingTree(root)\n        dfsOrder = mutatedRoot.getDfsOrder([])\n        expected = [1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13]\n        self.assertEqual(dfsOrder, expected)\n\n\nclass BinaryTree(program.BinaryTree):\n    def insert(self, values, i=0):\n        if i >= len(values):\n            return\n        queue = [self]\n        while len(queue) > 0:\n            current = queue.pop(0)\n            if current.left is None:\n                current.left = BinaryTree(values[i])\n                break\n            queue.append(current.left)\n            if current.right is None:\n                current.right = BinaryTree(values[i])\n                break\n            queue.append(current.right)\n        self.insert(values, i + 1)\n        return self\n\n    def getDfsOrder(self, values):\n        values.append(self.value)\n        if self.left is not None:\n            self.left.getDfsOrder(values)\n        if self.right is not None:\n            self.right.getDfsOrder(values)\n        return values\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def rightSiblingTree(tree)\n    # Write your code here.\n    return nil\n  end\nend\n",
      "solutions": [
        "# Copyright Â© 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def rightSiblingTree(tree)\n    # Write your code here.\n    return nil\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.rightSiblingTree\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.rightSiblingTree\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is the class of the input root. Do not edit it.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  func rightSiblingTree(root: BinaryTree) -> BinaryTree {\n    // Write your code here.\n    return root\n  }\n}\n",
      "solutions": [
        "// Copyright Â© 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(n) time | O(d) space - where n is the number of nodes in\n  // the Binary Tree and d is the depth (height) of the Binary Tree\n  func rightSiblingTree(root: BinaryTree) -> BinaryTree {\n    mutate(node: root, parent: nil, isLeftChild: false)\n    return root\n  }\n\n  func mutate(node: BinaryTree?, parent: BinaryTree?, isLeftChild: Bool) {\n    if let tree = node {\n      var left = tree.left\n      var right = tree.right\n      mutate(node: left, parent: tree, isLeftChild: true)\n      if let p = parent {\n        if isLeftChild {\n          tree.right = p.right\n        } else {\n          if let right = p.right {\n            tree.right = right.left\n          } else {\n            tree.right = nil\n          }\n        }\n      } else {\n        tree.right = nil\n      }\n\n      mutate(node: right, parent: tree, isLeftChild: false)\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var root = TestBinaryTree(value: 1).insertAll(values: [2, 3, 4, 5, 6, 7, 8, 9])\n      root.left?.right?.right = TestBinaryTree(value: 10)\n      root.right?.left?.left = TestBinaryTree(value: 11)\n      root.right?.right?.left = TestBinaryTree(value: 12)\n      root.right?.right?.right = TestBinaryTree(value: 13)\n      root.right?.left?.left?.left = TestBinaryTree(value: 14)\n      var mutatedRoot = program.rightSiblingTree(root: root)\n      var actual = getDfsOrder(tree: mutatedRoot)\n      var expected = [1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13]\n      try assertEqual(expected, actual)\n    }\n  }\n}\n\nclass TestBinaryTree: Program.BinaryTree {\n  func insert(value: Int) -> TestBinaryTree {\n    var queue = [self as Program.BinaryTree]\n    while queue.count > 0 {\n      var current = queue[0]\n      queue.removeFirst()\n      if let left = current.left {\n        queue.append(left)\n      } else {\n        current.left = TestBinaryTree(value: value)\n        return self\n      }\n\n      if let right = current.right {\n        queue.append(right)\n      } else {\n        current.right = TestBinaryTree(value: value)\n        return self\n      }\n    }\n    return self\n  }\n\n  func insertAll(values: [Int]) -> TestBinaryTree {\n    for v in values {\n      insert(value: v)\n    }\n    return self\n  }\n}\n\nfunc getDfsOrder(tree: Program.BinaryTree) -> [Int] {\n  var result = [tree.value]\n  if let left = tree.left {\n    var sub = getDfsOrder(tree: left)\n    result.append(contentsOf: sub)\n  }\n  if let right = tree.right {\n    var sub = getDfsOrder(tree: right)\n    result.append(contentsOf: sub)\n  }\n  return result\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var root = TestBinaryTree(value: 1).insertAll(values: [2, 3, 4, 5, 6, 7, 8, 9])\n      root.left?.right?.right = TestBinaryTree(value: 10)\n      root.right?.left?.left = TestBinaryTree(value: 11)\n      root.right?.right?.left = TestBinaryTree(value: 12)\n      root.right?.right?.right = TestBinaryTree(value: 13)\n      root.right?.left?.left?.left = TestBinaryTree(value: 14)\n      var mutatedRoot = program.rightSiblingTree(root: root)\n      var actual = getDfsOrder(tree: mutatedRoot)\n      var expected = [1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13]\n      try assertEqual(expected, actual)\n    }\n  }\n}\n\nclass TestBinaryTree: Program.BinaryTree {\n  func insert(value: Int) -> TestBinaryTree {\n    var queue = [self as Program.BinaryTree]\n    while queue.count > 0 {\n      var current = queue[0]\n      queue.removeFirst()\n      if let left = current.left {\n        queue.append(left)\n      } else {\n        current.left = TestBinaryTree(value: value)\n        return self\n      }\n\n      if let right = current.right {\n        queue.append(right)\n      } else {\n        current.right = TestBinaryTree(value: value)\n        return self\n      }\n    }\n    return self\n  }\n\n  func insertAll(values: [Int]) -> TestBinaryTree {\n    for v in values {\n      insert(value: v)\n    }\n    return self\n  }\n}\n\nfunc getDfsOrder(tree: Program.BinaryTree) -> [Int] {\n  var result = [tree.value]\n  if let left = tree.left {\n    var sub = getDfsOrder(tree: left)\n    result.append(contentsOf: sub)\n  }\n  if let right = tree.right {\n    var sub = getDfsOrder(tree: right)\n    result.append(contentsOf: sub)\n  }\n  return result\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is the class of the input root. Do not edit it.\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport function rightSiblingTree(root: BinaryTree) {\n  // Write your code here.\n  return root;\n}\n",
      "solutions": [
        "// Copyright Â© 2023 AlgoExpert LLC. All rights reserved.\n\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(d) space - where n is the number of nodes in the Binary Tree and d is the depth (height) of the Binary Tree\nexport function rightSiblingTree(root: BinaryTree) {\n  mutate(root, null, null);\n  return root;\n}\n\nfunction mutate(node: BinaryTree | null, parent: BinaryTree | null, isLeftChild: boolean | null) {\n  if (node === null) return;\n  const {left, right} = node;\n  mutate(left, node, true);\n  if (parent === null) {\n    node.right = null;\n  } else if (isLeftChild) {\n    node.right = parent.right;\n  } else {\n    if (parent.right === null) {\n      node.right = null;\n    } else {\n      node.right = parent.right.left;\n    }\n  }\n  mutate(right, node, false);\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1);\n  root.left = new BinaryTree(2);\n  root.right = new BinaryTree(3);\n  root.left.left = new BinaryTree(4);\n  root.left.right = new BinaryTree(5);\n  root.right.left = new BinaryTree(6);\n  root.right.right = new BinaryTree(7);\n  root.left.left.left = new BinaryTree(8);\n  root.left.left.right = new BinaryTree(9);\n  root.left.right.right = new BinaryTree(10);\n  root.right.left.left = new BinaryTree(11);\n  root.right.right.left = new BinaryTree(12);\n  root.right.right.right = new BinaryTree(13);\n  root.right.left.left.left = new BinaryTree(14);\n\n  const mutatedRoot = program.rightSiblingTree(root);\n  const dfsOrder = getDfsOrder(mutatedRoot, []);\n  const expected = [1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13];\n  chai.expect(dfsOrder).to.deep.equal(expected);\n});\n\nfunction getDfsOrder(tree: BinaryTree, values: number[]) {\n  values.push(tree.value);\n  if (tree.left !== null) {\n    getDfsOrder(tree.left, values);\n  }\n  if (tree.right !== null) {\n    getDfsOrder(tree.right, values);\n  }\n  return values;\n}\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1);\n  root.left = new BinaryTree(2);\n  root.right = new BinaryTree(3);\n  root.left.left = new BinaryTree(4);\n  root.left.right = new BinaryTree(5);\n  root.right.left = new BinaryTree(6);\n  root.right.right = new BinaryTree(7);\n  root.left.left.left = new BinaryTree(8);\n  root.left.left.right = new BinaryTree(9);\n  root.left.right.right = new BinaryTree(10);\n  root.right.left.left = new BinaryTree(11);\n  root.right.right.left = new BinaryTree(12);\n  root.right.right.right = new BinaryTree(13);\n  root.right.left.left.left = new BinaryTree(14);\n\n  const mutatedRoot = program.rightSiblingTree(root);\n  const dfsOrder = getDfsOrder(mutatedRoot, []);\n  const expected = [1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13];\n  chai.expect(dfsOrder).to.deep.equal(expected);\n});\n\nfunction getDfsOrder(tree: BinaryTree, values: number[]) {\n  values.push(tree.value);\n  if (tree.left !== null) {\n    getDfsOrder(tree.left, values);\n  }\n  if (tree.right !== null) {\n    getDfsOrder(tree.right, values);\n  }\n  return values;\n}\n"
    }
  },
  "customInputVars": [
    {
      "name": "tree",
      "example": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": "12",
            "right": "13",
            "value": 7
          },
          {
            "id": "13",
            "left": null,
            "right": null,
            "value": 13
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "6",
            "left": "11",
            "right": null,
            "value": 6
          },
          {
            "id": "11",
            "left": "14",
            "right": null,
            "value": 11
          },
          {
            "id": "14",
            "left": null,
            "right": null,
            "value": 14
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": null,
            "right": "10",
            "value": 5
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      },
      "schema": {
        "description": "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "left": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "right": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "left",
                "right"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "root": {
            "type": "string"
          }
        },
        "required": [
          "root",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": "12",
            "right": "13",
            "value": 7
          },
          {
            "id": "13",
            "left": null,
            "right": null,
            "value": 13
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "6",
            "left": "11",
            "right": null,
            "value": 6
          },
          {
            "id": "11",
            "left": "14",
            "right": null,
            "value": 11
          },
          {
            "id": "14",
            "left": null,
            "right": null,
            "value": 14
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": null,
            "right": "10",
            "value": 5
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "2",
            "left": "4",
            "right": null,
            "value": 2
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": null,
            "value": 3
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": null,
            "value": 3
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": "7",
            "right": "8",
            "value": 5
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": "14",
            "right": "15",
            "value": 7
          },
          {
            "id": "15",
            "left": null,
            "right": null,
            "value": 15
          },
          {
            "id": "14",
            "left": null,
            "right": null,
            "value": 14
          },
          {
            "id": "6",
            "left": "12",
            "right": "13",
            "value": 6
          },
          {
            "id": "13",
            "left": null,
            "right": null,
            "value": 13
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": "10",
            "right": "11",
            "value": 5
          },
          {
            "id": "11",
            "left": null,
            "right": null,
            "value": 11
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    }
  ],
  "jsonTests": [
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": "12",
            "right": "13",
            "value": 7
          },
          {
            "id": "13",
            "left": null,
            "right": null,
            "value": 13
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "6",
            "left": "11",
            "right": null,
            "value": 6
          },
          {
            "id": "11",
            "left": "14",
            "right": null,
            "value": 11
          },
          {
            "id": "14",
            "left": null,
            "right": null,
            "value": 14
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": null,
            "right": "10",
            "value": 5
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "2",
            "left": "4",
            "right": null,
            "value": 2
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": null,
            "value": 3
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": null,
            "value": 3
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": "7",
            "right": "8",
            "value": 5
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "3",
            "left": "6",
            "right": "7",
            "value": 3
          },
          {
            "id": "7",
            "left": "14",
            "right": "15",
            "value": 7
          },
          {
            "id": "15",
            "left": null,
            "right": null,
            "value": 15
          },
          {
            "id": "14",
            "left": null,
            "right": null,
            "value": 14
          },
          {
            "id": "6",
            "left": "12",
            "right": "13",
            "value": 6
          },
          {
            "id": "13",
            "left": null,
            "right": null,
            "value": 13
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "2",
            "left": "4",
            "right": "5",
            "value": 2
          },
          {
            "id": "5",
            "left": "10",
            "right": "11",
            "value": 5
          },
          {
            "id": "11",
            "left": null,
            "right": null,
            "value": 11
          },
          {
            "id": "10",
            "left": null,
            "right": null,
            "value": 10
          },
          {
            "id": "4",
            "left": "8",
            "right": "9",
            "value": 4
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "1"
      }
    }
  ],
  "changelog": []
}