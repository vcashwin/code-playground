{
  "uid": "river-sizes",
  "testStrategy": "JSON",
  "name": "River Sizes",
  "version": 0,
  "releaseDate": "2000-05-04T00:00:00Z",
  "category": "Graphs",
  "difficulty": 2,
  "acl": {
    "isFree": true,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 39474,
    "failureCount": 22377
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "249312783",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 1390
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given a two-dimensional array (a matrix) of potentially unequal height\n  and width containing only <span>0</span>s and <span>1</span>s. Each\n  <span>0</span> represents land, and each <span>1</span> represents part of a\n  river. A river consists of any number of <span>1</span>s that are either\n  horizontally or vertically adjacent (but not diagonally adjacent). The number\n  of adjacent <span>1</span>s forming a river determine its size.\n</p>\n<p>\n  Note that a river can twist. In other words, it doesn't have to be a straight\n  vertical line or a straight horizontal line; it can be L-shaped, for example.\n</p>\n<p>\n  Write a function that returns an array of the sizes of all rivers represented\n  in the input matrix. The sizes don't need to be in any particular order.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">matrix</span> = [\n  [1, 0, 0, 1, 0],\n  [1, 0, 1, 0, 0],\n  [0, 0, 1, 0, 1],\n  [1, 0, 1, 0, 1],\n  [1, 0, 1, 1, 0],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[1, 2, 2, 2, 5] <span class=\"CodeEditor-promptComment\">// The numbers could be ordered differently.</span>\n\n<span class=\"CodeEditor-promptComment\">// The rivers can be clearly seen here:</span>\n<span class=\"CodeEditor-promptComment\">// [</span>\n<span class=\"CodeEditor-promptComment\">//   [1,  ,  , 1,  ],</span>\n<span class=\"CodeEditor-promptComment\">//   [1,  , 1,  ,  ],</span>\n<span class=\"CodeEditor-promptComment\">//   [ ,  , 1,  , 1],</span>\n<span class=\"CodeEditor-promptComment\">//   [1,  , 1,  , 1],</span>\n<span class=\"CodeEditor-promptComment\">//   [1,  , 1, 1,  ],</span>\n<span class=\"CodeEditor-promptComment\">// ]</span>\n</pre>\n</div>",
  "hints": [
    "<p>\nSince you must return the sizes of rivers, which consist of horizontally and vertically adjacent 1s in the input matrix, you must somehow keep track of groups of neighboring 1s as you traverse the matrix. Try treating the matrix as a graph, where each element in the matrix is a node in the graph with up to 4 neighboring nodes (above, below, to the left, and to the right), and traverse it using a popular graph-traversal algorithm like Depth-first Search or Breadth-first Search.\n</p>\n",
    "\n<p>\nBy traversing the matrix using DFS or BFS as mentioned in Hint #1, any time that you encounter a 1 you can traverse the entire river that this 1 is a part of (and keep track of its size) by simply iterating through the given node's neighboring nodes and their own neighboring nodes so long as the nodes are 1s.\n</p>\n",
    "\n<p>\nNaturally, many nodes in the graph mentioned in Hint #1 will have overlapping neighboring nodes, and as you traverse the matrix, you will undoubtedly encounter nodes that you have previously visited. In order to prevent mistakenly calculating the same river's size multiple times and to avoid doing needless computational work, try keeping track of every node that you visit in an auxiliary data structure and only performing important computations on unvisited nodes. What data structure would be ideal here?\n</p>"
  ],
  "spaceTime": "O(wh) time | O(wh) space - where w and h are the width and height of the input matrix",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nvector<int> riverSizes(vector<vector<int>> matrix) {\n  // Write your code here.\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nvoid traverseNode(\n  int i,\n  int j,\n  vector<vector<int>>& matrix,\n  vector<vector<int>>& visited,\n  vector<int>& sizes\n);\nvector<vector<int>> getUnvisitedNeighbors(\n  int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& visited\n);\n\n// O(wh) time | O(wh) space\nvector<int> riverSizes(vector<vector<int>> matrix) {\n  vector<int> sizes = {};\n  vector<vector<int>> visited(\n    matrix.size(), vector<int>(matrix[0].size(), false)\n  );\n  for (int i = 0; i < matrix.size(); i++) {\n    for (int j = 0; j < matrix[i].size(); j++) {\n      if (visited[i][j]) {\n        continue;\n      }\n      traverseNode(i, j, matrix, visited, sizes);\n    }\n  }\n  return sizes;\n}\n\nvoid traverseNode(\n  int i,\n  int j,\n  vector<vector<int>>& matrix,\n  vector<vector<int>>& visited,\n  vector<int>& sizes\n) {\n  int currentRiverSize = 0;\n  vector<vector<int>> nodesToExplore{{i, j}};\n  while (nodesToExplore.size() != 0) {\n    vector<int> currentNode = nodesToExplore.back();\n    nodesToExplore.pop_back();\n    i = currentNode[0];\n    j = currentNode[1];\n    if (visited[i][j]) {\n      continue;\n    }\n    visited[i][j] = true;\n    if (matrix[i][j] == 0) {\n      continue;\n    }\n    currentRiverSize++;\n    vector<vector<int>> unvisitedNeighbors =\n      getUnvisitedNeighbors(i, j, matrix, visited);\n    for (vector<int> neighbor : unvisitedNeighbors) {\n      nodesToExplore.push_back(neighbor);\n    }\n  }\n  if (currentRiverSize > 0) {\n    sizes.push_back(currentRiverSize);\n  }\n}\n\nvector<vector<int>> getUnvisitedNeighbors(\n  int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& visited\n) {\n  vector<vector<int>> unvisitedNeighbors{};\n  if (i > 0 && !visited[i - 1][j]) {\n    unvisitedNeighbors.push_back({i - 1, j});\n  }\n  if (i < matrix.size() - 1 && !visited[i + 1][j]) {\n    unvisitedNeighbors.push_back({i + 1, j});\n  }\n  if (j > 0 && !visited[i][j - 1]) {\n    unvisitedNeighbors.push_back({i, j - 1});\n  }\n  if (j < matrix[0].size() - 1 && !visited[i][j + 1]) {\n    unvisitedNeighbors.push_back({i, j + 1});\n  }\n  return unvisitedNeighbors;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include <algorithm>\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> testInput{\n        {1, 0, 0, 1, 0},\n        {1, 0, 1, 0, 0},\n        {0, 0, 1, 0, 1},\n        {1, 0, 1, 0, 1},\n        {1, 0, 1, 1, 0},\n      };\n      vector<int> expected{1, 2, 2, 2, 5};\n      vector<int> output = riverSizes(testInput);\n      sort(output.begin(), output.end());\n      assert(output == expected);\n    });\n  }\n};\n",
      "unitTests": "#include <algorithm>\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> testInput{\n        {1, 0, 0, 1, 0},\n        {1, 0, 1, 0, 0},\n        {0, 0, 1, 0, 1},\n        {1, 0, 1, 0, 1},\n        {1, 0, 1, 1, 0},\n      };\n      vector<int> expected{1, 2, 2, 2, 5};\n      vector<int> output = riverSizes(testInput);\n      sort(output.begin(), output.end());\n      assert(output == expected);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n  public static List<int> RiverSizes(int[,] matrix) {\n    // Write your code here.\n    return new List<int>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(wh) time | O(wh) space\n  public static List<int> RiverSizes(int[,] matrix) {\n    List<int> sizes = new List<int>();\n    bool[,] visited = new bool[matrix.GetLength(0), matrix.GetLength(1)];\n    for (int i = 0; i < matrix.GetLength(0); i++) {\n      for (int j = 0; j < matrix.GetLength(1); j++) {\n        if (visited[i, j]) {\n          continue;\n        }\n        traverseNode(i, j, matrix, visited, sizes);\n      }\n    }\n    return sizes;\n  }\n\n  public static void traverseNode(\n    int i, int j, int[,] matrix, bool[,] visited, List<int> sizes\n  ) {\n    int currentRiverSize = 0;\n    Stack<int[]> nodesToExplore = new Stack<int[]>();\n    nodesToExplore.Push(new int[] { i, j });\n    while (nodesToExplore.Count != 0) {\n      int[] currentNode = nodesToExplore.Pop();\n      i = currentNode[0];\n      j = currentNode[1];\n      if (visited[i, j]) {\n        continue;\n      }\n      visited[i, j] = true;\n      if (matrix[i, j] == 0) {\n        continue;\n      }\n      currentRiverSize++;\n      List<int[]> unvisitedNeighbors =\n        getUnvisitedNeighbors(i, j, matrix, visited);\n      foreach (var neighbor in unvisitedNeighbors) {\n        nodesToExplore.Push(neighbor);\n      }\n    }\n    if (currentRiverSize > 0) {\n      sizes.Add(currentRiverSize);\n    }\n  }\n\n  public static List<int[]> getUnvisitedNeighbors(\n    int i, int j, int[,] matrix, bool[,] visited\n  ) {\n    List<int[]> unvisitedNeighbors = new List<int[]>();\n    if (i > 0 && !visited[i - 1, j]) {\n      unvisitedNeighbors.Add(new int[] { i - 1, j });\n    }\n    if (i < matrix.GetLength(0) - 1 && !visited[i + 1, j]) {\n      unvisitedNeighbors.Add(new int[] { i + 1, j });\n    }\n    if (j > 0 && !visited[i, j - 1]) {\n      unvisitedNeighbors.Add(new int[] { i, j - 1 });\n    }\n    if (j < matrix.GetLength(1) - 1 && !visited[i, j + 1]) {\n      unvisitedNeighbors.Add(new int[] { i, j + 1 });\n    }\n    return unvisitedNeighbors;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[,] input = {\n      { 1, 0, 0, 1, 0 },\n      { 1, 0, 1, 0, 0 },\n      { 0, 0, 1, 0, 1 },\n      { 1, 0, 1, 0, 1 },\n      { 1, 0, 1, 1, 0 },\n    };\n    int[] expected = { 1, 2, 2, 2, 5 };\n    List<int> output = Program.RiverSizes(input);\n    output.Sort();\n    Utils.AssertTrue(compare(output, expected));\n  }\n\n  public static bool compare(List<int> arr1, int[] arr2) {\n    if (arr1.Count != arr2.Length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.Count; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[,] input = {\n      { 1, 0, 0, 1, 0 },\n      { 1, 0, 1, 0, 0 },\n      { 0, 0, 1, 0, 1 },\n      { 1, 0, 1, 0, 1 },\n      { 1, 0, 1, 1, 0 },\n    };\n    int[] expected = { 1, 2, 2, 2, 5 };\n    List<int> output = Program.RiverSizes(input);\n    output.Sort();\n    Utils.AssertTrue(compare(output, expected));\n  }\n\n  public static bool compare(List<int> arr1, int[] arr2) {\n    if (arr1.Count != arr2.Length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.Count; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc RiverSizes(matrix [][]int) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(wh) time | O(wh) space\nfunc RiverSizes(matrix [][]int) []int {\n\tsizes := []int{}\n\tvisited := make([][]bool, len(matrix))\n\tfor i := range visited {\n\t\tvisited[i] = make([]bool, len(matrix[i]))\n\t}\n\tfor i := range matrix {\n\t\tfor j := range matrix[i] {\n\t\t\tif visited[i][j] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsizes = traverseNode(i, j, matrix, visited, sizes)\n\t\t}\n\t}\n\treturn sizes\n}\n\nfunc traverseNode(i, j int, matrix [][]int, visited [][]bool, sizes []int) []int {\n\tcurrentRiverSize := 0\n\tnodesToExplore := [][]int{{i, j}}\n\tfor len(nodesToExplore) > 0 {\n\t\tcurrentNode := nodesToExplore[0]\n\t\tnodesToExplore = nodesToExplore[1:]\n\t\ti, j := currentNode[0], currentNode[1]\n\t\tif visited[i][j] {\n\t\t\tcontinue\n\t\t}\n\t\tvisited[i][j] = true\n\t\tif matrix[i][j] == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tcurrentRiverSize += 1\n\t\tunvisitedNeighbors := getUnvisitedNeighbors(i, j, matrix, visited)\n\t\tfor _, neighbor := range unvisitedNeighbors {\n\t\t\tnodesToExplore = append(nodesToExplore, neighbor)\n\t\t}\n\t}\n\tif currentRiverSize > 0 {\n\t\tsizes = append(sizes, currentRiverSize)\n\t}\n\treturn sizes\n}\n\nfunc getUnvisitedNeighbors(i, j int, matrix [][]int, visited [][]bool) [][]int {\n\tunvisitedNeighbors := [][]int{}\n\tif i > 0 && !visited[i-1][j] {\n\t\tunvisitedNeighbors = append(unvisitedNeighbors, []int{i - 1, j})\n\t}\n\tif i < len(matrix)-1 && !visited[i+1][j] {\n\t\tunvisitedNeighbors = append(unvisitedNeighbors, []int{i + 1, j})\n\t}\n\tif j > 0 && !visited[i][j-1] {\n\t\tunvisitedNeighbors = append(unvisitedNeighbors, []int{i, j - 1})\n\t}\n\tif j < len(matrix[0])-1 && !visited[i][j+1] {\n\t\tunvisitedNeighbors = append(unvisitedNeighbors, []int{i, j + 1})\n\t}\n\treturn unvisitedNeighbors\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"reflect\"\n\t\"sort\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{1, 2, 2, 2, 5}\n\tinput := [][]int{\n\t\t{1, 0, 0, 1, 0},\n\t\t{1, 0, 1, 0, 0},\n\t\t{0, 0, 1, 0, 1},\n\t\t{1, 0, 1, 0, 1},\n\t\t{1, 0, 1, 1, 0},\n\t}\n\toutput := RiverSizes(input)\n\tsort.Ints(output)\n\tif !reflect.DeepEqual(expected, output) {\n\t\tt.Fail()\n\t}\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"reflect\"\n\t\"sort\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{1, 2, 2, 2, 5}\n\tinput := [][]int{\n\t\t{1, 0, 0, 1, 0},\n\t\t{1, 0, 1, 0, 0},\n\t\t{0, 0, 1, 0, 1},\n\t\t{1, 0, 1, 0, 1},\n\t\t{1, 0, 1, 1, 0},\n\t}\n\toutput := RiverSizes(input)\n\tsort.Ints(output)\n\tif !reflect.DeepEqual(expected, output) {\n\t\tt.Fail()\n\t}\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static List<Integer> riverSizes(int[][] matrix) {\n    // Write your code here.\n    return new ArrayList<Integer>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(wh) time | O(wh) space\n  public static List<Integer> riverSizes(int[][] matrix) {\n    List<Integer> sizes = new ArrayList<Integer>();\n    boolean[][] visited = new boolean[matrix.length][matrix[0].length];\n    for (int i = 0; i < matrix.length; i++) {\n      for (int j = 0; j < matrix[0].length; j++) {\n        if (visited[i][j]) {\n          continue;\n        }\n        traverseNode(i, j, matrix, visited, sizes);\n      }\n    }\n    return sizes;\n  }\n\n  public static void traverseNode(\n    int i, int j, int[][] matrix, boolean[][] visited, List<Integer> sizes\n  ) {\n    int currentRiverSize = 0;\n    Stack<Integer[]> nodesToExplore = new Stack<Integer[]>();\n    nodesToExplore.push(new Integer[] {i, j});\n    while (!nodesToExplore.empty()) {\n      Integer[] currentNode = nodesToExplore.pop();\n      i = currentNode[0];\n      j = currentNode[1];\n      if (visited[i][j]) {\n        continue;\n      }\n      visited[i][j] = true;\n      if (matrix[i][j] == 0) {\n        continue;\n      }\n      currentRiverSize++;\n      List<Integer[]> unvisitedNeighbors =\n        getUnvisitedNeighbors(i, j, matrix, visited);\n      for (Integer[] neighbor : unvisitedNeighbors) {\n        nodesToExplore.add(neighbor);\n      }\n    }\n    if (currentRiverSize > 0) {\n      sizes.add(currentRiverSize);\n    }\n  }\n\n  public static List<Integer[]> getUnvisitedNeighbors(\n    int i, int j, int[][] matrix, boolean[][] visited\n  ) {\n    List<Integer[]> unvisitedNeighbors = new ArrayList<Integer[]>();\n    if (i > 0 && !visited[i - 1][j]) {\n      unvisitedNeighbors.add(new Integer[] {i - 1, j});\n    }\n    if (i < matrix.length - 1 && !visited[i + 1][j]) {\n      unvisitedNeighbors.add(new Integer[] {i + 1, j});\n    }\n    if (j > 0 && !visited[i][j - 1]) {\n      unvisitedNeighbors.add(new Integer[] {i, j - 1});\n    }\n    if (j < matrix[0].length - 1 && !visited[i][j + 1]) {\n      unvisitedNeighbors.add(new Integer[] {i, j + 1});\n    }\n    return unvisitedNeighbors;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] input = {\n      {1, 0, 0, 1, 0},\n      {1, 0, 1, 0, 0},\n      {0, 0, 1, 0, 1},\n      {1, 0, 1, 0, 1},\n      {1, 0, 1, 1, 0},\n    };\n    int[] expected = {1, 2, 2, 2, 5};\n    List<Integer> output = Program.riverSizes(input);\n    Collections.sort(output);\n    Utils.assertTrue(compare(output, expected));\n  }\n\n  public static boolean compare(List<Integer> arr1, int[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] input = {\n      {1, 0, 0, 1, 0},\n      {1, 0, 1, 0, 0},\n      {0, 0, 1, 0, 1},\n      {1, 0, 1, 0, 1},\n      {1, 0, 1, 1, 0},\n    };\n    int[] expected = {1, 2, 2, 2, 5};\n    List<Integer> output = Program.riverSizes(input);\n    Collections.sort(output);\n    Utils.assertTrue(compare(output, expected));\n  }\n\n  public static boolean compare(List<Integer> arr1, int[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function riverSizes(matrix) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.riverSizes = riverSizes;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(wh) time | O(wh) space\nfunction riverSizes(matrix) {\n  const sizes = [];\n  const visited = matrix.map(row => row.map(value => false));\n  for (let i = 0; i < matrix.length; i++) {\n    for (let j = 0; j < matrix[i].length; j++) {\n      if (visited[i][j]) continue;\n      traverseNode(i, j, matrix, visited, sizes);\n    }\n  }\n  return sizes;\n}\n\nfunction traverseNode(i, j, matrix, visited, sizes) {\n  let currentRiverSize = 0;\n  const nodesToExplore = [[i, j]];\n  while (nodesToExplore.length) {\n    const currentNode = nodesToExplore.pop();\n    i = currentNode[0];\n    j = currentNode[1];\n    if (visited[i][j]) continue;\n    visited[i][j] = true;\n    if (matrix[i][j] === 0) continue;\n    currentRiverSize++;\n    const unvisitedNeighbors = getUnvisitedNeighbors(i, j, matrix, visited);\n    for (const neighbor of unvisitedNeighbors) {\n      nodesToExplore.push(neighbor);\n    }\n  }\n  if (currentRiverSize > 0) sizes.push(currentRiverSize);\n}\n\nfunction getUnvisitedNeighbors(i, j, matrix, visited) {\n  const unvisitedNeighbors = [];\n  if (i > 0 && !visited[i - 1][j]) unvisitedNeighbors.push([i - 1, j]);\n  if (i < matrix.length - 1 && !visited[i + 1][j]) unvisitedNeighbors.push([i + 1, j]);\n  if (j > 0 && !visited[i][j - 1]) unvisitedNeighbors.push([i, j - 1]);\n  if (j < matrix[0].length - 1 && !visited[i][j + 1]) unvisitedNeighbors.push([i, j + 1]);\n  return unvisitedNeighbors;\n}\n\nexports.riverSizes = riverSizes;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const testInput = [\n    [1, 0, 0, 1, 0],\n    [1, 0, 1, 0, 0],\n    [0, 0, 1, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 1, 1, 0],\n  ];\n  const expected = [1, 2, 2, 2, 5];\n  chai.expect(program.riverSizes(testInput).sort((a, b) => a - b)).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const testInput = [\n    [1, 0, 0, 1, 0],\n    [1, 0, 1, 0, 0],\n    [0, 0, 1, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 1, 1, 0],\n  ];\n  const expected = [1, 2, 2, 2, 5];\n  chai.expect(program.riverSizes(testInput).sort((a, b) => a - b)).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun riverSizes(matrix: List<List<Int>>): List<Int> {\n    // Write your code here.\n    return listOf()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport java.util.Stack\n\n// O(wh) time | O(wh) space\nfun riverSizes(matrix: List<List<Int>>): List<Int> {\n    val sizes = mutableListOf<Int>()\n    val visited = List(matrix.size) { MutableList(matrix[0].size) { false } }\n    for (i in 0 until matrix.size) {\n        for (j in 0 until matrix[0].size) {\n            if (visited[i][j]) {\n                continue\n            }\n            traverseNode(i, j, matrix, visited, sizes)\n        }\n    }\n    return sizes\n}\n\nfun traverseNode(iStart: Int, jStart: Int, matrix: List<List<Int>>, visited: List<MutableList<Boolean>>, sizes: MutableList<Int>) {\n    var i = iStart\n    var j = jStart\n\n    var currentRiverSize = 0\n    val nodesToExplore = Stack<Pair<Int, Int>>()\n    nodesToExplore.push(Pair(i, j))\n    while (!nodesToExplore.empty()) {\n        val currentNode = nodesToExplore.pop()\n        i = currentNode.first\n        j = currentNode.second\n        if (visited[i][j]) {\n            continue\n        }\n        visited[i][j] = true\n        if (matrix[i][j] == 0) {\n            continue\n        }\n        currentRiverSize++\n        val unvisitedNeighbors = getUnvisitedNeighbors(i, j, matrix, visited)\n        for (neighbor in unvisitedNeighbors) {\n            nodesToExplore.add(neighbor)\n        }\n    }\n    if (currentRiverSize > 0) {\n        sizes.add(currentRiverSize)\n    }\n}\n\nfun getUnvisitedNeighbors(i: Int, j: Int, matrix: List<List<Int>>, visited: List<List<Boolean>>): List<Pair<Int, Int>> {\n    val unvisitedNeighbors = mutableListOf<Pair<Int, Int>>()\n    if (i > 0 && !visited[i - 1][j]) {\n        unvisitedNeighbors.add(Pair(i - 1, j))\n    }\n    if (i < matrix.size - 1 && !visited[i + 1][j]) {\n        unvisitedNeighbors.add(Pair(i + 1, j))\n    }\n    if (j > 0 && !visited[i][j - 1]) {\n        unvisitedNeighbors.add(Pair(i, j - 1))\n    }\n    if (j < matrix[0].size - 1 && !visited[i][j + 1]) {\n        unvisitedNeighbors.add(Pair(i, j + 1))\n    }\n    return unvisitedNeighbors\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.riverSizes\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(\n            listOf(1, 0, 0, 1, 0),\n            listOf(1, 0, 1, 0, 0),\n            listOf(0, 0, 1, 0, 1),\n            listOf(1, 0, 1, 0, 1),\n            listOf(1, 0, 1, 1, 0),\n        )\n        val expected = listOf(1, 2, 2, 2, 5)\n        val output = riverSizes(input).sorted()\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.riverSizes\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(\n            listOf(1, 0, 0, 1, 0),\n            listOf(1, 0, 1, 0, 0),\n            listOf(0, 0, 1, 0, 1),\n            listOf(1, 0, 1, 0, 1),\n            listOf(1, 0, 1, 1, 0),\n        )\n        val expected = listOf(1, 2, 2, 2, 5)\n        val output = riverSizes(input).sorted()\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def riverSizes(matrix):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(wh) time | O(wh) space\ndef riverSizes(matrix):\n    sizes = []\n    visited = [[False for value in row] for row in matrix]\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            if visited[i][j]:\n                continue\n            traverseNode(i, j, matrix, visited, sizes)\n    return sizes\n\n\ndef traverseNode(i, j, matrix, visited, sizes):\n    currentRiverSize = 0\n    nodesToExplore = [[i, j]]\n    while len(nodesToExplore):\n        currentNode = nodesToExplore.pop()\n        i = currentNode[0]\n        j = currentNode[1]\n        if visited[i][j]:\n            continue\n        visited[i][j] = True\n        if matrix[i][j] == 0:\n            continue\n        currentRiverSize += 1\n        unvisitedNeighbors = getUnvisitedNeighbors(i, j, matrix, visited)\n        for neighbor in unvisitedNeighbors:\n            nodesToExplore.append(neighbor)\n    if currentRiverSize > 0:\n        sizes.append(currentRiverSize)\n\n\ndef getUnvisitedNeighbors(i, j, matrix, visited):\n    unvisitedNeighbors = []\n    if i > 0 and not visited[i - 1][j]:\n        unvisitedNeighbors.append([i - 1, j])\n    if i < len(matrix) - 1 and not visited[i + 1][j]:\n        unvisitedNeighbors.append([i + 1, j])\n    if j > 0 and not visited[i][j - 1]:\n        unvisitedNeighbors.append([i, j - 1])\n    if j < len(matrix[0]) - 1 and not visited[i][j + 1]:\n        unvisitedNeighbors.append([i, j + 1])\n    return unvisitedNeighbors\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        testInput = [\n            [1, 0, 0, 1, 0],\n            [1, 0, 1, 0, 0],\n            [0, 0, 1, 0, 1],\n            [1, 0, 1, 0, 1],\n            [1, 0, 1, 1, 0],\n        ]\n        expected = [1, 2, 2, 2, 5]\n        self.assertEqual(sorted(program.riverSizes(testInput)), expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        testInput = [\n            [1, 0, 0, 1, 0],\n            [1, 0, 1, 0, 0],\n            [0, 0, 1, 0, 1],\n            [1, 0, 1, 0, 1],\n            [1, 0, 1, 1, 0],\n        ]\n        expected = [1, 2, 2, 2, 5]\n        self.assertEqual(sorted(program.riverSizes(testInput)), expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def riverSizes(matrix)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def riverSizes(matrix)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.riverSizes\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.riverSizes\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func riverSizes(_ matrix: [[Int]]) -> [Int] {\n    // Write your code here.\n    return []\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(wh) time | O(wh) space\n  func riverSizes(_ matrix: [[Int]]) -> [Int] {\n    var sizes: [Int] = []\n    var visited: [[Bool]] = matrix.map { $0.map { $0 == 2 } }\n    for var i in 0 ..< matrix.count {\n      for var j in 0 ..< matrix[i].count {\n        if visited[i][j] { continue }\n        traverseNode(i, j, matrix, &visited, &sizes)\n      }\n    }\n    return sizes\n  }\n\n  func traverseNode(_ k: Int, _ l: Int, _ matrix: [[Int]], _ visited: inout [[Bool]], _ sizes: inout [Int]) {\n    var i = k\n    var j = l\n    var currentRiverSize = 0\n    var nodesToExplore = [[i, j]]\n    while nodesToExplore.count > 0 {\n      let currentNode = nodesToExplore.popLast()!\n\n      i = currentNode[0]\n      j = currentNode[1]\n      if visited[i][j] { continue }\n      visited[i][j] = true\n\n      if matrix[i][j] == 0 { continue }\n      currentRiverSize += 1\n\n      let unvisitedNeighbors = getUnvisitedNeighbors(i, j, matrix, visited)\n      for node in unvisitedNeighbors {\n        nodesToExplore.append(node)\n      }\n    }\n    if currentRiverSize > 0 { sizes.append(currentRiverSize) }\n  }\n\n  func getUnvisitedNeighbors(_ i: Int, _ j: Int, _ matrix: [[Int]], _ visited: [[Bool]]) -> [[Int]] {\n    var unvisitedNeighbors: [[Int]] = []\n\n    if i > 0, !visited[i - 1][j] {\n      unvisitedNeighbors.append([i - 1, j])\n    }\n    if i < matrix.count - 1, !visited[i + 1][j] {\n      unvisitedNeighbors.append([i + 1, j])\n    }\n    if j > 0, !visited[i][j - 1] {\n      unvisitedNeighbors.append([i, j - 1])\n    }\n    if j < matrix[i].count - 1, !visited[i][j + 1] {\n      unvisitedNeighbors.append([i, j + 1])\n    }\n    return unvisitedNeighbors\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let Matrix = [\n        [1, 0, 0, 1, 0],\n        [1, 0, 1, 0, 0],\n        [0, 0, 1, 0, 1],\n        [1, 0, 1, 0, 1],\n        [1, 0, 1, 1, 0],\n      ]\n      let Expected = [1, 2, 2, 2, 5]\n      let RiverSizes = program.riverSizes(Matrix).sorted()\n      try assertEqual(Expected, RiverSizes)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let Matrix = [\n        [1, 0, 0, 1, 0],\n        [1, 0, 1, 0, 0],\n        [0, 0, 1, 0, 1],\n        [1, 0, 1, 0, 1],\n        [1, 0, 1, 1, 0],\n      ]\n      let Expected = [1, 2, 2, 2, 5]\n      let RiverSizes = program.riverSizes(Matrix).sorted()\n      try assertEqual(Expected, RiverSizes)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function riverSizes(matrix: number[][]) {\n  // Write your code here.\n  return [-1];\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(wh) time | O(wh) space\nexport function riverSizes(matrix: number[][]) {\n  const sizes: number[] = [];\n  const visited: boolean[][] = matrix.map(row => row.map(value => false));\n  for (let i = 0; i < matrix.length; i++) {\n    for (let j = 0; j < matrix[i].length; j++) {\n      if (visited[i][j]) continue;\n      traverseNode(i, j, matrix, visited, sizes);\n    }\n  }\n  return sizes;\n}\n\nfunction traverseNode(\n  i: number,\n  j: number,\n  matrix: number[][],\n  visited: boolean[][],\n  sizes: number[],\n) {\n  let currentRiverSize = 0;\n  const nodesToExplore = [[i, j]];\n  while (nodesToExplore.length) {\n    const currentNode = nodesToExplore.pop()!;\n    i = currentNode[0];\n    j = currentNode[1];\n    if (visited[i][j]) continue;\n    visited[i][j] = true;\n    if (matrix[i][j] === 0) continue;\n    currentRiverSize++;\n    const unvisitedNeighbors = getUnvisitedNeighbors(i, j, matrix, visited);\n    for (const neighbor of unvisitedNeighbors) {\n      nodesToExplore.push(neighbor);\n    }\n  }\n  if (currentRiverSize > 0) sizes.push(currentRiverSize);\n}\n\nfunction getUnvisitedNeighbors(i: number, j: number, matrix: number[][], visited: boolean[][]) {\n  const unvisitedNeighbors: [number, number][] = [];\n  if (i > 0 && !visited[i - 1][j]) unvisitedNeighbors.push([i - 1, j]);\n  if (i < matrix.length - 1 && !visited[i + 1][j]) unvisitedNeighbors.push([i + 1, j]);\n  if (j > 0 && !visited[i][j - 1]) unvisitedNeighbors.push([i, j - 1]);\n  if (j < matrix[0].length - 1 && !visited[i][j + 1]) unvisitedNeighbors.push([i, j + 1]);\n  return unvisitedNeighbors;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const testInput = [\n    [1, 0, 0, 1, 0],\n    [1, 0, 1, 0, 0],\n    [0, 0, 1, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 1, 1, 0],\n  ];\n  const expected = [1, 2, 2, 2, 5];\n  chai.expect(program.riverSizes(testInput).sort((a, b) => a - b)).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const testInput = [\n    [1, 0, 0, 1, 0],\n    [1, 0, 1, 0, 0],\n    [0, 0, 1, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 1, 1, 0],\n  ];\n  const expected = [1, 2, 2, 2, 5];\n  chai.expect(program.riverSizes(testInput).sort((a, b) => a - b)).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "matrix",
      "example": [
        [
          1,
          0,
          0,
          1,
          0
        ],
        [
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1
        ],
        [
          1,
          0,
          1,
          0,
          1
        ],
        [
          1,
          0,
          1,
          1,
          0
        ]
      ],
      "schema": {
        "items": {
          "items": {
            "maximum": 1,
            "minimum": 0,
            "type": "integer"
          },
          "type": "array"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "matrix": [
        [
          1,
          0,
          0,
          1,
          0
        ],
        [
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1
        ],
        [
          1,
          0,
          1,
          0,
          1
        ],
        [
          1,
          0,
          1,
          1,
          0
        ]
      ]
    },
    {
      "matrix": [
        [
          0
        ]
      ]
    },
    {
      "matrix": [
        [
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          1,
          1,
          0,
          1,
          1,
          0,
          0,
          0,
          1,
          0
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          0,
          0,
          1
        ],
        [
          1,
          0,
          1,
          0
        ],
        [
          0,
          0,
          1,
          0
        ],
        [
          1,
          0,
          1,
          0
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          1,
          1,
          1,
          0
        ],
        [
          1,
          0,
          1,
          0,
          0,
          1,
          1,
          1,
          1,
          0,
          1,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1,
          0,
          1,
          1,
          1
        ],
        [
          1,
          0,
          1,
          0,
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          1,
          0,
          1,
          1,
          0,
          0,
          0,
          1,
          1,
          1,
          0,
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ],
        [
          0,
          1,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          1,
          0
        ],
        [
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ],
        [
          0,
          1,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          1,
          0
        ],
        [
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          1,
          0,
          0,
          0,
          0,
          1,
          1
        ],
        [
          1,
          0,
          1,
          1,
          1,
          1,
          0,
          1
        ],
        [
          0,
          1,
          1,
          0,
          0,
          0,
          1,
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          1,
          0
        ],
        [
          1,
          0,
          1
        ],
        [
          1,
          1,
          1
        ],
        [
          1,
          1,
          0
        ],
        [
          1,
          0,
          1
        ],
        [
          0,
          1,
          0
        ],
        [
          1,
          0,
          0
        ],
        [
          1,
          0,
          0
        ],
        [
          0,
          0,
          0
        ],
        [
          1,
          0,
          0
        ],
        [
          1,
          0,
          1
        ],
        [
          1,
          1,
          1
        ]
      ]
    }
  ],
  "jsonTests": [
    {
      "matrix": [
        [
          1,
          0,
          0,
          1,
          0
        ],
        [
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1
        ],
        [
          1,
          0,
          1,
          0,
          1
        ],
        [
          1,
          0,
          1,
          1,
          0
        ]
      ]
    },
    {
      "matrix": [
        [
          0
        ]
      ]
    },
    {
      "matrix": [
        [
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          1,
          1,
          0,
          1,
          1,
          0,
          0,
          0,
          1,
          0
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          0,
          0,
          1
        ],
        [
          1,
          0,
          1,
          0
        ],
        [
          0,
          0,
          1,
          0
        ],
        [
          1,
          0,
          1,
          0
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          1,
          1,
          1,
          0
        ],
        [
          1,
          0,
          1,
          0,
          0,
          1,
          1,
          1,
          1,
          0,
          1,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1,
          0,
          1,
          1,
          1
        ],
        [
          1,
          0,
          1,
          0,
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          0
        ],
        [
          1,
          0,
          1,
          1,
          0,
          0,
          0,
          1,
          1,
          1,
          0,
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ],
        [
          0,
          1,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          1,
          0
        ],
        [
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ],
        [
          0,
          1,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          1,
          0
        ],
        [
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          1,
          0,
          0,
          0,
          0,
          1,
          1
        ],
        [
          1,
          0,
          1,
          1,
          1,
          1,
          0,
          1
        ],
        [
          0,
          1,
          1,
          0,
          0,
          0,
          1,
          1
        ]
      ]
    },
    {
      "matrix": [
        [
          1,
          1,
          0
        ],
        [
          1,
          0,
          1
        ],
        [
          1,
          1,
          1
        ],
        [
          1,
          1,
          0
        ],
        [
          1,
          0,
          1
        ],
        [
          0,
          1,
          0
        ],
        [
          1,
          0,
          0
        ],
        [
          1,
          0,
          0
        ],
        [
          0,
          0,
          0
        ],
        [
          1,
          0,
          0
        ],
        [
          1,
          0,
          1
        ],
        [
          1,
          1,
          1
        ]
      ]
    }
  ],
  "changelog": []
}