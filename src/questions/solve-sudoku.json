{
  "uid": "solve-sudoku",
  "testStrategy": "JSON",
  "name": "Solve Sudoku",
  "version": 0,
  "releaseDate": "2021-02-20T00:00:00Z",
  "category": "Recursion",
  "difficulty": 3,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 5103,
    "failureCount": 1339
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "512972146",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 1267
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given a two-dimensional array that represents a 9x9 partially filled\n  Sudoku board. Write a function that returns the solved Sudoku board.\n</p>\n<p>\n  Sudoku is a famous number-placement puzzle in which you need to fill a 9x9\n  grid with integers in the range of <span>1-9</span>. Each 9x9 Sudoku board is\n  split into 9 3x3 subgrids, as seen in the illustration below, and starts out\n  partially filled.\n</p>\n<pre>\n- - 3 | - 2 - | 6 - - \n9 - - | 3 - 5 | - - 1 \n- - 1 | 8 - 6 | 4 - -\n- - - - - - - - - - - \n- - 8 | 1 - 2 | 9 - -\n7 - - | - - - | - - 8 \n- - 6 | 7 - 8 | 2 - -\n- - - - - - - - - - -\n- - 2 | 6 - 9 | 5 - - \n8 - - | 2 - 3 | - - 9\n- - 5 | - 1 - | 3 - -\n</pre>\n<p>\n  The objective is to fill the grid such that each row, column, and 3x3 subgrid\n  contains the numbers <span>1-9</span> exactly once. In other words, no row may\n  contain the same digit more than once, no column may contain the same digit\n  more than once, and none of the 9 3x3 subgrids may contain the same digit more\n  than once.\n</p>\n<p>\n  Your input for this problem will always be a partially filled 9x9\n  two-dimensional array that represents a solvable Sudoku puzzle. Every element\n  in the array will be an integer in the range of <span>0-9</span>, where a\n  <span>0</span> represents an empty square that must be filled by your\n  algorithm.\n</p>\n<p>\n  Note that you may modify the input array and that there will always be exactly\n  one solution to each input Sudoku board.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">board</span> = \n[\n  [7, 8, 0, 4, 0, 0, 1, 2, 0],\n  [6, 0, 0, 0, 7, 5, 0, 0, 9],\n  [0, 0, 0, 6, 0, 1, 0, 7, 8],\n  [0, 0, 7, 0, 4, 0, 2, 6, 0],\n  [0, 0, 1, 0, 5, 0, 9, 3, 0],\n  [9, 0, 4, 0, 6, 0, 0, 0, 5],\n  [0, 7, 0, 3, 0, 0, 0, 1, 2],\n  [1, 2, 0, 0, 0, 7, 4, 0, 0],\n  [0, 4, 9, 2, 0, 6, 0, 0, 7],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[\n  [7, 8, 5, 4, 3, 9, 1, 2, 6],\n  [6, 1, 2, 8, 7, 5, 3, 4, 9],\n  [4, 9, 3, 6, 2, 1, 5, 7, 8],\n  [8, 5, 7, 9, 4, 3, 2, 6, 1],\n  [2, 6, 1, 7, 5, 8, 9, 3, 4],\n  [9, 3, 4, 1, 6, 2, 7, 8, 5],\n  [5, 7, 8, 3, 9, 4, 6, 1, 2],\n  [1, 2, 6, 5, 8, 7, 4, 9, 3],\n  [3, 4, 9, 2, 1, 6, 8, 5, 7],\n]\n</pre>\n</div>",
  "hints": [
    "<p>\n  The brute-force approach to this problem is to generate every possible Sudoku\n  board and to check each one until you find one that's valid. The issue with\n  this approach is that there are <span>9^81</span> possible 9x9 Sudoku boards.\n  This is an extremely large number, which makes it practically impossible to\n  take this approach. How can you avoid generating every possible Sudoku board?\n</p>\n",
    "\n<p>\n  Keep in mind that a Sudoku board doesn't need to be entirely filled to figure\n  out if it's invalid and won't lead to a solution. Try generating partially\n  filled Sudoku boards until they become invalid, thereby abandoning solutions\n  that will never lead to a properly solved board.\n</p>\n",
    "\n<p>\n  The method described in Hint #2 is more formally known as backtracking. This\n  involves attempting to place digits into empty positions in the Sudoku board\n  and checking at each insertion if that newly inserted digit makes the Sudoku\n  board invalid. If it does, then you try to insert another digit until you find\n  one that doesn't invalidate the board. If it doesn't invalidate the board, you\n  temporarily place that digit and continue to try to solve the rest of the\n  board. If you ever reach a position where there are no valid digits to be\n  inserted (every digit placed in that position leads to an invalid board), that\n  means that one of the previously inserted digits is incorrect. Thus, you must\n  backtrack and change previously placed digits. For more details on this\n  approach, refer to the Conceptual Overview section of this question's video\n  explanation.\n</p>"
  ],
  "spaceTime": "O(1) time | O(1) space - assuming a 9x9 input board",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nvector<vector<int>> solveSudoku(vector<vector<int>> board) {\n  // Write your code here.\n  return {};\n}",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nbool solvePartialSudoku(int row, int col, vector<vector<int>>& board);\nbool tryDigitsAtPosition(int row, int col, vector<vector<int>>& board);\nbool isValidAtPosition(int value, int row, int col, vector<vector<int>>& board);\n\n// O(1) time | O(1) space - assuming a 9x9 input board\nvector<vector<int>> solveSudoku(vector<vector<int>> board) {\n  solvePartialSudoku(0, 0, board);\n  return board;\n}\n\nbool solvePartialSudoku(int row, int col, vector<vector<int>>& board) {\n  int currentRow = row;\n  int currentCol = col;\n\n  if (currentCol == board[currentRow].size()) {\n    currentRow++;\n    currentCol = 0;\n    if (currentRow == board.size()) return true;\n  }\n\n  if (board[currentRow][currentCol] == 0) {\n    return tryDigitsAtPosition(currentRow, currentCol, board);\n  }\n\n  return solvePartialSudoku(currentRow, currentCol + 1, board);\n}\n\nbool tryDigitsAtPosition(int row, int col, vector<vector<int>>& board) {\n  for (int digit = 1; digit < 10; digit++) {\n    if (isValidAtPosition(digit, row, col, board)) {\n      board[row][col] = digit;\n      if (solvePartialSudoku(row, col + 1, board)) return true;\n    }\n  }\n\n  board[row][col] = 0;\n  return false;\n}\n\nbool isValidAtPosition(\n  int value, int row, int col, vector<vector<int>>& board\n) {\n  bool rowIsValid =\n    find(board[row].begin(), board[row].end(), value) == board[row].end();\n  bool colIsValid = true;\n  for (auto arr : board) {\n    if (arr[col] == value) {\n      colIsValid = false;\n      break;\n    }\n  }\n\n  if (!rowIsValid || !colIsValid) return false;\n\n  // Check subgrid constraint.\n  int subgridRowStart = row / 3 * 3;\n  int subgridColStart = col / 3 * 3;\n  for (int rowIdx = 0; rowIdx < 3; rowIdx++) {\n    for (int colIdx = 0; colIdx < 3; colIdx++) {\n      int rowToCheck = subgridRowStart + rowIdx;\n      int colToCheck = subgridColStart + colIdx;\n      int existingValue = board[rowToCheck][colToCheck];\n\n      if (existingValue == value) return false;\n    }\n  }\n\n  return true;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> input = {\n        {7, 8, 0, 4, 0, 0, 1, 2, 0},\n        {6, 0, 0, 0, 7, 5, 0, 0, 9},\n        {0, 0, 0, 6, 0, 1, 0, 7, 8},\n        {0, 0, 7, 0, 4, 0, 2, 6, 0},\n        {0, 0, 1, 0, 5, 0, 9, 3, 0},\n        {9, 0, 4, 0, 6, 0, 0, 0, 5},\n        {0, 7, 0, 3, 0, 0, 0, 1, 2},\n        {1, 2, 0, 0, 0, 7, 4, 0, 0},\n        {0, 4, 9, 2, 0, 6, 0, 0, 7},\n      };\n      vector<vector<int>> expected = {\n        {7, 8, 5, 4, 3, 9, 1, 2, 6},\n        {6, 1, 2, 8, 7, 5, 3, 4, 9},\n        {4, 9, 3, 6, 2, 1, 5, 7, 8},\n        {8, 5, 7, 9, 4, 3, 2, 6, 1},\n        {2, 6, 1, 7, 5, 8, 9, 3, 4},\n        {9, 3, 4, 1, 6, 2, 7, 8, 5},\n        {5, 7, 8, 3, 9, 4, 6, 1, 2},\n        {1, 2, 6, 5, 8, 7, 4, 9, 3},\n        {3, 4, 9, 2, 1, 6, 8, 5, 7},\n      };\n      auto actual = solveSudoku(input);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> input = {\n        {7, 8, 0, 4, 0, 0, 1, 2, 0},\n        {6, 0, 0, 0, 7, 5, 0, 0, 9},\n        {0, 0, 0, 6, 0, 1, 0, 7, 8},\n        {0, 0, 7, 0, 4, 0, 2, 6, 0},\n        {0, 0, 1, 0, 5, 0, 9, 3, 0},\n        {9, 0, 4, 0, 6, 0, 0, 0, 5},\n        {0, 7, 0, 3, 0, 0, 0, 1, 2},\n        {1, 2, 0, 0, 0, 7, 4, 0, 0},\n        {0, 4, 9, 2, 0, 6, 0, 0, 7},\n      };\n      vector<vector<int>> expected = {\n        {7, 8, 5, 4, 3, 9, 1, 2, 6},\n        {6, 1, 2, 8, 7, 5, 3, 4, 9},\n        {4, 9, 3, 6, 2, 1, 5, 7, 8},\n        {8, 5, 7, 9, 4, 3, 2, 6, 1},\n        {2, 6, 1, 7, 5, 8, 9, 3, 4},\n        {9, 3, 4, 1, 6, 2, 7, 8, 5},\n        {5, 7, 8, 3, 9, 4, 6, 1, 2},\n        {1, 2, 6, 5, 8, 7, 4, 9, 3},\n        {3, 4, 9, 2, 1, 6, 8, 5, 7},\n      };\n      auto actual = solveSudoku(input);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System.Collections.Generic;\nusing System;\n\npublic class Program {\n  public List<List<int> > SolveSudoku(List<List<int> > board) {\n    // Write your code here.\n    return new List<List<int> >();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // O(1) time | O(1) space - assuming a 9x9 input board\n  public List<List<int> > SolveSudoku(List<List<int> > board) {\n    solvePartialSudoku(0, 0, board);\n    return board;\n  }\n\n  public bool solvePartialSudoku(int row, int col, List<List<int> > board) {\n    int currentRow = row;\n    int currentCol = col;\n\n    if (currentCol == board[currentRow].Count) {\n      currentRow += 1;\n      currentCol = 0;\n      if (currentRow == board.Count) {\n        return true;  // board is completed\n      }\n    }\n\n    if (board[currentRow][currentCol] == 0) {\n      return tryDigitsAtPosition(currentRow, currentCol, board);\n    }\n\n    return solvePartialSudoku(currentRow, currentCol + 1, board);\n  }\n\n  public bool tryDigitsAtPosition(int row, int col, List<List<int> > board) {\n    for (int digit = 1; digit < 10; digit++) {\n      if (isValidAtPosition(digit, row, col, board)) {\n        board[row][col] = digit;\n        if (solvePartialSudoku(row, col + 1, board)) {\n          return true;\n        }\n      }\n    }\n\n    board[row][col] = 0;\n    return false;\n  }\n\n  public bool isValidAtPosition(\n    int value, int row, int col, List<List<int> > board\n  ) {\n    bool rowIsValid = !board[row].Contains(value);\n    bool columnIsValid = true;\n\n    for (int r = 0; r < board.Count; r++) {\n      if (board[r][col] == value) columnIsValid = false;\n    }\n\n    if (!rowIsValid || !columnIsValid) {\n      return false;\n    }\n\n    // Check subgrid constraints\n    int subgridRowStart = (row / 3) * 3;\n    int subgridColStart = (col / 3) * 3;\n\n    for (int rowIdx = 0; rowIdx < 3; rowIdx++) {\n      for (int colIdx = 0; colIdx < 3; colIdx++) {\n        int rowToCheck = subgridRowStart + rowIdx;\n        int colToCheck = subgridColStart + colIdx;\n        int existingValue = board[rowToCheck][colToCheck];\n\n        if (existingValue == value) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[][] inputValues = new int[][] {\n      new int[] { 7, 8, 0, 4, 0, 0, 1, 2, 0 },\n      new int[] { 6, 0, 0, 0, 7, 5, 0, 0, 9 },\n      new int[] { 0, 0, 0, 6, 0, 1, 0, 7, 8 },\n      new int[] { 0, 0, 7, 0, 4, 0, 2, 6, 0 },\n      new int[] { 0, 0, 1, 0, 5, 0, 9, 3, 0 },\n      new int[] { 9, 0, 4, 0, 6, 0, 0, 0, 5 },\n      new int[] { 0, 7, 0, 3, 0, 0, 0, 1, 2 },\n      new int[] { 1, 2, 0, 0, 0, 7, 4, 0, 0 },\n      new int[] { 0, 4, 9, 2, 0, 6, 0, 0, 7 }\n    };\n    int[][] expectedValues = new int[][] {\n      new int[] { 7, 8, 5, 4, 3, 9, 1, 2, 6 },\n      new int[] { 6, 1, 2, 8, 7, 5, 3, 4, 9 },\n      new int[] { 4, 9, 3, 6, 2, 1, 5, 7, 8 },\n      new int[] { 8, 5, 7, 9, 4, 3, 2, 6, 1 },\n      new int[] { 2, 6, 1, 7, 5, 8, 9, 3, 4 },\n      new int[] { 9, 3, 4, 1, 6, 2, 7, 8, 5 },\n      new int[] { 5, 7, 8, 3, 9, 4, 6, 1, 2 },\n      new int[] { 1, 2, 6, 5, 8, 7, 4, 9, 3 },\n      new int[] { 3, 4, 9, 2, 1, 6, 8, 5, 7 }\n    };\n\n    var input = new List<List<int> >();\n    for (int i = 0; i < inputValues.Length; i++) {\n      List<int> row = new List<int>();\n      for (int j = 0; j < inputValues[i].Length; j++) {\n        row.Add(inputValues[i][j]);\n      }\n      input.Add(row);\n    }\n\n    var actual = new Program().SolveSudoku(input);\n    for (int i = 0; i < expectedValues.Length; i++) {\n      for (int j = 0; j < expectedValues[i].Length; j++) {\n        Utils.AssertEquals(actual[i][j], expectedValues[i][j]);\n      }\n    }\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[][] inputValues = new int[][] {\n      new int[] { 7, 8, 0, 4, 0, 0, 1, 2, 0 },\n      new int[] { 6, 0, 0, 0, 7, 5, 0, 0, 9 },\n      new int[] { 0, 0, 0, 6, 0, 1, 0, 7, 8 },\n      new int[] { 0, 0, 7, 0, 4, 0, 2, 6, 0 },\n      new int[] { 0, 0, 1, 0, 5, 0, 9, 3, 0 },\n      new int[] { 9, 0, 4, 0, 6, 0, 0, 0, 5 },\n      new int[] { 0, 7, 0, 3, 0, 0, 0, 1, 2 },\n      new int[] { 1, 2, 0, 0, 0, 7, 4, 0, 0 },\n      new int[] { 0, 4, 9, 2, 0, 6, 0, 0, 7 }\n    };\n    int[][] expectedValues = new int[][] {\n      new int[] { 7, 8, 5, 4, 3, 9, 1, 2, 6 },\n      new int[] { 6, 1, 2, 8, 7, 5, 3, 4, 9 },\n      new int[] { 4, 9, 3, 6, 2, 1, 5, 7, 8 },\n      new int[] { 8, 5, 7, 9, 4, 3, 2, 6, 1 },\n      new int[] { 2, 6, 1, 7, 5, 8, 9, 3, 4 },\n      new int[] { 9, 3, 4, 1, 6, 2, 7, 8, 5 },\n      new int[] { 5, 7, 8, 3, 9, 4, 6, 1, 2 },\n      new int[] { 1, 2, 6, 5, 8, 7, 4, 9, 3 },\n      new int[] { 3, 4, 9, 2, 1, 6, 8, 5, 7 }\n    };\n\n    var input = new List<List<int> >();\n    for (int i = 0; i < inputValues.Length; i++) {\n      List<int> row = new List<int>();\n      for (int j = 0; j < inputValues[i].Length; j++) {\n        row.Add(inputValues[i][j]);\n      }\n      input.Add(row);\n    }\n\n    var actual = new Program().SolveSudoku(input);\n    for (int i = 0; i < expectedValues.Length; i++) {\n      for (int j = 0; j < expectedValues[i].Length; j++) {\n        Utils.AssertEquals(actual[i][j], expectedValues[i][j]);\n      }\n    }\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc SolveSudoku(board [][]int) [][]int {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(1) time | O(1) space - assuming a 9x9 input board\nfunc SolveSudoku(board [][]int) [][]int {\n\tsolvePartialSudoku(0, 0, board)\n\treturn board\n}\n\nfunc solvePartialSudoku(row int, col int, board [][]int) bool {\n\tvar currentRow = row\n\tvar currentCol = col\n\n\tif currentCol == len(board[currentRow]) {\n\t\tcurrentRow += 1\n\t\tcurrentCol = 0\n\t\tif currentRow == len(board) {\n\t\t\treturn true // board is completed\n\t\t}\n\t}\n\n\tif board[currentRow][currentCol] == 0 {\n\t\treturn tryDigitsAtPosition(currentRow, currentCol, board)\n\t}\n\n\treturn solvePartialSudoku(currentRow, currentCol+1, board)\n}\n\nfunc tryDigitsAtPosition(row int, col int, board [][]int) bool {\n\tfor digit := 1; digit < 10; digit++ {\n\t\tif isValidAtPosition(digit, row, col, board) {\n\t\t\tboard[row][col] = digit\n\t\t\tif solvePartialSudoku(row, col+1, board) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\tboard[row][col] = 0\n\treturn false\n}\n\nfunc isValidAtPosition(value int, row int, col int, board [][]int) bool {\n\trowIsValid := !rowContains(board, row, value)\n\tcolumnIsValid := !columnContains(board, col, value)\n\n\tif !rowIsValid || !columnIsValid {\n\t\treturn false\n\t}\n\n\t// Check subgrid constraint.\n\tsubgridRowStart := (row / 3) * 3\n\tsubgridColStart := (col / 3) * 3\n\tfor rowIdx := 0; rowIdx < 3; rowIdx++ {\n\t\tfor colIdx := 0; colIdx < 3; colIdx++ {\n\t\t\trowToCheck := subgridRowStart + rowIdx\n\t\t\tcolToCheck := subgridColStart + colIdx\n\t\t\texistingValue := board[rowToCheck][colToCheck]\n\n\t\t\tif existingValue == value {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc rowContains(board [][]int, row int, value int) bool {\n\tfor _, element := range board[row] {\n\t\tif value == element {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc columnContains(board [][]int, col int, value int) bool {\n\tfor _, row := range board {\n\t\tif row[col] == value {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{7, 8, 0, 4, 0, 0, 1, 2, 0},\n\t\t{6, 0, 0, 0, 7, 5, 0, 0, 9},\n\t\t{0, 0, 0, 6, 0, 1, 0, 7, 8},\n\t\t{0, 0, 7, 0, 4, 0, 2, 6, 0},\n\t\t{0, 0, 1, 0, 5, 0, 9, 3, 0},\n\t\t{9, 0, 4, 0, 6, 0, 0, 0, 5},\n\t\t{0, 7, 0, 3, 0, 0, 0, 1, 2},\n\t\t{1, 2, 0, 0, 0, 7, 4, 0, 0},\n\t\t{0, 4, 9, 2, 0, 6, 0, 0, 7},\n\t}\n\texpected := [][]int{\n\t\t{7, 8, 5, 4, 3, 9, 1, 2, 6},\n\t\t{6, 1, 2, 8, 7, 5, 3, 4, 9},\n\t\t{4, 9, 3, 6, 2, 1, 5, 7, 8},\n\t\t{8, 5, 7, 9, 4, 3, 2, 6, 1},\n\t\t{2, 6, 1, 7, 5, 8, 9, 3, 4},\n\t\t{9, 3, 4, 1, 6, 2, 7, 8, 5},\n\t\t{5, 7, 8, 3, 9, 4, 6, 1, 2},\n\t\t{1, 2, 6, 5, 8, 7, 4, 9, 3},\n\t\t{3, 4, 9, 2, 1, 6, 8, 5, 7},\n\t}\n\tactual := SolveSudoku(input)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{7, 8, 0, 4, 0, 0, 1, 2, 0},\n\t\t{6, 0, 0, 0, 7, 5, 0, 0, 9},\n\t\t{0, 0, 0, 6, 0, 1, 0, 7, 8},\n\t\t{0, 0, 7, 0, 4, 0, 2, 6, 0},\n\t\t{0, 0, 1, 0, 5, 0, 9, 3, 0},\n\t\t{9, 0, 4, 0, 6, 0, 0, 0, 5},\n\t\t{0, 7, 0, 3, 0, 0, 0, 1, 2},\n\t\t{1, 2, 0, 0, 0, 7, 4, 0, 0},\n\t\t{0, 4, 9, 2, 0, 6, 0, 0, 7},\n\t}\n\texpected := [][]int{\n\t\t{7, 8, 5, 4, 3, 9, 1, 2, 6},\n\t\t{6, 1, 2, 8, 7, 5, 3, 4, 9},\n\t\t{4, 9, 3, 6, 2, 1, 5, 7, 8},\n\t\t{8, 5, 7, 9, 4, 3, 2, 6, 1},\n\t\t{2, 6, 1, 7, 5, 8, 9, 3, 4},\n\t\t{9, 3, 4, 1, 6, 2, 7, 8, 5},\n\t\t{5, 7, 8, 3, 9, 4, 6, 1, 2},\n\t\t{1, 2, 6, 5, 8, 7, 4, 9, 3},\n\t\t{3, 4, 9, 2, 1, 6, 8, 5, 7},\n\t}\n\tactual := SolveSudoku(input)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public ArrayList<ArrayList<Integer>> solveSudoku(\n    ArrayList<ArrayList<Integer>> board\n  ) {\n    // Write your code here.\n    return new ArrayList<ArrayList<Integer>>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(1) time | O(1) space - assuming a 9x9 input board\n  public ArrayList<ArrayList<Integer>> solveSudoku(\n    ArrayList<ArrayList<Integer>> board\n  ) {\n    solvePartialSudoku(0, 0, board);\n    return board;\n  }\n\n  public boolean solvePartialSudoku(\n    int row, int col, ArrayList<ArrayList<Integer>> board\n  ) {\n    int currentRow = row;\n    int currentCol = col;\n\n    if (currentCol == board.get(currentRow).size()) {\n      currentRow += 1;\n      currentCol = 0;\n      if (currentRow == board.size()) {\n        return true; // board is completed\n      }\n    }\n\n    if (board.get(currentRow).get(currentCol) == 0) {\n      return tryDigitsAtPosition(currentRow, currentCol, board);\n    }\n\n    return solvePartialSudoku(currentRow, currentCol + 1, board);\n  }\n\n  public boolean tryDigitsAtPosition(\n    int row, int col, ArrayList<ArrayList<Integer>> board\n  ) {\n    for (int digit = 1; digit < 10; digit++) {\n      if (isValidAtPosition(digit, row, col, board)) {\n        board.get(row).set(col, digit);\n        if (solvePartialSudoku(row, col + 1, board)) {\n          return true;\n        }\n      }\n    }\n\n    board.get(row).set(col, 0);\n    return false;\n  }\n\n  public boolean isValidAtPosition(\n    int value, int row, int col, ArrayList<ArrayList<Integer>> board\n  ) {\n    boolean rowIsValid = !board.get(row).contains(value);\n    boolean columnIsValid = true;\n\n    for (int r = 0; r < board.size(); r++) {\n      if (board.get(r).get(col) == value) columnIsValid = false;\n    }\n\n    if (!rowIsValid || !columnIsValid) {\n      return false;\n    }\n\n    // Check subgrid constraints\n    int subgridRowStart = (row / 3) * 3;\n    int subgridColStart = (col / 3) * 3;\n\n    for (int rowIdx = 0; rowIdx < 3; rowIdx++) {\n      for (int colIdx = 0; colIdx < 3; colIdx++) {\n        int rowToCheck = subgridRowStart + rowIdx;\n        int colToCheck = subgridColStart + colIdx;\n        int existingValue = board.get(rowToCheck).get(colToCheck);\n\n        if (existingValue == value) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] inputValues = new int[][] {\n      {7, 8, 0, 4, 0, 0, 1, 2, 0},\n      {6, 0, 0, 0, 7, 5, 0, 0, 9},\n      {0, 0, 0, 6, 0, 1, 0, 7, 8},\n      {0, 0, 7, 0, 4, 0, 2, 6, 0},\n      {0, 0, 1, 0, 5, 0, 9, 3, 0},\n      {9, 0, 4, 0, 6, 0, 0, 0, 5},\n      {0, 7, 0, 3, 0, 0, 0, 1, 2},\n      {1, 2, 0, 0, 0, 7, 4, 0, 0},\n      {0, 4, 9, 2, 0, 6, 0, 0, 7}};\n    int[][] expectedValues = new int[][] {\n      {7, 8, 5, 4, 3, 9, 1, 2, 6},\n      {6, 1, 2, 8, 7, 5, 3, 4, 9},\n      {4, 9, 3, 6, 2, 1, 5, 7, 8},\n      {8, 5, 7, 9, 4, 3, 2, 6, 1},\n      {2, 6, 1, 7, 5, 8, 9, 3, 4},\n      {9, 3, 4, 1, 6, 2, 7, 8, 5},\n      {5, 7, 8, 3, 9, 4, 6, 1, 2},\n      {1, 2, 6, 5, 8, 7, 4, 9, 3},\n      {3, 4, 9, 2, 1, 6, 8, 5, 7}};\n\n    var input = new ArrayList<ArrayList<Integer>>();\n    for (int i = 0; i < inputValues.length; i++) {\n      ArrayList<Integer> row = new ArrayList<Integer>();\n      for (int j = 0; j < inputValues[i].length; j++) {\n        row.add(inputValues[i][j]);\n      }\n      input.add(row);\n    }\n\n    var expected = new ArrayList<ArrayList<Integer>>();\n    for (int i = 0; i < expectedValues.length; i++) {\n      ArrayList<Integer> row = new ArrayList<Integer>();\n      for (int j = 0; j < expectedValues[i].length; j++) {\n        row.add(expectedValues[i][j]);\n      }\n      expected.add(row);\n    }\n\n    var actual = new Program().solveSudoku(input);\n    Utils.assertTrue(expected.equals(actual));\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] inputValues = new int[][] {\n      {7, 8, 0, 4, 0, 0, 1, 2, 0},\n      {6, 0, 0, 0, 7, 5, 0, 0, 9},\n      {0, 0, 0, 6, 0, 1, 0, 7, 8},\n      {0, 0, 7, 0, 4, 0, 2, 6, 0},\n      {0, 0, 1, 0, 5, 0, 9, 3, 0},\n      {9, 0, 4, 0, 6, 0, 0, 0, 5},\n      {0, 7, 0, 3, 0, 0, 0, 1, 2},\n      {1, 2, 0, 0, 0, 7, 4, 0, 0},\n      {0, 4, 9, 2, 0, 6, 0, 0, 7}};\n    int[][] expectedValues = new int[][] {\n      {7, 8, 5, 4, 3, 9, 1, 2, 6},\n      {6, 1, 2, 8, 7, 5, 3, 4, 9},\n      {4, 9, 3, 6, 2, 1, 5, 7, 8},\n      {8, 5, 7, 9, 4, 3, 2, 6, 1},\n      {2, 6, 1, 7, 5, 8, 9, 3, 4},\n      {9, 3, 4, 1, 6, 2, 7, 8, 5},\n      {5, 7, 8, 3, 9, 4, 6, 1, 2},\n      {1, 2, 6, 5, 8, 7, 4, 9, 3},\n      {3, 4, 9, 2, 1, 6, 8, 5, 7}};\n\n    var input = new ArrayList<ArrayList<Integer>>();\n    for (int i = 0; i < inputValues.length; i++) {\n      ArrayList<Integer> row = new ArrayList<Integer>();\n      for (int j = 0; j < inputValues[i].length; j++) {\n        row.add(inputValues[i][j]);\n      }\n      input.add(row);\n    }\n\n    var expected = new ArrayList<ArrayList<Integer>>();\n    for (int i = 0; i < expectedValues.length; i++) {\n      ArrayList<Integer> row = new ArrayList<Integer>();\n      for (int j = 0; j < expectedValues[i].length; j++) {\n        row.add(expectedValues[i][j]);\n      }\n      expected.add(row);\n    }\n\n    var actual = new Program().solveSudoku(input);\n    Utils.assertTrue(expected.equals(actual));\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function solveSudoku(board) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.solveSudoku = solveSudoku;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(1) time | O(1) space - assuming a 9x9 input board\nfunction solveSudoku(board) {\n  solvePartialSudoku(0, 0, board);\n  return board;\n}\n\nfunction solvePartialSudoku(row, col, board) {\n  let currentRow = row;\n  let currentCol = col;\n\n  if (currentCol === board[currentRow].length) {\n    currentRow++;\n    currentCol = 0;\n    if (currentRow === board.length) return true;\n  }\n\n  if (board[currentRow][currentCol] === 0) {\n    return tryDigitsAtPosition(currentRow, currentCol, board);\n  }\n\n  return solvePartialSudoku(currentRow, currentCol + 1, board);\n}\n\nfunction tryDigitsAtPosition(row, col, board) {\n  for (let digit = 1; digit < 10; digit++) {\n    if (isValidAtPosition(digit, row, col, board)) {\n      board[row][col] = digit;\n      if (solvePartialSudoku(row, col + 1, board)) return true;\n    }\n  }\n\n  board[row][col] = 0;\n  return false;\n}\n\nfunction isValidAtPosition(value, row, col, board) {\n  const rowIsValid = !board[row].includes(value);\n  const colIsValid = !board.map(r => r[col]).includes(value);\n\n  if (!rowIsValid || !colIsValid) return false;\n\n  // Check subgrid constraint.\n  const subgridRowStart = Math.floor(row / 3) * 3;\n  const subgridColStart = Math.floor(col / 3) * 3;\n  for (let rowIdx = 0; rowIdx < 3; rowIdx++) {\n    for (let colIdx = 0; colIdx < 3; colIdx++) {\n      const rowToCheck = subgridRowStart + rowIdx;\n      const colToCheck = subgridColStart + colIdx;\n      const existingValue = board[rowToCheck][colToCheck];\n\n      if (existingValue === value) return false;\n    }\n  }\n\n  return true;\n}\n\n// Do not edit the line below.\nexports.solveSudoku = solveSudoku;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [7, 8, 0, 4, 0, 0, 1, 2, 0],\n    [6, 0, 0, 0, 7, 5, 0, 0, 9],\n    [0, 0, 0, 6, 0, 1, 0, 7, 8],\n    [0, 0, 7, 0, 4, 0, 2, 6, 0],\n    [0, 0, 1, 0, 5, 0, 9, 3, 0],\n    [9, 0, 4, 0, 6, 0, 0, 0, 5],\n    [0, 7, 0, 3, 0, 0, 0, 1, 2],\n    [1, 2, 0, 0, 0, 7, 4, 0, 0],\n    [0, 4, 9, 2, 0, 6, 0, 0, 7],\n  ];\n  const expected = [\n    [7, 8, 5, 4, 3, 9, 1, 2, 6],\n    [6, 1, 2, 8, 7, 5, 3, 4, 9],\n    [4, 9, 3, 6, 2, 1, 5, 7, 8],\n    [8, 5, 7, 9, 4, 3, 2, 6, 1],\n    [2, 6, 1, 7, 5, 8, 9, 3, 4],\n    [9, 3, 4, 1, 6, 2, 7, 8, 5],\n    [5, 7, 8, 3, 9, 4, 6, 1, 2],\n    [1, 2, 6, 5, 8, 7, 4, 9, 3],\n    [3, 4, 9, 2, 1, 6, 8, 5, 7],\n  ];\n  const actual = program.solveSudoku(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [7, 8, 0, 4, 0, 0, 1, 2, 0],\n    [6, 0, 0, 0, 7, 5, 0, 0, 9],\n    [0, 0, 0, 6, 0, 1, 0, 7, 8],\n    [0, 0, 7, 0, 4, 0, 2, 6, 0],\n    [0, 0, 1, 0, 5, 0, 9, 3, 0],\n    [9, 0, 4, 0, 6, 0, 0, 0, 5],\n    [0, 7, 0, 3, 0, 0, 0, 1, 2],\n    [1, 2, 0, 0, 0, 7, 4, 0, 0],\n    [0, 4, 9, 2, 0, 6, 0, 0, 7],\n  ];\n  const expected = [\n    [7, 8, 5, 4, 3, 9, 1, 2, 6],\n    [6, 1, 2, 8, 7, 5, 3, 4, 9],\n    [4, 9, 3, 6, 2, 1, 5, 7, 8],\n    [8, 5, 7, 9, 4, 3, 2, 6, 1],\n    [2, 6, 1, 7, 5, 8, 9, 3, 4],\n    [9, 3, 4, 1, 6, 2, 7, 8, 5],\n    [5, 7, 8, 3, 9, 4, 6, 1, 2],\n    [1, 2, 6, 5, 8, 7, 4, 9, 3],\n    [3, 4, 9, 2, 1, 6, 8, 5, 7],\n  ];\n  const actual = program.solveSudoku(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun solveSudoku(board: MutableList<MutableList<Int>>): MutableList<MutableList<Int>> {\n    // Write your code here.\n    return mutableListOf()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(1) time | O(1) space - assuming a 9x9 input board\nfun solveSudoku(board: MutableList<MutableList<Int>>): MutableList<MutableList<Int>> {\n    solvePartialSudoku(0, 0, board)\n    return board\n}\n\nfun solvePartialSudoku(row: Int, col: Int, board: MutableList<MutableList<Int>>): Boolean {\n    var currentRow = row\n    var currentCol = col\n\n    if (currentCol == board[currentRow].size) {\n        currentRow += 1\n        currentCol = 0\n        if (currentRow == board.size) return true // board is completed\n    }\n\n    if (board[currentRow][currentCol] == 0) {\n        return tryDigitsAtPosition(currentRow, currentCol, board)\n    }\n\n    return solvePartialSudoku(currentRow, currentCol + 1, board)\n}\n\nfun tryDigitsAtPosition(row: Int, col: Int, board: MutableList<MutableList<Int>>): Boolean {\n    for (digit in 1 until 10) {\n        if (isValidAtPosition(digit, row, col, board)) {\n            board[row][col] = digit\n            if (solvePartialSudoku(row, col + 1, board)) return true\n        }\n    }\n\n    board[row][col] = 0\n    return false\n}\n\nfun isValidAtPosition(value: Int, row: Int, col: Int, board: MutableList<MutableList<Int>>): Boolean {\n    val rowIsValid = !board[row].contains(value)\n    val columnIsValid = !board.map() { r -> r[col] }.contains(value)\n\n    if (!rowIsValid || !columnIsValid) return false\n\n    // Check subgrid constraint.\n    val subgridRowStart = (row / 3) * 3\n    val subgridColStart = (col / 3) * 3\n    for (rowIdx in 0 until 3) {\n        for (colIdx in 0 until 3) {\n            val rowToCheck = subgridRowStart + rowIdx\n            val colToCheck = subgridColStart + colIdx\n            val existingValue = board[rowToCheck][colToCheck]\n\n            if (existingValue == value) return false\n        }\n    }\n\n    return true\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.solveSudoku\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = mutableListOf(\n            mutableListOf(7, 8, 0, 4, 0, 0, 1, 2, 0),\n            mutableListOf(6, 0, 0, 0, 7, 5, 0, 0, 9),\n            mutableListOf(0, 0, 0, 6, 0, 1, 0, 7, 8),\n            mutableListOf(0, 0, 7, 0, 4, 0, 2, 6, 0),\n            mutableListOf(0, 0, 1, 0, 5, 0, 9, 3, 0),\n            mutableListOf(9, 0, 4, 0, 6, 0, 0, 0, 5),\n            mutableListOf(0, 7, 0, 3, 0, 0, 0, 1, 2),\n            mutableListOf(1, 2, 0, 0, 0, 7, 4, 0, 0),\n            mutableListOf(0, 4, 9, 2, 0, 6, 0, 0, 7),\n        )\n        val expected = mutableListOf(\n            mutableListOf(7, 8, 5, 4, 3, 9, 1, 2, 6),\n            mutableListOf(6, 1, 2, 8, 7, 5, 3, 4, 9),\n            mutableListOf(4, 9, 3, 6, 2, 1, 5, 7, 8),\n            mutableListOf(8, 5, 7, 9, 4, 3, 2, 6, 1),\n            mutableListOf(2, 6, 1, 7, 5, 8, 9, 3, 4),\n            mutableListOf(9, 3, 4, 1, 6, 2, 7, 8, 5),\n            mutableListOf(5, 7, 8, 3, 9, 4, 6, 1, 2),\n            mutableListOf(1, 2, 6, 5, 8, 7, 4, 9, 3),\n            mutableListOf(3, 4, 9, 2, 1, 6, 8, 5, 7),\n        )\n        val output = solveSudoku(input)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.solveSudoku\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = mutableListOf(\n            mutableListOf(7, 8, 0, 4, 0, 0, 1, 2, 0),\n            mutableListOf(6, 0, 0, 0, 7, 5, 0, 0, 9),\n            mutableListOf(0, 0, 0, 6, 0, 1, 0, 7, 8),\n            mutableListOf(0, 0, 7, 0, 4, 0, 2, 6, 0),\n            mutableListOf(0, 0, 1, 0, 5, 0, 9, 3, 0),\n            mutableListOf(9, 0, 4, 0, 6, 0, 0, 0, 5),\n            mutableListOf(0, 7, 0, 3, 0, 0, 0, 1, 2),\n            mutableListOf(1, 2, 0, 0, 0, 7, 4, 0, 0),\n            mutableListOf(0, 4, 9, 2, 0, 6, 0, 0, 7),\n        )\n        val expected = mutableListOf(\n            mutableListOf(7, 8, 5, 4, 3, 9, 1, 2, 6),\n            mutableListOf(6, 1, 2, 8, 7, 5, 3, 4, 9),\n            mutableListOf(4, 9, 3, 6, 2, 1, 5, 7, 8),\n            mutableListOf(8, 5, 7, 9, 4, 3, 2, 6, 1),\n            mutableListOf(2, 6, 1, 7, 5, 8, 9, 3, 4),\n            mutableListOf(9, 3, 4, 1, 6, 2, 7, 8, 5),\n            mutableListOf(5, 7, 8, 3, 9, 4, 6, 1, 2),\n            mutableListOf(1, 2, 6, 5, 8, 7, 4, 9, 3),\n            mutableListOf(3, 4, 9, 2, 1, 6, 8, 5, 7),\n        )\n        val output = solveSudoku(input)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def solveSudoku(board):\n    # Write your code here.\n    return []\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(1) time | O(1) space - assuming a 9x9 input board\ndef solveSudoku(board):\n    solvePartialSudoku(0, 0, board)\n    return board\n\n\ndef solvePartialSudoku(row, col, board):\n    currentRow = row\n    currentCol = col\n\n    if currentCol == len(board[currentRow]):\n        currentRow += 1\n        currentCol = 0\n        if currentRow == len(board):\n            return True  # board is completed\n\n    if board[currentRow][currentCol] == 0:\n        return tryDigitsAtPosition(currentRow, currentCol, board)\n\n    return solvePartialSudoku(currentRow, currentCol + 1, board)\n\n\ndef tryDigitsAtPosition(row, col, board):\n    for digit in range(1, 10):\n        if isValidAtPosition(digit, row, col, board):\n            board[row][col] = digit\n            if solvePartialSudoku(row, col + 1, board):\n                return True\n\n    board[row][col] = 0\n    return False\n\n\ndef isValidAtPosition(value, row, col, board):\n    rowIsValid = value not in board[row]\n    columnIsValid = value not in map(lambda r: r[col], board)\n\n    if not rowIsValid or not columnIsValid:\n        return False\n\n    # Check subgrid constraint.\n    subgridRowStart = (row // 3) * 3\n    subgridColStart = (col // 3) * 3\n    for rowIdx in range(3):\n        for colIdx in range(3):\n            rowToCheck = subgridRowStart + rowIdx\n            colToCheck = subgridColStart + colIdx\n            existingValue = board[rowToCheck][colToCheck]\n\n            if existingValue == value:\n                return False\n\n    return True\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [\n            [7, 8, 0, 4, 0, 0, 1, 2, 0],\n            [6, 0, 0, 0, 7, 5, 0, 0, 9],\n            [0, 0, 0, 6, 0, 1, 0, 7, 8],\n            [0, 0, 7, 0, 4, 0, 2, 6, 0],\n            [0, 0, 1, 0, 5, 0, 9, 3, 0],\n            [9, 0, 4, 0, 6, 0, 0, 0, 5],\n            [0, 7, 0, 3, 0, 0, 0, 1, 2],\n            [1, 2, 0, 0, 0, 7, 4, 0, 0],\n            [0, 4, 9, 2, 0, 6, 0, 0, 7],\n        ]\n        expected = [\n            [7, 8, 5, 4, 3, 9, 1, 2, 6],\n            [6, 1, 2, 8, 7, 5, 3, 4, 9],\n            [4, 9, 3, 6, 2, 1, 5, 7, 8],\n            [8, 5, 7, 9, 4, 3, 2, 6, 1],\n            [2, 6, 1, 7, 5, 8, 9, 3, 4],\n            [9, 3, 4, 1, 6, 2, 7, 8, 5],\n            [5, 7, 8, 3, 9, 4, 6, 1, 2],\n            [1, 2, 6, 5, 8, 7, 4, 9, 3],\n            [3, 4, 9, 2, 1, 6, 8, 5, 7],\n        ]\n        actual = program.solveSudoku(input)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [\n            [7, 8, 0, 4, 0, 0, 1, 2, 0],\n            [6, 0, 0, 0, 7, 5, 0, 0, 9],\n            [0, 0, 0, 6, 0, 1, 0, 7, 8],\n            [0, 0, 7, 0, 4, 0, 2, 6, 0],\n            [0, 0, 1, 0, 5, 0, 9, 3, 0],\n            [9, 0, 4, 0, 6, 0, 0, 0, 5],\n            [0, 7, 0, 3, 0, 0, 0, 1, 2],\n            [1, 2, 0, 0, 0, 7, 4, 0, 0],\n            [0, 4, 9, 2, 0, 6, 0, 0, 7],\n        ]\n        expected = [\n            [7, 8, 5, 4, 3, 9, 1, 2, 6],\n            [6, 1, 2, 8, 7, 5, 3, 4, 9],\n            [4, 9, 3, 6, 2, 1, 5, 7, 8],\n            [8, 5, 7, 9, 4, 3, 2, 6, 1],\n            [2, 6, 1, 7, 5, 8, 9, 3, 4],\n            [9, 3, 4, 1, 6, 2, 7, 8, 5],\n            [5, 7, 8, 3, 9, 4, 6, 1, 2],\n            [1, 2, 6, 5, 8, 7, 4, 9, 3],\n            [3, 4, 9, 2, 1, 6, 8, 5, 7],\n        ]\n        actual = program.solveSudoku(input)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "class Program\n  def solveSudoku(board)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def solveSudoku(board)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.solveSudoku\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.solveSudoku\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func solveSudoku(_ board: inout [[Int]]) -> [[Int]] {\n    // Write your code here.\n    return [[Int]]()\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(1) time | O(1) space - assuming a 9x9 input board\n  func solveSudoku(_ board: inout [[Int]]) -> [[Int]] {\n    solvePartialSudoku(0, 0, &board)\n    return board\n  }\n\n  func solvePartialSudoku(_ row: Int, _ col: Int, _ board: inout [[Int]]) -> Bool {\n    var currentRow = row\n    var currentCol = col\n\n    if currentCol == board[currentRow].count {\n      currentRow += 1\n      currentCol = 0\n      if currentRow == board.count {\n        return true // board is completed\n      }\n    }\n\n    if board[currentRow][currentCol] == 0 {\n      return tryDigitsAtPosition(currentRow, currentCol, &board)\n    }\n\n    return solvePartialSudoku(currentRow, currentCol + 1, &board)\n  }\n\n  func tryDigitsAtPosition(_ row: Int, _ col: Int, _ board: inout [[Int]]) -> Bool {\n    for digit in stride(from: 1, to: 10, by: 1) {\n      if isValidAtPosition(digit, row, col, board) {\n        board[row][col] = digit\n        if solvePartialSudoku(row, col + 1, &board) {\n          return true\n        }\n      }\n    }\n\n    board[row][col] = 0\n    return false\n  }\n\n  func isValidAtPosition(_ value: Int, _ row: Int, _ col: Int, _ board: [[Int]]) -> Bool {\n    let rowIsValid = !rowContains(board, row, value)\n    let columnIsValid = !columnContains(board, col, value)\n\n    if !rowIsValid || !columnIsValid {\n      return false\n    }\n\n    // Check subgrid constraint.\n    let subgridRowStart = (row / 3) * 3\n    let subgridColStart = (col / 3) * 3\n    for rowIdx in [0, 1, 2] {\n      for colIdx in [0, 1, 2] {\n        let rowToCheck = subgridRowStart + rowIdx\n        let colToCheck = subgridColStart + colIdx\n        let existingValue = board[rowToCheck][colToCheck]\n\n        if existingValue == value {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n  func rowContains(_ board: [[Int]], _ row: Int, _ value: Int) -> Bool {\n    for element in board[row] {\n      if value == element {\n        return true\n      }\n    }\n    return false\n  }\n\n  func columnContains(_ board: [[Int]], _ col: Int, _ value: Int) -> Bool {\n    for row in board {\n      if row[col] == value {\n        return true\n      }\n    }\n    return false\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var input = [\n        [7, 8, 0, 4, 0, 0, 1, 2, 0],\n        [6, 0, 0, 0, 7, 5, 0, 0, 9],\n        [0, 0, 0, 6, 0, 1, 0, 7, 8],\n        [0, 0, 7, 0, 4, 0, 2, 6, 0],\n        [0, 0, 1, 0, 5, 0, 9, 3, 0],\n        [9, 0, 4, 0, 6, 0, 0, 0, 5],\n        [0, 7, 0, 3, 0, 0, 0, 1, 2],\n        [1, 2, 0, 0, 0, 7, 4, 0, 0],\n        [0, 4, 9, 2, 0, 6, 0, 0, 7],\n      ]\n      var expected = [\n        [7, 8, 5, 4, 3, 9, 1, 2, 6],\n        [6, 1, 2, 8, 7, 5, 3, 4, 9],\n        [4, 9, 3, 6, 2, 1, 5, 7, 8],\n        [8, 5, 7, 9, 4, 3, 2, 6, 1],\n        [2, 6, 1, 7, 5, 8, 9, 3, 4],\n        [9, 3, 4, 1, 6, 2, 7, 8, 5],\n        [5, 7, 8, 3, 9, 4, 6, 1, 2],\n        [1, 2, 6, 5, 8, 7, 4, 9, 3],\n        [3, 4, 9, 2, 1, 6, 8, 5, 7],\n      ]\n      var actual = Program().solveSudoku(&input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var input = [\n        [7, 8, 0, 4, 0, 0, 1, 2, 0],\n        [6, 0, 0, 0, 7, 5, 0, 0, 9],\n        [0, 0, 0, 6, 0, 1, 0, 7, 8],\n        [0, 0, 7, 0, 4, 0, 2, 6, 0],\n        [0, 0, 1, 0, 5, 0, 9, 3, 0],\n        [9, 0, 4, 0, 6, 0, 0, 0, 5],\n        [0, 7, 0, 3, 0, 0, 0, 1, 2],\n        [1, 2, 0, 0, 0, 7, 4, 0, 0],\n        [0, 4, 9, 2, 0, 6, 0, 0, 7],\n      ]\n      var expected = [\n        [7, 8, 5, 4, 3, 9, 1, 2, 6],\n        [6, 1, 2, 8, 7, 5, 3, 4, 9],\n        [4, 9, 3, 6, 2, 1, 5, 7, 8],\n        [8, 5, 7, 9, 4, 3, 2, 6, 1],\n        [2, 6, 1, 7, 5, 8, 9, 3, 4],\n        [9, 3, 4, 1, 6, 2, 7, 8, 5],\n        [5, 7, 8, 3, 9, 4, 6, 1, 2],\n        [1, 2, 6, 5, 8, 7, 4, 9, 3],\n        [3, 4, 9, 2, 1, 6, 8, 5, 7],\n      ]\n      var actual = Program().solveSudoku(&input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function solveSudoku(board: number[][]) {\n  // Write your code here.\n  return [];\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(1) time | O(1) space - assuming a 9x9 input board\nexport function solveSudoku(board: number[][]) {\n  solvePartialSudoku(0, 0, board);\n  return board;\n}\n\nfunction solvePartialSudoku(row: number, col: number, board: number[][]): boolean {\n  let currentRow = row;\n  let currentCol = col;\n\n  if (currentCol === board[currentRow].length) {\n    currentRow++;\n    currentCol = 0;\n    if (currentRow === board.length) return true;\n  }\n\n  if (board[currentRow][currentCol] === 0) {\n    return tryDigitsAtPosition(currentRow, currentCol, board);\n  }\n\n  return solvePartialSudoku(currentRow, currentCol + 1, board);\n}\n\nfunction tryDigitsAtPosition(row: number, col: number, board: number[][]) {\n  for (let digit = 1; digit < 10; digit++) {\n    if (isValidAtPosition(digit, row, col, board)) {\n      board[row][col] = digit;\n      if (solvePartialSudoku(row, col + 1, board)) return true;\n    }\n  }\n\n  board[row][col] = 0;\n  return false;\n}\n\nfunction isValidAtPosition(value: number, row: number, col: number, board: number[][]) {\n  const rowIsValid = !board[row].includes(value);\n  const colIsValid = !board.map(r => r[col]).includes(value);\n\n  if (!rowIsValid || !colIsValid) return false;\n\n  // Check subgrid constraint.\n  const subgridRowStart = Math.floor(row / 3) * 3;\n  const subgridColStart = Math.floor(col / 3) * 3;\n  for (let rowIdx = 0; rowIdx < 3; rowIdx++) {\n    for (let colIdx = 0; colIdx < 3; colIdx++) {\n      const rowToCheck = subgridRowStart + rowIdx;\n      const colToCheck = subgridColStart + colIdx;\n      const existingValue = board[rowToCheck][colToCheck];\n\n      if (existingValue === value) return false;\n    }\n  }\n\n  return true;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [7, 8, 0, 4, 0, 0, 1, 2, 0],\n    [6, 0, 0, 0, 7, 5, 0, 0, 9],\n    [0, 0, 0, 6, 0, 1, 0, 7, 8],\n    [0, 0, 7, 0, 4, 0, 2, 6, 0],\n    [0, 0, 1, 0, 5, 0, 9, 3, 0],\n    [9, 0, 4, 0, 6, 0, 0, 0, 5],\n    [0, 7, 0, 3, 0, 0, 0, 1, 2],\n    [1, 2, 0, 0, 0, 7, 4, 0, 0],\n    [0, 4, 9, 2, 0, 6, 0, 0, 7],\n  ];\n  const expected = [\n    [7, 8, 5, 4, 3, 9, 1, 2, 6],\n    [6, 1, 2, 8, 7, 5, 3, 4, 9],\n    [4, 9, 3, 6, 2, 1, 5, 7, 8],\n    [8, 5, 7, 9, 4, 3, 2, 6, 1],\n    [2, 6, 1, 7, 5, 8, 9, 3, 4],\n    [9, 3, 4, 1, 6, 2, 7, 8, 5],\n    [5, 7, 8, 3, 9, 4, 6, 1, 2],\n    [1, 2, 6, 5, 8, 7, 4, 9, 3],\n    [3, 4, 9, 2, 1, 6, 8, 5, 7],\n  ];\n  const actual = program.solveSudoku(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [7, 8, 0, 4, 0, 0, 1, 2, 0],\n    [6, 0, 0, 0, 7, 5, 0, 0, 9],\n    [0, 0, 0, 6, 0, 1, 0, 7, 8],\n    [0, 0, 7, 0, 4, 0, 2, 6, 0],\n    [0, 0, 1, 0, 5, 0, 9, 3, 0],\n    [9, 0, 4, 0, 6, 0, 0, 0, 5],\n    [0, 7, 0, 3, 0, 0, 0, 1, 2],\n    [1, 2, 0, 0, 0, 7, 4, 0, 0],\n    [0, 4, 9, 2, 0, 6, 0, 0, 7],\n  ];\n  const expected = [\n    [7, 8, 5, 4, 3, 9, 1, 2, 6],\n    [6, 1, 2, 8, 7, 5, 3, 4, 9],\n    [4, 9, 3, 6, 2, 1, 5, 7, 8],\n    [8, 5, 7, 9, 4, 3, 2, 6, 1],\n    [2, 6, 1, 7, 5, 8, 9, 3, 4],\n    [9, 3, 4, 1, 6, 2, 7, 8, 5],\n    [5, 7, 8, 3, 9, 4, 6, 1, 2],\n    [1, 2, 6, 5, 8, 7, 4, 9, 3],\n    [3, 4, 9, 2, 1, 6, 8, 5, 7],\n  ];\n  const actual = program.solveSudoku(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "board",
      "example": [
        [
          7,
          8,
          0,
          4,
          0,
          0,
          1,
          2,
          0
        ],
        [
          6,
          0,
          0,
          0,
          7,
          5,
          0,
          0,
          9
        ],
        [
          0,
          0,
          0,
          6,
          0,
          1,
          0,
          7,
          8
        ],
        [
          0,
          0,
          7,
          0,
          4,
          0,
          2,
          6,
          0
        ],
        [
          0,
          0,
          1,
          0,
          5,
          0,
          9,
          3,
          0
        ],
        [
          9,
          0,
          4,
          0,
          6,
          0,
          0,
          0,
          5
        ],
        [
          0,
          7,
          0,
          3,
          0,
          0,
          0,
          1,
          2
        ],
        [
          1,
          2,
          0,
          0,
          0,
          7,
          4,
          0,
          0
        ],
        [
          0,
          4,
          9,
          2,
          0,
          6,
          0,
          0,
          7
        ]
      ],
      "schema": {
        "items": {
          "items": {
            "maximum": 9,
            "minimum": 0,
            "type": "integer"
          },
          "maxItems": 9,
          "minItems": 9,
          "type": "array"
        },
        "maxItems": 9,
        "minItems": 9,
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "board": [
        [
          7,
          8,
          0,
          4,
          0,
          0,
          1,
          2,
          0
        ],
        [
          6,
          0,
          0,
          0,
          7,
          5,
          0,
          0,
          9
        ],
        [
          0,
          0,
          0,
          6,
          0,
          1,
          0,
          7,
          8
        ],
        [
          0,
          0,
          7,
          0,
          4,
          0,
          2,
          6,
          0
        ],
        [
          0,
          0,
          1,
          0,
          5,
          0,
          9,
          3,
          0
        ],
        [
          9,
          0,
          4,
          0,
          6,
          0,
          0,
          0,
          5
        ],
        [
          0,
          7,
          0,
          3,
          0,
          0,
          0,
          1,
          2
        ],
        [
          1,
          2,
          0,
          0,
          0,
          7,
          4,
          0,
          0
        ],
        [
          0,
          4,
          9,
          2,
          0,
          6,
          0,
          0,
          7
        ]
      ]
    },
    {
      "board": [
        [
          0,
          0,
          0,
          0,
          3,
          0,
          0,
          0,
          9
        ],
        [
          0,
          4,
          0,
          5,
          0,
          0,
          0,
          7,
          8
        ],
        [
          2,
          9,
          0,
          0,
          0,
          1,
          0,
          5,
          0
        ],
        [
          0,
          7,
          8,
          0,
          0,
          3,
          0,
          0,
          6
        ],
        [
          0,
          3,
          0,
          0,
          6,
          0,
          0,
          8,
          0
        ],
        [
          6,
          0,
          0,
          8,
          0,
          0,
          9,
          3,
          0
        ],
        [
          0,
          6,
          0,
          9,
          0,
          0,
          0,
          2,
          7
        ],
        [
          7,
          2,
          0,
          0,
          0,
          5,
          0,
          6,
          0
        ],
        [
          8,
          0,
          0,
          0,
          7,
          0,
          0,
          0,
          0
        ]
      ]
    },
    {
      "board": [
        [
          5,
          3,
          8,
          0,
          1,
          0,
          0,
          0,
          0
        ],
        [
          0,
          7,
          9,
          6,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          4,
          0,
          0,
          2,
          0,
          0,
          0
        ],
        [
          0,
          0,
          7,
          0,
          2,
          3,
          4,
          0,
          0
        ],
        [
          0,
          0,
          5,
          0,
          8,
          0,
          0,
          0,
          9
        ],
        [
          4,
          6,
          0,
          0,
          9,
          0,
          0,
          0,
          1
        ],
        [
          0,
          9,
          0,
          2,
          3,
          4,
          1,
          5,
          0
        ],
        [
          0,
          4,
          1,
          5,
          0,
          0,
          2,
          0,
          0
        ],
        [
          0,
          0,
          0,
          8,
          6,
          1,
          0,
          3,
          0
        ]
      ]
    },
    {
      "board": [
        [
          0,
          2,
          0,
          0,
          9,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          7,
          8,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          3,
          6,
          0
        ],
        [
          0,
          0,
          1,
          9,
          0,
          4,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          6,
          0,
          5,
          0,
          0,
          7
        ],
        [
          8,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          9
        ],
        [
          0,
          0,
          0,
          0,
          2,
          0,
          0,
          0,
          0
        ],
        [
          7,
          0,
          0,
          0,
          0,
          0,
          0,
          8,
          5
        ],
        [
          4,
          9,
          0,
          0,
          3,
          0,
          0,
          0,
          0
        ]
      ]
    }
  ],
  "jsonTests": [
    {
      "board": [
        [
          7,
          8,
          0,
          4,
          0,
          0,
          1,
          2,
          0
        ],
        [
          6,
          0,
          0,
          0,
          7,
          5,
          0,
          0,
          9
        ],
        [
          0,
          0,
          0,
          6,
          0,
          1,
          0,
          7,
          8
        ],
        [
          0,
          0,
          7,
          0,
          4,
          0,
          2,
          6,
          0
        ],
        [
          0,
          0,
          1,
          0,
          5,
          0,
          9,
          3,
          0
        ],
        [
          9,
          0,
          4,
          0,
          6,
          0,
          0,
          0,
          5
        ],
        [
          0,
          7,
          0,
          3,
          0,
          0,
          0,
          1,
          2
        ],
        [
          1,
          2,
          0,
          0,
          0,
          7,
          4,
          0,
          0
        ],
        [
          0,
          4,
          9,
          2,
          0,
          6,
          0,
          0,
          7
        ]
      ]
    },
    {
      "board": [
        [
          0,
          0,
          0,
          0,
          3,
          0,
          0,
          0,
          9
        ],
        [
          0,
          4,
          0,
          5,
          0,
          0,
          0,
          7,
          8
        ],
        [
          2,
          9,
          0,
          0,
          0,
          1,
          0,
          5,
          0
        ],
        [
          0,
          7,
          8,
          0,
          0,
          3,
          0,
          0,
          6
        ],
        [
          0,
          3,
          0,
          0,
          6,
          0,
          0,
          8,
          0
        ],
        [
          6,
          0,
          0,
          8,
          0,
          0,
          9,
          3,
          0
        ],
        [
          0,
          6,
          0,
          9,
          0,
          0,
          0,
          2,
          7
        ],
        [
          7,
          2,
          0,
          0,
          0,
          5,
          0,
          6,
          0
        ],
        [
          8,
          0,
          0,
          0,
          7,
          0,
          0,
          0,
          0
        ]
      ]
    },
    {
      "board": [
        [
          5,
          3,
          8,
          0,
          1,
          0,
          0,
          0,
          0
        ],
        [
          0,
          7,
          9,
          6,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          4,
          0,
          0,
          2,
          0,
          0,
          0
        ],
        [
          0,
          0,
          7,
          0,
          2,
          3,
          4,
          0,
          0
        ],
        [
          0,
          0,
          5,
          0,
          8,
          0,
          0,
          0,
          9
        ],
        [
          4,
          6,
          0,
          0,
          9,
          0,
          0,
          0,
          1
        ],
        [
          0,
          9,
          0,
          2,
          3,
          4,
          1,
          5,
          0
        ],
        [
          0,
          4,
          1,
          5,
          0,
          0,
          2,
          0,
          0
        ],
        [
          0,
          0,
          0,
          8,
          6,
          1,
          0,
          3,
          0
        ]
      ]
    },
    {
      "board": [
        [
          0,
          2,
          0,
          0,
          9,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          7,
          8,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          3,
          6,
          0
        ],
        [
          0,
          0,
          1,
          9,
          0,
          4,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          6,
          0,
          5,
          0,
          0,
          7
        ],
        [
          8,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          9
        ],
        [
          0,
          0,
          0,
          0,
          2,
          0,
          0,
          0,
          0
        ],
        [
          7,
          0,
          0,
          0,
          0,
          0,
          0,
          8,
          5
        ],
        [
          4,
          9,
          0,
          0,
          3,
          0,
          0,
          0,
          0
        ]
      ]
    }
  ],
  "changelog": []
}