{
  "uid": "symmetrical-tree",
  "testStrategy": "JSON",
  "name": "Symmetrical Tree",
  "version": 0,
  "releaseDate": "2022-12-15T00:00:00Z",
  "category": "Binary Trees",
  "difficulty": 2,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 4913,
    "failureCount": 481
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "762830988",
    "duration": 0,
    "annotations": [],
    "instructor": "Conner Ardman",
    "overviewTime": 0,
    "codeWalkthroughTime": 891
  },
  "prompt": "<div class=\"html\">\n<p>\n  Write a function that takes in a Binary Tree and returns if that tree is\n  symmetrical. A tree is symmetrical if the left and right subtrees are\n  mirror images of each other.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">tree</span> =    1\n       /     \\\n      2       2\n    /   \\   /   \\\n   3     4 4     3\n /   \\          /  \\\n5     6        6    5\n</pre>\n<h3>Sample Output</h3>\n<pre>True</pre>\n</div>",
  "hints": [
    "<p>\n  It's important to first think about what it means for a binary tree to be\n  symmetrical. The left and right subtrees do not need to be the same, but\n  rather they need to be mirror images of each other (i.e. the same if one\n  is inverted).\n</p>\n",
    "\n<p>\n  It can be helpful to think about this problem one step at a time. Looking at\n  just the first node, how can you ensure its children are symmetrical? Then\n  looking at those children, how can you make sure they are symmetrical of each\n  other?\n</p>\n",
    "\n<p>\n  This problem can be solved either recursively or iteratively. Either way, try\n  traversing through the tree, uses a mirrored traversal on one side, and check\n  that the values of each node are the same.\n</p>"
  ],
  "spaceTime": "O(n) time | O(h) space - where n is the number of nodes in the tree and h is the height of the tree.",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left = nullptr;\n  BinaryTree* right = nullptr;\n\n  BinaryTree(int value) { this->value = value; }\n};\n\nbool symmetricalTree(BinaryTree* tree) {\n  // Write your code here.\n  return false;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <stack>\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left = nullptr;\n  BinaryTree* right = nullptr;\n\n  BinaryTree(int value) { this->value = value; }\n};\n\n// O(n) time | O(h) space - where n is the number of nodes in the tree\n// and h is the height of the tree.\nbool symmetricalTree(BinaryTree* tree) {\n  stack<BinaryTree*> stackLeft;\n  stackLeft.push(tree->left);\n  stack<BinaryTree*> stackRight;\n  stackRight.push(tree->right);\n\n  while (!stackLeft.empty() && !stackRight.empty()) {\n    BinaryTree* left = stackLeft.top();\n    stackLeft.pop();\n    BinaryTree* right = stackRight.top();\n    stackRight.pop();\n\n    if (left == nullptr && right == nullptr) {\n      continue;\n    }\n\n    if (left == nullptr || right == nullptr || left->value != right->value) {\n      return false;\n    }\n\n    stackLeft.push(left->left);\n    stackLeft.push(left->right);\n    stackRight.push(right->right);\n    stackRight.push(right->left);\n  }\n\n  return stackLeft.empty() && stackRight.empty();\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <stack>\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n public:\n  int value;\n  BinaryTree* left = nullptr;\n  BinaryTree* right = nullptr;\n\n  BinaryTree(int value) { this->value = value; }\n};\n\nbool treesAreMirrored(BinaryTree* left, BinaryTree* right);\n\n// O(n) time | O(h) space - where n is the number of nodes in the tree\n// and h is the height of the tree.\nbool symmetricalTree(BinaryTree* tree) {\n  return treesAreMirrored(tree->left, tree->right);\n}\n\nbool treesAreMirrored(BinaryTree* left, BinaryTree* right) {\n  if (left != nullptr && right != nullptr && left->value == right->value) {\n    return treesAreMirrored(left->left, right->right) &&\n           treesAreMirrored(left->right, right->left);\n  }\n\n  return left == right;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree* tree = new BinaryTree(10);\n      tree->left = new BinaryTree(5);\n      tree->right = new BinaryTree(5);\n      tree->left->left = new BinaryTree(7);\n      tree->left->right = new BinaryTree(9);\n      tree->right->left = new BinaryTree(9);\n      tree->right->right = new BinaryTree(7);\n      auto expected = true;\n      auto actual = symmetricalTree(tree);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BinaryTree* tree = new BinaryTree(10);\n      tree->left = new BinaryTree(5);\n      tree->right = new BinaryTree(5);\n      tree->left->left = new BinaryTree(7);\n      tree->left->right = new BinaryTree(9);\n      tree->right->left = new BinaryTree(9);\n      tree->right->right = new BinaryTree(7);\n      auto expected = true;\n      auto actual = symmetricalTree(tree);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  public bool SymmetricalTree(BinaryTree tree) {\n    // Write your code here.\n    return false;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the tree\n  // and h is the height of the tree.\n  public bool SymmetricalTree(BinaryTree tree) {\n    Stack<BinaryTree> stackLeft = new Stack<BinaryTree>();\n    stackLeft.Push(tree.left);\n    Stack<BinaryTree> stackRight = new Stack<BinaryTree>();\n    stackRight.Push(tree.right);\n\n    while (stackLeft.Count != 0 && stackRight.Count != 0) {\n      BinaryTree left = stackLeft.Pop();\n      BinaryTree right = stackRight.Pop();\n\n      if (left == null && right == null) {\n        continue;\n      }\n\n      if (left == null || right == null || left.value != right.value) {\n        return false;\n      }\n\n      stackLeft.Push(left.left);\n      stackLeft.Push(left.right);\n      stackRight.Push(right.right);\n      stackRight.Push(right.left);\n    }\n\n    return stackLeft.Count == 0 && stackRight.Count == 0;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the tree\n  // and h is the height of the tree.\n  public bool SymmetricalTree(BinaryTree tree) {\n    return treesAreMirrored(tree.left, tree.right);\n  }\n\n  private bool treesAreMirrored(BinaryTree left, BinaryTree right) {\n    if (left != null && right != null && left.value == right.value) {\n      return treesAreMirrored(left.left, right.right) &&\n             treesAreMirrored(left.right, right.left);\n    }\n\n    return left == right;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.BinaryTree tree = new Program.BinaryTree(10);\n    tree.left = new Program.BinaryTree(5);\n    tree.right = new Program.BinaryTree(5);\n    tree.left.left = new Program.BinaryTree(7);\n    tree.left.right = new Program.BinaryTree(9);\n    tree.right.left = new Program.BinaryTree(9);\n    tree.right.right = new Program.BinaryTree(7);\n    var expected = true;\n    var actual = new Program().SymmetricalTree(tree);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    Program.BinaryTree tree = new Program.BinaryTree(10);\n    tree.left = new Program.BinaryTree(5);\n    tree.right = new Program.BinaryTree(5);\n    tree.left.left = new Program.BinaryTree(7);\n    tree.left.right = new Program.BinaryTree(9);\n    tree.right.left = new Program.BinaryTree(9);\n    tree.right.right = new Program.BinaryTree(7);\n    var expected = true;\n    var actual = new Program().SymmetricalTree(tree);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\nfunc SymmetricalTree(tree *BinaryTree) bool {\n\t// Write your code here.\n\treturn false\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the tree\n// and h is the height of the tree.\nfunc SymmetricalTree(tree *BinaryTree) bool {\n\tstackLeft := []*BinaryTree{tree.Left}\n\tstackRight := []*BinaryTree{tree.Right}\n\n\tfor len(stackLeft) > 0 {\n\t\tvar left, right *BinaryTree\n\t\tleft, stackLeft = stackLeft[len(stackLeft)-1], stackLeft[:len(stackLeft)-1]\n\t\tright, stackRight = stackRight[len(stackRight)-1], stackRight[:len(stackRight)-1]\n\n\t\tif left == nil && right == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif left == nil || right == nil || left.Value != right.Value {\n\t\t\treturn false\n\t\t}\n\n\t\tstackLeft = append(stackLeft, left.Left, left.Right)\n\t\tstackRight = append(stackRight, right.Right, right.Left)\n\t}\n\n\treturn true\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the tree\n// and h is the height of the tree.\nfunc SymmetricalTree(tree *BinaryTree) bool {\n\treturn treesAreMirrored(tree.Left, tree.Right)\n}\n\nfunc treesAreMirrored(left, right *BinaryTree) bool {\n\tif left != nil && right != nil && left.Value == right.Value {\n\t\treturn treesAreMirrored(left.Left, right.Right) && treesAreMirrored(left.Right, right.Left)\n\t}\n\n\treturn left == right\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\ttree := &BinaryTree{Value: 6}\n\ttree.Left = &BinaryTree{Value: (5)}\n\ttree.Right = &BinaryTree{Value: (5)}\n\ttree.Left.Left = &BinaryTree{Value: (7)}\n\ttree.Left.Right = &BinaryTree{Value: (9)}\n\ttree.Right.Left = &BinaryTree{Value: (9)}\n\ttree.Right.Right = &BinaryTree{Value: (7)}\n\texpected := true\n\tactual := SymmetricalTree(tree)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\ttree := &BinaryTree{Value: 6}\n\ttree.Left = &BinaryTree{Value: (5)}\n\ttree.Right = &BinaryTree{Value: (5)}\n\ttree.Left.Left = &BinaryTree{Value: (7)}\n\ttree.Left.Right = &BinaryTree{Value: (9)}\n\ttree.Right.Left = &BinaryTree{Value: (9)}\n\ttree.Right.Right = &BinaryTree{Value: (7)}\n\texpected := true\n\tactual := SymmetricalTree(tree)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  public boolean symmetricalTree(BinaryTree tree) {\n    // Write your code here.\n    return false;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the tree\n  // and h is the height of the tree.\n  public boolean symmetricalTree(BinaryTree tree) {\n    Stack<BinaryTree> stackLeft = new Stack<BinaryTree>();\n    stackLeft.push(tree.left);\n    Stack<BinaryTree> stackRight = new Stack<BinaryTree>();\n    stackRight.push(tree.right);\n\n    while (!stackLeft.isEmpty() && !stackRight.isEmpty()) {\n      BinaryTree left = stackLeft.pop();\n      BinaryTree right = stackRight.pop();\n\n      if (left == null && right == null) {\n        continue;\n      }\n\n      if (left == null || right == null || left.value != right.value) {\n        return false;\n      }\n\n      stackLeft.push(left.left);\n      stackLeft.push(left.right);\n      stackRight.push(right.right);\n      stackRight.push(right.left);\n    }\n\n    return stackLeft.isEmpty() && stackRight.isEmpty();\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the tree\n  // and h is the height of the tree.\n  public boolean symmetricalTree(BinaryTree tree) {\n    return treesAreMirrored(tree.left, tree.right);\n  }\n\n  private boolean treesAreMirrored(BinaryTree left, BinaryTree right) {\n    if (left != null && right != null && left.value == right.value) {\n      return treesAreMirrored(left.left, right.right)\n        && treesAreMirrored(left.right, right.left);\n    }\n\n    return left == right;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.BinaryTree tree = new Program.BinaryTree(10);\n    tree.left = new Program.BinaryTree(5);\n    tree.right = new Program.BinaryTree(5);\n    tree.left.left = new Program.BinaryTree(7);\n    tree.left.right = new Program.BinaryTree(9);\n    tree.right.left = new Program.BinaryTree(9);\n    tree.right.right = new Program.BinaryTree(7);\n    var expected = true;\n    var actual = new Program().symmetricalTree(tree);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.BinaryTree tree = new Program.BinaryTree(10);\n    tree.left = new Program.BinaryTree(5);\n    tree.right = new Program.BinaryTree(5);\n    tree.left.left = new Program.BinaryTree(7);\n    tree.left.right = new Program.BinaryTree(9);\n    tree.right.left = new Program.BinaryTree(9);\n    tree.right.right = new Program.BinaryTree(7);\n    var expected = true;\n    var actual = new Program().symmetricalTree(tree);\n    Utils.assertTrue(expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.BinaryTree = BinaryTree;\n\nfunction symmetricalTree(tree) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.symmetricalTree = symmetricalTree;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the tree\n// and h is the height of the tree.\nfunction symmetricalTree(tree) {\n  const stackLeft = [tree.left];\n  const stackRight = [tree.right];\n\n  while (stackLeft.length > 0) {\n    const left = stackLeft.pop();\n    const right = stackRight.pop();\n\n    if (left === null && right === null) continue;\n\n    if (left === null || right === null || left.value != right.value) {\n      return false;\n    }\n\n    stackLeft.push(left.left);\n    stackLeft.push(left.right);\n    stackRight.push(right.right);\n    stackRight.push(right.left);\n  }\n\n  return true;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.symmetricalTree = symmetricalTree;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the tree\n// and h is the height of the tree.\nfunction symmetricalTree(tree) {\n  return treesAreMirrored(tree.left, tree.right);\n}\n\nfunction treesAreMirrored(left, right) {\n  if (left !== null && right !== null && left.value === right.value) {\n    return treesAreMirrored(left.left, right.right) && treesAreMirrored(left.right, right.left);\n  }\n\n  return left === right;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.symmetricalTree = symmetricalTree;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(6);\n  tree.left = new BinaryTree(5);\n  tree.right = new BinaryTree(5);\n  tree.left.left = new BinaryTree(7);\n  tree.left.right = new BinaryTree(9);\n  tree.right.left = new BinaryTree(9);\n  tree.right.right = new BinaryTree(7);\n  const expected = true;\n  const actual = program.symmetricalTree(tree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(6);\n  tree.left = new BinaryTree(5);\n  tree.right = new BinaryTree(5);\n  tree.left.left = new BinaryTree(7);\n  tree.left.right = new BinaryTree(9);\n  tree.right.left = new BinaryTree(9);\n  tree.right.right = new BinaryTree(7);\n  const expected = true;\n  const actual = program.symmetricalTree(tree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\nfun symmetricalTree(tree: BinaryTree): Boolean {\n    // Write your code here.\n    return false\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport java.util.Stack\n\n// This is an input class. Do not edit.\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the tree\n// and h is the height of the tree.\nfun symmetricalTree(tree: BinaryTree): Boolean {\n    val stackLeft = Stack<BinaryTree>()\n    val stackRight = Stack<BinaryTree>()\n    stackLeft.add(tree.left)\n    stackRight.add(tree.right)\n\n    while (stackLeft.size > 0) {\n        val left = stackLeft.pop()\n        val right = stackRight.pop()\n\n        if (left == null && right == null) continue\n\n        if (left == null || right == null || left.value != right.value) {\n            return false\n        }\n\n        stackLeft.add(left.left)\n        stackLeft.add(left.right)\n        stackRight.add(right.right)\n        stackRight.add(right.left)\n    }\n\n    return true\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the tree\n// and h is the height of the tree.\nfun symmetricalTree(tree: BinaryTree): Boolean {\n    return treesAreMirrored(tree.left, tree.right)\n}\n\nfun treesAreMirrored(left: BinaryTree?, right: BinaryTree?): Boolean {\n    if (left !== null && right !== null && left.value == right.value) {\n        return treesAreMirrored(left.left, right.right) && treesAreMirrored(left.right, right.left)\n    }\n\n    return left == right\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.symmetricalTree\nimport com.algoexpert.program.BinaryTree as BinaryTree\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree = BinaryTree(10)\n        tree.left = BinaryTree(5)\n        tree.right = BinaryTree(5)\n        tree.left!!.left = BinaryTree(7)\n        tree.left!!.right = BinaryTree(9)\n        tree.right!!.left = BinaryTree(9)\n        tree.right!!.right = BinaryTree(7)\n        val expected = true\n        val output = symmetricalTree(tree)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.symmetricalTree\nimport com.algoexpert.program.BinaryTree as BinaryTree\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val tree = BinaryTree(10)\n        tree.left = BinaryTree(5)\n        tree.right = BinaryTree(5)\n        tree.left!!.left = BinaryTree(7)\n        tree.left!!.right = BinaryTree(9)\n        tree.right!!.left = BinaryTree(9)\n        tree.right!!.right = BinaryTree(7)\n        val expected = true\n        val output = symmetricalTree(tree)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef symmetricalTree(tree):\n    # Write your code here.\n    return False\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# O(n) time | O(h) space - where n is the number of nodes in the tree\n# and h is the height of the tree.\ndef symmetricalTree(tree):\n    stackLeft = [tree.left]\n    stackRight = [tree.right]\n\n    while len(stackLeft) > 0:\n        left = stackLeft.pop()\n        right = stackRight.pop()\n\n        if left is None and right is None:\n            continue\n\n        if left is None or right is None or left.value != right.value:\n            return False\n\n        stackLeft.append(left.left)\n        stackLeft.append(left.right)\n        stackRight.append(right.right)\n        stackRight.append(right.left)\n\n    return True\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# O(n) time | O(h) space - where n is the number of nodes in the tree\n# and h is the height of the tree.\ndef symmetricalTree(tree):\n    return treesAreMirrored(tree.left, tree.right)\n\n\ndef treesAreMirrored(left, right):\n    if left is not None and right is not None and left.value == right.value:\n        return treesAreMirrored(left.left, right.right) and treesAreMirrored(left.right, right.left)\n\n    return left == right\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        tree = BinaryTree(10)\n        tree.left = BinaryTree(5)\n        tree.right = BinaryTree(5)\n        tree.left.left = BinaryTree(7)\n        tree.left.right = BinaryTree(9)\n        tree.right.left = BinaryTree(9)\n        tree.right.right = BinaryTree(7)\n        expected = True\n        actual = program.symmetricalTree(tree)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        tree = BinaryTree(10)\n        tree.left = BinaryTree(5)\n        tree.right = BinaryTree(5)\n        tree.left.left = BinaryTree(7)\n        tree.left.right = BinaryTree(9)\n        tree.right.left = BinaryTree(9)\n        tree.right.right = BinaryTree(7)\n        expected = True\n        actual = program.symmetricalTree(tree)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "# This is an input struct. Do not edit.\nclass BinaryTree\n    attr_accessor :value\n    attr_accessor :left\n    attr_accessor :right\n\n    def initialize(value)\n        @value = value\n        @left = nil\n        @right = nil\n    end\nend\n\n\nclass Program\n    def symmetricalTree(tree)\n        # Write your code here.\n        return false\n    end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BinaryTree\n    attr_accessor :value\n    attr_accessor :left\n    attr_accessor :right\n\n    def initialize(value)\n        @value = value\n        @left = nil\n        @right = nil\n    end\nend\n\n\nclass Program\n    def symmetricalTree(tree)\n        # Write your code here.\n        return false\n    end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire './program.rb'\n\nclass TestSuite\n    include Assertions\n    def test_1\n        # inputs = ...\n        # output = Program.new.symmetricalTree\n        # expected = ...\n        # assertEqual(expected, output)\n    end\nend\n\n",
      "unitTests": "require './program.rb'\n\nclass TestSuite\n    include Assertions\n    def test_1\n        # inputs = ...\n        # output = Program.new.symmetricalTree\n        # expected = ...\n        # assertEqual(expected, output)\n    end\nend\n\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  func symmetricalTree(_ tree: BinaryTree) -> Bool {\n    // Write your code here.\n    return false\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the tree\n  // and h is the height of the tree.\n  func symmetricalTree(_ tree: BinaryTree) -> Bool {\n    var stackLeft = [tree.left]\n    var stackRight = [tree.right]\n\n    while stackLeft.count > 0 {\n      var left: BinaryTree? = stackLeft.popLast()!\n      var right: BinaryTree? = stackRight.popLast()!\n\n      if left == nil && right == nil {\n        continue\n      }\n\n      if left == nil || right == nil || left!.value != right!.value {\n        return false\n      }\n\n      stackLeft += [left!.left, left!.right]\n      stackRight += [right!.right, right!.left]\n    }\n\n    return true\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(n) time | O(h) space - where n is the number of nodes in the tree\n  // and h is the height of the tree.\n  func symmetricalTree(_ tree: BinaryTree) -> Bool {\n    return treesAreMirrored(tree.left, tree.right)\n  }\n\n  func treesAreMirrored(_ left: BinaryTree?, _ right: BinaryTree?) -> Bool {\n    if left != nil && right != nil && left!.value == right!.value {\n      return treesAreMirrored(left!.left, right!.right) && treesAreMirrored(left!.right, right!.left)\n    }\n\n    return left == nil && right == nil\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      var tree = Program.BinaryTree(value: 6)\n      tree.left = Program.BinaryTree(value: 5)\n      tree.right = Program.BinaryTree(value: 5)\n      tree.left!.left = Program.BinaryTree(value: 7)\n      tree.left!.right = Program.BinaryTree(value: 9)\n      tree.right!.left = Program.BinaryTree(value: 9)\n      tree.right!.right = Program.BinaryTree(value: 7)\n      var expected = true\n      var actual = Program().symmetricalTree(tree)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws in\n      var tree = Program.BinaryTree(value: 6)\n      tree.left = Program.BinaryTree(value: 5)\n      tree.right = Program.BinaryTree(value: 5)\n      tree.left!.left = Program.BinaryTree(value: 7)\n      tree.left!.right = Program.BinaryTree(value: 9)\n      tree.right!.left = Program.BinaryTree(value: 9)\n      tree.right!.right = Program.BinaryTree(value: 7)\n      var expected = true\n      var actual = Program().symmetricalTree(tree)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport function symmetricalTree(tree: BinaryTree) {\n  // Write your code here.\n  return false;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the tree\n// and h is the height of the tree.\nexport function symmetricalTree(tree: BinaryTree) {\n  const stackLeft = [tree.left];\n  const stackRight = [tree.right];\n\n  while (stackLeft.length > 0) {\n    const left: BinaryTree | null = stackLeft.pop()!;\n    const right: BinaryTree | null = stackRight.pop()!;\n\n    if (left === null && right === null) continue;\n\n    if (left === null || right === null || left.value != right.value) {\n      return false;\n    }\n\n    stackLeft.push(left.left);\n    stackLeft.push(left.right);\n    stackRight.push(right.right);\n    stackRight.push(right.left);\n  }\n\n  return true;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the tree\n// and h is the height of the tree.\nexport function symmetricalTree(tree: BinaryTree) {\n  return treesAreMirrored(tree.left, tree.right);\n}\n\nfunction treesAreMirrored(left: BinaryTree | null, right: BinaryTree | null): boolean {\n  if (left !== null && right !== null && left.value === right.value) {\n    return treesAreMirrored(left.left, right.right) && treesAreMirrored(left.right, right.left);\n  }\n\n  return left === right;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(6);\n  tree.left = new BinaryTree(5);\n  tree.right = new BinaryTree(5);\n  tree.left.left = new BinaryTree(7);\n  tree.left.right = new BinaryTree(9);\n  tree.right.left = new BinaryTree(9);\n  tree.right.right = new BinaryTree(7);\n  const expected = true;\n  const actual = program.symmetricalTree(tree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nclass BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(6);\n  tree.left = new BinaryTree(5);\n  tree.right = new BinaryTree(5);\n  tree.left.left = new BinaryTree(7);\n  tree.left.right = new BinaryTree(9);\n  tree.right.left = new BinaryTree(9);\n  tree.right.right = new BinaryTree(7);\n  const expected = true;\n  const actual = program.symmetricalTree(tree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "tree",
      "example": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      },
      "schema": {
        "description": "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "left": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "right": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "left",
                "right"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "root": {
            "type": "string"
          }
        },
        "required": [
          "root",
          "nodes"
        ],
        "type": "object"
      }
    }
  ],
  "tests": [
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "2-2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": null,
            "value": 2
          },
          {
            "id": "2-2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "3-2",
            "value": 2
          },
          {
            "id": "2-2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-2",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "3-2",
            "value": 2
          },
          {
            "id": "2-2",
            "left": "3-3",
            "right": "3-4",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-2",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-4",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "4",
            "value": 2
          },
          {
            "id": "2-2",
            "left": "4-2",
            "right": "3-2",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-2",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "4-2",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "4",
            "value": 2
          },
          {
            "id": "2-2",
            "left": "3-2",
            "right": "4-2",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-2",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "4-2",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "5",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "4",
            "value": 2
          },
          {
            "id": "5",
            "left": "4-2",
            "right": "3-2",
            "value": 5
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-2",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "4-2",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "4",
            "value": 2
          },
          {
            "id": "2-2",
            "left": "4-2",
            "right": "3-2",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-2",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "4-2",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "4",
            "value": 2
          },
          {
            "id": "2-2",
            "left": "4-2",
            "right": "3-2",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-2",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "5-2",
            "right": null,
            "value": 4
          },
          {
            "id": "4-2",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "5-2",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    }
  ],
  "jsonTests": [
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "3",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "2-2",
            "left": null,
            "right": null,
            "value": 2
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": null,
            "value": 2
          },
          {
            "id": "2-2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "3-2",
            "value": 2
          },
          {
            "id": "2-2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-2",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "3-2",
            "value": 2
          },
          {
            "id": "2-2",
            "left": "3-3",
            "right": "3-4",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-2",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-4",
            "left": null,
            "right": null,
            "value": 3
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "4",
            "value": 2
          },
          {
            "id": "2-2",
            "left": "4-2",
            "right": "3-2",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-2",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "4-2",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "4",
            "value": 2
          },
          {
            "id": "2-2",
            "left": "3-2",
            "right": "4-2",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-2",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "4-2",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "5",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "4",
            "value": 2
          },
          {
            "id": "5",
            "left": "4-2",
            "right": "3-2",
            "value": 5
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-2",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "4-2",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "4",
            "value": 2
          },
          {
            "id": "2-2",
            "left": "4-2",
            "right": "3-2",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-2",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "4-2",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    },
    {
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": "2",
            "right": "2-2",
            "value": 1
          },
          {
            "id": "2",
            "left": "3",
            "right": "4",
            "value": 2
          },
          {
            "id": "2-2",
            "left": "4-2",
            "right": "3-2",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "3-2",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "5-2",
            "right": null,
            "value": 4
          },
          {
            "id": "4-2",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "5-2",
            "left": null,
            "right": null,
            "value": 5
          }
        ],
        "root": "1"
      }
    }
  ],
  "changelog": []
}