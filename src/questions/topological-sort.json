{
  "uid": "topological-sort",
  "testStrategy": "JSON",
  "name": "Topological Sort",
  "version": 0,
  "releaseDate": "2018-10-20T00:00:00Z",
  "category": "Famous Algorithms",
  "difficulty": 3,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 10800,
    "failureCount": 4164
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "295907837",
    "duration": 0,
    "annotations": [],
    "instructor": "Clement Mihailescu",
    "overviewTime": 0,
    "codeWalkthroughTime": 2157
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given a list of arbitrary jobs that need to be completed; these jobs\n  are represented by distinct integers. You're also given a list of dependencies. A\n  dependency is represented as a pair of jobs where the first job is a\n  prerequisite of the second one. In other words, the second job depends on the\n  first one; it can only be completed once the first job is completed.\n</p>\n<p>\n  Write a function that takes in a list of jobs and a list of dependencies and\n  returns a list containing a valid order in which the given jobs can be\n  completed. If no such order exists, the function should return an empty array.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">jobs</span> = [1, 2, 3, 4]\n<span class=\"CodeEditor-promptParameter\">deps</span> = [[1, 2], [1, 3], [3, 2], [4, 2], [4, 3]]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[1, 4, 3, 2] or [4, 1, 3, 2]\n</pre>\n</div>",
  "hints": [
    "<p>\nTry representing the jobs and dependencies as a graph, where each vertex is a job and each edge is a dependency. How can you traverse this graph to topologically sort the list of jobs?\n</p>\n",
    "\n<p>\nOne approach to solving this problem is to traverse the graph mentioned in Hint #1 using Depth-first Search. Starting at a random job, traverse its prerequisite jobs in Depth-first Search fashion until you reach a job with no prerequisites; such a job can safely be appended to the final order. Once you've traversed and added all prerequisites of a job to the final order, you can append the job in question to the order. This approach will have to track whether nodes have been traversed already, whether they're in the process of being traversed (which would indicate a cycle in the graph and therefore no valid topological order), or whether they're ready to be traversed.\n</p>\n",
    "\n<p>\nAnother approach to solving this problem is to traverse the graph mentioned in Hint #1 starting specifically with jobs that have no prerequisites. Keep track of all the jobs that have no prerequisites, traverse them one by one, and append them to the final order. For all of these jobs, remove their dependencies from the graph and update the number of prerequisites for each of these dependencies accordingly (these dependencies should now have one prerequisite less since one of their prerequisite job has just been added to the final order). As you update the number of prerequisites for these other jobs, keep track of the ones that no longer have prerequisites and that are ready to be traversed. You'll eventually go through all of the jobs if there are no cycles in the graph. If there is a cycle in the graph, there will still be jobs with prerequisites and you'll know that there is no valid topological order. This approach will involve keeping track of the number of prerequisites per job as well as all the actual dependencies of each job.\n</p>"
  ],
  "spaceTime": "O(j + d) time | O(j + d) space - where j is the number of jobs and d is the number of dependencies",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nvector<int> topologicalSort(vector<int> jobs, vector<vector<int>> deps) {\n  // Write your code here.\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nclass JobNode {\n public:\n  int job;\n  vector<JobNode*> prereqs;\n  bool visited;\n  bool visiting;\n\n  JobNode(int job);\n};\n\nclass JobGraph {\n public:\n  vector<JobNode*> nodes;\n  unordered_map<int, JobNode*> graph;\n\n  JobGraph(vector<int> jobs);\n  void addPrereq(int job, int prereq);\n  void addNode(int job);\n  JobNode* getNode(int job);\n};\n\nJobGraph* createJobGraph(vector<int> jobs, vector<vector<int>> deps);\nvector<int> getOrderedJobs(JobGraph* graph);\nbool depthFirstTraverse(JobNode* node, vector<int>* orderedJobs);\n\n// O(j + d) time | O(j + d) space\nvector<int> topologicalSort(vector<int> jobs, vector<vector<int>> deps) {\n  JobGraph* jobGraph = createJobGraph(jobs, deps);\n  return getOrderedJobs(jobGraph);\n}\n\nJobGraph* createJobGraph(vector<int> jobs, vector<vector<int>> deps) {\n  JobGraph* graph = new JobGraph(jobs);\n  for (vector<int> dep : deps) {\n    graph->addPrereq(dep[1], dep[0]);\n  }\n  return graph;\n}\n\nvector<int> getOrderedJobs(JobGraph* graph) {\n  vector<int> orderedJobs = {};\n  vector<JobNode*> nodes = graph->nodes;\n  while (nodes.size()) {\n    JobNode* node = nodes.back();\n    nodes.pop_back();\n    bool containsCycle = depthFirstTraverse(node, &orderedJobs);\n    if (containsCycle) return {};\n  }\n  return orderedJobs;\n}\n\nbool depthFirstTraverse(JobNode* node, vector<int>* orderedJobs) {\n  if (node->visited) return false;\n  if (node->visiting) return true;\n  node->visiting = true;\n  for (JobNode* prereqNode : node->prereqs) {\n    bool containsCycle = depthFirstTraverse(prereqNode, orderedJobs);\n    if (containsCycle) return true;\n  }\n  node->visited = true;\n  node->visiting = false;\n  orderedJobs->push_back(node->job);\n  return false;\n}\n\nJobGraph::JobGraph(vector<int> jobs) {\n  nodes = {};\n  for (int job : jobs) {\n    addNode(job);\n  }\n}\n\nvoid JobGraph::addPrereq(int job, int prereq) {\n  JobNode* jobNode = getNode(job);\n  JobNode* prereqNode = getNode(prereq);\n  jobNode->prereqs.push_back(prereqNode);\n}\n\nvoid JobGraph::addNode(int job) {\n  graph[job] = new JobNode(job);\n  nodes.push_back(graph[job]);\n}\n\nJobNode* JobGraph::getNode(int job) {\n  if (graph.find(job) == graph.end()) addNode(job);\n  return graph[job];\n}\n\nJobNode::JobNode(int job) {\n  this->job = job;\n  prereqs = {};\n  visited = false;\n  visiting = false;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nclass JobNode {\n public:\n  int job;\n  vector<JobNode*> deps;\n  int numOfPrereqs;\n\n  JobNode(int job);\n};\n\nclass JobGraph {\n public:\n  vector<JobNode*> nodes;\n  unordered_map<int, JobNode*> graph;\n\n  JobGraph(vector<int> jobs);\n  void addDep(int job, int dep);\n  void addNode(int job);\n  JobNode* getNode(int job);\n};\n\nJobGraph* createJobGraph(vector<int> jobs, vector<vector<int>> deps);\nvector<int> getOrderedJobs(JobGraph* graph);\nvoid removeDeps(JobNode* node, vector<JobNode*>* nodesWithNoPrereqs);\n\n// O(j + d) time | O(j + d) space\nvector<int> topologicalSort(vector<int> jobs, vector<vector<int>> deps) {\n  JobGraph* jobGraph = createJobGraph(jobs, deps);\n  return getOrderedJobs(jobGraph);\n}\n\nJobGraph* createJobGraph(vector<int> jobs, vector<vector<int>> deps) {\n  JobGraph* graph = new JobGraph(jobs);\n  for (vector<int> dep : deps) {\n    graph->addDep(dep[0], dep[1]);\n  }\n  return graph;\n}\n\nvector<int> getOrderedJobs(JobGraph* graph) {\n  vector<int> orderedJobs = {};\n  vector<JobNode*> nodesWithNoPrereqs(graph->nodes.size());\n  auto it = copy_if(\n    graph->nodes.begin(),\n    graph->nodes.end(),\n    nodesWithNoPrereqs.begin(),\n    [](JobNode* node) { return node->numOfPrereqs == 0; }\n  );\n  nodesWithNoPrereqs.resize(distance(nodesWithNoPrereqs.begin(), it));\n  while (nodesWithNoPrereqs.size()) {\n    JobNode* node = nodesWithNoPrereqs.back();\n    nodesWithNoPrereqs.pop_back();\n    orderedJobs.push_back(node->job);\n    removeDeps(node, &nodesWithNoPrereqs);\n  }\n  bool graphHasEdges = false;\n  for (JobNode* node : graph->nodes) {\n    if (node->numOfPrereqs) {\n      graphHasEdges = true;\n    }\n  }\n  return graphHasEdges ? vector<int>{} : orderedJobs;\n}\n\nvoid removeDeps(JobNode* node, vector<JobNode*>* nodesWithNoPrereqs) {\n  while (node->deps.size()) {\n    JobNode* dep = node->deps.back();\n    node->deps.pop_back();\n    dep->numOfPrereqs--;\n    if (!dep->numOfPrereqs) nodesWithNoPrereqs->push_back(dep);\n  }\n}\n\nJobGraph::JobGraph(vector<int> jobs) {\n  nodes = {};\n  for (int job : jobs) {\n    addNode(job);\n  }\n}\n\nvoid JobGraph::addDep(int job, int dep) {\n  JobNode* jobNode = getNode(job);\n  JobNode* depNode = getNode(dep);\n  jobNode->deps.push_back(depNode);\n  depNode->numOfPrereqs++;\n}\n\nvoid JobGraph::addNode(int job) {\n  graph[job] = new JobNode(job);\n  nodes.push_back(graph[job]);\n}\n\nJobNode* JobGraph::getNode(int job) {\n  if (graph.find(job) == graph.end()) addNode(job);\n  return graph[job];\n}\n\nJobNode::JobNode(int job) {\n  this->job = job;\n  deps = {};\n  numOfPrereqs = 0;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include <unordered_map>\n\nbool isValidTopologicalOrder(\n  vector<int> order, vector<int> jobs, vector<vector<int>> deps\n);\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<int> jobs = {1, 2, 3, 4};\n      vector<vector<int>> deps = {{1, 2}, {1, 3}, {3, 2}, {4, 2}, {4, 3}};\n      vector<int> order = topologicalSort(jobs, deps);\n      assert(isValidTopologicalOrder(order, jobs, deps) == true);\n    });\n  }\n};\n\nbool isValidTopologicalOrder(\n  vector<int> order, vector<int> jobs, vector<vector<int>> deps\n) {\n  unordered_map<int, bool> visited;\n  for (int candidate : order) {\n    for (vector<int> dep : deps) {\n      if (candidate == dep[0] && visited.find(dep[1]) != visited.end())\n        return false;\n    }\n    visited[candidate] = true;\n  }\n  for (int job : jobs) {\n    if (visited.find(job) == visited.end()) return false;\n  }\n  return order.size() == jobs.size();\n}\n",
      "unitTests": "#include <unordered_map>\n\nbool isValidTopologicalOrder(\n  vector<int> order, vector<int> jobs, vector<vector<int>> deps\n);\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<int> jobs = {1, 2, 3, 4};\n      vector<vector<int>> deps = {{1, 2}, {1, 3}, {3, 2}, {4, 2}, {4, 3}};\n      vector<int> order = topologicalSort(jobs, deps);\n      assert(isValidTopologicalOrder(order, jobs, deps) == true);\n    });\n  }\n};\n\nbool isValidTopologicalOrder(\n  vector<int> order, vector<int> jobs, vector<vector<int>> deps\n) {\n  unordered_map<int, bool> visited;\n  for (int candidate : order) {\n    for (vector<int> dep : deps) {\n      if (candidate == dep[0] && visited.find(dep[1]) != visited.end())\n        return false;\n    }\n    visited[candidate] = true;\n  }\n  for (int job : jobs) {\n    if (visited.find(job) == visited.end()) return false;\n  }\n  return order.size() == jobs.size();\n}\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n  public static List<int> TopologicalSort(List<int> jobs, List<int[]> deps) {\n    // Write your code here.\n    return new List<int>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(j + d) time | O(j + d) space\n  public static List<int> TopologicalSort(List<int> jobs, List<int[]> deps) {\n    JobGraph jobGraph = createJobGraph(jobs, deps);\n    return getOrderedJobs(jobGraph);\n  }\n\n  public static JobGraph createJobGraph(List<int> jobs, List<int[]> deps) {\n    JobGraph graph = new JobGraph(jobs);\n    foreach (int[] dep in deps) {\n      graph.addPrereq(dep[1], dep[0]);\n    }\n    return graph;\n  }\n\n  public static List<int> getOrderedJobs(JobGraph graph) {\n    List<int> orderedJobs = new List<int>();\n    List<JobNode> nodes = new List<JobNode>(graph.nodes);\n    while (nodes.Count > 0) {\n      JobNode node = nodes[nodes.Count - 1];\n      nodes.RemoveAt(nodes.Count - 1);\n      bool ContainsCycle = depthFirstTraverse(node, orderedJobs);\n      if (ContainsCycle) return new List<int>();\n    }\n    return orderedJobs;\n  }\n\n  public static bool depthFirstTraverse(JobNode node, List<int> orderedJobs) {\n    if (node.visited) return false;\n    if (node.visiting) return true;\n    node.visiting = true;\n    foreach (JobNode prereqNode in node.prereqs) {\n      bool ContainsCycle = depthFirstTraverse(prereqNode, orderedJobs);\n      if (ContainsCycle) return true;\n    }\n    node.visited = true;\n    node.visiting = false;\n    orderedJobs.Add(node.job);\n    return false;\n  }\n\n  public class JobGraph {\n    public List<JobNode> nodes;\n    public Dictionary<int, JobNode> graph;\n\n    public JobGraph(List<int> jobs) {\n      nodes = new List<JobNode>();\n      graph = new Dictionary<int, JobNode>();\n      foreach (int job in jobs) {\n        addNode(job);\n      }\n    }\n\n    public void addPrereq(int job, int prereq) {\n      JobNode jobNode = getNode(job);\n      JobNode prereqNode = getNode(prereq);\n      jobNode.prereqs.Add(prereqNode);\n    }\n\n    public void addNode(int job) {\n      graph.Add(job, new JobNode(job));\n      nodes.Add(graph[job]);\n    }\n\n    public JobNode getNode(int job) {\n      if (!graph.ContainsKey(job)) addNode(job);\n      return graph[job];\n    }\n  }\n\n  public class JobNode {\n    public int job;\n    public List<JobNode> prereqs;\n    public bool visited;\n    public bool visiting;\n\n    public JobNode(int job) {\n      this.job = job;\n      prereqs = new List<JobNode>();\n      visited = false;\n      visiting = false;\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n  // O(j + d) time | O(j + d) space\n  public static List<int> TopologicalSort(List<int> jobs, List<int[]> deps) {\n    JobGraph jobGraph = createJobGraph(jobs, deps);\n    return getOrderedJobs(jobGraph);\n  }\n\n  public static JobGraph createJobGraph(List<int> jobs, List<int[]> deps) {\n    JobGraph graph = new JobGraph(jobs);\n    foreach (int[] dep in deps) {\n      graph.addDep(dep[0], dep[1]);\n    }\n    return graph;\n  }\n\n  public static List<int> getOrderedJobs(JobGraph graph) {\n    List<int> orderedJobs = new List<int>();\n    List<JobNode> nodesWithNoPrereqs = new List<JobNode>();\n    foreach (JobNode node in graph.nodes) {\n      if (node.numOfPrereqs == 0) {\n        nodesWithNoPrereqs.Add(node);\n      }\n    }\n    while (nodesWithNoPrereqs.Count > 0) {\n      JobNode node = nodesWithNoPrereqs[nodesWithNoPrereqs.Count - 1];\n      nodesWithNoPrereqs.RemoveAt(nodesWithNoPrereqs.Count - 1);\n      orderedJobs.Add(node.job);\n      removeDeps(node, nodesWithNoPrereqs);\n    }\n    bool graphHasEdges = false;\n    foreach (JobNode node in graph.nodes) {\n      if (node.numOfPrereqs > 0) {\n        graphHasEdges = true;\n      }\n    }\n    return graphHasEdges ? new List<int>() : orderedJobs;\n  }\n\n  public static void removeDeps(\n    JobNode node, List<JobNode> nodesWithNoPrereqs\n  ) {\n    while (node.deps.Count > 0) {\n      JobNode dep = node.deps[node.deps.Count - 1];\n      node.deps.RemoveAt(node.deps.Count - 1);\n      dep.numOfPrereqs--;\n      if (dep.numOfPrereqs == 0) nodesWithNoPrereqs.Add(dep);\n    }\n  }\n\n  public class JobGraph {\n    public List<JobNode> nodes;\n    public Dictionary<int, JobNode> graph;\n\n    public JobGraph(List<int> jobs) {\n      nodes = new List<JobNode>();\n      graph = new Dictionary<int, JobNode>();\n      foreach (int job in jobs) {\n        addNode(job);\n      }\n    }\n\n    public void addDep(int job, int dep) {\n      JobNode jobNode = getNode(job);\n      JobNode depNode = getNode(dep);\n      jobNode.deps.Add(depNode);\n      depNode.numOfPrereqs++;\n    }\n\n    public void addNode(int job) {\n      graph.Add(job, new JobNode(job));\n      nodes.Add(graph[job]);\n    }\n\n    public JobNode getNode(int job) {\n      if (!graph.ContainsKey(job)) addNode(job);\n      return graph[job];\n    }\n  }\n\n  public class JobNode {\n    public int job;\n    public List<JobNode> deps;\n    public int numOfPrereqs;\n\n    public JobNode(int job) {\n      this.job = job;\n      deps = new List<JobNode>();\n      numOfPrereqs = 0;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    List<int> jobs = new List<int>() { 1, 2, 3, 4 };\n    int[,] depsArray =\n      new int[,] { { 1, 2 }, { 1, 3 }, { 3, 2 }, { 4, 2 }, { 4, 3 } };\n    List<int[]> deps = new List<int[]>();\n    fillDeps(depsArray, deps);\n    List<int> order = Program.TopologicalSort(jobs, deps);\n    Utils.AssertTrue(isValidTopologicalOrder(order, jobs, deps) == true);\n  }\n\n  void fillDeps(int[,] depsArray, List<int[]> deps) {\n    for (int x = 0; x < depsArray.GetLength(0); x++) {\n      var arr = new int[depsArray.GetLength(1)];\n      for (int y = 0; y < depsArray.GetLength(1); y++) {\n        arr[y] = depsArray[x, y];\n      }\n      deps.Add(arr);\n    }\n  }\n\n  bool isValidTopologicalOrder(\n    List<int> order, List<int> jobs, List<int[]> deps\n  ) {\n    Dictionary<int, bool> visited = new Dictionary<int, bool>();\n    foreach (int candidate in order) {\n      foreach (int[] dep in deps) {\n        if (candidate == dep[0] && visited.ContainsKey(dep[1])) return false;\n      }\n      visited.Add(candidate, true);\n    }\n    foreach (int job in jobs) {\n      if (!visited.ContainsKey(job)) return false;\n    }\n    return order.Count == jobs.Count;\n  }\n}\n",
      "unitTests": "using System.Collections.Generic;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    List<int> jobs = new List<int>() { 1, 2, 3, 4 };\n    int[,] depsArray =\n      new int[,] { { 1, 2 }, { 1, 3 }, { 3, 2 }, { 4, 2 }, { 4, 3 } };\n    List<int[]> deps = new List<int[]>();\n    fillDeps(depsArray, deps);\n    List<int> order = Program.TopologicalSort(jobs, deps);\n    Utils.AssertTrue(isValidTopologicalOrder(order, jobs, deps) == true);\n  }\n\n  void fillDeps(int[,] depsArray, List<int[]> deps) {\n    for (int x = 0; x < depsArray.GetLength(0); x++) {\n      var arr = new int[depsArray.GetLength(1)];\n      for (int y = 0; y < depsArray.GetLength(1); y++) {\n        arr[y] = depsArray[x, y];\n      }\n      deps.Add(arr);\n    }\n  }\n\n  bool isValidTopologicalOrder(\n    List<int> order, List<int> jobs, List<int[]> deps\n  ) {\n    Dictionary<int, bool> visited = new Dictionary<int, bool>();\n    foreach (int candidate in order) {\n      foreach (int[] dep in deps) {\n        if (candidate == dep[0] && visited.ContainsKey(dep[1])) return false;\n      }\n      visited.Add(candidate, true);\n    }\n    foreach (int job in jobs) {\n      if (!visited.ContainsKey(job)) return false;\n    }\n    return order.Count == jobs.Count;\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\ntype Dep struct {\n\tPrereq int\n\tJob    int\n}\n\nfunc TopologicalSort(jobs []int, deps []Dep) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype Dep struct {\n\tPrereq int\n\tJob    int\n}\n\n// O(j + d) time | O(j + d) space\nfunc TopologicalSort(jobs []int, deps []Dep) []int {\n\tjobGraph := createJobGraph(jobs, deps)\n\treturn getOrderedJobs(jobGraph)\n}\n\nfunc createJobGraph(jobs []int, deps []Dep) *JobGraph {\n\tgraph := NewJobGraph(jobs)\n\tfor _, dep := range deps {\n\t\tgraph.AddPrereq(dep.Job, dep.Prereq)\n\t}\n\treturn graph\n}\n\nfunc getOrderedJobs(graph *JobGraph) []int {\n\torderedJobs := []int{}\n\tnodes := graph.Nodes\n\tfor len(nodes) != 0 {\n\t\tnode := nodes[len(nodes)-1]\n\t\tnodes = nodes[:len(nodes)-1]\n\t\tcontainsCycle := depthFirstTraverse(node, &orderedJobs)\n\t\tif containsCycle {\n\t\t\treturn []int{}\n\t\t}\n\t}\n\treturn orderedJobs\n}\n\nfunc depthFirstTraverse(node *JobNode, orderedJobs *[]int) bool {\n\tif node.Visited {\n\t\treturn false\n\t} else if node.Visiting {\n\t\treturn true\n\t}\n\tnode.Visiting = true\n\tfor _, prereqNode := range node.Prereqs {\n\t\tcontainsCycle := depthFirstTraverse(prereqNode, orderedJobs)\n\t\tif containsCycle {\n\t\t\treturn true\n\t\t}\n\t}\n\tnode.Visited = true\n\tnode.Visiting = false\n\t*orderedJobs = append(*orderedJobs, node.Job)\n\treturn false\n}\n\ntype JobGraph struct {\n\tNodes []*JobNode\n\tGraph map[int]*JobNode\n}\n\nfunc NewJobGraph(jobs []int) *JobGraph {\n\tg := &JobGraph{\n\t\tGraph: map[int]*JobNode{},\n\t}\n\tfor _, job := range jobs {\n\t\tg.AddNode(job)\n\t}\n\treturn g\n}\n\nfunc (g *JobGraph) AddPrereq(job, prereq int) {\n\tjobNode := g.GetNode(job)\n\tprereqNode := g.GetNode(prereq)\n\tjobNode.Prereqs = append(jobNode.Prereqs, prereqNode)\n}\n\nfunc (g *JobGraph) AddNode(job int) {\n\tg.Graph[job] = &JobNode{Job: job}\n\tg.Nodes = append(g.Nodes, g.Graph[job])\n}\n\nfunc (g *JobGraph) GetNode(job int) *JobNode {\n\tif _, found := g.Graph[job]; !found {\n\t\tg.AddNode(job)\n\t}\n\treturn g.Graph[job]\n}\n\ntype JobNode struct {\n\tJob      int\n\tPrereqs  []*JobNode\n\tVisited  bool\n\tVisiting bool\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype Dep struct {\n\tPrereq int\n\tJob    int\n}\n\n// O(j + d) time | O(j + d) space\nfunc TopologicalSort(jobs []int, deps []Dep) []int {\n\tjobGraph := createJobGraph(jobs, deps)\n\treturn getOrderedJobs(jobGraph)\n}\n\nfunc createJobGraph(jobs []int, deps []Dep) *JobGraph {\n\tgraph := NewJobGraph(jobs)\n\tfor _, dep := range deps {\n\t\tgraph.AddDep(dep.Prereq, dep.Job)\n\t}\n\treturn graph\n}\n\nfunc getOrderedJobs(graph *JobGraph) []int {\n\torderedJobs := []int{}\n\tnodesWithNoPrereqs := []*JobNode{}\n\tfor _, node := range graph.Nodes {\n\t\tif node.NumOfPrereqs == 0 {\n\t\t\tnodesWithNoPrereqs = append(nodesWithNoPrereqs, node)\n\t\t}\n\t}\n\tfor len(nodesWithNoPrereqs) > 0 {\n\t\tnode := nodesWithNoPrereqs[len(nodesWithNoPrereqs)-1]\n\t\tnodesWithNoPrereqs = nodesWithNoPrereqs[:len(nodesWithNoPrereqs)-1]\n\t\torderedJobs = append(orderedJobs, node.Job)\n\t\tremoveDeps(node, &nodesWithNoPrereqs)\n\t}\n\tfor _, node := range graph.Nodes {\n\t\tif node.NumOfPrereqs > 0 {\n\t\t\treturn []int{}\n\t\t}\n\t}\n\treturn orderedJobs\n}\n\nfunc removeDeps(node *JobNode, nodesWithNoPrereqs *[]*JobNode) {\n\tfor len(node.Deps) > 0 {\n\t\tdep := node.Deps[len(node.Deps)-1]\n\t\tnode.Deps = node.Deps[:len(node.Deps)-1]\n\t\tdep.NumOfPrereqs--\n\t\tif dep.NumOfPrereqs == 0 {\n\t\t\t*nodesWithNoPrereqs = append(*nodesWithNoPrereqs, dep)\n\t\t}\n\t}\n}\n\ntype JobGraph struct {\n\tNodes []*JobNode\n\tGraph map[int]*JobNode\n}\n\nfunc NewJobGraph(jobs []int) *JobGraph {\n\tg := &JobGraph{\n\t\tGraph: map[int]*JobNode{},\n\t}\n\tfor _, job := range jobs {\n\t\tg.AddNode(job)\n\t}\n\treturn g\n}\n\nfunc (g *JobGraph) AddDep(job, dep int) {\n\tjobNode, depNode := g.GetNode(job), g.GetNode(dep)\n\tjobNode.Deps = append(jobNode.Deps, depNode)\n\tdepNode.NumOfPrereqs++\n}\n\nfunc (g *JobGraph) AddNode(job int) {\n\tg.Graph[job] = &JobNode{Job: job}\n\tg.Nodes = append(g.Nodes, g.Graph[job])\n}\n\nfunc (g *JobGraph) GetNode(job int) *JobNode {\n\tif _, found := g.Graph[job]; !found {\n\t\tg.AddNode(job)\n\t}\n\treturn g.Graph[job]\n}\n\ntype JobNode struct {\n\tJob          int\n\tDeps         []*JobNode\n\tNumOfPrereqs int\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tjobs := jobs(4)\n\tdeps := []Dep{{1, 2}, {1, 3}, {3, 2}, {4, 2}, {4, 3}}\n\torder := TopologicalSort(jobs, deps)\n\tif !isValidTopologicalOrder(order, jobs, deps) {\n\t\tt.Fail()\n\t}\n}\n\nfunc jobs(n int) []int {\n\tout := []int{}\n\tfor i := 1; i <= n; i++ {\n\t\tout = append(out, i)\n\t}\n\treturn out\n}\n\nfunc isValidTopologicalOrder(order []int, jobs []int, deps []Dep) bool {\n\tvisited := map[int]bool{}\n\tfor _, candidate := range order {\n\t\tfor _, dep := range deps {\n\t\t\tif _, found := visited[dep.Job]; found && candidate == dep.Prereq {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\tvisited[candidate] = true\n\t}\n\tfor _, job := range jobs {\n\t\tif _, found := visited[job]; !found {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn len(order) == len(jobs)\n}\n",
      "unitTests": "package main\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tjobs := jobs(4)\n\tdeps := []Dep{{1, 2}, {1, 3}, {3, 2}, {4, 2}, {4, 3}}\n\torder := TopologicalSort(jobs, deps)\n\tif !isValidTopologicalOrder(order, jobs, deps) {\n\t\tt.Fail()\n\t}\n}\n\nfunc jobs(n int) []int {\n\tout := []int{}\n\tfor i := 1; i <= n; i++ {\n\t\tout = append(out, i)\n\t}\n\treturn out\n}\n\nfunc isValidTopologicalOrder(order []int, jobs []int, deps []Dep) bool {\n\tvisited := map[int]bool{}\n\tfor _, candidate := range order {\n\t\tfor _, dep := range deps {\n\t\t\tif _, found := visited[dep.Job]; found && candidate == dep.Prereq {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\tvisited[candidate] = true\n\t}\n\tfor _, job := range jobs {\n\t\tif _, found := visited[job]; !found {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn len(order) == len(jobs)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public static List<Integer> topologicalSort(\n    List<Integer> jobs, List<Integer[]> deps\n  ) {\n    // Write your code here.\n    return new ArrayList<Integer>();\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(j + d) time | O(j + d) space\n  public static List<Integer> topologicalSort(\n    List<Integer> jobs, List<Integer[]> deps\n  ) {\n    JobGraph jobGraph = createJobGraph(jobs, deps);\n    return getOrderedJobs(jobGraph);\n  }\n\n  public static JobGraph createJobGraph(\n    List<Integer> jobs, List<Integer[]> deps\n  ) {\n    JobGraph graph = new JobGraph(jobs);\n    for (Integer[] dep : deps) {\n      graph.addPrereq(dep[1], dep[0]);\n    }\n    return graph;\n  }\n\n  public static List<Integer> getOrderedJobs(JobGraph graph) {\n    List<Integer> orderedJobs = new ArrayList<Integer>();\n    List<JobNode> nodes = new ArrayList<JobNode>(graph.nodes);\n    while (nodes.size() > 0) {\n      JobNode node = nodes.get(nodes.size() - 1);\n      nodes.remove(nodes.size() - 1);\n      boolean containsCycle = depthFirstTraverse(node, orderedJobs);\n      if (containsCycle) return new ArrayList<Integer>();\n    }\n    return orderedJobs;\n  }\n\n  public static boolean depthFirstTraverse(\n    JobNode node, List<Integer> orderedJobs\n  ) {\n    if (node.visited) return false;\n    if (node.visiting) return true;\n    node.visiting = true;\n    for (JobNode prereqNode : node.prereqs) {\n      boolean containsCycle = depthFirstTraverse(prereqNode, orderedJobs);\n      if (containsCycle) return true;\n    }\n    node.visited = true;\n    node.visiting = false;\n    orderedJobs.add(node.job);\n    return false;\n  }\n\n  static class JobGraph {\n    public List<JobNode> nodes;\n    public Map<Integer, JobNode> graph;\n\n    public JobGraph(List<Integer> jobs) {\n      nodes = new ArrayList<JobNode>();\n      graph = new HashMap<Integer, JobNode>();\n      for (Integer job : jobs) {\n        addNode(job);\n      }\n    }\n\n    public void addPrereq(Integer job, Integer prereq) {\n      JobNode jobNode = getNode(job);\n      JobNode prereqNode = getNode(prereq);\n      jobNode.prereqs.add(prereqNode);\n    }\n\n    public void addNode(Integer job) {\n      graph.put(job, new JobNode(job));\n      nodes.add(graph.get(job));\n    }\n\n    public JobNode getNode(Integer job) {\n      if (!graph.containsKey(job)) addNode(job);\n      return graph.get(job);\n    }\n  }\n\n  static class JobNode {\n    public Integer job;\n    public List<JobNode> prereqs;\n    public boolean visited;\n    public boolean visiting;\n\n    public JobNode(Integer job) {\n      this.job = job;\n      prereqs = new ArrayList<JobNode>();\n      visited = false;\n      visiting = false;\n    }\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(j + d) time | O(j + d) space\n  public static List<Integer> topologicalSort(\n    List<Integer> jobs, List<Integer[]> deps\n  ) {\n    JobGraph jobGraph = createJobGraph(jobs, deps);\n    return getOrderedJobs(jobGraph);\n  }\n\n  public static JobGraph createJobGraph(\n    List<Integer> jobs, List<Integer[]> deps\n  ) {\n    JobGraph graph = new JobGraph(jobs);\n    for (Integer[] dep : deps) {\n      graph.addDep(dep[0], dep[1]);\n    }\n    return graph;\n  }\n\n  public static List<Integer> getOrderedJobs(JobGraph graph) {\n    List<Integer> orderedJobs = new ArrayList<Integer>();\n    List<JobNode> nodesWithNoPrereqs = new ArrayList<JobNode>();\n    for (JobNode node : graph.nodes) {\n      if (node.numOfPrereqs == 0) {\n        nodesWithNoPrereqs.add(node);\n      }\n    }\n    while (nodesWithNoPrereqs.size() > 0) {\n      JobNode node = nodesWithNoPrereqs.get(nodesWithNoPrereqs.size() - 1);\n      nodesWithNoPrereqs.remove(nodesWithNoPrereqs.size() - 1);\n      orderedJobs.add(node.job);\n      removeDeps(node, nodesWithNoPrereqs);\n    }\n    boolean graphHasEdges = false;\n    for (JobNode node : graph.nodes) {\n      if (node.numOfPrereqs > 0) {\n        graphHasEdges = true;\n      }\n    }\n    return graphHasEdges ? new ArrayList<Integer>() : orderedJobs;\n  }\n\n  public static void removeDeps(\n    JobNode node, List<JobNode> nodesWithNoPrereqs\n  ) {\n    while (node.deps.size() > 0) {\n      JobNode dep = node.deps.get(node.deps.size() - 1);\n      node.deps.remove(node.deps.size() - 1);\n      dep.numOfPrereqs--;\n      if (dep.numOfPrereqs == 0) nodesWithNoPrereqs.add(dep);\n    }\n  }\n\n  static class JobGraph {\n    public List<JobNode> nodes;\n    public Map<Integer, JobNode> graph;\n\n    public JobGraph(List<Integer> jobs) {\n      nodes = new ArrayList<JobNode>();\n      graph = new HashMap<Integer, JobNode>();\n      for (Integer job : jobs) {\n        addNode(job);\n      }\n    }\n\n    public void addDep(Integer job, Integer dep) {\n      JobNode jobNode = getNode(job);\n      JobNode depNode = getNode(dep);\n      jobNode.deps.add(depNode);\n      depNode.numOfPrereqs++;\n    }\n\n    public void addNode(Integer job) {\n      graph.put(job, new JobNode(job));\n      nodes.add(graph.get(job));\n    }\n\n    public JobNode getNode(Integer job) {\n      if (!graph.containsKey(job)) addNode(job);\n      return graph.get(job);\n    }\n  }\n\n  static class JobNode {\n    public Integer job;\n    public List<JobNode> deps;\n    public Integer numOfPrereqs;\n\n    public JobNode(Integer job) {\n      this.job = job;\n      deps = new ArrayList<JobNode>();\n      numOfPrereqs = 0;\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<Integer> jobs = new ArrayList<Integer>(Arrays.asList(1, 2, 3, 4));\n    Integer[][] depsArray =\n      new Integer[][] {{1, 2}, {1, 3}, {3, 2}, {4, 2}, {4, 3}};\n    List<Integer[]> deps = new ArrayList<Integer[]>();\n    fillDeps(depsArray, deps);\n    List<Integer> order = Program.topologicalSort(jobs, deps);\n    Utils.assertTrue(isValidTopologicalOrder(order, jobs, deps) == true);\n  }\n\n  void fillDeps(Integer[][] depsArray, List<Integer[]> deps) {\n    for (Integer[] depArray : depsArray) {\n      deps.add(depArray);\n    }\n  }\n\n  boolean isValidTopologicalOrder(\n    List<Integer> order, List<Integer> jobs, List<Integer[]> deps\n  ) {\n    Map<Integer, Boolean> visited = new HashMap<Integer, Boolean>();\n    for (Integer candidate : order) {\n      for (Integer[] dep : deps) {\n        if (candidate == dep[0] && visited.containsKey(dep[1])) return false;\n      }\n      visited.put(candidate, true);\n    }\n    for (Integer job : jobs) {\n      if (!visited.containsKey(job)) return false;\n    }\n    return order.size() == jobs.size();\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<Integer> jobs = new ArrayList<Integer>(Arrays.asList(1, 2, 3, 4));\n    Integer[][] depsArray =\n      new Integer[][] {{1, 2}, {1, 3}, {3, 2}, {4, 2}, {4, 3}};\n    List<Integer[]> deps = new ArrayList<Integer[]>();\n    fillDeps(depsArray, deps);\n    List<Integer> order = Program.topologicalSort(jobs, deps);\n    Utils.assertTrue(isValidTopologicalOrder(order, jobs, deps) == true);\n  }\n\n  void fillDeps(Integer[][] depsArray, List<Integer[]> deps) {\n    for (Integer[] depArray : depsArray) {\n      deps.add(depArray);\n    }\n  }\n\n  boolean isValidTopologicalOrder(\n    List<Integer> order, List<Integer> jobs, List<Integer[]> deps\n  ) {\n    Map<Integer, Boolean> visited = new HashMap<Integer, Boolean>();\n    for (Integer candidate : order) {\n      for (Integer[] dep : deps) {\n        if (candidate == dep[0] && visited.containsKey(dep[1])) return false;\n      }\n      visited.put(candidate, true);\n    }\n    for (Integer job : jobs) {\n      if (!visited.containsKey(job)) return false;\n    }\n    return order.size() == jobs.size();\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function topologicalSort(jobs, deps) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.topologicalSort = topologicalSort;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(j + d) time | O(j + d) space\nfunction topologicalSort(jobs, deps) {\n  const jobGraph = createJobGraph(jobs, deps);\n  return getOrderedJobs(jobGraph);\n}\n\nfunction createJobGraph(jobs, deps) {\n  const graph = new JobGraph(jobs);\n  for (const [prereq, job] of deps) {\n    graph.addPrereq(job, prereq);\n  }\n  return graph;\n}\n\nfunction getOrderedJobs(graph) {\n  const orderedJobs = [];\n  const {nodes} = graph;\n  while (nodes.length) {\n    const node = nodes.pop();\n    const containsCycle = depthFirstTraverse(node, orderedJobs);\n    if (containsCycle) return [];\n  }\n  return orderedJobs;\n}\n\nfunction depthFirstTraverse(node, orderedJobs) {\n  if (node.visited) return false;\n  if (node.visiting) return true;\n  node.visiting = true;\n  for (const prereqNode of node.prereqs) {\n    const containsCycle = depthFirstTraverse(prereqNode, orderedJobs);\n    if (containsCycle) return true;\n  }\n  node.visited = true;\n  node.visiting = false;\n  orderedJobs.push(node.job);\n  return false;\n}\n\nclass JobGraph {\n  constructor(jobs) {\n    this.nodes = [];\n    this.graph = {};\n    for (const job of jobs) {\n      this.addNode(job);\n    }\n  }\n\n  addPrereq(job, prereq) {\n    const jobNode = this.getNode(job);\n    const prereqNode = this.getNode(prereq);\n    jobNode.prereqs.push(prereqNode);\n  }\n\n  addNode(job) {\n    this.graph[job] = new JobNode(job);\n    this.nodes.push(this.graph[job]);\n  }\n\n  getNode(job) {\n    if (!(job in this.graph)) this.addNode(job);\n    return this.graph[job];\n  }\n}\n\nclass JobNode {\n  constructor(job) {\n    this.job = job;\n    this.prereqs = [];\n    this.visited = false;\n    this.visiting = false;\n  }\n}\n\nexports.topologicalSort = topologicalSort;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(j + d) time | O(j + d) space\nfunction topologicalSort(jobs, deps) {\n  const jobGraph = createJobGraph(jobs, deps);\n  return getOrderedJobs(jobGraph);\n}\n\nfunction createJobGraph(jobs, deps) {\n  const graph = new JobGraph(jobs);\n  for (const [job, dep] of deps) {\n    graph.addDep(job, dep);\n  }\n  return graph;\n}\n\nfunction getOrderedJobs(graph) {\n  const orderedJobs = [];\n  const nodesWithNoPrereqs = graph.nodes.filter(node => !node.numOfPrereqs);\n  while (nodesWithNoPrereqs.length) {\n    const node = nodesWithNoPrereqs.pop();\n    orderedJobs.push(node.job);\n    removeDeps(node, nodesWithNoPrereqs);\n  }\n  const graphHasEdges = graph.nodes.some(node => node.numOfPrereqs);\n  return graphHasEdges ? [] : orderedJobs;\n}\n\nfunction removeDeps(node, nodesWithNoPrereqs) {\n  while (node.deps.length) {\n    const dep = node.deps.pop();\n    dep.numOfPrereqs--;\n    if (!dep.numOfPrereqs) nodesWithNoPrereqs.push(dep);\n  }\n}\n\nclass JobGraph {\n  constructor(jobs) {\n    this.nodes = [];\n    this.graph = {};\n    for (const job of jobs) {\n      this.addNode(job);\n    }\n  }\n\n  addDep(job, dep) {\n    const jobNode = this.getNode(job);\n    const depNode = this.getNode(dep);\n    jobNode.deps.push(depNode);\n    depNode.numOfPrereqs++;\n  }\n\n  addNode(job) {\n    this.graph[job] = new JobNode(job);\n    this.nodes.push(this.graph[job]);\n  }\n\n  getNode(job) {\n    if (!(job in this.graph)) this.addNode(job);\n    return this.graph[job];\n  }\n}\n\nclass JobNode {\n  constructor(job) {\n    this.job = job;\n    this.deps = [];\n    this.numOfPrereqs = 0;\n  }\n}\n\nexports.topologicalSort = topologicalSort;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const jobs = [1, 2, 3, 4];\n  const deps = [\n    [1, 2],\n    [1, 3],\n    [3, 2],\n    [4, 2],\n    [4, 3],\n  ];\n  const order = program.topologicalSort(jobs, deps);\n  chai.expect(isValidTopologicalOrder(order, jobs, deps)).to.deep.equal(true);\n});\n\nfunction isValidTopologicalOrder(order, jobs, deps) {\n  const visited = {};\n  for (const candidate of order) {\n    for (const [prereq, job] of deps) {\n      if (candidate === prereq && job in visited) return false;\n    }\n    visited[candidate] = true;\n  }\n  for (const job of jobs) {\n    if (!(job in visited)) return false;\n  }\n  return order.length === jobs.length;\n}\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const jobs = [1, 2, 3, 4];\n  const deps = [\n    [1, 2],\n    [1, 3],\n    [3, 2],\n    [4, 2],\n    [4, 3],\n  ];\n  const order = program.topologicalSort(jobs, deps);\n  chai.expect(isValidTopologicalOrder(order, jobs, deps)).to.deep.equal(true);\n});\n\nfunction isValidTopologicalOrder(order, jobs, deps) {\n  const visited = {};\n  for (const candidate of order) {\n    for (const [prereq, job] of deps) {\n      if (candidate === prereq && job in visited) return false;\n    }\n    visited[candidate] = true;\n  }\n  for (const job of jobs) {\n    if (!(job in visited)) return false;\n  }\n  return order.length === jobs.length;\n}\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun topologicalSort(jobs: List<Int>, deps: List<List<Int>>): List<Int> {\n    // Write you code here.\n    return listOf()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(j + d) time | O(j + d) space\nfun topologicalSort(jobs: List<Int>, deps: List<List<Int>>): List<Int> {\n    val jobGraph = createJobGraph(jobs, deps)\n    return getOrderedJobs(jobGraph)\n}\n\nfun createJobGraph(jobs: List<Int>, deps: List<List<Int>>): JobGraph {\n    val graph = JobGraph(jobs)\n    for (dep in deps) {\n        graph.addPrereq(dep[1], dep[0])\n    }\n    return graph\n}\n\nfun getOrderedJobs(graph: JobGraph): List<Int> {\n    val orderedJobs = mutableListOf<Int>()\n    val nodes = graph.nodes\n    while (nodes.size > 0) {\n        val node = nodes.removeAt(nodes.size - 1)\n        val containsCycle = depthFirstTraverse(node, orderedJobs)\n        if (containsCycle) return listOf()\n    }\n    return orderedJobs\n}\n\nfun depthFirstTraverse(node: JobNode, orderedJobs: MutableList<Int>): Boolean {\n    if (node.visited) return false\n    if (node.visiting) return true\n    node.visiting = true\n    for (prereqNode in node.prereqs) {\n        val containsCycle = depthFirstTraverse(prereqNode, orderedJobs)\n        if (containsCycle) return true\n    }\n    node.visited = true\n    node.visiting = false\n    orderedJobs.add(node.job)\n    return false\n}\n\nclass JobGraph(jobs: List<Int>) {\n    val nodes = mutableListOf<JobNode>()\n    val graph = mutableMapOf<Int, JobNode>()\n\n    init {\n        for (job in jobs) {\n            addNode(job)\n        }\n    }\n\n    fun addPrereq(job: Int, prereq: Int) {\n        val jobNode = getNode(job)\n        val prereqNode = getNode(prereq)\n        jobNode.prereqs.add(prereqNode)\n    }\n\n    fun addNode(job: Int) {\n        graph[job] = JobNode(job)\n        nodes.add(graph[job]!!)\n    }\n\n    fun getNode(job: Int): JobNode {\n        if (!graph.containsKey(job)) addNode(job)\n        return graph[job]!!\n    }\n}\n\nclass JobNode(job: Int) {\n    val job = job\n    val prereqs = mutableListOf<JobNode>()\n    var visited = false\n    var visiting = false\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(j + d) time | O(j + d) space\nfun topologicalSort(jobs: List<Int>, deps: List<List<Int>>): List<Int> {\n    val jobGraph = createJobGraph(jobs, deps)\n    return getOrderedJobs(jobGraph)\n}\n\nfun createJobGraph(jobs: List<Int>, deps: List<List<Int>>): JobGraph {\n    val graph = JobGraph(jobs)\n    for (dep in deps) {\n        graph.addDep(dep[0], dep[1])\n    }\n    return graph\n}\n\nfun getOrderedJobs(graph: JobGraph): List<Int> {\n    val orderedJobs = mutableListOf<Int>()\n    val nodesWithNoPrereqs = graph.nodes.filter { node -> node.numOfPrereqs == 0 }.toMutableList()\n    while (nodesWithNoPrereqs.size > 0) {\n        val node = nodesWithNoPrereqs.removeAt(nodesWithNoPrereqs.size - 1)\n        orderedJobs.add(node.job)\n        removeDeps(node, nodesWithNoPrereqs)\n    }\n    for (node in graph.nodes) {\n        if (node.numOfPrereqs > 0) return listOf()\n    }\n    return orderedJobs\n}\n\nfun removeDeps(node: JobNode, nodesWithNoPrereqs: MutableList<JobNode>) {\n    while (node.deps.size > 0) {\n        val dep = node.deps.removeAt(node.deps.size - 1)\n        dep.numOfPrereqs--\n        if (dep.numOfPrereqs == 0) nodesWithNoPrereqs.add(dep)\n    }\n}\n\nclass JobGraph(jobs: List<Int>) {\n    val nodes = mutableListOf<JobNode>()\n    val graph = mutableMapOf<Int, JobNode>()\n\n    init {\n        for (job in jobs) {\n            addNode(job)\n        }\n    }\n\n    fun addDep(job: Int, dep: Int) {\n        val jobNode = getNode(job)\n        val depNode = getNode(dep)\n        jobNode.deps.add(depNode)\n        depNode.numOfPrereqs++\n    }\n\n    fun addNode(job: Int) {\n        graph[job] = JobNode(job)\n        nodes.add(graph[job]!!)\n    }\n\n    fun getNode(job: Int): JobNode {\n        if (!graph.containsKey(job)) addNode(job)\n        return graph[job]!!\n    }\n}\n\nclass JobNode(job: Int) {\n    val job = job\n    val deps = mutableListOf<JobNode>()\n    var numOfPrereqs = 0\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.topologicalSort as topologicalSort\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val jobs = listOf(1, 2, 3, 4)\n        val deps = listOf(\n            listOf(1, 2),\n            listOf(1, 3),\n            listOf(3, 2),\n            listOf(4, 2),\n            listOf(4, 3),\n        )\n        val order = topologicalSort(jobs, deps)\n        assert(isValidTopologicalOrder(order, jobs, deps))\n    }\n\n    fun isValidTopologicalOrder(order: List<Int>, jobs: List<Int>, deps: List<List<Int>>): Boolean {\n        val visited = mutableMapOf<Int, Boolean>()\n        for (candidate in order) {\n            for (dep in deps) {\n                if (candidate == dep[0] && visited.containsKey(dep[1])) return false\n            }\n            visited[candidate] = true\n        }\n        for (job in jobs) {\n            if (!visited.containsKey(job)) return false\n        }\n        return order.size == jobs.size\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.topologicalSort as topologicalSort\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val jobs = listOf(1, 2, 3, 4)\n        val deps = listOf(\n            listOf(1, 2),\n            listOf(1, 3),\n            listOf(3, 2),\n            listOf(4, 2),\n            listOf(4, 3),\n        )\n        val order = topologicalSort(jobs, deps)\n        assert(isValidTopologicalOrder(order, jobs, deps))\n    }\n\n    fun isValidTopologicalOrder(order: List<Int>, jobs: List<Int>, deps: List<List<Int>>): Boolean {\n        val visited = mutableMapOf<Int, Boolean>()\n        for (candidate in order) {\n            for (dep in deps) {\n                if (candidate == dep[0] && visited.containsKey(dep[1])) return false\n            }\n            visited[candidate] = true\n        }\n        for (job in jobs) {\n            if (!visited.containsKey(job)) return false\n        }\n        return order.size == jobs.size\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def topologicalSort(jobs, deps):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(j + d) time | O(j + d) space\ndef topologicalSort(jobs, deps):\n    jobGraph = createJobGraph(jobs, deps)\n    return getOrderedJobs(jobGraph)\n\n\ndef createJobGraph(jobs, deps):\n    graph = JobGraph(jobs)\n    for prereq, job in deps:\n        graph.addPrereq(job, prereq)\n    return graph\n\n\ndef getOrderedJobs(graph):\n    orderedJobs = []\n    nodes = graph.nodes\n    while len(nodes):\n        node = nodes.pop()\n        containsCycle = depthFirstTraverse(node, orderedJobs)\n        if containsCycle:\n            return []\n    return orderedJobs\n\n\ndef depthFirstTraverse(node, orderedJobs):\n    if node.visited:\n        return False\n    if node.visiting:\n        return True\n    node.visiting = True\n    for prereqNode in node.prereqs:\n        containsCycle = depthFirstTraverse(prereqNode, orderedJobs)\n        if containsCycle:\n            return True\n    node.visited = True\n    node.visiting = False\n    orderedJobs.append(node.job)\n    return False\n\n\nclass JobGraph:\n    def __init__(self, jobs):\n        self.nodes = []\n        self.graph = {}\n        for job in jobs:\n            self.addNode(job)\n\n    def addPrereq(self, job, prereq):\n        jobNode = self.getNode(job)\n        prereqNode = self.getNode(prereq)\n        jobNode.prereqs.append(prereqNode)\n\n    def addNode(self, job):\n        self.graph[job] = JobNode(job)\n        self.nodes.append(self.graph[job])\n\n    def getNode(self, job):\n        if job not in self.graph:\n            self.addNode(job)\n        return self.graph[job]\n\n\nclass JobNode:\n    def __init__(self, job):\n        self.job = job\n        self.prereqs = []\n        self.visited = False\n        self.visiting = False\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(j + d) time | O(j + d) space\ndef topologicalSort(jobs, deps):\n    jobGraph = createJobGraph(jobs, deps)\n    return getOrderedJobs(jobGraph)\n\n\ndef createJobGraph(jobs, deps):\n    graph = JobGraph(jobs)\n    for job, dep in deps:\n        graph.addDep(job, dep)\n    return graph\n\n\ndef getOrderedJobs(graph):\n    orderedJobs = []\n    nodesWithNoPrereqs = list(filter(lambda node: node.numOfPrereqs == 0, graph.nodes))\n    while len(nodesWithNoPrereqs):\n        node = nodesWithNoPrereqs.pop()\n        orderedJobs.append(node.job)\n        removeDeps(node, nodesWithNoPrereqs)\n    graphHasEdges = any(node.numOfPrereqs for node in graph.nodes)\n    return [] if graphHasEdges else orderedJobs\n\n\ndef removeDeps(node, nodesWithNoPrereqs):\n    while len(node.deps):\n        dep = node.deps.pop()\n        dep.numOfPrereqs -= 1\n        if dep.numOfPrereqs == 0:\n            nodesWithNoPrereqs.append(dep)\n\n\nclass JobGraph:\n    def __init__(self, jobs):\n        self.nodes = []\n        self.graph = {}\n        for job in jobs:\n            self.addNode(job)\n\n    def addDep(self, job, dep):\n        jobNode = self.getNode(job)\n        depNode = self.getNode(dep)\n        jobNode.deps.append(depNode)\n        depNode.numOfPrereqs += 1\n\n    def addNode(self, job):\n        self.graph[job] = JobNode(job)\n        self.nodes.append(self.graph[job])\n\n    def getNode(self, job):\n        if job not in self.graph:\n            self.addNode(job)\n        return self.graph[job]\n\n\nclass JobNode:\n    def __init__(self, job):\n        self.job = job\n        self.deps = []\n        self.numOfPrereqs = 0\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        jobs = [1, 2, 3, 4]\n        deps = [[1, 2], [1, 3], [3, 2], [4, 2], [4, 3]]\n        order = program.topologicalSort(jobs, deps)\n        self.assertEqual(isValidTopologicalOrder(order, jobs, deps), True)\n\n\ndef isValidTopologicalOrder(order, jobs, deps):\n    visited = {}\n    for candidate in order:\n        for prereq, job in deps:\n            if candidate == prereq and job in visited:\n                return False\n        visited[candidate] = True\n    for job in jobs:\n        if job not in visited:\n            return False\n    return len(order) == len(jobs)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        jobs = [1, 2, 3, 4]\n        deps = [[1, 2], [1, 3], [3, 2], [4, 2], [4, 3]]\n        order = program.topologicalSort(jobs, deps)\n        self.assertEqual(isValidTopologicalOrder(order, jobs, deps), True)\n\n\ndef isValidTopologicalOrder(order, jobs, deps):\n    visited = {}\n    for candidate in order:\n        for prereq, job in deps:\n            if candidate == prereq and job in visited:\n                return False\n        visited[candidate] = True\n    for job in jobs:\n        if job not in visited:\n            return False\n    return len(order) == len(jobs)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def topologicalSort(jobs, deps)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def topologicalSort(jobs, deps)\n    # Write your code here.\n    return []\n  end\nend\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def topologicalSort(jobs, deps)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.topologicalSort\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.topologicalSort\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func topologicalSort(jobs: [Int], dependencies: [[Int]]) -> [Int] {\n    // Write your code here.\n    return []\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class JobNode {\n    let job: Int\n    var prerequisites: [JobNode]\n    var visited: Bool\n    var visiting: Bool\n\n    init(job: Int) {\n      self.job = job\n      prerequisites = [JobNode]()\n      visited = false\n      visiting = false\n    }\n  }\n\n  class JobGraph {\n    var nodes: [JobNode]\n    var graph: [Int: JobNode]\n\n    init(jobs: [Int]) {\n      nodes = [JobNode]()\n      graph = [Int: JobNode]()\n      for job in jobs {\n        addNode(job: job)\n      }\n    }\n\n    func addNode(job: Int) {\n      let jobNode = JobNode(job: job)\n\n      nodes.append(jobNode)\n      graph[job] = jobNode\n    }\n\n    func addPrerequisiteToJob(job: Int, prerequisite: Int) {\n      let jobNode = getNode(job: job)\n      let prerequisiteNode = getNode(job: prerequisite)\n      jobNode.prerequisites.append(prerequisiteNode)\n    }\n\n    func getNode(job: Int) -> JobNode {\n      if let node = graph[job] {\n        return node\n      } else {\n        graph[job] = JobNode(job: job)\n        return graph[job]!\n      }\n    }\n  }\n\n  // O(j + d) time | O(j + d) space\n  func topologicalSort(jobs: [Int], dependencies: [[Int]]) -> [Int] {\n    let jobGraph = createJobGraph(jobs: jobs, dependencies: dependencies)\n    return getOrderedJobs(jobGraph: jobGraph)\n  }\n\n  func createJobGraph(jobs: [Int], dependencies: [[Int]]) -> JobGraph {\n    let jobGraph = JobGraph(jobs: jobs)\n\n    for dependency in dependencies {\n      let job = dependency[1]\n      let prerequisite = dependency[0]\n      jobGraph.addPrerequisiteToJob(job: job, prerequisite: prerequisite)\n    }\n\n    return jobGraph\n  }\n\n  func getOrderedJobs(jobGraph: JobGraph) -> [Int] {\n    var orderedJobs = [Int]()\n    var jobNodes = jobGraph.nodes\n\n    while jobNodes.count > 0 {\n      if let jobNode = jobNodes.popLast() {\n        let containsCycle = depthFirstTraverse(jobNode: jobNode, orderedJobs: &orderedJobs)\n        if containsCycle {\n          return []\n        }\n      }\n    }\n\n    return orderedJobs\n  }\n\n  func depthFirstTraverse(jobNode: JobNode, orderedJobs: inout [Int]) -> Bool {\n    if jobNode.visited {\n      return false\n    }\n\n    if jobNode.visiting {\n      return true\n    }\n\n    jobNode.visiting = true\n\n    for prerequisite in jobNode.prerequisites {\n      let containsCycle = depthFirstTraverse(jobNode: prerequisite, orderedJobs: &orderedJobs)\n\n      if containsCycle {\n        return true\n      }\n    }\n\n    jobNode.visited = true\n    jobNode.visiting = false\n\n    orderedJobs.append(jobNode.job)\n\n    return false\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class JobNode {\n    let job: Int\n    var dependencies: [JobNode]\n    var numberOfPrerequisites: Int\n\n    init(job: Int) {\n      self.job = job\n      dependencies = [JobNode]()\n      numberOfPrerequisites = 0\n    }\n  }\n\n  class JobGraph {\n    var nodes: [JobNode]\n    var graph: [Int: JobNode]\n\n    init(jobs: [Int]) {\n      nodes = [JobNode]()\n      graph = [Int: JobNode]()\n      for job in jobs {\n        addNode(job: job)\n      }\n    }\n\n    func addNode(job: Int) {\n      let jobNode = JobNode(job: job)\n\n      nodes.append(jobNode)\n      graph[job] = jobNode\n    }\n\n    func addDependencyToJob(job: Int, dependency: Int) {\n      let jobNode = getNode(job: job)\n      let dependencyNode = getNode(job: dependency)\n      jobNode.dependencies.append(dependencyNode)\n      dependencyNode.numberOfPrerequisites += 1\n    }\n\n    func getNode(job: Int) -> JobNode {\n      if let node = graph[job] {\n        return node\n      } else {\n        graph[job] = JobNode(job: job)\n        return graph[job]!\n      }\n    }\n  }\n\n  // O(j + d) time | O(j + d) space\n  func topologicalSort(jobs: [Int], dependencies: [[Int]]) -> [Int] {\n    let jobGraph = createJobGraph(jobs: jobs, dependencies: dependencies)\n    return getOrderedJobs(jobGraph: jobGraph)\n  }\n\n  func createJobGraph(jobs: [Int], dependencies: [[Int]]) -> JobGraph {\n    let jobGraph = JobGraph(jobs: jobs)\n\n    for dependency in dependencies {\n      let job = dependency[0]\n      let dep = dependency[1]\n      jobGraph.addDependencyToJob(job: job, dependency: dep)\n    }\n\n    return jobGraph\n  }\n\n  func getOrderedJobs(jobGraph: JobGraph) -> [Int] {\n    var orderedJobs = [Int]()\n    var nodesWithNoPrerequisites = jobGraph.nodes.filter { $0.numberOfPrerequisites == 0 }\n\n    while nodesWithNoPrerequisites.count > 0 {\n      if let jobNode = nodesWithNoPrerequisites.popLast() {\n        orderedJobs.append(jobNode.job)\n        removeDependencies(jobNode: jobNode, nodesWithNoPrerequisites: &nodesWithNoPrerequisites)\n      }\n    }\n\n    let graphHasEdges = jobGraph.nodes.filter { $0.numberOfPrerequisites > 0 }.count > 0\n\n    return graphHasEdges ? [] : orderedJobs\n  }\n\n  func removeDependencies(jobNode: JobNode, nodesWithNoPrerequisites: inout [JobNode]) {\n    while jobNode.dependencies.count > 0 {\n      if let dependency = jobNode.dependencies.popLast() {\n        dependency.numberOfPrerequisites -= 1\n\n        if dependency.numberOfPrerequisites == 0 {\n          nodesWithNoPrerequisites.append(dependency)\n        }\n      }\n    }\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws in\n      var jobs = [1, 2, 3, 4]\n      var dependencies = [[1, 2], [1, 3], [3, 2], [4, 2], [4, 3]]\n      var order = program.topologicalSort(jobs: jobs, dependencies: dependencies)\n      var isValid = isValidTopologicalOrder(order: order, jobs: jobs, dependencies: dependencies)\n      try assert(isValid)\n    }\n  }\n\n  func isValidTopologicalOrder(order: [Int], jobs: [Int], dependencies: [[Int]]) -> Bool {\n    var visited = [Int: Bool]()\n\n    for candidate in order {\n      for dependency in dependencies {\n        let job = dependency[1]\n        let prerequisite = dependency[0]\n\n        if candidate == prerequisite, visited.keys.contains(job) {\n          return false\n        }\n      }\n\n      visited[candidate] = true\n    }\n\n    for job in jobs {\n      if !visited.keys.contains(job) {\n        return false\n      }\n    }\n\n    return order.count == jobs.count\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws in\n      var jobs = [1, 2, 3, 4]\n      var dependencies = [[1, 2], [1, 3], [3, 2], [4, 2], [4, 3]]\n      var order = program.topologicalSort(jobs: jobs, dependencies: dependencies)\n      var isValid = isValidTopologicalOrder(order: order, jobs: jobs, dependencies: dependencies)\n      try assert(isValid)\n    }\n  }\n\n  func isValidTopologicalOrder(order: [Int], jobs: [Int], dependencies: [[Int]]) -> Bool {\n    var visited = [Int: Bool]()\n\n    for candidate in order {\n      for dependency in dependencies {\n        let job = dependency[1]\n        let prerequisite = dependency[0]\n\n        if candidate == prerequisite, visited.keys.contains(job) {\n          return false\n        }\n      }\n\n      visited[candidate] = true\n    }\n\n    for job in jobs {\n      if !visited.keys.contains(job) {\n        return false\n      }\n    }\n\n    return order.count == jobs.count\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "type Dependency = [number, number];\n\nexport function topologicalSort(jobs: number[], deps: Dependency[]) {\n  // Write your code here.\n  return [-1];\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\ntype Dependency = [number, number];\n\n// O(j + d) time | O(j + d) space\nexport function topologicalSort(jobs: number[], deps: Dependency[]) {\n  const jobGraph = createJobGraph(jobs, deps);\n  return getOrderedJobs(jobGraph);\n}\n\nfunction createJobGraph(jobs: number[], deps: Dependency[]) {\n  const graph = new JobGraph(jobs);\n  for (const [prereq, job] of deps) {\n    graph.addPrereq(job, prereq);\n  }\n  return graph;\n}\n\nfunction getOrderedJobs(graph: JobGraph) {\n  const orderedJobs: number[] = [];\n  const {nodes} = graph;\n  while (nodes.length) {\n    const node = nodes.pop()!;\n    const containsCycle = depthFirstTraverse(node, orderedJobs);\n    if (containsCycle) return [];\n  }\n  return orderedJobs;\n}\n\nfunction depthFirstTraverse(node: JobNode, orderedJobs: number[]) {\n  if (node.visited) return false;\n  if (node.visiting) return true;\n  node.visiting = true;\n  for (const prereqNode of node.prereqs) {\n    const containsCycle = depthFirstTraverse(prereqNode, orderedJobs);\n    if (containsCycle) return true;\n  }\n  node.visited = true;\n  node.visiting = false;\n  orderedJobs.push(node.job);\n  return false;\n}\n\nclass JobGraph {\n  nodes: JobNode[];\n  graph: {[key: number]: JobNode};\n\n  constructor(jobs: number[]) {\n    this.nodes = [];\n    this.graph = {};\n    for (const job of jobs) {\n      this.addNode(job);\n    }\n  }\n\n  addPrereq(job: number, prereq: number) {\n    const jobNode = this.getNode(job);\n    const prereqNode = this.getNode(prereq);\n    jobNode.prereqs.push(prereqNode);\n  }\n\n  addNode(job: number) {\n    this.graph[job] = new JobNode(job);\n    this.nodes.push(this.graph[job]);\n  }\n\n  getNode(job: number) {\n    if (!(job in this.graph)) this.addNode(job);\n    return this.graph[job];\n  }\n}\n\nclass JobNode {\n  job: number;\n  prereqs: JobNode[];\n  visited: boolean;\n  visiting: boolean;\n\n  constructor(job: number) {\n    this.job = job;\n    this.prereqs = [];\n    this.visited = false;\n    this.visiting = false;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\ntype Dependency = [number, number];\n\n// O(j + d) time | O(j + d) space\nexport function topologicalSort(jobs: number[], deps: Dependency[]) {\n  const jobGraph = createJobGraph(jobs, deps);\n  return getOrderedJobs(jobGraph);\n}\n\nfunction createJobGraph(jobs: number[], deps: Dependency[]) {\n  const graph = new JobGraph(jobs);\n  for (const [job, dep] of deps) {\n    graph.addDep(job, dep);\n  }\n  return graph;\n}\n\nfunction getOrderedJobs(graph: JobGraph) {\n  const orderedJobs: number[] = [];\n  const nodesWithNoPrereqs = graph.nodes.filter(node => !node.numOfPrereqs);\n  while (nodesWithNoPrereqs.length) {\n    const node = nodesWithNoPrereqs.pop()!;\n    orderedJobs.push(node.job);\n    removeDeps(node, nodesWithNoPrereqs);\n  }\n  const graphHasEdges = graph.nodes.some(node => node.numOfPrereqs);\n  return graphHasEdges ? [] : orderedJobs;\n}\n\nfunction removeDeps(node: JobNode, nodesWithNoPrereqs: JobNode[]) {\n  while (node.deps.length) {\n    const dep = node.deps.pop()!;\n    dep.numOfPrereqs--;\n    if (!dep.numOfPrereqs) nodesWithNoPrereqs.push(dep);\n  }\n}\n\nclass JobGraph {\n  nodes: JobNode[];\n  graph: {[key: number]: JobNode};\n\n  constructor(jobs: number[]) {\n    this.nodes = [];\n    this.graph = {};\n    for (const job of jobs) {\n      this.addNode(job);\n    }\n  }\n\n  addDep(job: number, dep: number) {\n    const jobNode = this.getNode(job);\n    const depNode = this.getNode(dep);\n    jobNode.deps.push(depNode);\n    depNode.numOfPrereqs++;\n  }\n\n  addNode(job: number) {\n    this.graph[job] = new JobNode(job);\n    this.nodes.push(this.graph[job]);\n  }\n\n  getNode(job: number) {\n    if (!(job in this.graph)) this.addNode(job);\n    return this.graph[job];\n  }\n}\n\nclass JobNode {\n  job: number;\n  deps: JobNode[];\n  numOfPrereqs: number;\n\n  constructor(job: number) {\n    this.job = job;\n    this.deps = [];\n    this.numOfPrereqs = 0;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\ntype Dependency = [number, number];\n\nit('Test Case #1', function () {\n  const jobs = [1, 2, 3, 4];\n  const deps: Dependency[] = [\n    [1, 2],\n    [1, 3],\n    [3, 2],\n    [4, 2],\n    [4, 3],\n  ];\n  const order = program.topologicalSort(jobs, deps);\n  chai.expect(isValidTopologicalOrder(order, jobs, deps)).to.deep.equal(true);\n});\n\nfunction isValidTopologicalOrder(order: number[], jobs: number[], deps: Dependency[]) {\n  const visited: {[key: string]: boolean} = {};\n  for (const candidate of order) {\n    for (const [prereq, job] of deps) {\n      if (candidate === prereq && job in visited) return false;\n    }\n    visited[candidate] = true;\n  }\n  for (const job of jobs) {\n    if (!(job in visited)) return false;\n  }\n  return order.length === jobs.length;\n}\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\ntype Dependency = [number, number];\n\nit('Test Case #1', function () {\n  const jobs = [1, 2, 3, 4];\n  const deps: Dependency[] = [\n    [1, 2],\n    [1, 3],\n    [3, 2],\n    [4, 2],\n    [4, 3],\n  ];\n  const order = program.topologicalSort(jobs, deps);\n  chai.expect(isValidTopologicalOrder(order, jobs, deps)).to.deep.equal(true);\n});\n\nfunction isValidTopologicalOrder(order: number[], jobs: number[], deps: Dependency[]) {\n  const visited: {[key: string]: boolean} = {};\n  for (const candidate of order) {\n    for (const [prereq, job] of deps) {\n      if (candidate === prereq && job in visited) return false;\n    }\n    visited[candidate] = true;\n  }\n  for (const job of jobs) {\n    if (!(job in visited)) return false;\n  }\n  return order.length === jobs.length;\n}\n"
    }
  },
  "customInputVars": [
    {
      "name": "jobs",
      "example": [
        1,
        2,
        3,
        4
      ],
      "schema": {
        "items": {
          "type": "integer"
        },
        "type": "array",
        "uniqueItems": true
      }
    },
    {
      "name": "deps",
      "example": [
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          3,
          2
        ],
        [
          4,
          2
        ],
        [
          4,
          3
        ]
      ],
      "schema": {
        "items": {
          "items": {
            "type": "integer"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "deps": [
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          3,
          2
        ],
        [
          4,
          2
        ],
        [
          4,
          3
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4
      ]
    },
    {
      "deps": [
        [
          3,
          1
        ],
        [
          8,
          1
        ],
        [
          8,
          7
        ],
        [
          5,
          7
        ],
        [
          5,
          2
        ],
        [
          1,
          4
        ],
        [
          1,
          6
        ],
        [
          1,
          2
        ],
        [
          7,
          6
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
      ]
    },
    {
      "deps": [
        [
          3,
          1
        ],
        [
          8,
          1
        ],
        [
          8,
          7
        ],
        [
          5,
          7
        ],
        [
          5,
          2
        ],
        [
          1,
          4
        ],
        [
          6,
          7
        ],
        [
          1,
          2
        ],
        [
          7,
          6
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
      ]
    },
    {
      "deps": [
        [
          3,
          1
        ],
        [
          8,
          1
        ],
        [
          8,
          7
        ],
        [
          5,
          7
        ],
        [
          5,
          2
        ],
        [
          1,
          4
        ],
        [
          1,
          6
        ],
        [
          1,
          2
        ],
        [
          7,
          6
        ],
        [
          4,
          6
        ],
        [
          6,
          2
        ],
        [
          2,
          3
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
      ]
    },
    {
      "deps": [
        [
          1,
          2
        ],
        [
          2,
          3
        ],
        [
          3,
          4
        ],
        [
          4,
          5
        ],
        [
          5,
          6
        ],
        [
          6,
          7
        ],
        [
          7,
          8
        ],
        [
          8,
          1
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
      ]
    },
    {
      "deps": [
        [
          1,
          2
        ],
        [
          2,
          3
        ],
        [
          3,
          4
        ],
        [
          4,
          5
        ],
        [
          5,
          6
        ],
        [
          7,
          6
        ],
        [
          7,
          8
        ],
        [
          8,
          1
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ]
    },
    {
      "deps": [
        [
          1,
          2
        ],
        [
          3,
          5
        ],
        [
          4,
          6
        ],
        [
          3,
          6
        ],
        [
          1,
          7
        ],
        [
          7,
          8
        ],
        [
          1,
          8
        ],
        [
          2,
          8
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
      ]
    },
    {
      "deps": [
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          1,
          4
        ],
        [
          1,
          5
        ],
        [
          1,
          6
        ],
        [
          1,
          7
        ],
        [
          2,
          8
        ],
        [
          3,
          8
        ],
        [
          4,
          8
        ],
        [
          5,
          8
        ],
        [
          6,
          8
        ],
        [
          7,
          8
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
      ]
    },
    {
      "deps": [
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          1,
          4
        ],
        [
          1,
          5
        ],
        [
          1,
          6
        ],
        [
          1,
          7
        ],
        [
          2,
          8
        ],
        [
          3,
          8
        ],
        [
          4,
          8
        ],
        [
          5,
          8
        ],
        [
          6,
          8
        ],
        [
          7,
          8
        ],
        [
          2,
          3
        ],
        [
          2,
          4
        ],
        [
          5,
          4
        ],
        [
          7,
          6
        ],
        [
          6,
          2
        ],
        [
          6,
          3
        ],
        [
          6,
          5
        ],
        [
          5,
          9
        ],
        [
          9,
          8
        ],
        [
          8,
          0
        ],
        [
          4,
          0
        ],
        [
          5,
          0
        ],
        [
          9,
          0
        ],
        [
          2,
          0
        ],
        [
          3,
          9
        ],
        [
          3,
          10
        ],
        [
          10,
          11
        ],
        [
          11,
          12
        ],
        [
          2,
          12
        ]
      ],
      "jobs": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12
      ]
    },
    {
      "deps": [
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          1,
          4
        ],
        [
          1,
          5
        ],
        [
          1,
          6
        ],
        [
          1,
          7
        ],
        [
          2,
          8
        ],
        [
          3,
          8
        ],
        [
          4,
          8
        ],
        [
          5,
          8
        ],
        [
          6,
          8
        ],
        [
          7,
          8
        ],
        [
          2,
          3
        ],
        [
          2,
          4
        ],
        [
          5,
          4
        ],
        [
          7,
          6
        ],
        [
          6,
          2
        ],
        [
          6,
          3
        ],
        [
          6,
          5
        ],
        [
          5,
          9
        ],
        [
          9,
          8
        ],
        [
          8,
          0
        ],
        [
          4,
          0
        ],
        [
          5,
          0
        ],
        [
          9,
          0
        ],
        [
          2,
          0
        ],
        [
          3,
          9
        ],
        [
          3,
          10
        ],
        [
          10,
          11
        ],
        [
          11,
          12
        ],
        [
          12,
          2
        ]
      ],
      "jobs": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12
      ]
    },
    {
      "deps": [],
      "jobs": [
        1,
        2,
        3,
        4,
        5
      ]
    },
    {
      "deps": [
        [
          1,
          4
        ],
        [
          5,
          2
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5
      ]
    }
  ],
  "jsonTests": [
    {
      "deps": [
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          3,
          2
        ],
        [
          4,
          2
        ],
        [
          4,
          3
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4
      ]
    },
    {
      "deps": [
        [
          3,
          1
        ],
        [
          8,
          1
        ],
        [
          8,
          7
        ],
        [
          5,
          7
        ],
        [
          5,
          2
        ],
        [
          1,
          4
        ],
        [
          1,
          6
        ],
        [
          1,
          2
        ],
        [
          7,
          6
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
      ]
    },
    {
      "deps": [
        [
          3,
          1
        ],
        [
          8,
          1
        ],
        [
          8,
          7
        ],
        [
          5,
          7
        ],
        [
          5,
          2
        ],
        [
          1,
          4
        ],
        [
          6,
          7
        ],
        [
          1,
          2
        ],
        [
          7,
          6
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
      ]
    },
    {
      "deps": [
        [
          3,
          1
        ],
        [
          8,
          1
        ],
        [
          8,
          7
        ],
        [
          5,
          7
        ],
        [
          5,
          2
        ],
        [
          1,
          4
        ],
        [
          1,
          6
        ],
        [
          1,
          2
        ],
        [
          7,
          6
        ],
        [
          4,
          6
        ],
        [
          6,
          2
        ],
        [
          2,
          3
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
      ]
    },
    {
      "deps": [
        [
          1,
          2
        ],
        [
          2,
          3
        ],
        [
          3,
          4
        ],
        [
          4,
          5
        ],
        [
          5,
          6
        ],
        [
          6,
          7
        ],
        [
          7,
          8
        ],
        [
          8,
          1
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
      ]
    },
    {
      "deps": [
        [
          1,
          2
        ],
        [
          2,
          3
        ],
        [
          3,
          4
        ],
        [
          4,
          5
        ],
        [
          5,
          6
        ],
        [
          7,
          6
        ],
        [
          7,
          8
        ],
        [
          8,
          1
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ]
    },
    {
      "deps": [
        [
          1,
          2
        ],
        [
          3,
          5
        ],
        [
          4,
          6
        ],
        [
          3,
          6
        ],
        [
          1,
          7
        ],
        [
          7,
          8
        ],
        [
          1,
          8
        ],
        [
          2,
          8
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
      ]
    },
    {
      "deps": [
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          1,
          4
        ],
        [
          1,
          5
        ],
        [
          1,
          6
        ],
        [
          1,
          7
        ],
        [
          2,
          8
        ],
        [
          3,
          8
        ],
        [
          4,
          8
        ],
        [
          5,
          8
        ],
        [
          6,
          8
        ],
        [
          7,
          8
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
      ]
    },
    {
      "deps": [
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          1,
          4
        ],
        [
          1,
          5
        ],
        [
          1,
          6
        ],
        [
          1,
          7
        ],
        [
          2,
          8
        ],
        [
          3,
          8
        ],
        [
          4,
          8
        ],
        [
          5,
          8
        ],
        [
          6,
          8
        ],
        [
          7,
          8
        ],
        [
          2,
          3
        ],
        [
          2,
          4
        ],
        [
          5,
          4
        ],
        [
          7,
          6
        ],
        [
          6,
          2
        ],
        [
          6,
          3
        ],
        [
          6,
          5
        ],
        [
          5,
          9
        ],
        [
          9,
          8
        ],
        [
          8,
          0
        ],
        [
          4,
          0
        ],
        [
          5,
          0
        ],
        [
          9,
          0
        ],
        [
          2,
          0
        ],
        [
          3,
          9
        ],
        [
          3,
          10
        ],
        [
          10,
          11
        ],
        [
          11,
          12
        ],
        [
          2,
          12
        ]
      ],
      "jobs": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12
      ]
    },
    {
      "deps": [
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          1,
          4
        ],
        [
          1,
          5
        ],
        [
          1,
          6
        ],
        [
          1,
          7
        ],
        [
          2,
          8
        ],
        [
          3,
          8
        ],
        [
          4,
          8
        ],
        [
          5,
          8
        ],
        [
          6,
          8
        ],
        [
          7,
          8
        ],
        [
          2,
          3
        ],
        [
          2,
          4
        ],
        [
          5,
          4
        ],
        [
          7,
          6
        ],
        [
          6,
          2
        ],
        [
          6,
          3
        ],
        [
          6,
          5
        ],
        [
          5,
          9
        ],
        [
          9,
          8
        ],
        [
          8,
          0
        ],
        [
          4,
          0
        ],
        [
          5,
          0
        ],
        [
          9,
          0
        ],
        [
          2,
          0
        ],
        [
          3,
          9
        ],
        [
          3,
          10
        ],
        [
          10,
          11
        ],
        [
          11,
          12
        ],
        [
          12,
          2
        ]
      ],
      "jobs": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12
      ]
    },
    {
      "deps": [],
      "jobs": [
        1,
        2,
        3,
        4,
        5
      ]
    },
    {
      "deps": [
        [
          1,
          4
        ],
        [
          5,
          2
        ]
      ],
      "jobs": [
        1,
        2,
        3,
        4,
        5
      ]
    }
  ],
  "changelog": []
}