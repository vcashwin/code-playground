{
  "uid": "two-edge-connected-graph",
  "testStrategy": "JSON",
  "name": "Two-Edge-Connected Graph",
  "version": 0,
  "releaseDate": "2021-05-17T00:00:00Z",
  "category": "Graphs",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 1766,
    "failureCount": 463
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "540930009",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 2133
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given a list of <span>edges</span> representing an unweighted and\n  undirected graph. Write a function that returns a boolean representing whether\n  the given graph is two-edge-connected.\n</p>\n<p>\n  A graph is connected if, for every pair of vertices in the graph, there's a\n  path of one or more edges connecting the given vertices. A graph that isn't\n  connected is said to be disconnected.\n</p>\n<p>\n  A graph is two-edge-connected if, for every one of its edges, the edge's\n  removal from the graph doesn't cause the graph to become disconnected. If the\n  removal of any single edge disconnects the graph, then it isn't\n  two-edge-connected. If the given graph is already disconnected, then it also\n  isn't two-edge-connected. An empty graph is considered two-edge-connected.\n</p>\n<p>\n  The input list is what's called an adjacency list, and it represents a graph.\n  The number of vertices in the graph is equal to the length of\n  <span>edges</span>, where each index <span>i</span> in\n  <span>edges</span> contains vertex <span>i</span>'s outbound edges, in no\n  particular order. Each outbound edge is represented by a positive integer that\n  denotes an index (a destination vertex) in the list that this vertex is\n  connected to. Note that these edges are undirected, meaning that you can\n  travel from a particular vertex to its destination and from the destination\n  back to that vertex. Since these edges are undirected, if vertex\n  <span>i</span> has an outbound edge to vertex <span>j</span>, then vertex\n  <span>j</span> is guaranteed to have an outbound edge to vertex\n  <span>i</span>. For example, an undirected graph with two vertices and one\n  edge would be represented by the following adjacency list\n  <span>edges = [[1], [0]]</span>.\n</p>\n<p>\n  Note that the input graph will never contain parallel edges (edges that share\n  the same source and destination vertices). In other words, there will never be\n  more than one edge that connects the same two vertices to each other.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">edges</span> = [\n  [1, 2, 5],\n  [0, 2],\n  [0, 1, 3],\n  [2, 4, 5],\n  [3, 5],\n  [0, 3, 4],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue \n</pre>\n</div>",
  "hints": [
    "<p>\n  The brute-force approach to solving this problem is to simply remove one edge\n  from the graph at a time and to then check if the resulting graph is\n  disconnected. This approach works, but is isn't optimal. Can you think of a\n  better approach?\n</p>\n",
    "\n<p>\n  It's easy to see that, if there's only one edge that connects a vertex or a\n  group of vertices to the rest of the graph, then this graph isn't\n  two-edge-connected. This is because, after the removal of that particular\n  edge, the graph would become disconnected. This type of edge is what's known\n  as a bridge; if you discover a bridge in the graph, the graph isn't\n  two-edge-connected.\n</p>\n",
    "\n<p>\n  In order for a graph to be two-edge-connected, it must be connected before the\n  removal of any edges, and it must not contain any bridges. To determine if a\n  graph is connected, you can simply run a depth-first search from any vertex\n  and see if you're able to visit every other vertex. To determine if a graph\n  contains any bridges is a little bit more difficult, but it can be done with a\n  modified depth-first search that considers the different types of edges in the\n  graph.\n</p>\n",
    "\n<p>\n  To confirm that no bridges exist in the graph, you need to see if there's an\n  edge from every vertex in the graph to a vertex that is visited before it in a\n  depth-first search (this is known as a back edge). A back edge indicates that\n  there's a way to reach a vertex other than from the original edge that reached\n  it. This means that if you remove the original edge that reached a vertex, it\n  can still be visited, and the original edge you've just removed isn't a\n  bridge. If every vertex in the graph (with the exception of the starting\n  vertex in a given depth-first search) has a back edge, then the graph is\n  two-edge-connected. See the Conceptual Overview section of this question's\n  video explanation for a more in-depth explanation.\n</p>"
  ],
  "spaceTime": "O(v + e) time | O(v) space - where v is the number of vertices and e is the number of edges in the graph",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\nusing namespace std;\n\nbool twoEdgeConnectedGraph(vector<vector<int>> edges) {\n  // Write your code here.\n  return false;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nbool areAllVerticesVisited(const vector<int>& arrivalTimes);\nint getMinimumArrivalTimeOfAncestors(\n  int currentVertex,\n  int parent,\n  int currentTime,\n  vector<int>& arrivalTimes,\n  const vector<vector<int>>& edges\n);\n\n// O(v + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the graph\nbool twoEdgeConnectedGraph(vector<vector<int>> edges) {\n  if (edges.size() == 0) return true;\n\n  vector<int> arrivalTimes(edges.size(), -1);\n  int startVertex = 0;\n\n  if (getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, arrivalTimes, edges) == -1) {\n    return false;\n  }\n\n  return areAllVerticesVisited(arrivalTimes);\n}\n\nbool areAllVerticesVisited(const vector<int>& arrivalTimes) {\n  for (const auto& time : arrivalTimes) {\n    if (time == -1) return false;\n  }\n\n  return true;\n}\n\nint getMinimumArrivalTimeOfAncestors(\n  int currentVertex,\n  int parent,\n  int currentTime,\n  vector<int>& arrivalTimes,\n  const vector<vector<int>>& edges\n) {\n  arrivalTimes[currentVertex] = currentTime;\n\n  int minimumArrivalTime = currentTime;\n\n  for (const auto& destination : edges[currentVertex]) {\n    if (arrivalTimes[destination] == -1) {\n      minimumArrivalTime = min(\n        minimumArrivalTime,\n        getMinimumArrivalTimeOfAncestors(\n          destination, currentVertex, currentTime + 1, arrivalTimes, edges\n        )\n      );\n    } else if (destination != parent) {\n      minimumArrivalTime = min(minimumArrivalTime, arrivalTimes[destination]);\n    }\n  }\n\n  // A bridge was detected, which means the graph isn't two-edge-connected.\n  if (minimumArrivalTime == currentTime && parent != -1) return -1;\n\n  return minimumArrivalTime;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> input = {\n        {1, 2, 5}, {0, 2}, {0, 1, 3}, {2, 4, 5}, {3, 5}, {0, 3, 5}};\n      auto expected = true;\n      auto actual = twoEdgeConnectedGraph(input);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<int>> input = {\n        {1, 2, 5}, {0, 2}, {0, 1, 3}, {2, 4, 5}, {3, 5}, {0, 3, 5}};\n      auto expected = true;\n      auto actual = twoEdgeConnectedGraph(input);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public bool TwoEdgeConnectedGraph(int[][] edges) {\n    // Write your code here.\n    return false;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // O(v + e) time | O(v) space - where v is the number of\n  // vertices and e is the number of edges in the graph\n  public bool TwoEdgeConnectedGraph(int[][] edges) {\n    if (edges.Length == 0) return true;\n\n    int[] arrivalTimes = new int[edges.Length];\n    Array.Fill(arrivalTimes, -1);\n    int startVertex = 0;\n\n    if (getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, arrivalTimes, edges) == -1) {\n      return false;\n    }\n\n    return areAllVerticesVisited(arrivalTimes);\n  }\n\n  public bool areAllVerticesVisited(int[] arrivalTimes) {\n    foreach (var time in arrivalTimes) {\n      if (time == -1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public int getMinimumArrivalTimeOfAncestors(\n    int currentVertex,\n    int parent,\n    int currentTime,\n    int[] arrivalTimes,\n    int[][] edges\n  ) {\n    arrivalTimes[currentVertex] = currentTime;\n\n    int minimumArrivalTime = currentTime;\n\n    foreach (var destination in edges[currentVertex]) {\n      if (arrivalTimes[destination] == -1) {\n        minimumArrivalTime = Math.Min(\n          minimumArrivalTime,\n          getMinimumArrivalTimeOfAncestors(\n            destination, currentVertex, currentTime + 1, arrivalTimes, edges\n          )\n        );\n      } else if (destination != parent) {\n        minimumArrivalTime =\n          Math.Min(minimumArrivalTime, arrivalTimes[destination]);\n      }\n    }\n\n    // A bridge was detected, which means the graph isn't two-edge-connected.\n    if (minimumArrivalTime == currentTime && parent != -1) {\n      return -1;\n    }\n\n    return minimumArrivalTime;\n  }\n}"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[][] input = new int[][] {\n      new int[] { 1, 2, 5 },\n      new int[] { 0, 2 },\n      new int[] { 0, 1, 3 },\n      new int[] { 2, 4, 5 },\n      new int[] { 3, 5 },\n      new int[] { 0, 3, 4 },\n    };\n    bool expected = true;\n    var actual = new Program().TwoEdgeConnectedGraph(input);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    int[][] input = new int[][] {\n      new int[] { 1, 2, 5 },\n      new int[] { 0, 2 },\n      new int[] { 0, 1, 3 },\n      new int[] { 2, 4, 5 },\n      new int[] { 3, 5 },\n      new int[] { 0, 3, 4 },\n    };\n    bool expected = true;\n    var actual = new Program().TwoEdgeConnectedGraph(input);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc TwoEdgeConnectedGraph(edges [][]int) bool {\n\t// Write your code here.\n\treturn false\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(v + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the graph\nfunc TwoEdgeConnectedGraph(edges [][]int) bool {\n\tif len(edges) == 0 {\n\t\treturn true\n\t}\n\n\tarrivalTimes := make([]int, len(edges))\n\tfor i := range edges {\n\t\tarrivalTimes[i] = -1\n\t}\n\tstartVertex := 0\n\n\tif getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, &arrivalTimes, edges) == -1 {\n\t\treturn false\n\t}\n\n\treturn areAllVerticesVisited(arrivalTimes)\n}\n\nfunc areAllVerticesVisited(arrivalTimes []int) bool {\n\tfor _, time := range arrivalTimes {\n\t\tif time == -1 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc getMinimumArrivalTimeOfAncestors(currentVertex, parent, currentTime int, arrivalTimes *[]int, edges [][]int) int {\n\t(*arrivalTimes)[currentVertex] = currentTime\n\n\tvar minimumArrivalTime = currentTime\n\n\tfor _, destination := range edges[currentVertex] {\n\t\tif (*arrivalTimes)[destination] == -1 {\n\t\t\tminimumArrivalTime = min(\n\t\t\t\tminimumArrivalTime,\n\t\t\t\tgetMinimumArrivalTimeOfAncestors(destination, currentVertex, currentTime+1, arrivalTimes, edges),\n\t\t\t)\n\t\t} else if destination != parent {\n\t\t\tminimumArrivalTime = min(\n\t\t\t\tminimumArrivalTime,\n\t\t\t\t(*arrivalTimes)[destination],\n\t\t\t)\n\t\t}\n\t}\n\n\t// A bridge was detected, which means the graph isn't two-edge-connected.\n\tif minimumArrivalTime == currentTime && parent != -1 {\n\t\treturn -1\n\t}\n\n\treturn minimumArrivalTime\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{1, 2, 5},\n\t\t{0, 2},\n\t\t{0, 1, 3},\n\t\t{2, 4, 5},\n\t\t{3, 5},\n\t\t{0, 3, 4},\n\t}\n\texpected := true\n\tactual := TwoEdgeConnectedGraph(input)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{1, 2, 5},\n\t\t{0, 2},\n\t\t{0, 1, 3},\n\t\t{2, 4, 5},\n\t\t{3, 5},\n\t\t{0, 3, 4},\n\t}\n\texpected := true\n\tactual := TwoEdgeConnectedGraph(input)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public boolean twoEdgeConnectedGraph(int[][] edges) {\n    // Write your code here.\n    return false;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(v + e) time | O(v) space - where v is the number of\n  // vertices and e is the number of edges in the graph\n  public boolean twoEdgeConnectedGraph(int[][] edges) {\n    if (edges.length == 0) return true;\n\n    int[] arrivalTimes = new int[edges.length];\n    Arrays.fill(arrivalTimes, -1);\n    int startVertex = 0;\n\n    if (getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, arrivalTimes, edges) == -1) {\n      return false;\n    }\n\n    return areAllVerticesVisited(arrivalTimes);\n  }\n\n  public boolean areAllVerticesVisited(int[] arrivalTimes) {\n    for (int time : arrivalTimes) {\n      if (time == -1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public int getMinimumArrivalTimeOfAncestors(\n    int currentVertex,\n    int parent,\n    int currentTime,\n    int[] arrivalTimes,\n    int[][] edges\n  ) {\n    arrivalTimes[currentVertex] = currentTime;\n\n    int minimumArrivalTime = currentTime;\n\n    for (int destination : edges[currentVertex]) {\n      if (arrivalTimes[destination] == -1) {\n        minimumArrivalTime = Math.min(\n          minimumArrivalTime,\n          getMinimumArrivalTimeOfAncestors(\n            destination, currentVertex, currentTime + 1, arrivalTimes, edges\n          )\n        );\n      } else if (destination != parent) {\n        minimumArrivalTime =\n          Math.min(minimumArrivalTime, arrivalTimes[destination]);\n      }\n    }\n\n    // A bridge was detected, which means the graph isn't two-edge-connected.\n    if (minimumArrivalTime == currentTime && parent != -1) {\n      return -1;\n    }\n\n    return minimumArrivalTime;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] input =\n      new int[][] {{1, 2, 5}, {0, 2}, {0, 1, 3}, {2, 4, 5}, {3, 5}, {0, 3, 4}};\n    boolean expected = true;\n    var actual = new Program().twoEdgeConnectedGraph(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] input =\n      new int[][] {{1, 2, 5}, {0, 2}, {0, 1, 3}, {2, 4, 5}, {3, 5}, {0, 3, 4}};\n    boolean expected = true;\n    var actual = new Program().twoEdgeConnectedGraph(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function twoEdgeConnectedGraph(edges) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.twoEdgeConnectedGraph = twoEdgeConnectedGraph;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(v + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the graph\nfunction twoEdgeConnectedGraph(edges) {\n  if (edges.length === 0) return true;\n\n  const arrivalTimes = new Array(edges.length).fill(-1);\n  const startVertex = 0;\n\n  if (getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, arrivalTimes, edges) === -1) {\n    return false;\n  }\n\n  return areAllVerticesVisited(arrivalTimes);\n}\n\nfunction areAllVerticesVisited(arrivalTimes) {\n  for (const time of arrivalTimes) {\n    if (time === -1) return false;\n  }\n\n  return true;\n}\n\nfunction getMinimumArrivalTimeOfAncestors(currentVertex, parent, currentTime, arrivalTimes, edges) {\n  arrivalTimes[currentVertex] = currentTime;\n\n  let minimumArrivalTime = currentTime;\n\n  for (const destination of edges[currentVertex]) {\n    if (arrivalTimes[destination] === -1) {\n      minimumArrivalTime = Math.min(\n        minimumArrivalTime,\n        getMinimumArrivalTimeOfAncestors(\n          destination,\n          currentVertex,\n          currentTime + 1,\n          arrivalTimes,\n          edges,\n        ),\n      );\n    } else if (destination !== parent) {\n      minimumArrivalTime = Math.min(minimumArrivalTime, arrivalTimes[destination]);\n    }\n  }\n\n  // A bridge was detected, which means the graph isn't two-edge-connected.\n  if (minimumArrivalTime === currentTime && parent !== -1) return -1;\n\n  return minimumArrivalTime;\n}\n\n// Do not edit the line below.\nexports.twoEdgeConnectedGraph = twoEdgeConnectedGraph;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 2, 5],\n    [0, 2],\n    [0, 1, 3],\n    [2, 4, 5],\n    [3, 5],\n    [0, 3, 4],\n  ];\n  const expected = true;\n  const actual = program.twoEdgeConnectedGraph(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 2, 5],\n    [0, 2],\n    [0, 1, 3],\n    [2, 4, 5],\n    [3, 5],\n    [0, 3, 4],\n  ];\n  const expected = true;\n  const actual = program.twoEdgeConnectedGraph(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun twoEdgeConnectedGraph(edges: List<List<Int>>): Boolean {\n    // Write your code here.\n    return false\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.min\n\n// O(v + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the graph\nfun twoEdgeConnectedGraph(edges: List<List<Int>>): Boolean {\n    if (edges.size == 0) return true\n\n    val arrivalTimes = MutableList(edges.size) { -1 }\n    val startVertex = 0\n\n    if (\n        getMinimumArrivalTimeOfAncestors(\n            startVertex,\n            -1,\n            0,\n            arrivalTimes,\n            edges,\n        ) == -1\n    ) {\n        return false\n    }\n\n    return areAllVerticesVisited(arrivalTimes)\n}\n\nfun areAllVerticesVisited(arrivalTimes: List<Int>): Boolean {\n    for (time in arrivalTimes) {\n        if (time == -1) return false\n    }\n\n    return true\n}\n\nfun getMinimumArrivalTimeOfAncestors(\n    currentVertex: Int,\n    parent: Int,\n    currentTime: Int,\n    arrivalTimes: MutableList<Int>,\n    edges: List<List<Int>>,\n): Int {\n    arrivalTimes[currentVertex] = currentTime\n\n    var minimumArrivalTime = currentTime\n\n    for (destination in edges[currentVertex]) {\n        if (arrivalTimes[destination] == -1) {\n            minimumArrivalTime = min(\n                minimumArrivalTime,\n                getMinimumArrivalTimeOfAncestors(\n                    destination,\n                    currentVertex,\n                    currentTime + 1,\n                    arrivalTimes,\n                    edges,\n                ),\n            )\n        } else if (destination != parent) {\n            minimumArrivalTime = min(\n                minimumArrivalTime,\n                arrivalTimes[destination],\n            )\n        }\n    }\n\n    // A bridge was detected, which means the graph isn't two-edge-connected.\n    if (minimumArrivalTime == currentTime && parent != -1) return -1\n\n    return minimumArrivalTime\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.twoEdgeConnectedGraph\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(\n            listOf(1, 2, 5),\n            listOf(0, 2),\n            listOf(0, 1, 3),\n            listOf(2, 4, 5),\n            listOf(3, 5),\n            listOf(0, 3, 4),\n        )\n        val expected = true\n        val output = twoEdgeConnectedGraph(input)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.twoEdgeConnectedGraph\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(\n            listOf(1, 2, 5),\n            listOf(0, 2),\n            listOf(0, 1, 3),\n            listOf(2, 4, 5),\n            listOf(3, 5),\n            listOf(0, 3, 4),\n        )\n        val expected = true\n        val output = twoEdgeConnectedGraph(input)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def twoEdgeConnectedGraph(edges):\n    # Write your code here.\n    return False\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(v + e) time | O(v) space - where v is the number of\n# vertices and e is the number of edges in the graph\ndef twoEdgeConnectedGraph(edges):\n    if len(edges) == 0:\n        return True\n\n    arrivalTimes = [-1] * len(edges)\n    startVertex = 0\n\n    if getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, arrivalTimes, edges) == -1:\n        return False\n\n    return areAllVerticesVisited(arrivalTimes)\n\n\ndef areAllVerticesVisited(arrivalTimes):\n    for time in arrivalTimes:\n        if time == -1:\n            return False\n\n    return True\n\n\ndef getMinimumArrivalTimeOfAncestors(currentVertex, parent, currentTime, arrivalTimes, edges):\n    arrivalTimes[currentVertex] = currentTime\n\n    minimumArrivalTime = currentTime\n\n    for destination in edges[currentVertex]:\n        if arrivalTimes[destination] == -1:\n            minimumArrivalTime = min(\n                minimumArrivalTime,\n                getMinimumArrivalTimeOfAncestors(\n                    destination, currentVertex, currentTime + 1, arrivalTimes, edges\n                ),\n            )\n        elif destination != parent:\n            minimumArrivalTime = min(minimumArrivalTime, arrivalTimes[destination])\n\n    # A bridge was detected, which means the graph isn't two-edge-connected.\n    if minimumArrivalTime == currentTime and parent != -1:\n        return -1\n\n    return minimumArrivalTime\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [[1, 2, 5], [0, 2], [0, 1, 3], [2, 4, 5], [3, 5], [0, 3, 4]]\n        expected = True\n        actual = program.twoEdgeConnectedGraph(input)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [[1, 2, 5], [0, 2], [0, 1, 3], [2, 4, 5], [3, 5], [0, 3, 4]]\n        expected = True\n        actual = program.twoEdgeConnectedGraph(input)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "class Program\n  def twoEdgeConnectedGraph(edges)\n    # Write your code here.\n    return false\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def twoEdgeConnectedGraph(edges)\n    # Write your code here.\n    return false\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.twoEdgeConnectedGraph\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.twoEdgeConnectedGraph\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func twoEdgeConnectedGraph(_ edges: inout [[Int]]) -> Bool {\n    // Write your code here.\n    return false\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(v + e) time | O(v) space - where v is the number of\n  // vertices and e is the number of edges in the graph\n  func twoEdgeConnectedGraph(_ edges: inout [[Int]]) -> Bool {\n    if edges.count == 0 {\n      return true\n    }\n\n    var arrivalTimes = Array(repeating: -1, count: edges.count)\n    let startVertex = 0\n\n    if getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, &arrivalTimes, &edges) == -1 {\n      return false\n    }\n\n    return areAllVerticesVisited(arrivalTimes)\n  }\n\n  func areAllVerticesVisited(_ arrivalTimes: [Int]) -> Bool {\n    for time in arrivalTimes {\n      if time == -1 {\n        return false\n      }\n    }\n    return true\n  }\n\n  func getMinimumArrivalTimeOfAncestors(_ currentVertex: Int, _ parent: Int, _ currentTime: Int,\n                                        _ arrivalTimes: inout [Int], _ edges: inout [[Int]]) -> Int\n  {\n    arrivalTimes[currentVertex] = currentTime\n\n    var minimumArrivalTime = currentTime\n\n    for destination in edges[currentVertex] {\n      if arrivalTimes[destination] == -1 {\n        minimumArrivalTime = min(\n          minimumArrivalTime,\n          getMinimumArrivalTimeOfAncestors(destination, currentVertex, currentTime + 1, &arrivalTimes, &edges)\n        )\n      } else if destination != parent {\n        minimumArrivalTime = min(\n          minimumArrivalTime,\n          arrivalTimes[destination]\n        )\n      }\n    }\n\n    // A bridge was detected, which means the graph isn't two-edge-connected.\n    if minimumArrivalTime == currentTime, parent != -1 {\n      return -1\n    }\n\n    return minimumArrivalTime\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var input = [\n        [1, 2, 5],\n        [0, 2],\n        [0, 1, 3],\n        [2, 4, 5],\n        [3, 5],\n        [0, 3, 4],\n      ]\n      var expected = true\n      var actual = Program().twoEdgeConnectedGraph(&input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var input = [\n        [1, 2, 5],\n        [0, 2],\n        [0, 1, 3],\n        [2, 4, 5],\n        [3, 5],\n        [0, 3, 4],\n      ]\n      var expected = true\n      var actual = Program().twoEdgeConnectedGraph(&input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function twoEdgeConnectedGraph(edges: number[][]) {\n  // Write your code here.\n  return false;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(v + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the graph\nexport function twoEdgeConnectedGraph(edges: number[][]) {\n  if (edges.length === 0) return true;\n\n  const arrivalTimes = new Array(edges.length).fill(-1);\n  const startVertex = 0;\n\n  if (getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, arrivalTimes, edges) === -1) {\n    return false;\n  }\n\n  return areAllVerticesVisited(arrivalTimes);\n}\n\nfunction areAllVerticesVisited(arrivalTimes: number[]) {\n  for (const time of arrivalTimes) {\n    if (time === -1) return false;\n  }\n\n  return true;\n}\n\nfunction getMinimumArrivalTimeOfAncestors(\n  currentVertex: number,\n  parent: number,\n  currentTime: number,\n  arrivalTimes: number[],\n  edges: number[][],\n) {\n  arrivalTimes[currentVertex] = currentTime;\n\n  let minimumArrivalTime = currentTime;\n\n  for (const destination of edges[currentVertex]) {\n    if (arrivalTimes[destination] === -1) {\n      minimumArrivalTime = Math.min(\n        minimumArrivalTime,\n        getMinimumArrivalTimeOfAncestors(\n          destination,\n          currentVertex,\n          currentTime + 1,\n          arrivalTimes,\n          edges,\n        ),\n      );\n    } else if (destination !== parent) {\n      minimumArrivalTime = Math.min(minimumArrivalTime, arrivalTimes[destination]);\n    }\n  }\n\n  // A bridge was detected, which means the graph isn't two-edge-connected.\n  if (minimumArrivalTime === currentTime && parent !== -1) return -1;\n\n  return minimumArrivalTime;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 2, 5],\n    [0, 2],\n    [0, 1, 3],\n    [2, 4, 5],\n    [3, 5],\n    [0, 3, 4],\n  ];\n  const expected = true;\n  const actual = program.twoEdgeConnectedGraph(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 2, 5],\n    [0, 2],\n    [0, 1, 3],\n    [2, 4, 5],\n    [3, 5],\n    [0, 3, 4],\n  ];\n  const expected = true;\n  const actual = program.twoEdgeConnectedGraph(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "edges",
      "example": [
        [
          1,
          2,
          5
        ],
        [
          0,
          2
        ],
        [
          0,
          1,
          3
        ],
        [
          2,
          4,
          5
        ],
        [
          3,
          5
        ],
        [
          0,
          3,
          4
        ]
      ],
      "schema": {
        "items": {
          "items": {
            "type": "integer"
          },
          "type": "array"
        },
        "type": "array"
      }
    }
  ],
  "tests": [
    {
      "edges": [
        [
          1,
          2,
          5
        ],
        [
          0,
          2
        ],
        [
          0,
          1,
          3
        ],
        [
          2,
          4,
          5
        ],
        [
          3,
          5
        ],
        [
          0,
          3,
          4
        ]
      ]
    },
    {
      "edges": [
        [
          1
        ],
        [
          0,
          2,
          3
        ],
        [
          1,
          3
        ],
        [
          1,
          2
        ]
      ]
    },
    {
      "edges": [
        [
          1,
          2
        ],
        [
          0,
          2,
          3
        ],
        [
          1,
          3,
          0
        ],
        [
          1,
          2
        ]
      ]
    },
    {
      "edges": [
        [
          1
        ],
        [
          0
        ]
      ]
    },
    {
      "edges": [
        [],
        []
      ]
    },
    {
      "edges": [
        [
          1,
          2,
          3
        ],
        [
          0,
          2
        ],
        [
          0,
          1
        ],
        [
          0,
          4,
          5
        ],
        [
          3,
          5
        ],
        [
          3,
          4
        ]
      ]
    },
    {
      "edges": [
        [
          1,
          2,
          3,
          5
        ],
        [
          0,
          2
        ],
        [
          0,
          1
        ],
        [
          0,
          4,
          5
        ],
        [
          3,
          5
        ],
        [
          3,
          4,
          0
        ]
      ]
    },
    {
      "edges": [
        []
      ]
    },
    {
      "edges": [
        [
          1,
          5,
          6
        ],
        [
          0,
          2,
          6
        ],
        [
          1,
          6,
          3
        ],
        [
          6,
          2,
          4
        ],
        [
          5,
          6,
          3
        ],
        [
          4,
          6,
          0
        ],
        [
          0,
          1,
          2,
          3,
          4,
          5
        ]
      ]
    },
    {
      "edges": [
        [
          1,
          5,
          6
        ],
        [
          0,
          2,
          6
        ],
        [
          1,
          6,
          3
        ],
        [
          6,
          2,
          4
        ],
        [
          6,
          3
        ],
        [
          0
        ],
        [
          0,
          1,
          2,
          3,
          4
        ]
      ]
    },
    {
      "edges": [
        [
          1,
          2
        ],
        [
          0,
          2,
          3
        ],
        [
          1,
          0,
          4
        ],
        [
          1,
          4
        ],
        [
          3,
          2
        ]
      ]
    },
    {
      "edges": [
        [
          1,
          2
        ],
        [
          0,
          2,
          3
        ],
        [
          1,
          0,
          4
        ],
        [
          1,
          4
        ],
        [
          3,
          2
        ],
        []
      ]
    },
    {
      "edges": [
        [
          1,
          7,
          4
        ],
        [
          0,
          2,
          7
        ],
        [
          1,
          6
        ],
        [
          7,
          5
        ],
        [
          0,
          7,
          5
        ],
        [
          4,
          7,
          6,
          3
        ],
        [
          5,
          2,
          7
        ],
        [
          6,
          0,
          1,
          3,
          4,
          5
        ]
      ]
    },
    {
      "edges": []
    }
  ],
  "jsonTests": [
    {
      "edges": [
        [
          1,
          2,
          5
        ],
        [
          0,
          2
        ],
        [
          0,
          1,
          3
        ],
        [
          2,
          4,
          5
        ],
        [
          3,
          5
        ],
        [
          0,
          3,
          4
        ]
      ]
    },
    {
      "edges": [
        [
          1
        ],
        [
          0,
          2,
          3
        ],
        [
          1,
          3
        ],
        [
          1,
          2
        ]
      ]
    },
    {
      "edges": [
        [
          1,
          2
        ],
        [
          0,
          2,
          3
        ],
        [
          1,
          3,
          0
        ],
        [
          1,
          2
        ]
      ]
    },
    {
      "edges": [
        [
          1
        ],
        [
          0
        ]
      ]
    },
    {
      "edges": [
        [],
        []
      ]
    },
    {
      "edges": [
        [
          1,
          2,
          3
        ],
        [
          0,
          2
        ],
        [
          0,
          1
        ],
        [
          0,
          4,
          5
        ],
        [
          3,
          5
        ],
        [
          3,
          4
        ]
      ]
    },
    {
      "edges": [
        [
          1,
          2,
          3,
          5
        ],
        [
          0,
          2
        ],
        [
          0,
          1
        ],
        [
          0,
          4,
          5
        ],
        [
          3,
          5
        ],
        [
          3,
          4,
          0
        ]
      ]
    },
    {
      "edges": [
        []
      ]
    },
    {
      "edges": [
        [
          1,
          5,
          6
        ],
        [
          0,
          2,
          6
        ],
        [
          1,
          6,
          3
        ],
        [
          6,
          2,
          4
        ],
        [
          5,
          6,
          3
        ],
        [
          4,
          6,
          0
        ],
        [
          0,
          1,
          2,
          3,
          4,
          5
        ]
      ]
    },
    {
      "edges": [
        [
          1,
          5,
          6
        ],
        [
          0,
          2,
          6
        ],
        [
          1,
          6,
          3
        ],
        [
          6,
          2,
          4
        ],
        [
          6,
          3
        ],
        [
          0
        ],
        [
          0,
          1,
          2,
          3,
          4
        ]
      ]
    },
    {
      "edges": [
        [
          1,
          2
        ],
        [
          0,
          2,
          3
        ],
        [
          1,
          0,
          4
        ],
        [
          1,
          4
        ],
        [
          3,
          2
        ]
      ]
    },
    {
      "edges": [
        [
          1,
          2
        ],
        [
          0,
          2,
          3
        ],
        [
          1,
          0,
          4
        ],
        [
          1,
          4
        ],
        [
          3,
          2
        ],
        []
      ]
    },
    {
      "edges": [
        [
          1,
          7,
          4
        ],
        [
          0,
          2,
          7
        ],
        [
          1,
          6
        ],
        [
          7,
          5
        ],
        [
          0,
          7,
          5
        ],
        [
          4,
          7,
          6,
          3
        ],
        [
          5,
          2,
          7
        ],
        [
          6,
          0,
          1,
          3,
          4,
          5
        ]
      ]
    },
    {
      "edges": []
    }
  ],
  "changelog": []
}