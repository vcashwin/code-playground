{
  "uid": "validate-three-nodes",
  "testStrategy": "JSON",
  "name": "Validate Three Nodes",
  "version": 0,
  "releaseDate": "2021-04-01T00:00:00Z",
  "category": "Binary Search Trees",
  "difficulty": 3,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 9622,
    "failureCount": 1904
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "524503257",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 1873
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given three nodes that are contained in the same Binary Search Tree:\n  <span>nodeOne</span>, <span>nodeTwo</span>, and <span>nodeThree</span>. Write\n  a function that returns a boolean representing whether one of\n  <span>nodeOne</span> or <span>nodeThree</span> is an ancestor of\n  <span>nodeTwo</span> and the other node is a descendant of\n  <span>nodeTwo</span>. For example, if your function determines that\n  <span>nodeOne</span> is an ancestor of <span>nodeTwo</span>, then it needs to\n  see if <span>nodeThree</span> is a descendant of <span>nodeTwo</span>. If your\n  function determines that <span>nodeThree</span> is an ancestor, then it needs\n  to see if <span>nodeOne</span> is a descendant.\n</p>\n<p>\n  A <b>descendant</b> of a node <span>N</span> is defined as a node contained in\n  the tree rooted at <span>N</span>. A node <span>N</span> is an ancestor of\n  another node <span>M</span> if <span>M</span> is a descendant of\n  <span>N</span>.\n</p>\n<p>\n  It isn't guaranteed that <span>nodeOne</span> or <span>nodeThree</span> will\n  be ancestors or descendants of <span>nodeTwo</span>, but it is guaranteed that\n  all three nodes will be unique and will never be <span>None</span> /\n  <span>null</span>. In other words, you'll be given valid input nodes.\n</p>\n<p>\n  Each <span>BST</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. A node is\n  said to be a valid <span>BST</span> node if and only if it satisfies the BST\n  property: its <span>value</span> is strictly greater than the values of every\n  node to its left; its <span>value</span> is less than or equal to the values\n  of every node to its right; and its children nodes are either valid\n  <span>BST</span> nodes themselves or <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">tree</span> =    5\n       /     \\\n      2       7\n    /   \\   /   \\\n   1     4 6     8\n  /     /\n 0     3  \n<span class=\"CodeEditor-promptComment\">// This tree won't actually be passed as an input; it's here to help you visualize the problem.</span>\n<span class=\"CodeEditor-promptParameter\">nodeOne</span> = 5 <span class=\"CodeEditor-promptComment\">// The actual node with value 5.</span>\n<span class=\"CodeEditor-promptParameter\">nodeTwo</span> = 2 <span class=\"CodeEditor-promptComment\">// The actual node with value 2.</span>\n<span class=\"CodeEditor-promptParameter\">nodeThree</span> = 3 <span class=\"CodeEditor-promptComment\">// The actual node with value 3.</span>\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue <span class=\"CodeEditor-promptComment\">// nodeOne is an ancestor of nodeTwo, and nodeThree is a descendant of nodeTwo.</span>\n</pre>\n</div>",
  "hints": [
    "<p>\n  Keep in mind that the nodes passed to you are contained in a Binary\n  <b><i>Search</i></b>\n  Tree—not just a normal Binary Tree. How might this help you traverse the tree\n  faster?\n</p>\n",
    "\n<p>\n  There are multiple ways to solve this problem, but the simplest is to just\n  check the possible relationships between the nodes. Since you're looking for a\n  descendant and an ancestor, simply check if <span>nodeOne</span> is a\n  descendant of <span>nodeTwo</span>, and if it is, then check if\n  <span>nodeThree</span> is an ancestor of <span>nodeTwo</span>. If the previous\n  checks come out negative, check if <span>nodeThree</span> is a descendant of\n  <span>nodeTwo</span>, and if it is, then check if <span>nodeOne</span> is an\n  ancestor of <span>nodeTwo</span>.\n</p>\n",
    "\n<p>\n  Although the approach mentioned in Hint #2 is fairly efficient (it runs in\n  <span>O(h)</span> time, where h is the height of the tree), there's a way to\n  solve this problem faster. It involves realizing that, when searching for\n  <span>nodeTwo</span> from either <span>nodeOne</span> or\n  <span>nodeThree</span>, if you ever reach <span>nodeThree</span> from\n  <span>nodeOne</span> or <span>nodeOne</span> from\n  <span>nodeThree</span> before reaching <span>nodeTwo</span>, then you can\n  immediately stop the algorithm, because <span>nodeTwo</span> cannot be between\n  these nodes. See the Conceptual Overview section of this question's video\n  explanation for a more in-depth explanation.\n</p>"
  ],
  "spaceTime": "O(d) time | O(1) space - where d is the distance between nodeOne and nodeThree",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "using namespace std;\n\n// This is an input class. Do not edit.\nclass BST {\n public:\n  int value;\n  BST* left = nullptr;\n  BST* right = nullptr;\n\n  BST(int value) { this->value = value; }\n};\n\nbool validateThreeNodes(BST* nodeOne, BST* nodeTwo, BST* nodeThree) {\n  // Write your code here.\n  return false;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BST {\n public:\n  int value;\n  BST* left = nullptr;\n  BST* right = nullptr;\n\n  BST(int value) { this->value = value; }\n};\n\nbool isDescendant(BST* node, BST* target);\n\n// O(h) time | O(h) space - where h is the height of the tree\nbool validateThreeNodes(BST* nodeOne, BST* nodeTwo, BST* nodeThree) {\n  if (isDescendant(nodeTwo, nodeOne)) return isDescendant(nodeThree, nodeTwo);\n\n  if (isDescendant(nodeTwo, nodeThree)) return isDescendant(nodeOne, nodeTwo);\n\n  return false;\n}\n\n// Whether the `target` is a descendant of the `node`.\nbool isDescendant(BST* node, BST* target) {\n  if (node == nullptr) return false;\n\n  if (node == target) return true;\n\n  return target->value < node->value ? isDescendant(node->left, target)\n                                     : isDescendant(node->right, target);\n}",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BST {\n public:\n  int value;\n  BST* left = nullptr;\n  BST* right = nullptr;\n\n  BST(int value) { this->value = value; }\n};\n\nbool isDescendant(BST* node, BST* target);\n\n// O(h) time | O(1) space - where h is the height of the tree\nbool validateThreeNodes(BST* nodeOne, BST* nodeTwo, BST* nodeThree) {\n  if (isDescendant(nodeTwo, nodeOne)) return isDescendant(nodeThree, nodeTwo);\n\n  if (isDescendant(nodeTwo, nodeThree)) return isDescendant(nodeOne, nodeTwo);\n\n  return false;\n}\n\n// Whether the `target` is a descendant of the `node`.\nbool isDescendant(BST* node, BST* target) {\n  BST* currentNode = node;\n  while (currentNode != nullptr && currentNode != target) {\n    currentNode = target->value < currentNode->value ? currentNode->left\n                                                     : currentNode->right;\n  }\n\n  return currentNode == target;\n}",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// This is an input class. Do not edit.\nclass BST {\n public:\n  int value;\n  BST* left = nullptr;\n  BST* right = nullptr;\n\n  BST(int value) { this->value = value; }\n};\n\nbool searchForTarget(BST* node, BST* target);\n\n// O(d) time | O(1) space - where d is the distance between nodeOne and\n// nodeThree\nbool validateThreeNodes(BST* nodeOne, BST* nodeTwo, BST* nodeThree) {\n  BST* searchOne = nodeOne;\n  BST* searchTwo = nodeThree;\n\n  while (true) {\n    bool foundThreeFromOne = searchOne == nodeThree;\n    bool foundOneFromThree = searchTwo == nodeOne;\n    bool foundNodeTwo = searchOne == nodeTwo || searchTwo == nodeTwo;\n    bool finishedSearching = searchOne == nullptr && searchTwo == nullptr;\n    if (foundThreeFromOne || foundOneFromThree || foundNodeTwo || finishedSearching) {\n      break;\n    }\n\n    if (searchOne != nullptr) {\n      searchOne =\n        searchOne->value > nodeTwo->value ? searchOne->left : searchOne->right;\n    }\n\n    if (searchTwo != nullptr) {\n      searchTwo =\n        searchTwo->value > nodeTwo->value ? searchTwo->left : searchTwo->right;\n    }\n  }\n\n  bool foundNodeFromOther = searchOne == nodeThree || searchTwo == nodeOne;\n  bool foundNodeTwo = searchOne == nodeTwo || searchTwo == nodeTwo;\n  if (!foundNodeTwo || foundNodeFromOther) return false;\n\n  return searchForTarget(nodeTwo, searchOne == nodeTwo ? nodeThree : nodeOne);\n}\n\nbool searchForTarget(BST* node, BST* target) {\n  BST* currentNode = node;\n  while (currentNode != nullptr && currentNode != target) {\n    currentNode = target->value < currentNode->value ? currentNode->left\n                                                     : currentNode->right;\n  }\n\n  return currentNode == target;\n}"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BST* root = new BST(5);\n      root->left = new BST(2);\n      root->right = new BST(7);\n      root->left->left = new BST(1);\n      root->left->right = new BST(4);\n      root->right->left = new BST(6);\n      root->right->right = new BST(8);\n      root->left->left->left = new BST(0);\n      root->left->right->left = new BST(3);\n      BST* nodeOne = root;\n      BST* nodeTwo = root->left;\n      BST* nodeThree = root->left->right->left;\n      bool expected = true;\n      auto actual = validateThreeNodes(nodeOne, nodeTwo, nodeThree);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      BST* root = new BST(5);\n      root->left = new BST(2);\n      root->right = new BST(7);\n      root->left->left = new BST(1);\n      root->left->right = new BST(4);\n      root->right->left = new BST(6);\n      root->right->right = new BST(8);\n      root->left->left->left = new BST(0);\n      root->left->right->left = new BST(3);\n      BST* nodeOne = root;\n      BST* nodeTwo = root->left;\n      BST* nodeThree = root->left->right->left;\n      bool expected = true;\n      auto actual = validateThreeNodes(nodeOne, nodeTwo, nodeThree);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  public bool ValidateThreeNodes(BST nodeOne, BST nodeTwo, BST nodeThree) {\n    // Write your code here.\n    return false;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(h) time | O(h) space - where h is the height of the tree\n  public bool ValidateThreeNodes(BST nodeOne, BST nodeTwo, BST nodeThree) {\n    if (isDescendant(nodeTwo, nodeOne)) {\n      return isDescendant(nodeThree, nodeTwo);\n    }\n\n    if (isDescendant(nodeTwo, nodeThree)) {\n      return isDescendant(nodeOne, nodeTwo);\n    }\n\n    return false;\n  }\n\n  // Whether the `target` is a descendant of the `node`.\n  public bool isDescendant(BST node, BST target) {\n    if (node == null) {\n      return false;\n    }\n\n    if (node == target) {\n      return true;\n    }\n\n    return (target.value < node.value) ? isDescendant(node.left, target)\n                                       : isDescendant(node.right, target);\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(h) time | O(1) space - where h is the height of the tree\n  public bool ValidateThreeNodes(BST nodeOne, BST nodeTwo, BST nodeThree) {\n    if (isDescendant(nodeTwo, nodeOne)) {\n      return isDescendant(nodeThree, nodeTwo);\n    }\n\n    if (isDescendant(nodeTwo, nodeThree)) {\n      return isDescendant(nodeOne, nodeTwo);\n    }\n\n    return false;\n  }\n\n  // Whether the `target` is a descendant of the `node`.\n  public bool isDescendant(BST node, BST target) {\n    while (node != null && node != target) {\n      node = (target.value < node.value) ? node.left : node.right;\n    }\n\n    return node == target;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // This is an input class. Do not edit.\n  public class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(d) time | O(1) space - where d is the distance between nodeOne and\n  // nodeThree\n  public bool ValidateThreeNodes(BST nodeOne, BST nodeTwo, BST nodeThree) {\n    BST searchOne = nodeOne;\n    BST searchTwo = nodeThree;\n\n    while (true) {\n      bool foundThreeFromOne = searchOne == nodeThree;\n      bool foundOneFromThree = searchTwo == nodeOne;\n      bool foundNodeTwo = (searchOne == nodeTwo) || (searchTwo == nodeTwo);\n      bool finishedSearching = (searchOne == null) && (searchTwo == null);\n      if (foundThreeFromOne || foundOneFromThree || foundNodeTwo || finishedSearching) {\n        break;\n      }\n\n      if (searchOne != null) {\n        searchOne =\n          (searchOne.value > nodeTwo.value) ? searchOne.left : searchOne.right;\n      }\n\n      if (searchTwo != null) {\n        searchTwo =\n          (searchTwo.value > nodeTwo.value) ? searchTwo.left : searchTwo.right;\n      }\n    }\n\n    bool foundNodeFromOther =\n      (searchOne == nodeThree) || (searchTwo == nodeOne);\n    bool foundNodeTwoFinal = (searchOne == nodeTwo) || (searchTwo == nodeTwo);\n    if (!foundNodeTwoFinal || foundNodeFromOther) {\n      return false;\n    }\n\n    return searchForTarget(\n      nodeTwo, (searchOne == nodeTwo) ? nodeThree : nodeOne\n    );\n  }\n\n  public bool searchForTarget(BST node, BST target) {\n    while (node != null && node != target) {\n      node = (target.value < node.value) ? node.left : node.right;\n    }\n\n    return node == target;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var root = new Program.BST(5);\n    root.left = new Program.BST(2);\n    root.right = new Program.BST(7);\n    root.left.left = new Program.BST(1);\n    root.left.right = new Program.BST(4);\n    root.right.left = new Program.BST(6);\n    root.right.right = new Program.BST(8);\n    root.left.left.left = new Program.BST(0);\n    root.left.right.left = new Program.BST(3);\n\n    var nodeOne = root;\n    var nodeTwo = root.left;\n    var nodeThree = root.left.right.left;\n    bool expected = true;\n    bool actual = new Program().ValidateThreeNodes(nodeOne, nodeTwo, nodeThree);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    var root = new Program.BST(5);\n    root.left = new Program.BST(2);\n    root.right = new Program.BST(7);\n    root.left.left = new Program.BST(1);\n    root.left.right = new Program.BST(4);\n    root.right.left = new Program.BST(6);\n    root.right.right = new Program.BST(8);\n    root.left.left.left = new Program.BST(0);\n    root.left.right.left = new Program.BST(3);\n\n    var nodeOne = root;\n    var nodeTwo = root.left;\n    var nodeThree = root.left.right.left;\n    bool expected = true;\n    bool actual = new Program().ValidateThreeNodes(nodeOne, nodeTwo, nodeThree);\n    Utils.AssertTrue(expected == actual);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\n// This is an input class. Do not edit.\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\nfunc ValidateThreeNodes(nodeOne *BST, nodeTwo *BST, nodeThree *BST) bool {\n\t// Write your code here.\n\treturn false\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\n// O(h) time | O(h) space - where h is the height of the tree\nfunc ValidateThreeNodes(nodeOne *BST, nodeTwo *BST, nodeThree *BST) bool {\n\tif isDescendant(nodeTwo, nodeOne) {\n\t\treturn isDescendant(nodeThree, nodeTwo)\n\t}\n\n\tif isDescendant(nodeTwo, nodeThree) {\n\t\treturn isDescendant(nodeOne, nodeTwo)\n\t}\n\n\treturn false\n}\n\nfunc isDescendant(node *BST, target *BST) bool {\n\tif node == nil {\n\t\treturn false\n\t}\n\n\tif node == target {\n\t\treturn true\n\t}\n\n\tif target.Value < node.Value {\n\t\treturn isDescendant(node.Left, target)\n\t}\n\treturn isDescendant(node.Right, target)\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n}\n\n// O(h) time | O(1) space - where h is the height of the tree\nfunc ValidateThreeNodes(nodeOne *BST, nodeTwo *BST, nodeThree *BST) bool {\n\tif isDescendant(nodeTwo, nodeOne) {\n\t\treturn isDescendant(nodeThree, nodeTwo)\n\t}\n\n\tif isDescendant(nodeTwo, nodeThree) {\n\t\treturn isDescendant(nodeOne, nodeTwo)\n\t}\n\n\treturn false\n}\n\n// Whether the `target` is a descendant of the `node`.\nfunc isDescendant(node *BST, target *BST) bool {\n\tcurrentNode := node\n\tfor currentNode != nil && currentNode != target {\n\t\tif target.Value < currentNode.Value {\n\t\t\tcurrentNode = currentNode.Left\n\t\t} else {\n\t\t\tcurrentNode = currentNode.Right\n\t\t}\n\t}\n\n\treturn currentNode == target\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BST struct {\n\tValue int\n\n\tLeft  *BST\n\tRight *BST\n\tvalue bool\n}\n\n// O(d) time | O(1) space - where d is the distance between nodeOne and nodeThree\nfunc ValidateThreeNodes(nodeOne *BST, nodeTwo *BST, nodeThree *BST) bool {\n\tsearchOne := nodeOne\n\tsearchTwo := nodeThree\n\n\tfor {\n\t\tfoundThreeFromOne := searchOne == nodeThree\n\t\tfoundOneFromThree := searchTwo == nodeOne\n\t\tfoundNodeTwo := searchOne == nodeTwo || searchTwo == nodeTwo\n\t\tfinishedSearching := searchOne == nil && searchTwo == nil\n\t\tif foundThreeFromOne || foundOneFromThree || foundNodeTwo || finishedSearching {\n\t\t\tbreak\n\t\t}\n\n\t\tif searchOne != nil {\n\t\t\tif searchOne.Value > nodeTwo.Value {\n\t\t\t\tsearchOne = searchOne.Left\n\t\t\t} else {\n\t\t\t\tsearchOne = searchOne.Right\n\t\t\t}\n\t\t}\n\n\t\tif searchTwo != nil {\n\t\t\tif searchTwo.Value > nodeTwo.Value {\n\t\t\t\tsearchTwo = searchTwo.Left\n\t\t\t} else {\n\t\t\t\tsearchTwo = searchTwo.Right\n\t\t\t}\n\t\t}\n\t}\n\n\tfoundNodeFromOther := searchOne == nodeThree || searchTwo == nodeOne\n\tfoundNodeTwo := searchOne == nodeTwo || searchTwo == nodeTwo\n\tif !foundNodeTwo || foundNodeFromOther {\n\t\treturn false\n\t}\n\n\tif searchOne == nodeTwo {\n\t\treturn searchForTarget(nodeTwo, nodeThree)\n\t}\n\treturn searchForTarget(nodeTwo, nodeOne)\n}\n\nfunc searchForTarget(node *BST, target *BST) bool {\n\tcurrentNode := node\n\tfor currentNode != nil && currentNode != target {\n\t\tif target.Value < currentNode.Value {\n\t\t\tcurrentNode = currentNode.Left\n\t\t} else {\n\t\t\tcurrentNode = currentNode.Right\n\t\t}\n\t}\n\n\treturn currentNode == target\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\troot := &BST{Value: 5}\n\troot.Left = &BST{Value: 2}\n\troot.Right = &BST{Value: 7}\n\troot.Left.Left = &BST{Value: 1}\n\troot.Left.Right = &BST{Value: 4}\n\troot.Right.Left = &BST{Value: 6}\n\troot.Right.Right = &BST{Value: 8}\n\troot.Left.Left.Left = &BST{Value: 0}\n\troot.Left.Right.Left = &BST{Value: 3}\n\n\tnodeOne := root\n\tnodeTwo := root.Left\n\tnodeThree := root.Left.Right.Left\n\texpected := true\n\tactual := ValidateThreeNodes(nodeOne, nodeTwo, nodeThree)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\troot := &BST{Value: 5}\n\troot.Left = &BST{Value: 2}\n\troot.Right = &BST{Value: 7}\n\troot.Left.Left = &BST{Value: 1}\n\troot.Left.Right = &BST{Value: 4}\n\troot.Right.Left = &BST{Value: 6}\n\troot.Right.Right = &BST{Value: 8}\n\troot.Left.Left.Left = &BST{Value: 0}\n\troot.Left.Right.Left = &BST{Value: 3}\n\n\tnodeOne := root\n\tnodeTwo := root.Left\n\tnodeThree := root.Left.Right.Left\n\texpected := true\n\tactual := ValidateThreeNodes(nodeOne, nodeTwo, nodeThree)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  public boolean validateThreeNodes(BST nodeOne, BST nodeTwo, BST nodeThree) {\n    // Write your code here.\n    return false;\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(h) time | O(h) space - where h is the height of the tree\n  public boolean validateThreeNodes(BST nodeOne, BST nodeTwo, BST nodeThree) {\n    if (isDescendant(nodeTwo, nodeOne)) {\n      return isDescendant(nodeThree, nodeTwo);\n    }\n\n    if (isDescendant(nodeTwo, nodeThree)) {\n      return isDescendant(nodeOne, nodeTwo);\n    }\n\n    return false;\n  }\n\n  // Whether the `target` is a descendant of the `node`.\n  public boolean isDescendant(BST node, BST target) {\n    if (node == null) {\n      return false;\n    }\n\n    if (node == target) {\n      return true;\n    }\n\n    return (target.value < node.value) ? isDescendant(node.left, target)\n                                       : isDescendant(node.right, target);\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(h) time | O(1) space - where h is the height of the tree\n  public boolean validateThreeNodes(BST nodeOne, BST nodeTwo, BST nodeThree) {\n    if (isDescendant(nodeTwo, nodeOne)) {\n      return isDescendant(nodeThree, nodeTwo);\n    }\n\n    if (isDescendant(nodeTwo, nodeThree)) {\n      return isDescendant(nodeOne, nodeTwo);\n    }\n\n    return false;\n  }\n\n  // Whether the `target` is a descendant of the `node`.\n  public boolean isDescendant(BST node, BST target) {\n    while (node != null && node != target) {\n      node = (target.value < node.value) ? node.left : node.right;\n    }\n\n    return node == target;\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BST {\n    public int value;\n    public BST left = null;\n    public BST right = null;\n\n    public BST(int value) {\n      this.value = value;\n    }\n  }\n\n  // O(d) time | O(1) space - where d is the distance between nodeOne and\n  // nodeThree\n  public boolean validateThreeNodes(BST nodeOne, BST nodeTwo, BST nodeThree) {\n    BST searchOne = nodeOne;\n    BST searchTwo = nodeThree;\n\n    while (true) {\n      boolean foundThreeFromOne = searchOne == nodeThree;\n      boolean foundOneFromThree = searchTwo == nodeOne;\n      boolean foundNodeTwo = (searchOne == nodeTwo) || (searchTwo == nodeTwo);\n      boolean finishedSearching = (searchOne == null) && (searchTwo == null);\n      if (foundThreeFromOne || foundOneFromThree || foundNodeTwo || finishedSearching) {\n        break;\n      }\n\n      if (searchOne != null) {\n        searchOne =\n          (searchOne.value > nodeTwo.value) ? searchOne.left : searchOne.right;\n      }\n\n      if (searchTwo != null) {\n        searchTwo =\n          (searchTwo.value > nodeTwo.value) ? searchTwo.left : searchTwo.right;\n      }\n    }\n\n    boolean foundNodeFromOther =\n      (searchOne == nodeThree) || (searchTwo == nodeOne);\n    boolean foundNodeTwo = (searchOne == nodeTwo) || (searchTwo == nodeTwo);\n    if (!foundNodeTwo || foundNodeFromOther) {\n      return false;\n    }\n\n    return searchForTarget(\n      nodeTwo, (searchOne == nodeTwo) ? nodeThree : nodeOne\n    );\n  }\n\n  public boolean searchForTarget(BST node, BST target) {\n    while (node != null && node != target) {\n      node = (target.value < node.value) ? node.left : node.right;\n    }\n\n    return node == target;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var root = new Program.BST(5);\n    root.left = new Program.BST(2);\n    root.right = new Program.BST(7);\n    root.left.left = new Program.BST(1);\n    root.left.right = new Program.BST(4);\n    root.right.left = new Program.BST(6);\n    root.right.right = new Program.BST(8);\n    root.left.left.left = new Program.BST(0);\n    root.left.right.left = new Program.BST(3);\n\n    var nodeOne = root;\n    var nodeTwo = root.left;\n    var nodeThree = root.left.right.left;\n    boolean expected = true;\n    boolean actual =\n      new Program().validateThreeNodes(nodeOne, nodeTwo, nodeThree);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var root = new Program.BST(5);\n    root.left = new Program.BST(2);\n    root.right = new Program.BST(7);\n    root.left.left = new Program.BST(1);\n    root.left.right = new Program.BST(4);\n    root.right.left = new Program.BST(6);\n    root.right.right = new Program.BST(8);\n    root.left.left.left = new Program.BST(0);\n    root.left.right.left = new Program.BST(3);\n\n    var nodeOne = root;\n    var nodeTwo = root.left;\n    var nodeThree = root.left.right.left;\n    boolean expected = true;\n    boolean actual =\n      new Program().validateThreeNodes(nodeOne, nodeTwo, nodeThree);\n    Utils.assertTrue(expected == actual);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction validateThreeNodes(nodeOne, nodeTwo, nodeThree) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.validateThreeNodes = validateThreeNodes;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(h) time | O(h) space - where h is the height of the tree\nfunction validateThreeNodes(nodeOne, nodeTwo, nodeThree) {\n  if (isDescendant(nodeTwo, nodeOne)) return isDescendant(nodeThree, nodeTwo);\n\n  if (isDescendant(nodeTwo, nodeThree)) return isDescendant(nodeOne, nodeTwo);\n\n  return false;\n}\n\n// Whether the `target` is a descendant of the `node`.\nfunction isDescendant(node, target) {\n  if (node === null) return false;\n\n  if (node === target) return true;\n\n  return target.value < node.value\n    ? isDescendant(node.left, target)\n    : isDescendant(node.right, target);\n}\n\n// Do not edit the lines below.\nexports.validateThreeNodes = validateThreeNodes;\nexports.BST = BST;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(h) time | O(1) space - where h is the height of the tree\nfunction validateThreeNodes(nodeOne, nodeTwo, nodeThree) {\n  if (isDescendant(nodeTwo, nodeOne)) return isDescendant(nodeThree, nodeTwo);\n\n  if (isDescendant(nodeTwo, nodeThree)) return isDescendant(nodeOne, nodeTwo);\n\n  return false;\n}\n\n// Whether the `target` is a descendant of the `node`.\nfunction isDescendant(node, target) {\n  while (node !== null && node !== target) {\n    node = target.value < node.value ? node.left : node.right;\n  }\n\n  return node === target;\n}\n\n// Do not edit the lines below.\nexports.validateThreeNodes = validateThreeNodes;\nexports.BST = BST;\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(d) time | O(1) space - where d is the distance between nodeOne and nodeThree\nfunction validateThreeNodes(nodeOne, nodeTwo, nodeThree) {\n  let searchOne = nodeOne;\n  let searchTwo = nodeThree;\n\n  while (true) {\n    const foundThreeFromOne = searchOne === nodeThree;\n    const foundOneFromThree = searchTwo === nodeOne;\n    const foundNodeTwo = searchOne === nodeTwo || searchTwo === nodeTwo;\n    const finishedSearching = searchOne === null && searchTwo === null;\n    if (foundThreeFromOne || foundOneFromThree || foundNodeTwo || finishedSearching) {\n      break;\n    }\n\n    if (searchOne !== null) {\n      searchOne = searchOne.value > nodeTwo.value ? searchOne.left : searchOne.right;\n    }\n\n    if (searchTwo !== null) {\n      searchTwo = searchTwo.value > nodeTwo.value ? searchTwo.left : searchTwo.right;\n    }\n  }\n\n  const foundNodeFromOther = searchOne === nodeThree || searchTwo === nodeOne;\n  const foundNodeTwo = searchOne === nodeTwo || searchTwo === nodeTwo;\n  if (!foundNodeTwo || foundNodeFromOther) return false;\n\n  return searchForTarget(nodeTwo, searchOne === nodeTwo ? nodeThree : nodeOne);\n}\n\nfunction searchForTarget(node, target) {\n  while (node !== null && node !== target) {\n    node = target.value < node.value ? node.left : node.right;\n  }\n\n  return node === target;\n}\n\n// Do not edit the lines below.\nexports.validateThreeNodes = validateThreeNodes;\nexports.BST = BST;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BST(5);\n  root.left = new program.BST(2);\n  root.right = new program.BST(7);\n  root.left.left = new program.BST(1);\n  root.left.right = new program.BST(4);\n  root.right.left = new program.BST(6);\n  root.right.right = new program.BST(8);\n  root.left.left.left = new program.BST(0);\n  root.left.right.left = new program.BST(3);\n\n  const nodeOne = root;\n  const nodeTwo = root.left;\n  const nodeThree = root.left.right.left;\n  const expected = true;\n  const actual = program.validateThreeNodes(nodeOne, nodeTwo, nodeThree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BST(5);\n  root.left = new program.BST(2);\n  root.right = new program.BST(7);\n  root.left.left = new program.BST(1);\n  root.left.right = new program.BST(4);\n  root.right.left = new program.BST(6);\n  root.right.right = new program.BST(8);\n  root.left.left.left = new program.BST(0);\n  root.left.right.left = new program.BST(3);\n\n  const nodeOne = root;\n  const nodeTwo = root.left;\n  const nodeThree = root.left.right.left;\n  const expected = true;\n  const actual = program.validateThreeNodes(nodeOne, nodeTwo, nodeThree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BST(value: Int) {\n    var value = value\n    var left: BST? = null\n    var right: BST? = null\n}\n\nfun validateThreeNodes(nodeOne: BST, nodeTwo: BST, nodeThree: BST): Boolean {\n    // Write your code here.\n    return false\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BST(value: Int) {\n    var value = value\n    var left: BST? = null\n    var right: BST? = null\n}\n\n// O(h) time | O(h) space - where h is the height of the tree\nfun validateThreeNodes(nodeOne: BST, nodeTwo: BST, nodeThree: BST): Boolean {\n    if (isDescendant(nodeTwo, nodeOne)) return isDescendant(nodeThree, nodeTwo)\n\n    if (isDescendant(nodeTwo, nodeThree)) return isDescendant(nodeOne, nodeTwo)\n\n    return false\n}\n\n// Whether the `target` is a descendant of the `node`.\nfun isDescendant(node: BST?, target: BST): Boolean {\n    if (node == null) return false\n\n    if (node == target) return true\n\n    return if (target.value < node.value) {\n        isDescendant(\n            node.left,\n            target,\n        )\n    } else {\n        isDescendant(node.right, target)\n    }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BST(value: Int) {\n    var value = value\n    var left: BST? = null\n    var right: BST? = null\n}\n\n// O(h) time | O(1) space - where h is the height of the tree\nfun validateThreeNodes(nodeOne: BST, nodeTwo: BST, nodeThree: BST): Boolean {\n    if (isDescendant(nodeTwo, nodeOne)) return isDescendant(nodeThree, nodeTwo)\n\n    if (isDescendant(nodeTwo, nodeThree)) return isDescendant(nodeOne, nodeTwo)\n\n    return false\n}\n\n// Whether the `target` is a descendant of the `node`.\nfun isDescendant(node: BST, target: BST): Boolean {\n    var currentNode: BST? = node\n    while (currentNode != null && currentNode != target) {\n        currentNode = if (target.value < currentNode.value) currentNode.left else currentNode.right\n    }\n\n    return currentNode == target\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BST(value: Int) {\n    var value = value\n    var left: BST? = null\n    var right: BST? = null\n}\n\n// O(d) time | O(1) space - where d is the distance between nodeOne and nodeThree\nfun validateThreeNodes(nodeOne: BST, nodeTwo: BST, nodeThree: BST): Boolean {\n    var searchOne: BST? = nodeOne\n    var searchTwo: BST? = nodeThree\n\n    while (true) {\n        val foundThreeFromOne = searchOne == nodeThree\n        val foundOneFromThree = searchTwo == nodeOne\n        val foundNodeTwo = searchOne == nodeTwo || searchTwo == nodeTwo\n        val finishedSearching = searchOne == null && searchTwo == null\n        if (foundThreeFromOne || foundOneFromThree || foundNodeTwo || finishedSearching) {\n            break\n        }\n\n        if (searchOne != null) {\n            searchOne = if (searchOne.value > nodeTwo.value) searchOne.left else searchOne.right\n        }\n\n        if (searchTwo != null) {\n            searchTwo = if (searchTwo.value > nodeTwo.value) searchTwo.left else searchTwo.right\n        }\n    }\n\n    val foundNodeFromOther = searchOne == nodeThree || searchTwo == nodeOne\n    val foundNodeTwo = searchOne == nodeTwo || searchTwo == nodeTwo\n    if (!foundNodeTwo || foundNodeFromOther) return false\n\n    return searchForTarget(nodeTwo, if (searchOne == nodeTwo) nodeThree else nodeOne)\n}\n\nfun searchForTarget(node: BST, target: BST): Boolean {\n    var currentNode: BST? = node\n    while (currentNode != null && currentNode != target) {\n        currentNode = if (target.value < currentNode.value) currentNode.left else currentNode.right\n    }\n\n    return currentNode == target\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.BST\nimport com.algoexpert.program.validateThreeNodes\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val root = BST(5)\n        root.left = BST(2)\n        root.right = BST(7)\n        root.left!!.left = BST(1)\n        root.left!!.right = BST(4)\n        root.right!!.left = BST(6)\n        root.right!!.right = BST(8)\n        root.left!!.left!!.left = BST(0)\n        root.left!!.right!!.left = BST(3)\n\n        val nodeOne = root\n        val nodeTwo = root.left!!\n        val nodeThree = root.left!!.right!!.left!!\n        val expected = true\n        val output = validateThreeNodes(nodeOne, nodeTwo, nodeThree)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.BST\nimport com.algoexpert.program.validateThreeNodes\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val root = BST(5)\n        root.left = BST(2)\n        root.right = BST(7)\n        root.left!!.left = BST(1)\n        root.left!!.right = BST(4)\n        root.right!!.left = BST(6)\n        root.right!!.right = BST(8)\n        root.left!!.left!!.left = BST(0)\n        root.left!!.right!!.left = BST(3)\n\n        val nodeOne = root\n        val nodeTwo = root.left!!\n        val nodeThree = root.left!!.right!!.left!!\n        val expected = true\n        val output = validateThreeNodes(nodeOne, nodeTwo, nodeThree)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "# This is an input class. Do not edit.\nclass BST:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef validateThreeNodes(nodeOne, nodeTwo, nodeThree):\n    # Write your code here.\n    return False\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BST:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# O(h) time | O(h) space - where h is the height of the tree\ndef validateThreeNodes(nodeOne, nodeTwo, nodeThree):\n    if isDescendant(nodeTwo, nodeOne):\n        return isDescendant(nodeThree, nodeTwo)\n\n    if isDescendant(nodeTwo, nodeThree):\n        return isDescendant(nodeOne, nodeTwo)\n\n    return False\n\n\n# Whether the `target` is a descendant of the `node`.\ndef isDescendant(node, target):\n    if node is None:\n        return False\n\n    if node is target:\n        return True\n\n    return (\n        isDescendant(node.left, target)\n        if target.value < node.value\n        else isDescendant(node.right, target)\n    )\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BST:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# O(h) time | O(1) space - where h is the height of the tree\ndef validateThreeNodes(nodeOne, nodeTwo, nodeThree):\n    if isDescendant(nodeTwo, nodeOne):\n        return isDescendant(nodeThree, nodeTwo)\n\n    if isDescendant(nodeTwo, nodeThree):\n        return isDescendant(nodeOne, nodeTwo)\n\n    return False\n\n\n# Whether the `target` is a descendant of the `node`.\ndef isDescendant(node, target):\n    while node is not None and node is not target:\n        node = node.left if target.value < node.value else node.right\n\n    return node is target\n",
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass BST:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# O(d) time | O(1) space - where d is the distance between nodeOne and nodeThree\ndef validateThreeNodes(nodeOne, nodeTwo, nodeThree):\n    searchOne = nodeOne\n    searchTwo = nodeThree\n\n    while True:\n        foundThreeFromOne = searchOne is nodeThree\n        foundOneFromThree = searchTwo is nodeOne\n        foundNodeTwo = searchOne is nodeTwo or searchTwo is nodeTwo\n        finishedSearching = searchOne is None and searchTwo is None\n        if foundThreeFromOne or foundOneFromThree or foundNodeTwo or finishedSearching:\n            break\n\n        if searchOne is not None:\n            searchOne = searchOne.left if searchOne.value > nodeTwo.value else searchOne.right\n\n        if searchTwo is not None:\n            searchTwo = searchTwo.left if searchTwo.value > nodeTwo.value else searchTwo.right\n\n    foundNodeFromOther = searchOne is nodeThree or searchTwo is nodeOne\n    foundNodeTwo = searchOne is nodeTwo or searchTwo is nodeTwo\n    if not foundNodeTwo or foundNodeFromOther:\n        return False\n\n    return searchForTarget(nodeTwo, nodeThree if searchOne is nodeTwo else nodeOne)\n\n\ndef searchForTarget(node, target):\n    while node is not None and node is not target:\n        node = node.left if target.value < node.value else node.right\n\n    return node is target\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = program.BST(5)\n        root.left = program.BST(2)\n        root.right = program.BST(7)\n        root.left.left = program.BST(1)\n        root.left.right = program.BST(4)\n        root.right.left = program.BST(6)\n        root.right.right = program.BST(8)\n        root.left.left.left = program.BST(0)\n        root.left.right.left = program.BST(3)\n\n        nodeOne = root\n        nodeTwo = root.left\n        nodeThree = root.left.right.left\n        expected = True\n        actual = program.validateThreeNodes(nodeOne, nodeTwo, nodeThree)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = program.BST(5)\n        root.left = program.BST(2)\n        root.right = program.BST(7)\n        root.left.left = program.BST(1)\n        root.left.right = program.BST(4)\n        root.right.left = program.BST(6)\n        root.right.right = program.BST(8)\n        root.left.left.left = program.BST(0)\n        root.left.right.left = program.BST(3)\n\n        nodeOne = root\n        nodeTwo = root.left\n        nodeThree = root.left.right.left\n        expected = True\n        actual = program.validateThreeNodes(nodeOne, nodeTwo, nodeThree)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": false,
      "startingCode": "# This is an input struct. Do not edit.\nclass BST\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def validateThreeNodes(nodeOne, nodeTwo, nodeThree)\n    # Write your code here.\n    return false\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BST\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def validateThreeNodes(nodeOne, nodeTwo, nodeThree)\n    # Write your code here.\n    return false\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.validateThreeNodes\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.validateThreeNodes\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  // This is an input class. Do not edit.\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  func validateThreeNodes(_ nodeOne: BST, _ nodeTwo: BST, _ nodeThree: BST) -> Bool {\n    // Write your code here.\n    return false\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(h) time | O(h) space - where h is the height of the tree\n  func validateThreeNodes(_ nodeOne: BST, _ nodeTwo: BST, _ nodeThree: BST) -> Bool {\n    if isDescendant(nodeTwo, nodeOne) {\n      return isDescendant(nodeThree, nodeTwo)\n    }\n\n    if isDescendant(nodeTwo, nodeThree) {\n      return isDescendant(nodeOne, nodeTwo)\n    }\n\n    return false\n  }\n\n  func isDescendant(_ node: BST?, _ target: BST) -> Bool {\n    if node == nil {\n      return false\n    }\n\n    if node === target {\n      return true\n    }\n\n    if target.value < node!.value {\n      return isDescendant(node!.left, target)\n    }\n    return isDescendant(node!.right, target)\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(h) time | O(1) space - where h is the height of the tree\n  func validateThreeNodes(_ nodeOne: BST, _ nodeTwo: BST, _ nodeThree: BST) -> Bool {\n    if isDescendant(nodeTwo, nodeOne) {\n      return isDescendant(nodeThree, nodeTwo)\n    }\n\n    if isDescendant(nodeTwo, nodeThree) {\n      return isDescendant(nodeOne, nodeTwo)\n    }\n\n    return false\n  }\n\n  func isDescendant(_ node: BST?, _ target: BST) -> Bool {\n    var currentNode = node\n    while currentNode != nil, currentNode !== target {\n      if target.value < currentNode!.value {\n        currentNode = currentNode!.left\n      } else {\n        currentNode = currentNode!.right\n      }\n    }\n\n    return currentNode === target\n  }\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // This is an input class. Do not edit.\n  class BST {\n    var value: Int\n    var left: BST?\n    var right: BST?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  // O(d) time | O(1) space - where d is the distance between nodeOne and nodeThree\n  func validateThreeNodes(_ nodeOne: BST, _ nodeTwo: BST, _ nodeThree: BST) -> Bool {\n    var searchOne: BST? = nodeOne\n    var searchTwo: BST? = nodeThree\n\n    while true {\n      var foundThreeFromOne = searchOne === nodeThree\n      var foundOneFromThree = searchTwo === nodeOne\n      var foundNodeTwo = searchOne === nodeTwo || searchTwo === nodeTwo\n      var finishedSearching = searchOne === nil && searchTwo === nil\n      if foundThreeFromOne || foundOneFromThree || foundNodeTwo || finishedSearching {\n        break\n      }\n\n      if searchOne != nil {\n        if searchOne!.value > nodeTwo.value {\n          searchOne = searchOne!.left\n        } else {\n          searchOne = searchOne!.right\n        }\n      }\n\n      if searchTwo != nil {\n        if searchTwo!.value > nodeTwo.value {\n          searchTwo = searchTwo!.left\n        } else {\n          searchTwo = searchTwo!.right\n        }\n      }\n    }\n\n    var foundNodeFromOther = searchOne === nodeThree || searchTwo === nodeOne\n    var foundNodeTwo = searchOne === nodeTwo || searchTwo === nodeTwo\n    if !foundNodeTwo || foundNodeFromOther {\n      return false\n    }\n\n    if searchOne === nodeTwo {\n      return searchForTarget(nodeTwo, nodeThree)\n    }\n    return searchForTarget(nodeTwo, nodeOne)\n  }\n\n  func searchForTarget(_ node: BST?, _ target: BST) -> Bool {\n    var currentNode = node\n    while currentNode != nil, currentNode !== target {\n      if target.value < currentNode!.value {\n        currentNode = currentNode!.left\n      } else {\n        currentNode = currentNode!.right\n      }\n    }\n\n    return currentNode === target\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var root = Program.BST(value: 5)\n      root.left = Program.BST(value: 2)\n      root.right = Program.BST(value: 7)\n      root.left!.left = Program.BST(value: 1)\n      root.left!.right = Program.BST(value: 4)\n      root.right!.left = Program.BST(value: 6)\n      root.right!.right = Program.BST(value: 8)\n      root.left!.left!.left = Program.BST(value: 0)\n      root.left!.right!.left = Program.BST(value: 3)\n\n      var nodeOne = root\n      var nodeTwo = root.left!\n      var nodeThree = root.left!.right!.left!\n      var expected = true\n      var actual = Program().validateThreeNodes(nodeOne, nodeTwo, nodeThree)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var root = Program.BST(value: 5)\n      root.left = Program.BST(value: 2)\n      root.right = Program.BST(value: 7)\n      root.left!.left = Program.BST(value: 1)\n      root.left!.right = Program.BST(value: 4)\n      root.right!.left = Program.BST(value: 6)\n      root.right!.right = Program.BST(value: 8)\n      root.left!.left!.left = Program.BST(value: 0)\n      root.left!.right!.left = Program.BST(value: 3)\n\n      var nodeOne = root\n      var nodeTwo = root.left!\n      var nodeThree = root.left!.right!.left!\n      var expected = true\n      var actual = Program().validateThreeNodes(nodeOne, nodeTwo, nodeThree)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "// This is an input class. Do not edit.\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport function validateThreeNodes(nodeOne: BST, nodeTwo: BST, nodeThree: BST) {\n  // Write your code here.\n  return false;\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(h) time | O(h) space - where h is the height of the tree\nexport function validateThreeNodes(nodeOne: BST, nodeTwo: BST, nodeThree: BST) {\n  if (isDescendant(nodeTwo, nodeOne)) return isDescendant(nodeThree, nodeTwo);\n\n  if (isDescendant(nodeTwo, nodeThree)) return isDescendant(nodeOne, nodeTwo);\n\n  return false;\n}\n\n// Whether the `target` is a descendant of the `node`.\nfunction isDescendant(node: BST | null, target: BST): boolean {\n  if (node === null) return false;\n\n  if (node === target) return true;\n\n  return target.value < node.value\n    ? isDescendant(node.left, target)\n    : isDescendant(node.right, target);\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(h) time | O(1) space - where h is the height of the tree\nexport function validateThreeNodes(nodeOne: BST, nodeTwo: BST, nodeThree: BST) {\n  if (isDescendant(nodeTwo, nodeOne)) return isDescendant(nodeThree, nodeTwo);\n\n  if (isDescendant(nodeTwo, nodeThree)) return isDescendant(nodeOne, nodeTwo);\n\n  return false;\n}\n\n// Whether the `target` is a descendant of the `node`.\nfunction isDescendant(node: BST, target: BST) {\n  let currentNode: BST | null = node;\n  while (currentNode !== null && currentNode !== target) {\n    currentNode = target.value < currentNode.value ? currentNode.left : currentNode.right;\n  }\n\n  return currentNode === target;\n}\n",
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nexport class BST {\n  value: number;\n  left: BST | null;\n  right: BST | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(d) time | O(1) space - where d is the distance between nodeOne and nodeThree\nexport function validateThreeNodes(nodeOne: BST, nodeTwo: BST, nodeThree: BST) {\n  let searchOne: BST | null = nodeOne;\n  let searchTwo: BST | null = nodeThree;\n\n  while (true) {\n    const foundThreeFromOne = searchOne === nodeThree;\n    const foundOneFromThree = searchTwo === nodeOne;\n    const foundNodeTwo = searchOne === nodeTwo || searchTwo === nodeTwo;\n    const finishedSearching = searchOne === null && searchTwo === null;\n    if (foundThreeFromOne || foundOneFromThree || foundNodeTwo || finishedSearching) {\n      break;\n    }\n\n    if (searchOne !== null) {\n      searchOne = searchOne.value > nodeTwo.value ? searchOne.left : searchOne.right;\n    }\n\n    if (searchTwo !== null) {\n      searchTwo = searchTwo.value > nodeTwo.value ? searchTwo.left : searchTwo.right;\n    }\n  }\n\n  const foundNodeFromOther = searchOne === nodeThree || searchTwo === nodeOne;\n  const foundNodeTwo = searchOne === nodeTwo || searchTwo === nodeTwo;\n  if (!foundNodeTwo || foundNodeFromOther) return false;\n\n  return searchForTarget(nodeTwo, searchOne === nodeTwo ? nodeThree : nodeOne);\n}\n\nfunction searchForTarget(node: BST, target: BST) {\n  let currentNode: BST | null = node;\n  while (currentNode !== null && currentNode !== target) {\n    currentNode = target.value < currentNode.value ? currentNode.left : currentNode.right;\n  }\n\n  return currentNode === target;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const root = new program.BST(5);\n  root.left = new program.BST(2);\n  root.right = new program.BST(7);\n  root.left.left = new program.BST(1);\n  root.left.right = new program.BST(4);\n  root.right.left = new program.BST(6);\n  root.right.right = new program.BST(8);\n  root.left.left.left = new program.BST(0);\n  root.left.right.left = new program.BST(3);\n\n  const nodeOne = root;\n  const nodeTwo = root.left;\n  const nodeThree = root.left.right.left;\n  const expected = true;\n  const actual = program.validateThreeNodes(nodeOne, nodeTwo, nodeThree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const root = new program.BST(5);\n  root.left = new program.BST(2);\n  root.right = new program.BST(7);\n  root.left.left = new program.BST(1);\n  root.left.right = new program.BST(4);\n  root.right.left = new program.BST(6);\n  root.right.right = new program.BST(8);\n  root.left.left.left = new program.BST(0);\n  root.left.right.left = new program.BST(3);\n\n  const nodeOne = root;\n  const nodeTwo = root.left;\n  const nodeThree = root.left.right.left;\n  const expected = true;\n  const actual = program.validateThreeNodes(nodeOne, nodeTwo, nodeThree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "tree",
      "example": {
        "nodes": [
          {
            "id": "0",
            "left": null,
            "right": null,
            "value": 0
          },
          {
            "id": "1",
            "left": "0",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": "4",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "2",
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "5"
      },
      "schema": {
        "description": "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
        "properties": {
          "nodes": {
            "items": {
              "properties": {
                "id": {
                  "type": "string"
                },
                "left": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "right": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "value": {
                  "type": "integer"
                }
              },
              "required": [
                "id",
                "value",
                "left",
                "right"
              ],
              "type": "object"
            },
            "type": "array"
          },
          "root": {
            "type": "string"
          }
        },
        "required": [
          "root",
          "nodes"
        ],
        "type": "object"
      }
    },
    {
      "name": "nodeOne",
      "example": "5",
      "schema": {
        "type": "string"
      }
    },
    {
      "name": "nodeTwo",
      "example": "2",
      "schema": {
        "type": "string"
      }
    },
    {
      "name": "nodeThree",
      "example": "3",
      "schema": {
        "type": "string"
      }
    }
  ],
  "tests": [
    {
      "nodeOne": "5",
      "nodeThree": "3",
      "nodeTwo": "2",
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": null,
            "right": null,
            "value": 0
          },
          {
            "id": "1",
            "left": "0",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": "4",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "2",
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "5"
      }
    },
    {
      "nodeOne": "5",
      "nodeThree": "1",
      "nodeTwo": "8",
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": null,
            "right": null,
            "value": 0
          },
          {
            "id": "1",
            "left": "0",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "3",
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "5"
      }
    },
    {
      "nodeOne": "8",
      "nodeThree": "2",
      "nodeTwo": "5",
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": null,
            "right": null,
            "value": 0
          },
          {
            "id": "1",
            "left": "0",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "3",
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "5"
      }
    },
    {
      "nodeOne": "2",
      "nodeThree": "8",
      "nodeTwo": "5",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": "7",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": "9",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "2"
      }
    },
    {
      "nodeOne": "4",
      "nodeThree": "2",
      "nodeTwo": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "1",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": "5",
            "value": 5
          },
          {
            "id": "6",
            "left": "4",
            "right": "8",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "7",
            "right": "9",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "6"
      }
    },
    {
      "nodeOne": "1",
      "nodeThree": "3",
      "nodeTwo": "2",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "2"
      }
    },
    {
      "nodeOne": "2",
      "nodeThree": "13",
      "nodeTwo": "4",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "3",
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "4",
            "right": "10",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": "9",
            "right": "14",
            "value": 10
          },
          {
            "id": "11",
            "left": null,
            "right": null,
            "value": 11
          },
          {
            "id": "12",
            "left": "11",
            "right": "13",
            "value": 12
          },
          {
            "id": "13",
            "left": null,
            "right": null,
            "value": 13
          },
          {
            "id": "14",
            "left": "12",
            "right": null,
            "value": 14
          }
        ],
        "root": "8"
      }
    },
    {
      "nodeOne": "8",
      "nodeThree": "1",
      "nodeTwo": "7",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "4",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "5",
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "7",
            "right": "9",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "8"
      }
    },
    {
      "nodeOne": "2",
      "nodeThree": "3",
      "nodeTwo": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": null,
            "value": 3
          }
        ],
        "root": "3"
      }
    },
    {
      "nodeOne": "1",
      "nodeThree": "3",
      "nodeTwo": "2",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": null,
            "value": 3
          }
        ],
        "root": "3"
      }
    },
    {
      "nodeOne": "9",
      "nodeThree": "6",
      "nodeTwo": "8",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "2",
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "4",
            "right": "8",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "7",
            "right": "9",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "6"
      }
    },
    {
      "nodeOne": "12",
      "nodeThree": "15",
      "nodeTwo": "13",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "1",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "3",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "5",
            "right": "8",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "7",
            "right": "9",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": "6",
            "right": "15",
            "value": 10
          },
          {
            "id": "11",
            "left": null,
            "right": "12",
            "value": 11
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "13",
            "left": "11",
            "right": null,
            "value": 13
          },
          {
            "id": "14",
            "left": "13",
            "right": null,
            "value": 14
          },
          {
            "id": "15",
            "left": "14",
            "right": "18",
            "value": 15
          },
          {
            "id": "16",
            "left": null,
            "right": null,
            "value": 16
          },
          {
            "id": "17",
            "left": "16",
            "right": null,
            "value": 17
          },
          {
            "id": "18",
            "left": "17",
            "right": null,
            "value": 18
          }
        ],
        "root": "10"
      }
    },
    {
      "nodeOne": "5",
      "nodeThree": "15",
      "nodeTwo": "10",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "1",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "3",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "5",
            "right": "8",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "7",
            "right": "9",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": "6",
            "right": "15",
            "value": 10
          },
          {
            "id": "11",
            "left": null,
            "right": "12",
            "value": 11
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "13",
            "left": "11",
            "right": null,
            "value": 13
          },
          {
            "id": "14",
            "left": "13",
            "right": null,
            "value": 14
          },
          {
            "id": "15",
            "left": "14",
            "right": "18",
            "value": 15
          },
          {
            "id": "16",
            "left": null,
            "right": null,
            "value": 16
          },
          {
            "id": "17",
            "left": "16",
            "right": null,
            "value": 17
          },
          {
            "id": "18",
            "left": "17",
            "right": null,
            "value": 18
          }
        ],
        "root": "10"
      }
    },
    {
      "nodeOne": "5",
      "nodeThree": "4",
      "nodeTwo": "3",
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": null,
            "right": null,
            "value": 0
          },
          {
            "id": "1",
            "left": "0",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "3",
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "5"
      }
    },
    {
      "nodeOne": "5",
      "nodeThree": "1",
      "nodeTwo": "3",
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": null,
            "right": null,
            "value": 0
          },
          {
            "id": "1",
            "left": "0",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "3",
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "5"
      }
    }
  ],
  "jsonTests": [
    {
      "nodeOne": "5",
      "nodeThree": "3",
      "nodeTwo": "2",
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": null,
            "right": null,
            "value": 0
          },
          {
            "id": "1",
            "left": "0",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": "4",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "2",
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "5"
      }
    },
    {
      "nodeOne": "5",
      "nodeThree": "1",
      "nodeTwo": "8",
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": null,
            "right": null,
            "value": 0
          },
          {
            "id": "1",
            "left": "0",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "3",
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "5"
      }
    },
    {
      "nodeOne": "8",
      "nodeThree": "2",
      "nodeTwo": "5",
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": null,
            "right": null,
            "value": 0
          },
          {
            "id": "1",
            "left": "0",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "3",
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "5"
      }
    },
    {
      "nodeOne": "2",
      "nodeThree": "8",
      "nodeTwo": "5",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": "6",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": "7",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": "9",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "2"
      }
    },
    {
      "nodeOne": "4",
      "nodeThree": "2",
      "nodeTwo": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "1",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": "5",
            "value": 5
          },
          {
            "id": "6",
            "left": "4",
            "right": "8",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "7",
            "right": "9",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "6"
      }
    },
    {
      "nodeOne": "1",
      "nodeThree": "3",
      "nodeTwo": "2",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          }
        ],
        "root": "2"
      }
    },
    {
      "nodeOne": "2",
      "nodeThree": "13",
      "nodeTwo": "4",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "3",
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "4",
            "right": "10",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": "9",
            "right": "14",
            "value": 10
          },
          {
            "id": "11",
            "left": null,
            "right": null,
            "value": 11
          },
          {
            "id": "12",
            "left": "11",
            "right": "13",
            "value": 12
          },
          {
            "id": "13",
            "left": null,
            "right": null,
            "value": 13
          },
          {
            "id": "14",
            "left": "12",
            "right": null,
            "value": 14
          }
        ],
        "root": "8"
      }
    },
    {
      "nodeOne": "8",
      "nodeThree": "1",
      "nodeTwo": "7",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "3",
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "4",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "5",
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "7",
            "right": "9",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "8"
      }
    },
    {
      "nodeOne": "2",
      "nodeThree": "3",
      "nodeTwo": "1",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": null,
            "value": 3
          }
        ],
        "root": "3"
      }
    },
    {
      "nodeOne": "1",
      "nodeThree": "3",
      "nodeTwo": "2",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": null,
            "value": 3
          }
        ],
        "root": "3"
      }
    },
    {
      "nodeOne": "9",
      "nodeThree": "6",
      "nodeTwo": "8",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": "3",
            "value": 2
          },
          {
            "id": "3",
            "left": null,
            "right": null,
            "value": 3
          },
          {
            "id": "4",
            "left": "2",
            "right": "5",
            "value": 4
          },
          {
            "id": "5",
            "left": null,
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "4",
            "right": "8",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "7",
            "right": "9",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          }
        ],
        "root": "6"
      }
    },
    {
      "nodeOne": "12",
      "nodeThree": "15",
      "nodeTwo": "13",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "1",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "3",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "5",
            "right": "8",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "7",
            "right": "9",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": "6",
            "right": "15",
            "value": 10
          },
          {
            "id": "11",
            "left": null,
            "right": "12",
            "value": 11
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "13",
            "left": "11",
            "right": null,
            "value": 13
          },
          {
            "id": "14",
            "left": "13",
            "right": null,
            "value": 14
          },
          {
            "id": "15",
            "left": "14",
            "right": "18",
            "value": 15
          },
          {
            "id": "16",
            "left": null,
            "right": null,
            "value": 16
          },
          {
            "id": "17",
            "left": "16",
            "right": null,
            "value": 17
          },
          {
            "id": "18",
            "left": "17",
            "right": null,
            "value": 18
          }
        ],
        "root": "10"
      }
    },
    {
      "nodeOne": "5",
      "nodeThree": "15",
      "nodeTwo": "10",
      "tree": {
        "nodes": [
          {
            "id": "1",
            "left": null,
            "right": "2",
            "value": 1
          },
          {
            "id": "2",
            "left": null,
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "1",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "3",
            "right": null,
            "value": 5
          },
          {
            "id": "6",
            "left": "5",
            "right": "8",
            "value": 6
          },
          {
            "id": "7",
            "left": null,
            "right": null,
            "value": 7
          },
          {
            "id": "8",
            "left": "7",
            "right": "9",
            "value": 8
          },
          {
            "id": "9",
            "left": null,
            "right": null,
            "value": 9
          },
          {
            "id": "10",
            "left": "6",
            "right": "15",
            "value": 10
          },
          {
            "id": "11",
            "left": null,
            "right": "12",
            "value": 11
          },
          {
            "id": "12",
            "left": null,
            "right": null,
            "value": 12
          },
          {
            "id": "13",
            "left": "11",
            "right": null,
            "value": 13
          },
          {
            "id": "14",
            "left": "13",
            "right": null,
            "value": 14
          },
          {
            "id": "15",
            "left": "14",
            "right": "18",
            "value": 15
          },
          {
            "id": "16",
            "left": null,
            "right": null,
            "value": 16
          },
          {
            "id": "17",
            "left": "16",
            "right": null,
            "value": 17
          },
          {
            "id": "18",
            "left": "17",
            "right": null,
            "value": 18
          }
        ],
        "root": "10"
      }
    },
    {
      "nodeOne": "5",
      "nodeThree": "4",
      "nodeTwo": "3",
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": null,
            "right": null,
            "value": 0
          },
          {
            "id": "1",
            "left": "0",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "3",
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "5"
      }
    },
    {
      "nodeOne": "5",
      "nodeThree": "1",
      "nodeTwo": "3",
      "tree": {
        "nodes": [
          {
            "id": "0",
            "left": null,
            "right": null,
            "value": 0
          },
          {
            "id": "1",
            "left": "0",
            "right": null,
            "value": 1
          },
          {
            "id": "2",
            "left": "1",
            "right": null,
            "value": 2
          },
          {
            "id": "3",
            "left": "2",
            "right": "4",
            "value": 3
          },
          {
            "id": "4",
            "left": null,
            "right": null,
            "value": 4
          },
          {
            "id": "5",
            "left": "3",
            "right": "7",
            "value": 5
          },
          {
            "id": "6",
            "left": null,
            "right": null,
            "value": 6
          },
          {
            "id": "7",
            "left": "6",
            "right": "8",
            "value": 7
          },
          {
            "id": "8",
            "left": null,
            "right": null,
            "value": 8
          }
        ],
        "root": "5"
      }
    }
  ],
  "changelog": []
}