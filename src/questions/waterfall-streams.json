{
  "uid": "waterfall-streams",
  "testStrategy": "JSON",
  "name": "Waterfall Streams",
  "version": 0,
  "releaseDate": "2020-11-16T00:00:00Z",
  "category": "Arrays",
  "difficulty": 4,
  "acl": {
    "isFree": false,
    "isFreeForStudents": false,
    "productRequired": [
      "algoexpert"
    ],
    "isAvailable": true
  },
  "languagesSupported": [
    "cpp",
    "csharp",
    "go",
    "java",
    "javascript",
    "kotlin",
    "swift",
    "python",
    "typescript"
  ],
  "submissionStatistics": {
    "correctCount": 4231,
    "failureCount": 1659
  },
  "assessmentSummary": null,
  "video": {
    "vimeoId": "471873456",
    "duration": 0,
    "annotations": [],
    "instructor": "Tim Ruscica",
    "overviewTime": 0,
    "codeWalkthroughTime": 1551
  },
  "prompt": "<div class=\"html\">\n<p>\n  You're given a two-dimensional array that represents the structure of an\n  indoor waterfall and a positive integer that represents the column that the\n  waterfall's water source will start at. More specifically, the water source\n  will start directly above the structure and will flow downwards.\n</p>\n<p>\n  Each row in the array contains <span>0</span>s and <span>1</span>s, where a\n  <span>0</span> represents a free space and a <span>1</span> represents a block\n  that water can't pass through. You can imagine that the last row of the array\n  contains buckets that the water will eventually flow into; thus, the last row\n  of the array will always contain only <span>0</span>s. You can also imagine\n  that there are walls on both sides of the structure, meaning that water will\n  never leave the structure; it will either be trapped against a wall or flow\n  into one of the buckets in the last row.\n</p>\n<p>\n  As water flows downwards, if it hits a block, it splits evenly to the left and\n  right-hand side of that block. In other words, 50% of the water flows left and\n  50% of it flows right. If a water stream is unable to flow to the left or to\n  the right (because of a block or a wall), the water stream in question becomes\n  trapped and can no longer continue to flow in that direction; it effectively\n  gets stuck in the structure and can no longer flow downwards, meaning that 50%\n  of the previous water stream is forever lost.\n</p>\n<p>\n  Lastly, the input array will always contain at least two rows and one column,\n  and the space directly below the water source (in the first row of the array)\n  will always be empty, allowing the water to start flowing downwards.\n</p>\n<p>\n  Write a function that returns the percentage of water inside each of the\n  bottom buckets after the water has flowed through the entire structure.\n</p>\n<p>\n  You can refer to the first 4.5 minutes of this question's video explanation\n  for a visual example.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">array</span> = [\n  [0, 0, 0, 0, 0, 0, 0],\n  [1, 0, 0, 0, 0, 0, 0],\n  [0, 0, 1, 1, 1, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0],\n  [1, 1, 1, 0, 0, 1, 0],\n  [0, 0, 0, 0, 0, 0, 1],\n  [0, 0, 0, 0, 0, 0, 0],\n]\n<span class=\"CodeEditor-promptParameter\">source</span> = 3\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[0, 0, 0, 25, 25, 0, 0]\n\n<span class=\"CodeEditor-promptComment\">// The water will flow as follows:</span>\n<span class=\"CodeEditor-promptComment\">// [</span>\n<span class=\"CodeEditor-promptComment\">//   [0, 0, 0, ., 0, 0, 0],</span>\n<span class=\"CodeEditor-promptComment\">//   [1, ., ., ., ., ., 0],</span>\n<span class=\"CodeEditor-promptComment\">//   [0, ., 1, 1, 1, ., 0],</span>\n<span class=\"CodeEditor-promptComment\">//   [., ., ., ., ., ., .],</span>\n<span class=\"CodeEditor-promptComment\">//   [1, 1, 1, ., ., 1, 0],</span>\n<span class=\"CodeEditor-promptComment\">//   [0, 0, 0, ., ., 0, 1],</span>\n<span class=\"CodeEditor-promptComment\">//   [0, 0, 0, ., ., 0, 0],</span>\n<span class=\"CodeEditor-promptComment\">// ]</span>\n</pre>\n</div>",
  "hints": [
    "<p>\nTry not to overthink the solution to this problem. If you were to manually go through an example of water flowing downwards through the waterfall structure, what steps would you follow exactly? Can you simply transcribe these steps into code?\n</p>\n",
    "\n<p>\nTo start simple, consider how you would solve this problem if there were only two rows. How would you make water flow from the first row to the second row with your code? Can you make a slight modification to this approach in order to solve this problem for any number of rows?\n</p>\n",
    "\n<p>\nYou'll want to traverse through the input array, all the while keeping track of where and how much water flows. To do this, you'll need to represent water with some value (-1, for example, to distinguish it from the other values in the array). Iterate through the input array, row by row, column by column, specifically looking at each current row and the row above it. When you see water in the row above, you'll have to reiterate through both the row above and the current row to see where the water will flow to next (i.e., whether there are open spaces allowing the water to flow sideways and / or downwards), mutating these rows along the way whenever water does flow. You'll have the make sure to keep track of the percentage of water that's flowing whenever water gets split in half.\n</p>"
  ],
  "spaceTime": "O(w^2 * h) time | O(w) space - where w and h are the width and height of the input array",
  "notes": "",
  "isSlowExecution": false,
  "isLongOutput": false,
  "visualization": {
    "inputType": null,
    "outputType": null
  },
  "resources": {
    "cpp": {
      "language": "cpp",
      "solutionsDisabled": false,
      "startingCode": "#include <vector>\n\nusing namespace std;\n\nvector<double> waterfallStreams(vector<vector<double>> array, int source) {\n  // Write your code here.\n  return {};\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n\nusing namespace std;\n\n// O(w^2 * h) time | O(w) space - where w and h\n// are the width and height of the input array\nvector<double> waterfallStreams(vector<vector<double>> array, int source) {\n  vector<double> rowAbove = array[0];\n  // We'll use -1 to represent water, since 1 is used for a block.\n  rowAbove[source] = -1;\n\n  for (int row = 1; row < array.size(); row++) {\n    vector<double> currentRow = array[row];\n    for (int idx = 0; idx < rowAbove.size(); idx++) {\n      double valueAbove = rowAbove[idx];\n\n      bool hasWaterAbove = valueAbove < 0;\n      bool hasBlock = currentRow[idx] == 1.0;\n\n      if (!hasWaterAbove) {\n        continue;\n      }\n\n      if (!hasBlock) {\n        // If there is no block in the current column, move the water down.\n        currentRow[idx] += valueAbove;\n        continue;\n      }\n\n      double splitWater = valueAbove / 2;\n      // Move water right.\n      int rightIdx = idx;\n      while (rightIdx + 1 < rowAbove.size()) {\n        rightIdx += 1;\n        if (rowAbove[rightIdx] == 1.0) {  // if there is a block in the way\n          break;\n        }\n        if (currentRow[rightIdx] != 1) {  // if there is no block below us\n          currentRow[rightIdx] += splitWater;\n          break;\n        }\n      }\n\n      // Move water left.\n      int leftIdx = idx;\n      while (leftIdx - 1 >= 0) {\n        leftIdx -= 1;\n        if (rowAbove[leftIdx] == 1.0) {  // if there is a block in the way\n          break;\n        }\n        if (currentRow[leftIdx] != 1.0) {  // if there is no block below us\n          currentRow[leftIdx] += splitWater;\n          break;\n        }\n      }\n    }\n\n    rowAbove = currentRow;\n  }\n\n  vector<double> finalPercentages;\n  for (double num : rowAbove) {\n    if (num == 0) {\n      finalPercentages.push_back(num);\n    } else {\n      finalPercentages.push_back(num * -100);\n    }\n  }\n  return finalPercentages;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<double>> array = {\n        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n        {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n        {0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0},\n        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n        {1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0},\n        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},\n        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n      };\n      auto source = 3;\n      vector<double> expected = {0.0, 0.0, 0.0, 25.0, 25.0, 0.0, 0.0};\n      vector<double> actual = waterfallStreams(array, source);\n      assert(expected == actual);\n    });\n  }\n};\n",
      "unitTests": "class ProgramTest : public TestSuite {\n public:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<vector<double>> array = {\n        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n        {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n        {0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0},\n        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n        {1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0},\n        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},\n        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n      };\n      auto source = 3;\n      vector<double> expected = {0.0, 0.0, 0.0, 25.0, 25.0, 0.0, 0.0};\n      vector<double> actual = waterfallStreams(array, source);\n      assert(expected == actual);\n    });\n  }\n};\n"
    },
    "csharp": {
      "language": "csharp",
      "solutionsDisabled": false,
      "startingCode": "using System;\n\npublic class Program {\n  public double[] WaterfallStreams(double[][] array, int source) {\n    // Write your code here.\n    return new double[] {};\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n  // O(w^2 * h) time | O(w) space - where w and h\n  // are the width and height of the input array\n  public double[] WaterfallStreams(double[][] array, int source) {\n    double[] rowAbove = array[0];\n    // We'll use -1 to represent water, since 1 is used for a block.\n    rowAbove[source] = -1;\n\n    for (int row = 1; row < array.Length; row++) {\n      double[] currentRow = array[row];\n      for (int idx = 0; idx < rowAbove.Length; idx++) {\n        double valueAbove = rowAbove[idx];\n\n        bool hasWaterAbove = valueAbove < 0;\n        bool hasBlock = currentRow[idx] == 1.0;\n\n        if (!hasWaterAbove) {\n          continue;\n        }\n\n        if (!hasBlock) {\n          // If there is no block in the current column, move the water down.\n          currentRow[idx] += valueAbove;\n          continue;\n        }\n\n        double splitWater = valueAbove / 2;\n        // Move water right.\n        int rightIdx = idx;\n        while (rightIdx + 1 < rowAbove.Length) {\n          rightIdx += 1;\n          if (rowAbove[rightIdx] == 1.0) {  // if there is a block in the way\n            break;\n          }\n          if (currentRow[rightIdx] != 1.0) {  // if there is no block below us\n            currentRow[rightIdx] += splitWater;\n            break;\n          }\n        }\n\n        // Move water left.\n        int leftIdx = idx;\n        while (leftIdx - 1 >= 0) {\n          leftIdx -= 1;\n          if (rowAbove[leftIdx] == 1.0) {  // if there is a block in the way\n            break;\n          }\n          if (currentRow[leftIdx] != 1.0) {  // if there is no block below us\n            currentRow[leftIdx] += splitWater;\n            break;\n          }\n        }\n      }\n\n      rowAbove = currentRow;\n    }\n\n    double[] finalPercentages = new double[rowAbove.Length];\n    for (int idx = 0; idx < rowAbove.Length; idx++) {\n      double num = rowAbove[idx];\n      if (num == 0) {\n        finalPercentages[idx] = num;\n      } else {\n        finalPercentages[idx] = (num * -100);\n      }\n    }\n    return finalPercentages;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    double[][] array = new double[][] {\n      new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n      new double[] { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n      new double[] { 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0 },\n      new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n      new double[] { 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0 },\n      new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 },\n      new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n    };\n    var source = 3;\n    double[] expected = { 0.0, 0.0, 0.0, 25.0, 25.0, 0.0, 0.0 };\n    double[] actual = new Program().WaterfallStreams(array, source);\n    Utils.AssertTrue(expected.Length == actual.Length);\n    for (int i = 0; i < expected.Length; i++)\n      Utils.AssertTrue(expected[i] == actual[i]);\n  }\n}\n",
      "unitTests": "using System;\n\npublic class ProgramTest {\n  [Test]\n  public void TestCase1() {\n    double[][] array = new double[][] {\n      new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n      new double[] { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n      new double[] { 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0 },\n      new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n      new double[] { 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0 },\n      new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 },\n      new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n    };\n    var source = 3;\n    double[] expected = { 0.0, 0.0, 0.0, 25.0, 25.0, 0.0, 0.0 };\n    double[] actual = new Program().WaterfallStreams(array, source);\n    Utils.AssertTrue(expected.Length == actual.Length);\n    for (int i = 0; i < expected.Length; i++)\n      Utils.AssertTrue(expected[i] == actual[i]);\n  }\n}\n"
    },
    "go": {
      "language": "go",
      "solutionsDisabled": false,
      "startingCode": "package main\n\nfunc WaterfallStreams(array [][]float64, source int) []float64 {\n\t// Write your code here.\n\treturn nil\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(w^2 * h) time | O(w) space - where w and h\n// are the width and height of the input array\nfunc WaterfallStreams(array [][]float64, source int) []float64 {\n\trowAbove := array[0]\n\t// We'll use -1 to represent water, since 1 is used for a block.\n\trowAbove[source] = -1\n\n\tfor row := 1; row < len(array); row++ {\n\t\tcurrentRow := array[row]\n\t\tfor idx := range rowAbove {\n\t\t\tvalueAbove := rowAbove[idx]\n\n\t\t\thasWaterAbove := valueAbove < 0\n\t\t\thasBlock := currentRow[idx] == 1\n\n\t\t\tif !hasWaterAbove {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !hasBlock {\n\t\t\t\t// If there is no block in the current column, move the water down.\n\t\t\t\tcurrentRow[idx] += valueAbove\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tsplitWater := valueAbove / 2\n\t\t\t// Move water right.\n\t\t\tvar rightIdx = idx\n\t\t\tfor rightIdx+1 < len(rowAbove) {\n\t\t\t\trightIdx += 1\n\t\t\t\tif rowAbove[rightIdx] == 1.0 {\n\t\t\t\t\tbreak // if there is a block in the way\n\t\t\t\t}\n\t\t\t\tif currentRow[rightIdx] != 1.0 { // if there is no block below us\n\t\t\t\t\tcurrentRow[rightIdx] += splitWater\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Move water left.\n\t\t\tvar leftIdx = idx\n\t\t\tfor leftIdx-1 >= 0 {\n\t\t\t\tleftIdx -= 1\n\t\t\t\tif rowAbove[leftIdx] == 1.0 {\n\t\t\t\t\tbreak // if there is a block in the way\n\t\t\t\t}\n\t\t\t\tif currentRow[leftIdx] != 1.0 { // if there is no block below us\n\t\t\t\t\tcurrentRow[leftIdx] += splitWater\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trowAbove = currentRow\n\t}\n\n\tfinalPercentages := make([]float64, 0, len(rowAbove))\n\tfor _, num := range rowAbove {\n\t\tif num == 0 {\n\t\t\tfinalPercentages = append(finalPercentages, num)\n\t\t} else {\n\t\t\tfinalPercentages = append(finalPercentages, num*-100)\n\t\t}\n\t}\n\treturn finalPercentages\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tarray := [][]float64{\n\t\t{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t{0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0},\n\t\t{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t{1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0},\n\t\t{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},\n\t\t{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n\t}\n\tsource := 3\n\texpected := []float64{0.0, 0.0, 0.0, 25.0, 25.0, 0.0, 0.0}\n\tactual := WaterfallStreams(array, source)\n\trequire.Equal(t, expected, actual)\n}\n",
      "unitTests": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tarray := [][]float64{\n\t\t{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t{0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0},\n\t\t{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t{1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0},\n\t\t{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},\n\t\t{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n\t}\n\tsource := 3\n\texpected := []float64{0.0, 0.0, 0.0, 25.0, 25.0, 0.0, 0.0}\n\tactual := WaterfallStreams(array, source)\n\trequire.Equal(t, expected, actual)\n}\n"
    },
    "java": {
      "language": "java",
      "solutionsDisabled": false,
      "startingCode": "import java.util.*;\n\nclass Program {\n  public double[] waterfallStreams(double[][] array, int source) {\n    // Write your code here.\n    return new double[] {};\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(w^2 * h) time | O(w) space - where w and h\n  // are the width and height of the input array\n  public double[] waterfallStreams(double[][] array, int source) {\n    double[] rowAbove = array[0];\n    // We'll use -1 to represent water, since 1 is used for a block.\n    rowAbove[source] = -1;\n\n    for (int row = 1; row < array.length; row++) {\n      double[] currentRow = array[row];\n      for (int idx = 0; idx < rowAbove.length; idx++) {\n        double valueAbove = rowAbove[idx];\n\n        boolean hasWaterAbove = valueAbove < 0;\n        boolean hasBlock = currentRow[idx] == 1.0;\n\n        if (!hasWaterAbove) {\n          continue;\n        }\n\n        if (!hasBlock) {\n          // If there is no block in the current column, move the water down.\n          currentRow[idx] += valueAbove;\n          continue;\n        }\n\n        double splitWater = valueAbove / 2;\n        // Move water right.\n        int rightIdx = idx;\n        while (rightIdx + 1 < rowAbove.length) {\n          rightIdx += 1;\n          if (rowAbove[rightIdx] == 1.0) { // if there is a block in the way\n            break;\n          }\n          if (currentRow[rightIdx] != 1) { // if there is no block below us\n            currentRow[rightIdx] += splitWater;\n            break;\n          }\n        }\n\n        // Move water left.\n        int leftIdx = idx;\n        while (leftIdx - 1 >= 0) {\n          leftIdx -= 1;\n          if (rowAbove[leftIdx] == 1.0) { // if there is a block in the way\n            break;\n          }\n          if (currentRow[leftIdx] != 1.0) { // if there is no block below us\n            currentRow[leftIdx] += splitWater;\n            break;\n          }\n        }\n      }\n\n      rowAbove = currentRow;\n    }\n\n    double[] finalPercentages = new double[rowAbove.length];\n    for (int idx = 0; idx < rowAbove.length; idx++) {\n      double num = rowAbove[idx];\n      if (num == 0) {\n        finalPercentages[idx] = num;\n      } else {\n        finalPercentages[idx] = (num * -100);\n      }\n    }\n    return finalPercentages;\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    double[][] array = new double[][] {\n      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n      {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n      {0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0},\n      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n      {1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0},\n      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},\n      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n    };\n    var source = 3;\n    double[] expected = {0.0, 0.0, 0.0, 25.0, 25.0, 0.0, 0.0};\n    double[] actual = new Program().waterfallStreams(array, source);\n    Utils.assertTrue(expected.length == actual.length);\n    for (int i = 0; i < expected.length; i++)\n      Utils.assertTrue(expected[i] == actual[i]);\n  }\n}\n",
      "unitTests": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    double[][] array = new double[][] {\n      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n      {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n      {0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0},\n      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n      {1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0},\n      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},\n      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\n    };\n    var source = 3;\n    double[] expected = {0.0, 0.0, 0.0, 25.0, 25.0, 0.0, 0.0};\n    double[] actual = new Program().waterfallStreams(array, source);\n    Utils.assertTrue(expected.length == actual.length);\n    for (int i = 0; i < expected.length; i++)\n      Utils.assertTrue(expected[i] == actual[i]);\n  }\n}\n"
    },
    "javascript": {
      "language": "javascript",
      "solutionsDisabled": false,
      "startingCode": "function waterfallStreams(array, source) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.waterfallStreams = waterfallStreams;\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(w^2 * h) time | O(w) space - where w and h\n// are the width and height of the input array\nfunction waterfallStreams(array, source) {\n  let rowAbove = [...array[0]];\n  // We'll use -1 to represent water, since 1 is used for a block.\n  rowAbove[source] = -1;\n\n  for (let row = 1; row < array.length; row++) {\n    const currentRow = [...array[row]];\n\n    for (let idx = 0; idx < rowAbove.length; idx++) {\n      const valueAbove = rowAbove[idx];\n\n      const hasWaterAbove = valueAbove < 0;\n      const hasBlock = currentRow[idx] === 1;\n\n      if (!hasWaterAbove) {\n        continue;\n      }\n\n      if (!hasBlock) {\n        // If there is no block in the current column, move the water down.\n        currentRow[idx] += valueAbove;\n        continue;\n      }\n\n      const splitWater = valueAbove / 2;\n\n      // Move water right\n      let rightIdx = idx;\n      while (rightIdx + 1 < rowAbove.length) {\n        rightIdx++;\n        if (rowAbove[rightIdx] === 1) {\n          // if there is a block in the way\n          break;\n        }\n        if (currentRow[rightIdx] !== 1) {\n          //if there is no block below us\n          currentRow[rightIdx] += splitWater;\n          break;\n        }\n      }\n\n      // Move water left\n      let leftIdx = idx;\n      while (leftIdx - 1 >= 0) {\n        leftIdx--;\n        if (rowAbove[leftIdx] === 1) {\n          // if there is a block in the way\n          break;\n        }\n        if (currentRow[leftIdx] !== 1) {\n          // if there is no block below us\n          currentRow[leftIdx] += splitWater;\n          break;\n        }\n      }\n    }\n    rowAbove = currentRow;\n  }\n\n  // Convert our negative values to positive percentages.\n  const finalPercentages = rowAbove.map(num => (num < 0 ? num * -100 : num));\n\n  return finalPercentages;\n}\n\nexports.waterfallStreams = waterfallStreams;\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [\n    [0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0],\n    [1, 1, 1, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0],\n  ];\n  const source = 3;\n  const expected = [0, 0, 0, 25, 25, 0, 0];\n  const actual = program.waterfallStreams(array, source);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [\n    [0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0],\n    [1, 1, 1, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0],\n  ];\n  const source = 3;\n  const expected = [0, 0, 0, 25, 25, 0, 0];\n  const actual = program.waterfallStreams(array, source);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    },
    "kotlin": {
      "language": "kotlin",
      "solutionsDisabled": false,
      "startingCode": "package com.algoexpert.program\n\nfun waterfallStreams(array: List<List<Double>>, source: Int): List<Double> {\n    // Write your code here.\n    return listOf()\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(w^2 * h) time | O(w) space - where w and h\n// are the width and height of the input array\nfun waterfallStreams(array: List<List<Double>>, source: Int): List<Double> {\n    var rowAbove = array[0].toMutableList()\n    // We'll use -1 to represent water, since 1 is used for a block.\n    rowAbove[source] = -1.0\n\n    for (row in 1 until array.size) {\n        val currentRow = array[row].toMutableList()\n\n        for (idx in 0 until rowAbove.size) {\n            val valueAbove = rowAbove[idx]\n\n            val hasWaterAbove = valueAbove < 0\n            val hasBlock = currentRow[idx] == 1.0\n\n            if (!hasWaterAbove) continue\n\n            if (!hasBlock) {\n                // If there is no block in the current column, move the water down.\n                currentRow[idx] += valueAbove\n                continue\n            }\n\n            val splitWater = valueAbove.toDouble() / 2\n\n            // Move water right.\n            var rightIdx = idx\n            while (rightIdx + 1 < rowAbove.size) {\n                rightIdx += 1\n                if (rowAbove[rightIdx] == 1.0) break // if there is a block in the way\n                if (currentRow[rightIdx] != 1.0) { // if there is no block below us\n                    currentRow[rightIdx] += splitWater\n                    break\n                }\n            }\n\n            // Move water left.\n            var leftIdx = idx\n            while (leftIdx - 1 >= 0) {\n                leftIdx -= 1\n                if (rowAbove[leftIdx] == 1.0) break // if there is a block in the way\n                if (currentRow[leftIdx] != 1.0) { // if there is no block below us\n                    currentRow[leftIdx] += splitWater\n                    break\n                }\n            }\n        }\n\n        rowAbove = currentRow\n    }\n\n    // Convert our negative values to positive percentages.\n    val finalPercentages = rowAbove.map { num -> if (num == 0.0) 0.0 else num * -100 }\n\n    return finalPercentages\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.waterfallStreams\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val array = listOf(\n            listOf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n            listOf(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n            listOf(0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0),\n            listOf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n            listOf(1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0),\n            listOf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0),\n            listOf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n        )\n        val source = 3\n        val expected = listOf(0.0, 0.0, 0.0, 25.0, 25.0, 0.0, 0.0)\n        val output = waterfallStreams(array, source)\n        println(output)\n        assert(expected == output)\n    }\n}\n",
      "unitTests": "import com.algoexpert.program.waterfallStreams\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val array = listOf(\n            listOf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n            listOf(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n            listOf(0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0),\n            listOf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n            listOf(1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0),\n            listOf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0),\n            listOf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n        )\n        val source = 3\n        val expected = listOf(0.0, 0.0, 0.0, 25.0, 25.0, 0.0, 0.0)\n        val output = waterfallStreams(array, source)\n        println(output)\n        assert(expected == output)\n    }\n}\n"
    },
    "python": {
      "language": "python",
      "solutionsDisabled": false,
      "startingCode": "def waterfallStreams(array, source):\n    # Write your code here.\n    pass\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n# O(w^2 * h) time | O(w) space - where w and h\n# are the width and height of the input array\ndef waterfallStreams(array, source):\n    rowAbove = array[0][:]\n    # We'll use -1 to represent water, since 1 is used for a block.\n    rowAbove[source] = -1\n\n    for row in range(1, len(array)):\n        currentRow = array[row][:]\n\n        for idx in range(len(rowAbove)):\n            valueAbove = rowAbove[idx]\n\n            hasWaterAbove = valueAbove < 0\n            hasBlock = currentRow[idx] == 1\n\n            if not hasWaterAbove:\n                continue\n\n            if not hasBlock:\n                # If there is no block in the current column, move the water down.\n                currentRow[idx] += valueAbove\n                continue\n\n            splitWater = valueAbove / 2\n\n            # Move water right.\n            rightIdx = idx\n            while rightIdx + 1 < len(rowAbove):\n                rightIdx += 1\n                if rowAbove[rightIdx] == 1:  # if there is a block in the way\n                    break\n                if currentRow[rightIdx] != 1:  # if there is no block below us\n                    currentRow[rightIdx] += splitWater\n                    break\n\n            # Move water left.\n            leftIdx = idx\n            while leftIdx - 1 >= 0:\n                leftIdx -= 1\n                if rowAbove[leftIdx] == 1:  # if there is a block in the way\n                    break\n                if currentRow[leftIdx] != 1:  # if there is no block below us\n                    currentRow[leftIdx] += splitWater\n                    break\n\n        rowAbove = currentRow\n\n    # Convert our negative values to positive percentages.\n    finalPercentages = list(map(lambda num: num * -100, rowAbove))\n\n    return finalPercentages\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        array = [\n            [0, 0, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0, 0],\n            [0, 0, 1, 1, 1, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0],\n            [1, 1, 1, 0, 0, 1, 0],\n            [0, 0, 0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0, 0, 0],\n        ]\n        source = 3\n        expected = [0, 0, 0, 25, 25, 0, 0]\n        actual = program.waterfallStreams(array, source)\n        self.assertEqual(actual, expected)\n",
      "unitTests": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        array = [\n            [0, 0, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0, 0],\n            [0, 0, 1, 1, 1, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0],\n            [1, 1, 1, 0, 0, 1, 0],\n            [0, 0, 0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0, 0, 0],\n        ]\n        source = 3\n        expected = [0, 0, 0, 25, 25, 0, 0]\n        actual = program.waterfallStreams(array, source)\n        self.assertEqual(actual, expected)\n"
    },
    "ruby": {
      "language": "ruby",
      "solutionsDisabled": true,
      "startingCode": "class Program\n  def waterfallStreams(array, source)\n    # Write your code here.\n    return []\n  end\nend\n",
      "solutions": [
        "# Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def waterfallStreams(array, source)\n    # Write your code here.\n    return []\n  end\nend\n"
      ],
      "sandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.waterfallStreams\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n",
      "unitTests": "require \"./program.rb\"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.waterfallStreams\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n"
    },
    "swift": {
      "language": "swift",
      "solutionsDisabled": false,
      "startingCode": "class Program {\n  func waterfallStreams(_ array: [[Double]], _ source: Int) -> [Double] {\n    // Write your code here.\n    return [Double]()\n  }\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(w^2 * h) time | O(w) space - where w and h\n  // are the width and height of the input array\n  func waterfallStreams(_ array: [[Double]], _ source: Int) -> [Double] {\n    var rowAbove = array[0]\n    // We'll use -1 to represent water, since 1 is used for a block.\n    rowAbove[source] = -1\n\n    for row in stride(from: 1, to: array.count, by: 1) {\n      var currentRow = array[row]\n      for idx in 0 ..< rowAbove.count {\n        var valueAbove = rowAbove[idx]\n\n        var hasWaterAbove = valueAbove < 0\n        var hasBlock = currentRow[idx] == 1\n\n        if !hasWaterAbove {\n          continue\n        }\n\n        if !hasBlock {\n          // If there is no block in the current column, move the water down.\n          currentRow[idx] += valueAbove\n          continue\n        }\n\n        var splitWater = valueAbove / 2\n        // Move water right.\n        var rightIdx = idx\n        while rightIdx + 1 < rowAbove.count {\n          rightIdx += 1\n          if rowAbove[rightIdx] == 1.0 {\n            break // if there is a block in the way\n          }\n          if currentRow[rightIdx] != 1.0 { // if there is no block below us\n            currentRow[rightIdx] += splitWater\n            break\n          }\n        }\n\n        // Move water left.\n        var leftIdx = idx\n        while leftIdx - 1 >= 0 {\n          leftIdx -= 1\n          if rowAbove[leftIdx] == 1.0 {\n            break // if there is a block in the way\n          }\n          if currentRow[leftIdx] != 1.0 { // if there is no block below us\n            currentRow[leftIdx] += splitWater\n            break\n          }\n        }\n      }\n\n      rowAbove = currentRow\n    }\n\n    var finalPercentages = [Double]()\n    for num in rowAbove {\n      if num == 0 {\n        finalPercentages.append(num)\n      } else {\n        finalPercentages.append(num * (-100))\n      }\n    }\n    return finalPercentages\n  }\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var array = [\n        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        [0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        [1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0],\n        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],\n        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n      ]\n      var source = 3\n      var expected = [0.0, 0.0, 0.0, 25.0, 25.0, 0.0, 0.0]\n      var actual = Program().waterfallStreams(array, source)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n",
      "unitTests": "class ProgramTest: TestSuite {\n  func test() {\n    runTest(\"Test Case 1\") { () throws -> Void in\n      var array = [\n        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        [0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        [1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0],\n        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],\n        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n      ]\n      var source = 3\n      var expected = [0.0, 0.0, 0.0, 25.0, 25.0, 0.0, 0.0]\n      var actual = Program().waterfallStreams(array, source)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n"
    },
    "typescript": {
      "language": "typescript",
      "solutionsDisabled": false,
      "startingCode": "export function waterfallStreams(array: number[][], source: number) {\n  // Write your code here.\n  return [0];\n}\n",
      "solutions": [
        "// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\n// O(w^2 * h) time | O(w) space - where w and h\n// are the width and height of the input array\nexport function waterfallStreams(array: number[][], source: number) {\n  let rowAbove = [...array[0]];\n  // We'll use -1 to represent water, since 1 is used for a block.\n  rowAbove[source] = -1;\n\n  for (let row = 1; row < array.length; row++) {\n    const currentRow = [...array[row]];\n\n    for (let idx = 0; idx < rowAbove.length; idx++) {\n      const valueAbove = rowAbove[idx];\n\n      const hasWaterAbove = valueAbove < 0;\n      const hasBlock = currentRow[idx] === 1;\n\n      if (!hasWaterAbove) {\n        continue;\n      }\n\n      if (!hasBlock) {\n        // If there is no block in the current column, move the water down.\n        currentRow[idx] += valueAbove;\n        continue;\n      }\n\n      const splitWater = valueAbove / 2;\n\n      // Move water right\n      let rightIdx = idx;\n      while (rightIdx + 1 < rowAbove.length) {\n        rightIdx++;\n        if (rowAbove[rightIdx] === 1) {\n          // if there is a block in the way\n          break;\n        }\n        if (currentRow[rightIdx] !== 1) {\n          //if there is no block below us\n          currentRow[rightIdx] += splitWater;\n          break;\n        }\n      }\n\n      // Move water left\n      let leftIdx = idx;\n      while (leftIdx - 1 >= 0) {\n        leftIdx--;\n        if (rowAbove[leftIdx] === 1) {\n          // if there is a block in the way\n          break;\n        }\n        if (currentRow[leftIdx] !== 1) {\n          // if there is no block below us\n          currentRow[leftIdx] += splitWater;\n          break;\n        }\n      }\n    }\n    rowAbove = currentRow;\n  }\n\n  // Convert our negative values to positive percentages.\n  const finalPercentages = rowAbove.map(num => (num < 0 ? num * -100 : num));\n\n  return finalPercentages;\n}\n"
      ],
      "sandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const array = [\n    [0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0],\n    [1, 1, 1, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0],\n  ];\n  const source = 3;\n  const expected = [0, 0, 0, 25, 25, 0, 0];\n  const actual = program.waterfallStreams(array, source);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      "unitTests": "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const array = [\n    [0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0],\n    [1, 1, 1, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0],\n  ];\n  const source = 3;\n  const expected = [0, 0, 0, 25, 25, 0, 0];\n  const actual = program.waterfallStreams(array, source);\n  chai.expect(actual).to.deep.equal(expected);\n});\n"
    }
  },
  "customInputVars": [
    {
      "name": "array",
      "example": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          1,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "schema": {
        "items": {
          "items": {
            "maximum": 1,
            "minimum": 0,
            "type": "integer"
          },
          "type": "array"
        },
        "type": "array"
      }
    },
    {
      "name": "source",
      "example": 3,
      "schema": {
        "minimum": 0,
        "type": "integer"
      }
    }
  ],
  "tests": [
    {
      "array": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          1,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "source": 3
    },
    {
      "array": [
        [
          0
        ],
        [
          0
        ],
        [
          0
        ],
        [
          0
        ],
        [
          0
        ],
        [
          0
        ],
        [
          0
        ]
      ],
      "source": 0
    },
    {
      "array": [
        [
          0
        ],
        [
          0
        ],
        [
          0
        ],
        [
          0
        ],
        [
          0
        ],
        [
          1
        ],
        [
          0
        ]
      ],
      "source": 0
    },
    {
      "array": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          1,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "source": 3
    },
    {
      "array": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          1,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          1,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "source": 3
    },
    {
      "array": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ],
        [
          0,
          0,
          1,
          0,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "source": 3
    },
    {
      "array": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ],
        [
          0,
          0,
          1,
          0,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "source": 6
    },
    {
      "array": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          1,
          1,
          0,
          0,
          1,
          1,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          0,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "source": 8
    },
    {
      "array": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          1,
          1,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          1,
          1,
          0,
          0,
          1,
          1,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "source": 8
    }
  ],
  "jsonTests": [
    {
      "array": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          1,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "source": 3
    },
    {
      "array": [
        [
          0
        ],
        [
          0
        ],
        [
          0
        ],
        [
          0
        ],
        [
          0
        ],
        [
          0
        ],
        [
          0
        ]
      ],
      "source": 0
    },
    {
      "array": [
        [
          0
        ],
        [
          0
        ],
        [
          0
        ],
        [
          0
        ],
        [
          0
        ],
        [
          1
        ],
        [
          0
        ]
      ],
      "source": 0
    },
    {
      "array": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          1,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "source": 3
    },
    {
      "array": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          1,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          1,
          1,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "source": 3
    },
    {
      "array": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ],
        [
          0,
          0,
          1,
          0,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "source": 3
    },
    {
      "array": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ],
        [
          0,
          0,
          1,
          0,
          1,
          1,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        [
          1,
          1,
          1,
          1,
          1,
          1,
          1
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "source": 6
    },
    {
      "array": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          1,
          1,
          0,
          0,
          1,
          1,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          0,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "source": 8
    },
    {
      "array": [
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          1,
          1,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          1,
          1,
          1,
          0,
          0,
          1,
          1,
          1,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "source": 8
    }
  ],
  "changelog": []
}